<html><head><title>proxylib.c</title></head><pre>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;dlfcn.h&gt;
#include &lt;errno.h&gt;
#include &lt;netinet/in.h&gt;



/* 
gcc -c -o proxyshell_connect.o proxylib.c -fpic
ld -shared -o proxyshell_connect.so proxyshell_connect.o -ldl
*/


#ifdef connect
 #undef connect
#endif


/*
	export LD_PRELOAD=/path/to/proxyshell_connect.so
	export SHELLPROXYHOST=192.168.1.16:1280

*/


#define PROXYHOSTENV	&quot;SHELLPROXYHOST&quot; 
#define DEFAULTPORT	1280


int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);
static void* original(char* func);
int (*real_connect)(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen) = NULL;


int main (int argc, char *argv[]) {

  int sd, rc, i;
  struct sockaddr_in localAddr, servAddr;
  struct hostent *h;


  sd = socket(AF_INET, SOCK_STREAM, 0);

  localAddr.sin_family = AF_INET;
  localAddr.sin_addr.s_addr = htonl(INADDR_ANY);
  localAddr.sin_port = htons(0);

   rc = connect(sd, (struct sockaddr *) &amp;localAddr, sizeof(servAddr));


}


int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen){
char *proxyhost,*tmphost,*tmpport;
int retval;
unsigned short port;
struct sockaddr_in shellcodeaddr;

	if(!real_connect){
		real_connect = original(&quot;connect&quot;);
	}

	if(serv_addr-&gt;sa_family == 2){
		if((proxyhost = getenv(PROXYHOSTENV))){
			if(!(tmphost = calloc(1,strlen(proxyhost)+1))){
				perror(&quot;call to calloc failed&quot;);
				exit(-1);
			}
			strcpy(tmphost,proxyhost);
			if((tmpport = strstr(tmphost,&quot;:&quot;)) &amp;&amp; strlen(tmpport)){
				tmpport[0] = 0;
				tmpport++;
				port = (unsigned short)atoi(tmpport);
			}else{
				port = (unsigned short)DEFAULTPORT;
			}
		}else{
			perror(&quot;env variable PROXYHOSTENV was not found&quot;);
			exit(-2);
		}
	
		shellcodeaddr.sin_family = 2;
		shellcodeaddr.sin_addr.s_addr = inet_addr(tmphost);
		shellcodeaddr.sin_port = htons(port);
	
		free(tmphost);
	
		if(!(retval = real_connect(sockfd, (struct sockaddr *)&amp;shellcodeaddr,sizeof(shellcodeaddr)))){
			send(sockfd,serv_addr,addrlen,0);
		}
		return retval;
	}else{
		return  real_connect(sockfd, serv_addr, addrlen );
	}
}




static void* original(char* func){
void* libc_handle, *func_addr;

	if(!(libc_handle = dlopen(&quot;libc.so&quot;, RTLD_LAZY))){
		if(!(libc_handle = dlopen(&quot;libc.so.6&quot;, RTLD_LAZY))){
			if(!(libc_handle = dlopen(&quot;libc.so.5&quot;, RTLD_LAZY))) {
				fprintf(stderr, &quot;Error ldopening libc!\n&quot;);
				return NULL;
 			}
		}
	}

	func_addr = dlsym(libc_handle, func);
	if(func_addr) return func_addr;
	fprintf(stderr, &quot;Unable to locate %s\n&quot;, func);
	return NULL;
}

// milw0rm.com [2006-02-07]</pre></html>